import * as Os from 'os'
import * as Path from 'path'
import * as FSE from 'fs-extra'

import { git } from './core'
import { v4 as uuid } from 'uuid'

import { Repository, LinkedWorkTree } from '../../models/repository'
import { getMatches } from '../helpers/regex'

const DesktopWorkTreePrefix = 'github-desktop-worktree-'

/** Enumerate the list of work trees reported by Git for a repository */
export async function listWorkTrees(
  repository: Repository
): Promise<ReadonlyArray<LinkedWorkTree>> {
  const result = await git(
    ['worktree', 'list', '--porcelain'],
    repository.path,
    'listWorkTrees'
  )

  const worktrees = new Array<LinkedWorkTree>()

  // the porcelain output from git-worktree covers multiple lines
  const listWorkTreeRe = /worktree (.*)\nHEAD ([a-f0-9]*)\n(branch .*|detached)\n/gm

  getMatches(result.stdout, listWorkTreeRe).forEach(m => {
    if (m.length === 4) {
      worktrees.push({
        path: m[1],
        head: m[2],
      })
    } else {
      log.debug(
        `[listWorkTrees] match '${m[0]}' does not have the expected data or output. Skipping...`
      )
    }
  })

  return worktrees
}

/**
 * Creates a temporary work tree for use in Desktop, even if one already exists
 * for that repository. Won't modify the repository's working directory.
 * _The returned worktree will be checked out to the given commit._
 */
export async function createTemporaryWorkTree(
  repository: Repository,
  commit: string
): Promise<LinkedWorkTree> {
  const workTreePath = await FSE.mkdtemp(getTemporaryDirectoryPrefix())
  await git(
    ['worktree', 'add', '-f', workTreePath, commit],
    repository.path,
    'addWorkTree'
  )
  // Because Git doesn't give enough information from stdout for the previous
  // Git call, this function enumerates the available worktrees to find the
  // expected worktree

  const workTrees = await listWorkTrees(repository)

  const directoryName = Path.basename(workTreePath)
  const workTree = workTrees.find(t => Path.basename(t.path) === directoryName)

  // intentionally vague here to cover `undefined` and `null`
  if (!workTree) {
    throw new Error(
      `[addWorkTree] Unable to find created worktree "${directoryName}"`
    )
  }

  return workTree
}

/** Cleanup the temporary worktree at a given location */
export async function destroyWorkTree(
  repository: Repository,
  workTree: LinkedWorkTree
): Promise<true> {
  await git(
    ['worktree', 'remove', '-f', workTree.path],
    repository.path,
    'removeWorkTree'
  )
  return true
}

// creates a unique (to desktop) path in the OS's temp dir
function getTemporaryDirectoryPrefix() {
  return Path.join(Os.tmpdir(), `${DesktopWorkTreePrefix}${uuid()}`)
}

async function findTemporaryWorkTrees(
  repository: Repository
): Promise<ReadonlyArray<LinkedWorkTree>> {
  const workTrees = await listWorkTrees(repository)

  // always exclude the first entry as that will be "main" worktree and we
  // should not even look at it funny
  const candidateWorkTrees = workTrees.slice(1)

  return candidateWorkTrees.filter(t => {
    // NOTE:
    // we can't reliably check the full path here because Git seems to be
    // prefixing the temporary paths on macOS with a `/private` prefix, and
    // NodeJS doesn't seem to include this when we ask for the temporary
    // directory for the OS
    const directoryName = Path.basename(t.path)
    return directoryName.startsWith(DesktopWorkTreePrefix)
  })
}

/** Enumerate and cleanup any worktrees generated by Desktop */
export async function cleanupTemporaryWorkTrees(
  repository: Repository
): Promise<void> {
  const temporaryWorkTrees = await findTemporaryWorkTrees(repository)

  for (const workTree of temporaryWorkTrees) {
    await destroyWorkTree(repository, workTree)
  }
}
