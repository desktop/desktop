removed in remote
  base   100644 25e9d0f1932af30296de26c5fb0013e09a99c19c atom/app/atom_content_client.cc
  our    100644 f17ae3137032f0b0e26eb735d37cfb3daaeebcfc atom/app/atom_content_client.cc
@@ -1,244 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_content_client.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/common/content_constants.h"
-#include "content/public/common/pepper_plugin_info.h"
-#include "content/public/common/user_agent.h"
-#include "media/media_features.h"
-#include "ppapi/shared_impl/ppapi_permissions.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "url/url_constants.h"
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-#include "chrome/common/widevine_cdm_constants.h"
-#endif
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/common/atom_constants.h"
-#include "pdf/pdf.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-namespace atom {
-
-namespace {
-
-content::PepperPluginInfo CreatePepperFlashInfo(const base::FilePath& path,
-                                                const std::string& version) {
-  content::PepperPluginInfo plugin;
-
-  plugin.is_out_of_process = true;
-  plugin.name = content::kFlashPluginName;
-  plugin.path = path;
-  plugin.permissions = ppapi::PERMISSION_ALL_BITS;
-
-  std::vector<std::string> flash_version_numbers = base::SplitString(
-      version, ".", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-  if (flash_version_numbers.empty())
-    flash_version_numbers.push_back("11");
-  // |SplitString()| puts in an empty string given an empty string. :(
-  else if (flash_version_numbers[0].empty())
-    flash_version_numbers[0] = "11";
-  if (flash_version_numbers.size() < 2)
-    flash_version_numbers.push_back("2");
-  if (flash_version_numbers.size() < 3)
-    flash_version_numbers.push_back("999");
-  if (flash_version_numbers.size() < 4)
-    flash_version_numbers.push_back("999");
-  // E.g., "Shockwave Flash 10.2 r154":
-  plugin.description = plugin.name + " " + flash_version_numbers[0] + "." +
-                       flash_version_numbers[1] + " r" +
-                       flash_version_numbers[2];
-  plugin.version = base::JoinString(flash_version_numbers, ".");
-  content::WebPluginMimeType swf_mime_type(content::kFlashPluginSwfMimeType,
-                                           content::kFlashPluginSwfExtension,
-                                           content::kFlashPluginSwfDescription);
-  plugin.mime_types.push_back(swf_mime_type);
-  content::WebPluginMimeType spl_mime_type(content::kFlashPluginSplMimeType,
-                                           content::kFlashPluginSplExtension,
-                                           content::kFlashPluginSplDescription);
-  plugin.mime_types.push_back(spl_mime_type);
-
-  return plugin;
-}
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-content::PepperPluginInfo CreateWidevineCdmInfo(const base::FilePath& path,
-                                                const std::string& version) {
-  content::PepperPluginInfo widevine_cdm;
-  widevine_cdm.is_out_of_process = true;
-  widevine_cdm.path = path;
-  widevine_cdm.name = kWidevineCdmDisplayName;
-  widevine_cdm.description =
-      kWidevineCdmDescription + std::string(" (version: ") + version + ")";
-  widevine_cdm.version = version;
-  content::WebPluginMimeType widevine_cdm_mime_type(
-      kWidevineCdmPluginMimeType, kWidevineCdmPluginExtension,
-      kWidevineCdmPluginMimeTypeDescription);
-
-  widevine_cdm.mime_types.push_back(widevine_cdm_mime_type);
-  widevine_cdm.permissions = kWidevineCdmPluginPermissions;
-
-  return widevine_cdm;
-}
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-
-#if defined(ENABLE_PDF_VIEWER)
-void ComputeBuiltInPlugins(std::vector<content::PepperPluginInfo>* plugins) {
-  content::PepperPluginInfo pdf_info;
-  pdf_info.is_internal = true;
-  pdf_info.is_out_of_process = true;
-  pdf_info.name = "Chromium PDF Viewer";
-  pdf_info.description = "Portable Document Format";
-  pdf_info.path = base::FilePath::FromUTF8Unsafe(kPdfPluginPath);
-  content::WebPluginMimeType pdf_mime_type(kPdfPluginMimeType, "pdf",
-                                           "Portable Document Format");
-  pdf_info.mime_types.push_back(pdf_mime_type);
-  pdf_info.internal_entry_points.get_interface = chrome_pdf::PPP_GetInterface;
-  pdf_info.internal_entry_points.initialize_module =
-      chrome_pdf::PPP_InitializeModule;
-  pdf_info.internal_entry_points.shutdown_module =
-      chrome_pdf::PPP_ShutdownModule;
-  pdf_info.permissions = ppapi::PERMISSION_PRIVATE | ppapi::PERMISSION_DEV;
-  plugins->push_back(pdf_info);
-}
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-void ConvertStringWithSeparatorToVector(std::vector<std::string>* vec,
-                                        const char* separator,
-                                        const char* cmd_switch) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  auto string_with_separator = command_line->GetSwitchValueASCII(cmd_switch);
-  if (!string_with_separator.empty())
-    *vec = base::SplitString(string_with_separator, separator,
-                             base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-}
-
-}  // namespace
-
-void AddPepperFlashFromCommandLine(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath flash_path =
-      command_line->GetSwitchValuePath(switches::kPpapiFlashPath);
-  if (flash_path.empty())
-    return;
-
-  auto flash_version =
-      command_line->GetSwitchValueASCII(switches::kPpapiFlashVersion);
-
-  plugins->push_back(CreatePepperFlashInfo(flash_path, flash_version));
-}
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-void AddWidevineCdmFromCommandLine(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath widevine_cdm_path =
-      command_line->GetSwitchValuePath(switches::kWidevineCdmPath);
-  if (widevine_cdm_path.empty())
-    return;
-
-  if (!base::PathExists(widevine_cdm_path))
-    return;
-
-  auto widevine_cdm_version =
-      command_line->GetSwitchValueASCII(switches::kWidevineCdmVersion);
-  if (widevine_cdm_version.empty())
-    return;
-
-  plugins->push_back(
-      CreateWidevineCdmInfo(widevine_cdm_path, widevine_cdm_version));
-}
-#endif  //  defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-
-AtomContentClient::AtomContentClient() {}
-
-AtomContentClient::~AtomContentClient() {}
-
-std::string AtomContentClient::GetProduct() const {
-  return "Chrome/" CHROME_VERSION_STRING;
-}
-
-std::string AtomContentClient::GetUserAgent() const {
-  return content::BuildUserAgentFromProduct("Chrome/" CHROME_VERSION_STRING
-                                            " " ATOM_PRODUCT_NAME
-                                            "/" ATOM_VERSION_STRING);
-}
-
-base::string16 AtomContentClient::GetLocalizedString(int message_id) const {
-  return l10n_util::GetStringUTF16(message_id);
-}
-
-void AtomContentClient::AddAdditionalSchemes(Schemes* schemes) {
-  schemes->standard_schemes.push_back("chrome-extension");
-
-  std::vector<std::string> splited;
-  ConvertStringWithSeparatorToVector(&splited, ",",
-                                     switches::kRegisterServiceWorkerSchemes);
-  for (const std::string& scheme : splited)
-    schemes->service_worker_schemes.push_back(scheme);
-  schemes->service_worker_schemes.push_back(url::kFileScheme);
-
-  ConvertStringWithSeparatorToVector(&splited, ",", switches::kSecureSchemes);
-  for (const std::string& scheme : splited)
-    schemes->secure_schemes.push_back(scheme);
-}
-
-void AtomContentClient::AddPepperPlugins(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  AddPepperFlashFromCommandLine(plugins);
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-  AddWidevineCdmFromCommandLine(plugins);
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-#if defined(ENABLE_PDF_VIEWER)
-  ComputeBuiltInPlugins(plugins);
-#endif  // defined(ENABLE_PDF_VIEWER)
-}
-
-void AtomContentClient::AddContentDecryptionModules(
-    std::vector<content::CdmInfo>* cdms,
-    std::vector<media::CdmHostFilePath>* cdm_host_file_paths) {
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-  auto command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath widevine_cdm_path =
-      command_line->GetSwitchValuePath(switches::kWidevineCdmPath);
-  if (widevine_cdm_path.empty())
-    return;
-
-  if (!base::PathExists(widevine_cdm_path))
-    return;
-
-  auto widevine_cdm_version =
-      command_line->GetSwitchValueASCII(switches::kWidevineCdmVersion);
-  if (widevine_cdm_version.empty())
-    return;
-
-  std::vector<media::VideoCodec> supported_video_codecs;
-  supported_video_codecs.push_back(media::VideoCodec::kCodecVP8);
-  supported_video_codecs.push_back(media::VideoCodec::kCodecVP9);
-#if BUILDFLAG(USE_PROPRIETARY_CODECS)
-  supported_video_codecs.push_back(media::VideoCodec::kCodecH264);
-#endif  // BUILDFLAG(USE_PROPRIETARY_CODECS)
-  content::CdmRegistry::GetInstance()->RegisterCdm(
-      content::CdmInfo(kWidevineCdmDisplayName, kWidevineCdmGuid,
-                       base::Version(widevine_cdm_version), widevine_cdm_path,
-                       kWidevineCdmFileSystemId, supported_video_codecs, false,
-                       kWidevineKeySystem, false));
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-}
-
-}  // namespace atom
removed in remote
  base   100644 33dbe19d990e6d3030d075f136e591c303b9432f atom/app/atom_content_client.h
  our    100644 b6ecc3407d0e967ba170be76968b4318b56f8450 atom/app/atom_content_client.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_CONTENT_CLIENT_H_
-#define ATOM_APP_ATOM_CONTENT_CLIENT_H_
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "brightray/common/content_client.h"
-
-namespace atom {
-
-class AtomContentClient : public brightray::ContentClient {
- public:
-  AtomContentClient();
-  ~AtomContentClient() override;
-
- protected:
-  // content::ContentClient:
-  std::string GetProduct() const override;
-  std::string GetUserAgent() const override;
-  base::string16 GetLocalizedString(int message_id) const override;
-  void AddAdditionalSchemes(Schemes* schemes) override;
-  void AddPepperPlugins(
-      std::vector<content::PepperPluginInfo>* plugins) override;
-  void AddContentDecryptionModules(
-      std::vector<content::CdmInfo>* cdms,
-      std::vector<media::CdmHostFilePath>* cdm_host_file_paths) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomContentClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_ATOM_CONTENT_CLIENT_H_
removed in remote
  base   100644 e1603fa5942f7b000c3385648530255032e775a2 atom/app/atom_library_main.h
  our    100644 2c7a27caa20a411558010c3c58bd78e7850c0737 atom/app/atom_library_main.h
@@ -1,22 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_LIBRARY_MAIN_H_
-#define ATOM_APP_ATOM_LIBRARY_MAIN_H_
-
-#include "build/build_config.h"
-
-#if defined(OS_MACOSX)
-extern "C" {
-__attribute__((visibility("default"))) int AtomMain(int argc, char* argv[]);
-
-#ifdef ENABLE_RUN_AS_NODE
-__attribute__((visibility("default"))) int AtomInitializeICUandStartNode(
-    int argc,
-    char* argv[]);
-#endif
-}
-#endif  // OS_MACOSX
-
-#endif  // ATOM_APP_ATOM_LIBRARY_MAIN_H_
removed in remote
  base   100644 7ee7522934689937f7be7b0f866134bf611c7d69 atom/app/atom_library_main.mm
  our    100644 57a519fcd0db28548ea75034cf92191161183385 atom/app/atom_library_main.mm
@@ -1,38 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_library_main.h"
-
-#include "atom/app/atom_main_delegate.h"
-#include "atom/app/node_main.h"
-#include "atom/common/atom_command_line.h"
-#include "base/at_exit.h"
-#include "base/i18n/icu_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/scoped_nsautorelease_pool.h"
-#include "brightray/common/mac/main_application_bundle.h"
-#include "content/public/app/content_main.h"
-
-int AtomMain(int argc, char* argv[]) {
-  atom::AtomMainDelegate delegate;
-  content::ContentMainParams params(&delegate);
-  params.argc = argc;
-  params.argv = const_cast<const char**>(argv);
-  atom::AtomCommandLine::Init(argc, argv);
-  return content::ContentMain(params);
-}
-
-#ifdef ENABLE_RUN_AS_NODE
-int AtomInitializeICUandStartNode(int argc, char* argv[]) {
-  base::AtExitManager atexit_manager;
-  base::mac::ScopedNSAutoreleasePool pool;
-  base::mac::SetOverrideFrameworkBundlePath(
-      brightray::MainApplicationBundlePath()
-          .Append("Contents")
-          .Append("Frameworks")
-          .Append(ATOM_PRODUCT_NAME " Framework.framework"));
-  base::i18n::InitializeICU();
-  return atom::NodeMain(argc, argv);
-}
-#endif
removed in remote
  base   100644 cbd0a85d57685e548b00a74f7133692cc92059e6 atom/app/atom_main.cc
  our    100644 fc77100d9acb58221c35f364c4db7866a44d347d atom/app/atom_main.cc
@@ -1,187 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main.h"
-
-#include <cstdlib>
-#include <vector>
-
-#if defined(OS_WIN)
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>  // ensures that ATL statics like `_AtlWinModule` are initialized (it's an issue in static debug build)
-#include <shellapi.h>
-#include <shellscalingapi.h>
-#include <tchar.h>
-
-#include "atom/app/atom_main_delegate.h"
-#include "atom/app/command_line_args.h"
-#include "atom/common/crash_reporter/win/crash_service_main.h"
-#include "base/environment.h"
-#include "base/process/launch.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/windows_version.h"
-#include "content/public/app/sandbox_helper_win.h"
-#include "sandbox/win/src/sandbox_types.h"
-#elif defined(OS_LINUX)                   // defined(OS_WIN)
-#include "atom/app/atom_main_delegate.h"  // NOLINT
-#include "content/public/app/content_main.h"
-#else  // defined(OS_LINUX)
-#include "atom/app/atom_library_main.h"
-#endif  // defined(OS_MACOSX)
-
-#include "atom/app/node_main.h"
-#include "atom/common/atom_command_line.h"
-#include "base/at_exit.h"
-#include "base/i18n/icu_util.h"
-
-namespace {
-
-#ifdef ENABLE_RUN_AS_NODE
-const char kRunAsNode[] = "ELECTRON_RUN_AS_NODE";
-#endif
-
-#if defined(ENABLE_RUN_AS_NODE) || defined(OS_WIN)
-bool IsEnvSet(const char* name) {
-#if defined(OS_WIN)
-  size_t required_size;
-  getenv_s(&required_size, nullptr, 0, name);
-  return required_size != 0;
-#else
-  char* indicator = getenv(name);
-  return indicator && indicator[0] != '\0';
-#endif
-}
-#endif
-
-}  // namespace
-
-#if defined(OS_WIN)
-int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE, wchar_t* cmd, int) {
-  struct Arguments {
-    int argc = 0;
-    wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
-
-    ~Arguments() { LocalFree(argv); }
-  } arguments;
-
-  if (!arguments.argv)
-    return -1;
-
-#ifdef _DEBUG
-  // Don't display assert dialog boxes in CI test runs
-  static const char* kCI = "ELECTRON_CI";
-  bool is_ci = IsEnvSet(kCI);
-  if (!is_ci) {
-    for (int i = 0; i < arguments.argc; ++i) {
-      if (!_wcsicmp(arguments.argv[i], L"--ci")) {
-        is_ci = true;
-        _putenv_s(kCI, "1");  // set flag for child processes
-        break;
-      }
-    }
-  }
-  if (is_ci) {
-    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
-
-    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
-
-    _set_error_mode(_OUT_TO_STDERR);
-  }
-#endif
-
-#ifdef ENABLE_RUN_AS_NODE
-  bool run_as_node = IsEnvSet(kRunAsNode);
-#else
-  bool run_as_node = false;
-#endif
-
-  // Make sure the output is printed to console.
-  if (run_as_node || !IsEnvSet("ELECTRON_NO_ATTACH_CONSOLE"))
-    base::RouteStdioToConsole(false);
-
-#ifndef DEBUG
-  // Chromium has its own TLS subsystem which supports automatic destruction
-  // of thread-local data, and also depends on memory allocation routines
-  // provided by the CRT. The problem is that the auto-destruction mechanism
-  // uses a hidden feature of the OS loader which calls a callback on thread
-  // exit, but only after all loaded DLLs have been detached. Since the CRT is
-  // also a DLL, it happens that by the time Chromium's `OnThreadExit` function
-  // is called, the heap functions, though still in memory, no longer perform
-  // their duties, and when Chromium calls `free` on its buffer, it triggers
-  // an access violation error.
-  // We work around this problem by invoking Chromium's `OnThreadExit` in time
-  // from within the CRT's atexit facility, ensuring the heap functions are
-  // still active. The second invocation from the OS loader will be a no-op.
-  extern void NTAPI OnThreadExit(PVOID module, DWORD reason, PVOID reserved);
-  atexit([]() { OnThreadExit(nullptr, DLL_THREAD_DETACH, nullptr); });
-#endif
-
-#ifdef ENABLE_RUN_AS_NODE
-  if (run_as_node) {
-    std::vector<char*> argv(arguments.argc);
-    std::transform(
-        arguments.argv, arguments.argv + arguments.argc, argv.begin(),
-        [](auto& a) { return _strdup(base::WideToUTF8(a).c_str()); });
-
-    base::AtExitManager atexit_manager;
-    base::i18n::InitializeICU();
-    auto ret = atom::NodeMain(argv.size(), argv.data());
-    std::for_each(argv.begin(), argv.end(), free);
-    return ret;
-  }
-#endif
-
-  if (IsEnvSet("ELECTRON_INTERNAL_CRASH_SERVICE")) {
-    return crash_service::Main(cmd);
-  }
-
-  if (!atom::CheckCommandLineArguments(arguments.argc, arguments.argv))
-    return -1;
-
-  sandbox::SandboxInterfaceInfo sandbox_info = {0};
-  content::InitializeSandboxInfo(&sandbox_info);
-  atom::AtomMainDelegate delegate;
-
-  content::ContentMainParams params(&delegate);
-  params.instance = instance;
-  params.sandbox_info = &sandbox_info;
-  atom::AtomCommandLine::Init(arguments.argc, arguments.argv);
-  return content::ContentMain(params);
-}
-
-#elif defined(OS_LINUX)  // defined(OS_WIN)
-
-int main(int argc, char* argv[]) {
-#ifdef ENABLE_RUN_AS_NODE
-  if (IsEnvSet(kRunAsNode)) {
-    base::i18n::InitializeICU();
-    base::AtExitManager atexit_manager;
-    return atom::NodeMain(argc, argv);
-  }
-#endif
-
-  atom::AtomMainDelegate delegate;
-  content::ContentMainParams params(&delegate);
-  params.argc = argc;
-  params.argv = const_cast<const char**>(argv);
-  atom::AtomCommandLine::Init(argc, argv);
-  return content::ContentMain(params);
-}
-
-#else  // defined(OS_LINUX)
-
-int main(int argc, char* argv[]) {
-#ifdef ENABLE_RUN_AS_NODE
-  if (IsEnvSet(kRunAsNode)) {
-    return AtomInitializeICUandStartNode(argc, argv);
-  }
-#endif
-
-  return AtomMain(argc, argv);
-}
-
-#endif  // defined(OS_MACOSX)
removed in remote
  base   100644 30663a429e936cd26efa35a188f293f34a783d92 atom/app/atom_main.h
  our    100644 30663a429e936cd26efa35a188f293f34a783d92 atom/app/atom_main.h
@@ -1,10 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_MAIN_H_
-#define ATOM_APP_ATOM_MAIN_H_
-
-#include "content/public/app/content_main.h"
-
-#endif  // ATOM_APP_ATOM_MAIN_H_
removed in remote
  base   100644 221d59c1619cc440671083dc74ab52fc5cc948a8 atom/app/atom_main_delegate.cc
  our    100644 b3b5b8f2a8f24b8928f69a286c80e8a3b8464366 atom/app/atom_main_delegate.cc
@@ -1,209 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main_delegate.h"
-
-#include <iostream>
-#include <string>
-
-#include "atom/app/atom_content_client.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/relauncher.h"
-#include "atom/common/google_api_key.h"
-#include "atom/common/options_switches.h"
-#include "atom/renderer/atom_renderer_client.h"
-#include "atom/renderer/atom_sandboxed_renderer_client.h"
-#include "atom/utility/atom_content_utility_client.h"
-#include "base/command_line.h"
-#include "base/debug/stack_trace.h"
-#include "base/environment.h"
-#include "base/logging.h"
-#include "chrome/common/chrome_paths.h"
-#include "content/public/common/content_switches.h"
-#include "ipc/ipc_features.h"
-#include "services/service_manager/sandbox/switches.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-
-#if BUILDFLAG(IPC_MESSAGE_LOG_ENABLED)
-#define IPC_MESSAGE_MACROS_LOG_ENABLED
-#include "content/public/common/content_ipc_logging.h"
-#define IPC_LOG_TABLE_ADD_ENTRY(msg_id, logger) \
-  content::RegisterIPCLogger(msg_id, logger)
-#include "atom/common/common_message_generator.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-const char* kRelauncherProcess = "relauncher";
-
-bool IsBrowserProcess(base::CommandLine* cmd) {
-  std::string process_type = cmd->GetSwitchValueASCII(::switches::kProcessType);
-  return process_type.empty();
-}
-
-#if defined(OS_WIN)
-void InvalidParameterHandler(const wchar_t*,
-                             const wchar_t*,
-                             const wchar_t*,
-                             unsigned int,
-                             uintptr_t) {
-  // noop.
-}
-#endif
-
-}  // namespace
-
-AtomMainDelegate::AtomMainDelegate() {}
-
-AtomMainDelegate::~AtomMainDelegate() {}
-
-bool AtomMainDelegate::BasicStartupComplete(int* exit_code) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  logging::LoggingSettings settings;
-#if defined(OS_WIN)
-  // On Windows the terminal returns immediately, so we add a new line to
-  // prevent output in the same line as the prompt.
-  if (IsBrowserProcess(command_line))
-    std::wcout << std::endl;
-#if defined(DEBUG)
-  // Print logging to debug.log on Windows
-  settings.logging_dest = logging::LOG_TO_ALL;
-  settings.log_file = L"debug.log";
-  settings.lock_log = logging::LOCK_LOG_FILE;
-  settings.delete_old = logging::DELETE_OLD_LOG_FILE;
-#else
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-#endif  // defined(DEBUG)
-#else   // defined(OS_WIN)
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-#endif  // !defined(OS_WIN)
-
-  // Only enable logging when --enable-logging is specified.
-  auto env = base::Environment::Create();
-  if (!command_line->HasSwitch(::switches::kEnableLogging) &&
-      !env->HasVar("ELECTRON_ENABLE_LOGGING")) {
-    settings.logging_dest = logging::LOG_NONE;
-    logging::SetMinLogLevel(logging::LOG_NUM_SEVERITIES);
-  }
-
-  logging::InitLogging(settings);
-
-  // Logging with pid and timestamp.
-  logging::SetLogItems(true, false, true, false);
-
-  // Enable convient stack printing.
-#if defined(DEBUG) && defined(OS_LINUX)
-  bool enable_stack_dumping = true;
-#else
-  bool enable_stack_dumping = env->HasVar("ELECTRON_ENABLE_STACK_DUMPING");
-#endif
-#if defined(ARCH_CPU_ARM_FAMILY) && defined(ARCH_CPU_32_BITS)
-  // For 32bit ARM enabling stack printing would end up crashing.
-  // https://github.com/electron/electron/pull/11230#issuecomment-363232482
-  enable_stack_dumping = false;
-#endif
-  if (enable_stack_dumping)
-    base::debug::EnableInProcessStackDumping();
-
-  chrome::RegisterPathProvider();
-
-#if defined(OS_MACOSX)
-  SetUpBundleOverrides();
-#endif
-
-#if defined(OS_WIN)
-  // Ignore invalid parameter errors.
-  _set_invalid_parameter_handler(InvalidParameterHandler);
-  // Disable the ActiveVerifier, which is used by Chrome to track possible
-  // bugs, but no use in Electron.
-  base::win::DisableHandleVerifier();
-#endif
-
-  return brightray::MainDelegate::BasicStartupComplete(exit_code);
-}
-
-void AtomMainDelegate::PreSandboxStartup() {
-  brightray::MainDelegate::PreSandboxStartup();
-
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  // Only append arguments for browser process.
-  if (!IsBrowserProcess(command_line))
-    return;
-
-  if (!command_line->HasSwitch(switches::kEnableMixedSandbox)) {
-    if (command_line->HasSwitch(switches::kEnableSandbox)) {
-      // Disable setuid sandbox since it is not longer required on
-      // linux(namespace sandbox is available on most distros).
-      command_line->AppendSwitch(
-          service_manager::switches::kDisableSetuidSandbox);
-    } else {
-      // Disable renderer sandbox for most of node's functions.
-      command_line->AppendSwitch(::switches::kNoSandbox);
-    }
-  }
-
-  // Allow file:// URIs to read other file:// URIs by default.
-  command_line->AppendSwitch(::switches::kAllowFileAccessFromFiles);
-
-#if defined(OS_MACOSX)
-  // Enable AVFoundation.
-  command_line->AppendSwitch("enable-avfoundation");
-#endif
-}
-
-content::ContentBrowserClient* AtomMainDelegate::CreateContentBrowserClient() {
-  browser_client_.reset(new AtomBrowserClient);
-  return browser_client_.get();
-}
-
-content::ContentRendererClient*
-AtomMainDelegate::CreateContentRendererClient() {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnableSandbox) ||
-      !base::CommandLine::ForCurrentProcess()->HasSwitch(
-          ::switches::kNoSandbox)) {
-    renderer_client_.reset(new AtomSandboxedRendererClient);
-  } else {
-    renderer_client_.reset(new AtomRendererClient);
-  }
-
-  return renderer_client_.get();
-}
-
-content::ContentUtilityClient* AtomMainDelegate::CreateContentUtilityClient() {
-  utility_client_.reset(new AtomContentUtilityClient);
-  return utility_client_.get();
-}
-
-int AtomMainDelegate::RunProcess(
-    const std::string& process_type,
-    const content::MainFunctionParams& main_function_params) {
-  if (process_type == kRelauncherProcess)
-    return relauncher::RelauncherMain(main_function_params);
-  else
-    return -1;
-}
-
-#if defined(OS_MACOSX)
-bool AtomMainDelegate::ShouldSendMachPort(const std::string& process_type) {
-  return process_type != kRelauncherProcess;
-}
-
-bool AtomMainDelegate::DelaySandboxInitialization(
-    const std::string& process_type) {
-  return process_type == kRelauncherProcess;
-}
-#endif
-
-std::unique_ptr<brightray::ContentClient>
-AtomMainDelegate::CreateContentClient() {
-  return std::make_unique<AtomContentClient>();
-}
-
-}  // namespace atom
removed in remote
  base   100644 5f4369302f5f6d0b6e03f0f0fe90f3f7b222d54a atom/app/atom_main_delegate.h
  our    100644 affdea01eec2ecb340a9d48c1fd1b6c22ed15e11 atom/app/atom_main_delegate.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_MAIN_DELEGATE_H_
-#define ATOM_APP_ATOM_MAIN_DELEGATE_H_
-
-#include <string>
-
-#include "brightray/common/content_client.h"
-#include "brightray/common/main_delegate.h"
-
-namespace atom {
-
-class AtomMainDelegate : public brightray::MainDelegate {
- public:
-  AtomMainDelegate();
-  ~AtomMainDelegate() override;
-
- protected:
-  // content::ContentMainDelegate:
-  bool BasicStartupComplete(int* exit_code) override;
-  void PreSandboxStartup() override;
-  content::ContentBrowserClient* CreateContentBrowserClient() override;
-  content::ContentRendererClient* CreateContentRendererClient() override;
-  content::ContentUtilityClient* CreateContentUtilityClient() override;
-  int RunProcess(
-      const std::string& process_type,
-      const content::MainFunctionParams& main_function_params) override;
-#if defined(OS_MACOSX)
-  bool ShouldSendMachPort(const std::string& process_type) override;
-  bool DelaySandboxInitialization(const std::string& process_type) override;
-#endif
-
-  // brightray::MainDelegate:
-  std::unique_ptr<brightray::ContentClient> CreateContentClient() override;
-#if defined(OS_MACOSX)
-  void OverrideChildProcessPath() override;
-  void OverrideFrameworkBundlePath() override;
-#endif
-
- private:
-#if defined(OS_MACOSX)
-  void SetUpBundleOverrides();
-#endif
-
-  std::unique_ptr<content::ContentBrowserClient> browser_client_;
-  std::unique_ptr<content::ContentRendererClient> renderer_client_;
-  std::unique_ptr<content::ContentUtilityClient> utility_client_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomMainDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_ATOM_MAIN_DELEGATE_H_
removed in remote
  base   100644 33a8dea4aabb9733b768bf3e2610ab82f3c8fafe atom/app/atom_main_delegate_mac.mm
  our    100644 3fcf6db68b6714b07b400c9b016055beb47174f4 atom/app/atom_main_delegate_mac.mm
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main_delegate.h"
-
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/scoped_nsautorelease_pool.h"
-#include "base/path_service.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "brightray/common/mac/main_application_bundle.h"
-#include "content/public/common/content_paths.h"
-
-namespace atom {
-
-namespace {
-
-base::FilePath GetFrameworksPath() {
-  return brightray::MainApplicationBundlePath()
-      .Append("Contents")
-      .Append("Frameworks");
-}
-
-base::FilePath GetHelperAppPath(const base::FilePath& frameworks_path,
-                                const std::string& name) {
-  return frameworks_path.Append(name + " Helper.app")
-      .Append("Contents")
-      .Append("MacOS")
-      .Append(name + " Helper");
-}
-
-}  // namespace
-
-void AtomMainDelegate::OverrideFrameworkBundlePath() {
-  base::mac::SetOverrideFrameworkBundlePath(
-      GetFrameworksPath().Append(ATOM_PRODUCT_NAME " Framework.framework"));
-}
-
-void AtomMainDelegate::OverrideChildProcessPath() {
-  base::FilePath frameworks_path = GetFrameworksPath();
-  base::FilePath helper_path =
-      GetHelperAppPath(frameworks_path, ATOM_PRODUCT_NAME);
-  if (!base::PathExists(helper_path))
-    helper_path =
-        GetHelperAppPath(frameworks_path, brightray::GetApplicationName());
-  if (!base::PathExists(helper_path))
-    LOG(FATAL) << "Unable to find helper app";
-  PathService::Override(content::CHILD_PROCESS_EXE, helper_path);
-}
-
-void AtomMainDelegate::SetUpBundleOverrides() {
-  base::mac::ScopedNSAutoreleasePool pool;
-  NSBundle* bundle = brightray::MainApplicationBundle();
-  std::string base_bundle_id =
-      base::SysNSStringToUTF8([bundle bundleIdentifier]);
-  NSString* team_id = [bundle objectForInfoDictionaryKey:@"ElectronTeamID"];
-  if (team_id)
-    base_bundle_id = base::SysNSStringToUTF8(team_id) + "." + base_bundle_id;
-  base::mac::SetBaseBundleID(base_bundle_id.c_str());
-}
-
-}  // namespace atom
removed in remote
  base   100644 b946ae28ff94a08cfb9bd7bb9159170c78001ee8 atom/app/node_main.cc
  our    100644 9a95165f77a2585b06975bb3dfd0f5e573329410 atom/app/node_main.cc
@@ -1,120 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifdef ENABLE_RUN_AS_NODE
-
-#include "atom/app/node_main.h"
-
-#include "atom/app/uv_task_runner.h"
-#include "atom/browser/javascript_environment.h"
-#include "atom/browser/node_debugger.h"
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_bindings.h"
-#include "base/command_line.h"
-#include "base/feature_list.h"
-#include "base/task_scheduler/task_scheduler.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "gin/array_buffer.h"
-#include "gin/public/isolate_holder.h"
-#include "gin/v8_initializer.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-int NodeMain(int argc, char* argv[]) {
-  base::CommandLine::Init(argc, argv);
-
-  int exit_code = 1;
-  {
-    // Feed gin::PerIsolateData with a task runner.
-    argv = uv_setup_args(argc, argv);
-    uv_loop_t* loop = uv_default_loop();
-    scoped_refptr<UvTaskRunner> uv_task_runner(new UvTaskRunner(loop));
-    base::ThreadTaskRunnerHandle handle(uv_task_runner);
-
-    // Initialize feature list.
-    auto feature_list = std::make_unique<base::FeatureList>();
-    feature_list->InitializeFromCommandLine("", "");
-    base::FeatureList::SetInstance(std::move(feature_list));
-
-    gin::V8Initializer::LoadV8Snapshot(
-        gin::V8Initializer::V8SnapshotFileType::kWithAdditionalContext);
-    gin::V8Initializer::LoadV8Natives();
-
-    // V8 requires a task scheduler apparently
-    base::TaskScheduler::CreateAndStartWithDefaultParams("Electron");
-
-    // Initialize gin::IsolateHolder.
-    JavascriptEnvironment gin_env;
-
-    // Explicitly register electron's builtin modules.
-    NodeBindings::RegisterBuiltinModules();
-
-    int exec_argc;
-    const char** exec_argv;
-    node::Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);
-
-    node::Environment* env = node::CreateEnvironment(
-        node::CreateIsolateData(gin_env.isolate(), loop, gin_env.platform()),
-        gin_env.context(), argc, argv, exec_argc, exec_argv);
-
-    // Enable support for v8 inspector.
-    NodeDebugger node_debugger(env);
-    node_debugger.Start(gin_env.platform());
-
-    mate::Dictionary process(gin_env.isolate(), env->process_object());
-#if defined(OS_WIN)
-    process.SetMethod("log", &AtomBindings::Log);
-#endif
-    process.SetMethod("crash", &AtomBindings::Crash);
-
-    // Setup process.crashReporter.start in child node processes
-    auto reporter = mate::Dictionary::CreateEmpty(gin_env.isolate());
-    reporter.SetMethod("start", &crash_reporter::CrashReporter::StartInstance);
-    process.Set("crashReporter", reporter);
-
-    node::LoadEnvironment(env);
-
-    bool more;
-    do {
-      more = uv_run(env->event_loop(), UV_RUN_ONCE);
-      gin_env.platform()->DrainBackgroundTasks(env->isolate());
-      if (more == false) {
-        node::EmitBeforeExit(env);
-
-        // Emit `beforeExit` if the loop became alive either after emitting
-        // event, or after running some callbacks.
-        more = uv_loop_alive(env->event_loop());
-        if (uv_run(env->event_loop(), UV_RUN_NOWAIT) != 0)
-          more = true;
-      }
-    } while (more == true);
-
-    exit_code = node::EmitExit(env);
-    node::RunAtExit(env);
-    gin_env.platform()->DrainBackgroundTasks(env->isolate());
-    gin_env.platform()->CancelPendingDelayedTasks(env->isolate());
-
-    node::FreeEnvironment(env);
-  }
-
-  // According to "src/gin/shell/gin_main.cc":
-  //
-  // gin::IsolateHolder waits for tasks running in TaskScheduler in its
-  // destructor and thus must be destroyed before TaskScheduler starts skipping
-  // CONTINUE_ON_SHUTDOWN tasks.
-  base::TaskScheduler::GetInstance()->Shutdown();
-
-  v8::V8::Dispose();
-
-  return exit_code;
-}
-
-}  // namespace atom
-
-#endif  // ENABLE_RUN_AS_NODE
removed in remote
  base   100644 a4e047de39f180b9022dc178fc58979f5b879aa3 atom/app/node_main.h
  our    100644 68fe25f6df6acc2e59d0379454c69ca227dae020 atom/app/node_main.h
@@ -1,18 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_NODE_MAIN_H_
-#define ATOM_APP_NODE_MAIN_H_
-
-#ifdef ENABLE_RUN_AS_NODE
-
-namespace atom {
-
-int NodeMain(int argc, char* argv[]);
-
-}  // namespace atom
-
-#endif  // ENABLE_RUN_AS_NODE
-
-#endif  // ATOM_APP_NODE_MAIN_H_
removed in remote
  base   100644 097cc3bcda182c36ffeffa5cbb3cf3442ebaedbe atom/app/uv_task_runner.cc
  our    100644 60befc6db8ff4773f9aecfa890271940bfa29634 atom/app/uv_task_runner.cc
@@ -1,60 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <utility>
-
-#include "atom/app/uv_task_runner.h"
-
-#include "base/stl_util.h"
-
-namespace atom {
-
-UvTaskRunner::UvTaskRunner(uv_loop_t* loop) : loop_(loop) {}
-
-UvTaskRunner::~UvTaskRunner() {
-  for (auto& iter : tasks_) {
-    uv_unref(reinterpret_cast<uv_handle_t*>(iter.first));
-    delete iter.first;
-  }
-}
-
-bool UvTaskRunner::PostDelayedTask(const base::Location& from_here,
-                                   base::OnceClosure task,
-                                   base::TimeDelta delay) {
-  auto* timer = new uv_timer_t;
-  timer->data = this;
-  uv_timer_init(loop_, timer);
-  uv_timer_start(timer, UvTaskRunner::OnTimeout, delay.InMilliseconds(), 0);
-  tasks_[timer] = std::move(task);
-  return true;
-}
-
-bool UvTaskRunner::RunsTasksInCurrentSequence() const {
-  return true;
-}
-
-bool UvTaskRunner::PostNonNestableDelayedTask(const base::Location& from_here,
-                                              base::OnceClosure task,
-                                              base::TimeDelta delay) {
-  return PostDelayedTask(from_here, std::move(task), delay);
-}
-
-// static
-void UvTaskRunner::OnTimeout(uv_timer_t* timer) {
-  UvTaskRunner* self = static_cast<UvTaskRunner*>(timer->data);
-  if (!ContainsKey(self->tasks_, timer))
-    return;
-
-  std::move(self->tasks_[timer]).Run();
-  self->tasks_.erase(timer);
-  uv_timer_stop(timer);
-  uv_close(reinterpret_cast<uv_handle_t*>(timer), UvTaskRunner::OnClose);
-}
-
-// static
-void UvTaskRunner::OnClose(uv_handle_t* handle) {
-  delete reinterpret_cast<uv_timer_t*>(handle);
-}
-
-}  // namespace atom
removed in remote
  base   100644 c7302766c2d1786cc00d58c56ca529574f09ac8d atom/app/uv_task_runner.h
  our    100644 578024d70486ba2f4a3cf9dc643a19bc857158db atom/app/uv_task_runner.h
@@ -1,45 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_UV_TASK_RUNNER_H_
-#define ATOM_APP_UV_TASK_RUNNER_H_
-
-#include <map>
-
-#include "base/callback.h"
-#include "base/location.h"
-#include "base/single_thread_task_runner.h"
-#include "uv.h"  // NOLINT(build/include)
-
-namespace atom {
-
-// TaskRunner implementation that posts tasks into libuv's default loop.
-class UvTaskRunner : public base::SingleThreadTaskRunner {
- public:
-  explicit UvTaskRunner(uv_loop_t* loop);
-
-  // base::SingleThreadTaskRunner:
-  bool PostDelayedTask(const base::Location& from_here,
-                       base::OnceClosure task,
-                       base::TimeDelta delay) override;
-  bool RunsTasksInCurrentSequence() const override;
-  bool PostNonNestableDelayedTask(const base::Location& from_here,
-                                  base::OnceClosure task,
-                                  base::TimeDelta delay) override;
-
- private:
-  ~UvTaskRunner() override;
-  static void OnTimeout(uv_timer_t* timer);
-  static void OnClose(uv_handle_t* handle);
-
-  uv_loop_t* loop_;
-
-  std::map<uv_timer_t*, base::OnceClosure> tasks_;
-
-  DISALLOW_COPY_AND_ASSIGN(UvTaskRunner);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_UV_TASK_RUNNER_H_
removed in remote
  base   100644 ad5b7214ccd724927f25292463c2972b7391313b atom/browser/api/atom_api_app.cc
  our    100644 089a2b63d1bae3afebea925582a3aac81ddeaa4f atom/browser/api/atom_api_app.cc
@@ -1,1378 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_app.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/login_handler.h"
-#include "atom/browser/relauncher.h"
-#include "atom/common/atom_command_line.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/network_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/path_service.h"
-#include "base/strings/string_util.h"
-#include "base/sys_info.h"
-#include "brightray/browser/brightray_paths.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/icon_manager.h"
-#include "chrome/common/chrome_paths.h"
-#include "content/browser/gpu/compositor_util.h"
-#include "content/browser/gpu/gpu_data_manager_impl.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "content/public/browser/browser_child_process_host.h"
-#include "content/public/browser/child_process_data.h"
-#include "content/public/browser/client_certificate_delegate.h"
-#include "content/public/browser/gpu_data_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/common/content_switches.h"
-#include "media/audio/audio_manager.h"
-#include "native_mate/object_template_builder.h"
-#include "net/ssl/client_cert_identity.h"
-#include "net/ssl/ssl_cert_request_info.h"
-#include "services/network/public/cpp/network_switches.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/gfx/image/image.h"
-
-#if defined(OS_WIN)
-#include "atom/browser/ui/win/jump_list.h"
-#include "base/strings/utf_string_conversions.h"
-#endif
-
-#if defined(OS_MACOSX)
-#include "atom/browser/ui/cocoa/atom_bundle_mover.h"
-#endif
-
-using atom::Browser;
-
-namespace mate {
-
-#if defined(OS_WIN)
-template <>
-struct Converter<Browser::UserTask> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     Browser::UserTask* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    if (!dict.Get("program", &(out->program)) ||
-        !dict.Get("title", &(out->title)))
-      return false;
-    if (dict.Get("iconPath", &(out->icon_path)) &&
-        !dict.Get("iconIndex", &(out->icon_index)))
-      return false;
-    dict.Get("arguments", &(out->arguments));
-    dict.Get("description", &(out->description));
-    return true;
-  }
-};
-
-using atom::JumpListCategory;
-using atom::JumpListItem;
-using atom::JumpListResult;
-
-template <>
-struct Converter<JumpListItem::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListItem::Type* out) {
-    std::string item_type;
-    if (!ConvertFromV8(isolate, val, &item_type))
-      return false;
-
-    if (item_type == "task")
-      *out = JumpListItem::Type::TASK;
-    else if (item_type == "separator")
-      *out = JumpListItem::Type::SEPARATOR;
-    else if (item_type == "file")
-      *out = JumpListItem::Type::FILE;
-    else
-      return false;
-
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   JumpListItem::Type val) {
-    std::string item_type;
-    switch (val) {
-      case JumpListItem::Type::TASK:
-        item_type = "task";
-        break;
-
-      case JumpListItem::Type::SEPARATOR:
-        item_type = "separator";
-        break;
-
-      case JumpListItem::Type::FILE:
-        item_type = "file";
-        break;
-    }
-    return mate::ConvertToV8(isolate, item_type);
-  }
-};
-
-template <>
-struct Converter<JumpListItem> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListItem* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    if (!dict.Get("type", &(out->type)))
-      return false;
-
-    switch (out->type) {
-      case JumpListItem::Type::TASK:
-        if (!dict.Get("program", &(out->path)) ||
-            !dict.Get("title", &(out->title)))
-          return false;
-
-        if (dict.Get("iconPath", &(out->icon_path)) &&
-            !dict.Get("iconIndex", &(out->icon_index)))
-          return false;
-
-        dict.Get("args", &(out->arguments));
-        dict.Get("description", &(out->description));
-        return true;
-
-      case JumpListItem::Type::SEPARATOR:
-        return true;
-
-      case JumpListItem::Type::FILE:
-        return dict.Get("path", &(out->path));
-    }
-
-    assert(false);
-    return false;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const JumpListItem& val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("type", val.type);
-
-    switch (val.type) {
-      case JumpListItem::Type::TASK:
-        dict.Set("program", val.path);
-        dict.Set("args", val.arguments);
-        dict.Set("title", val.title);
-        dict.Set("iconPath", val.icon_path);
-        dict.Set("iconIndex", val.icon_index);
-        dict.Set("description", val.description);
-        break;
-
-      case JumpListItem::Type::SEPARATOR:
-        break;
-
-      case JumpListItem::Type::FILE:
-        dict.Set("path", val.path);
-        break;
-    }
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<JumpListCategory::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListCategory::Type* out) {
-    std::string category_type;
-    if (!ConvertFromV8(isolate, val, &category_type))
-      return false;
-
-    if (category_type == "tasks")
-      *out = JumpListCategory::Type::TASKS;
-    else if (category_type == "frequent")
-      *out = JumpListCategory::Type::FREQUENT;
-    else if (category_type == "recent")
-      *out = JumpListCategory::Type::RECENT;
-    else if (category_type == "custom")
-      *out = JumpListCategory::Type::CUSTOM;
-    else
-      return false;
-
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   JumpListCategory::Type val) {
-    std::string category_type;
-    switch (val) {
-      case JumpListCategory::Type::TASKS:
-        category_type = "tasks";
-        break;
-
-      case JumpListCategory::Type::FREQUENT:
-        category_type = "frequent";
-        break;
-
-      case JumpListCategory::Type::RECENT:
-        category_type = "recent";
-        break;
-
-      case JumpListCategory::Type::CUSTOM:
-        category_type = "custom";
-        break;
-    }
-    return mate::ConvertToV8(isolate, category_type);
-  }
-};
-
-template <>
-struct Converter<JumpListCategory> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListCategory* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    if (dict.Get("name", &(out->name)) && out->name.empty())
-      return false;
-
-    if (!dict.Get("type", &(out->type))) {
-      if (out->name.empty())
-        out->type = JumpListCategory::Type::TASKS;
-      else
-        out->type = JumpListCategory::Type::CUSTOM;
-    }
-
-    if ((out->type == JumpListCategory::Type::TASKS) ||
-        (out->type == JumpListCategory::Type::CUSTOM)) {
-      if (!dict.Get("items", &(out->items)))
-        return false;
-    }
-
-    return true;
-  }
-};
-
-// static
-template <>
-struct Converter<JumpListResult> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, JumpListResult val) {
-    std::string result_code;
-    switch (val) {
-      case JumpListResult::SUCCESS:
-        result_code = "ok";
-        break;
-
-      case JumpListResult::ARGUMENT_ERROR:
-        result_code = "argumentError";
-        break;
-
-      case JumpListResult::GENERIC_ERROR:
-        result_code = "error";
-        break;
-
-      case JumpListResult::CUSTOM_CATEGORY_SEPARATOR_ERROR:
-        result_code = "invalidSeparatorError";
-        break;
-
-      case JumpListResult::MISSING_FILE_TYPE_REGISTRATION_ERROR:
-        result_code = "fileTypeRegistrationError";
-        break;
-
-      case JumpListResult::CUSTOM_CATEGORY_ACCESS_DENIED_ERROR:
-        result_code = "customCategoryAccessDeniedError";
-        break;
-    }
-    return ConvertToV8(isolate, result_code);
-  }
-};
-#endif
-
-template <>
-struct Converter<Browser::LoginItemSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     Browser::LoginItemSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    dict.Get("openAtLogin", &(out->open_at_login));
-    dict.Get("openAsHidden", &(out->open_as_hidden));
-    dict.Get("path", &(out->path));
-    dict.Get("args", &(out->args));
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   Browser::LoginItemSettings val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("openAtLogin", val.open_at_login);
-    dict.Set("openAsHidden", val.open_as_hidden);
-    dict.Set("restoreState", val.restore_state);
-    dict.Set("wasOpenedAtLogin", val.opened_at_login);
-    dict.Set("wasOpenedAsHidden", val.opened_as_hidden);
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<content::CertificateRequestResultType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::CertificateRequestResultType* out) {
-    bool b;
-    if (!ConvertFromV8(isolate, val, &b))
-      return false;
-    *out = b ? content::CERTIFICATE_REQUEST_RESULT_TYPE_CONTINUE
-             : content::CERTIFICATE_REQUEST_RESULT_TYPE_CANCEL;
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-ProcessMetric::ProcessMetric(int type,
-                             base::ProcessId pid,
-                             std::unique_ptr<base::ProcessMetrics> metrics) {
-  this->type = type;
-  this->pid = pid;
-  this->metrics = std::move(metrics);
-}
-
-ProcessMetric::~ProcessMetric() = default;
-
-namespace api {
-
-namespace {
-
-class AppIdProcessIterator : public base::ProcessIterator {
- public:
-  AppIdProcessIterator() : base::ProcessIterator(nullptr) {}
-
- protected:
-  bool IncludeEntry() override {
-    return (entry().parent_pid() == base::GetCurrentProcId() ||
-            entry().pid() == base::GetCurrentProcId());
-  }
-};
-
-IconLoader::IconSize GetIconSizeByString(const std::string& size) {
-  if (size == "small") {
-    return IconLoader::IconSize::SMALL;
-  } else if (size == "large") {
-    return IconLoader::IconSize::LARGE;
-  }
-  return IconLoader::IconSize::NORMAL;
-}
-
-// Return the path constant from string.
-int GetPathConstant(const std::string& name) {
-  if (name == "appData")
-    return brightray::DIR_APP_DATA;
-  else if (name == "userData")
-    return brightray::DIR_USER_DATA;
-  else if (name == "cache")
-    return brightray::DIR_CACHE;
-  else if (name == "userCache")
-    return brightray::DIR_USER_CACHE;
-  else if (name == "logs")
-    return brightray::DIR_APP_LOGS;
-  else if (name == "home")
-    return base::DIR_HOME;
-  else if (name == "temp")
-    return base::DIR_TEMP;
-  else if (name == "userDesktop" || name == "desktop")
-    return base::DIR_USER_DESKTOP;
-  else if (name == "exe")
-    return base::FILE_EXE;
-  else if (name == "module")
-    return base::FILE_MODULE;
-  else if (name == "documents")
-    return chrome::DIR_USER_DOCUMENTS;
-  else if (name == "downloads")
-    return chrome::DIR_DEFAULT_DOWNLOADS;
-  else if (name == "music")
-    return chrome::DIR_USER_MUSIC;
-  else if (name == "pictures")
-    return chrome::DIR_USER_PICTURES;
-  else if (name == "videos")
-    return chrome::DIR_USER_VIDEOS;
-  else if (name == "pepperFlashSystemPlugin")
-    return chrome::FILE_PEPPER_FLASH_SYSTEM_PLUGIN;
-  else
-    return -1;
-}
-
-bool NotificationCallbackWrapper(
-    const base::Callback<
-        void(const base::CommandLine::StringVector& command_line,
-             const base::FilePath& current_directory)>& callback,
-    const base::CommandLine::StringVector& cmd,
-    const base::FilePath& cwd) {
-  // Make sure the callback is called after app gets ready.
-  if (Browser::Get()->is_ready()) {
-    callback.Run(cmd, cwd);
-  } else {
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner(
-        base::ThreadTaskRunnerHandle::Get());
-    task_runner->PostTask(
-        FROM_HERE, base::BindOnce(base::IgnoreResult(callback), cmd, cwd));
-  }
-  // ProcessSingleton needs to know whether current process is quiting.
-  return !Browser::Get()->is_shutting_down();
-}
-
-void GotPrivateKey(std::shared_ptr<content::ClientCertificateDelegate> delegate,
-                   scoped_refptr<net::X509Certificate> cert,
-                   scoped_refptr<net::SSLPrivateKey> private_key) {
-  delegate->ContinueWithCertificate(cert, private_key);
-}
-
-void OnClientCertificateSelected(
-    v8::Isolate* isolate,
-    std::shared_ptr<content::ClientCertificateDelegate> delegate,
-    std::shared_ptr<net::ClientCertIdentityList> identities,
-    mate::Arguments* args) {
-  if (args->Length() == 2) {
-    delegate->ContinueWithCertificate(nullptr, nullptr);
-    return;
-  }
-
-  v8::Local<v8::Value> val;
-  args->GetNext(&val);
-  if (val->IsNull()) {
-    delegate->ContinueWithCertificate(nullptr, nullptr);
-    return;
-  }
-
-  mate::Dictionary cert_data;
-  if (!mate::ConvertFromV8(isolate, val, &cert_data)) {
-    args->ThrowError("Must pass valid certificate object.");
-    return;
-  }
-
-  std::string data;
-  if (!cert_data.Get("data", &data))
-    return;
-
-  auto certs = net::X509Certificate::CreateCertificateListFromBytes(
-      data.c_str(), data.length(), net::X509Certificate::FORMAT_AUTO);
-  if (!certs.empty()) {
-    scoped_refptr<net::X509Certificate> cert(certs[0].get());
-    for (size_t i = 0; i < identities->size(); ++i) {
-      if (cert->Equals((*identities)[i]->certificate())) {
-        net::ClientCertIdentity::SelfOwningAcquirePrivateKey(
-            std::move((*identities)[i]),
-            base::Bind(&GotPrivateKey, delegate, std::move(cert)));
-        break;
-      }
-    }
-  }
-}
-
-void PassLoginInformation(scoped_refptr<LoginHandler> login_handler,
-                          mate::Arguments* args) {
-  base::string16 username, password;
-  if (args->GetNext(&username) && args->GetNext(&password))
-    login_handler->Login(username, password);
-  else
-    login_handler->CancelAuth();
-}
-
-#if defined(USE_NSS_CERTS)
-int ImportIntoCertStore(CertificateManagerModel* model,
-                        const base::DictionaryValue& options) {
-  std::string file_data, cert_path;
-  base::string16 password;
-  net::ScopedCERTCertificateList imported_certs;
-  int rv = -1;
-  options.GetString("certificate", &cert_path);
-  options.GetString("password", &password);
-
-  if (!cert_path.empty()) {
-    if (base::ReadFileToString(base::FilePath(cert_path), &file_data)) {
-      auto module = model->cert_db()->GetPrivateSlot();
-      rv = model->ImportFromPKCS12(module.get(), file_data, password, true,
-                                   &imported_certs);
-      if (imported_certs.size() > 1) {
-        auto it = imported_certs.begin();
-        ++it;  // skip first which would  be the client certificate.
-        for (; it != imported_certs.end(); ++it)
-          rv &= model->SetCertTrust(it->get(), net::CA_CERT,
-                                    net::NSSCertDatabase::TRUSTED_SSL);
-      }
-    }
-  }
-  return rv;
-}
-#endif
-
-void OnIconDataAvailable(v8::Isolate* isolate,
-                         const App::FileIconCallback& callback,
-                         gfx::Image* icon) {
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-
-  if (icon && !icon->IsEmpty()) {
-    callback.Run(v8::Null(isolate), *icon);
-  } else {
-    v8::Local<v8::String> error_message =
-        v8::String::NewFromUtf8(isolate, "Failed to get file icon.");
-    callback.Run(v8::Exception::Error(error_message), gfx::Image());
-  }
-}
-
-}  // namespace
-
-App::App(v8::Isolate* isolate) {
-  static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())->set_delegate(this);
-  Browser::Get()->AddObserver(this);
-  content::GpuDataManager::GetInstance()->AddObserver(this);
-  base::ProcessId pid = base::GetCurrentProcId();
-  auto process_metric = std::make_unique<atom::ProcessMetric>(
-      content::PROCESS_TYPE_BROWSER, pid,
-      base::ProcessMetrics::CreateCurrentProcessMetrics());
-  app_metrics_[pid] = std::move(process_metric);
-  Init(isolate);
-}
-
-App::~App() {
-  static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())
-      ->set_delegate(nullptr);
-  Browser::Get()->RemoveObserver(this);
-  content::GpuDataManager::GetInstance()->RemoveObserver(this);
-  content::BrowserChildProcessObserver::Remove(this);
-}
-
-void App::OnBeforeQuit(bool* prevent_default) {
-  if (Emit("before-quit")) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnWillQuit(bool* prevent_default) {
-  if (Emit("will-quit")) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnWindowAllClosed() {
-  Emit("window-all-closed");
-}
-
-void App::OnQuit() {
-  int exitCode = AtomBrowserMainParts::Get()->GetExitCode();
-  Emit("quit", exitCode);
-
-  if (process_singleton_) {
-    process_singleton_->Cleanup();
-    process_singleton_.reset();
-  }
-}
-
-void App::OnOpenFile(bool* prevent_default, const std::string& file_path) {
-  if (Emit("open-file", file_path)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnOpenURL(const std::string& url) {
-  Emit("open-url", url);
-}
-
-void App::OnActivate(bool has_visible_windows) {
-  Emit("activate", has_visible_windows);
-}
-
-void App::OnWillFinishLaunching() {
-  Emit("will-finish-launching");
-}
-
-void App::OnFinishLaunching(const base::DictionaryValue& launch_info) {
-#if defined(OS_LINUX)
-  // Set the application name for audio streams shown in external
-  // applications. Only affects pulseaudio currently.
-  media::AudioManager::SetGlobalAppName(Browser::Get()->GetName());
-#endif
-  Emit("ready", launch_info);
-}
-
-void App::OnPreMainMessageLoopRun() {
-  content::BrowserChildProcessObserver::Add(this);
-  if (process_singleton_) {
-    process_singleton_->OnBrowserReady();
-  }
-}
-
-void App::OnAccessibilitySupportChanged() {
-  Emit("accessibility-support-changed", IsAccessibilitySupportEnabled());
-}
-
-#if defined(OS_MACOSX)
-void App::OnWillContinueUserActivity(bool* prevent_default,
-                                     const std::string& type) {
-  if (Emit("will-continue-activity", type)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnDidFailToContinueUserActivity(const std::string& type,
-                                          const std::string& error) {
-  Emit("continue-activity-error", type, error);
-}
-
-void App::OnContinueUserActivity(bool* prevent_default,
-                                 const std::string& type,
-                                 const base::DictionaryValue& user_info) {
-  if (Emit("continue-activity", type, user_info)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnUserActivityWasContinued(const std::string& type,
-                                     const base::DictionaryValue& user_info) {
-  Emit("activity-was-continued", type, user_info);
-}
-
-void App::OnUpdateUserActivityState(bool* prevent_default,
-                                    const std::string& type,
-                                    const base::DictionaryValue& user_info) {
-  if (Emit("update-activity-state", type, user_info)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnNewWindowForTab() {
-  Emit("new-window-for-tab");
-}
-#endif
-
-void App::OnLogin(scoped_refptr<LoginHandler> login_handler,
-                  const base::DictionaryValue& request_details) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  bool prevent_default = false;
-  content::WebContents* web_contents = login_handler->GetWebContents();
-  if (web_contents) {
-    prevent_default = Emit(
-        "login", WebContents::CreateFrom(isolate(), web_contents),
-        request_details, login_handler->auth_info(),
-        base::Bind(&PassLoginInformation, base::RetainedRef(login_handler)));
-  }
-
-  // Default behavior is to always cancel the auth.
-  if (!prevent_default)
-    login_handler->CancelAuth();
-}
-
-bool App::CanCreateWindow(
-    content::RenderFrameHost* opener,
-    const GURL& opener_url,
-    const GURL& opener_top_level_frame_url,
-    const GURL& source_origin,
-    content::mojom::WindowContainerType container_type,
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const blink::mojom::WindowFeatures& features,
-    const std::vector<std::string>& additional_features,
-    const scoped_refptr<network::ResourceRequestBody>& body,
-    bool user_gesture,
-    bool opener_suppressed,
-    bool* no_javascript_access) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  content::WebContents* web_contents =
-      content::WebContents::FromRenderFrameHost(opener);
-  if (web_contents) {
-    auto api_web_contents = WebContents::CreateFrom(isolate(), web_contents);
-    api_web_contents->OnCreateWindow(target_url, referrer, frame_name,
-                                     disposition, additional_features, body);
-  }
-
-  return false;
-}
-
-void App::AllowCertificateError(
-    content::WebContents* web_contents,
-    int cert_error,
-    const net::SSLInfo& ssl_info,
-    const GURL& request_url,
-    content::ResourceType resource_type,
-    bool strict_enforcement,
-    bool expired_previous_decision,
-    const base::Callback<void(content::CertificateRequestResultType)>&
-        callback) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  bool prevent_default = Emit(
-      "certificate-error", WebContents::CreateFrom(isolate(), web_contents),
-      request_url, net::ErrorToString(cert_error), ssl_info.cert, callback);
-
-  // Deny the certificate by default.
-  if (!prevent_default)
-    callback.Run(content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY);
-}
-
-void App::SelectClientCertificate(
-    content::WebContents* web_contents,
-    net::SSLCertRequestInfo* cert_request_info,
-    net::ClientCertIdentityList identities,
-    std::unique_ptr<content::ClientCertificateDelegate> delegate) {
-  std::shared_ptr<content::ClientCertificateDelegate> shared_delegate(
-      delegate.release());
-
-  // Convert the ClientCertIdentityList to a CertificateList
-  // to avoid changes in the API.
-  auto client_certs = net::CertificateList();
-  for (const std::unique_ptr<net::ClientCertIdentity>& identity : identities)
-    client_certs.push_back(identity->certificate());
-
-  auto shared_identities =
-      std::make_shared<net::ClientCertIdentityList>(std::move(identities));
-
-  bool prevent_default =
-      Emit("select-client-certificate",
-           WebContents::CreateFrom(isolate(), web_contents),
-           cert_request_info->host_and_port.ToString(), std::move(client_certs),
-           base::Bind(&OnClientCertificateSelected, isolate(), shared_delegate,
-                      shared_identities));
-
-  // Default to first certificate from the platform store.
-  if (!prevent_default) {
-    scoped_refptr<net::X509Certificate> cert =
-        (*shared_identities)[0]->certificate();
-    net::ClientCertIdentity::SelfOwningAcquirePrivateKey(
-        std::move((*shared_identities)[0]),
-        base::Bind(&GotPrivateKey, shared_delegate, std::move(cert)));
-  }
-}
-
-void App::OnGpuProcessCrashed(base::TerminationStatus status) {
-  Emit("gpu-process-crashed",
-       status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);
-}
-
-void App::BrowserChildProcessLaunchedAndConnected(
-    const content::ChildProcessData& data) {
-  ChildProcessLaunched(data.process_type, data.handle);
-}
-
-void App::BrowserChildProcessHostDisconnected(
-    const content::ChildProcessData& data) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::BrowserChildProcessCrashed(const content::ChildProcessData& data,
-                                     int exit_code) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::BrowserChildProcessKilled(const content::ChildProcessData& data,
-                                    int exit_code) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::RenderProcessReady(content::RenderProcessHost* host) {
-  ChildProcessLaunched(content::PROCESS_TYPE_RENDERER, host->GetHandle());
-}
-
-void App::RenderProcessDisconnected(base::ProcessId host_pid) {
-  ChildProcessDisconnected(host_pid);
-}
-
-void App::ChildProcessLaunched(int process_type, base::ProcessHandle handle) {
-  auto pid = base::GetProcId(handle);
-
-#if defined(OS_MACOSX)
-  std::unique_ptr<base::ProcessMetrics> metrics(
-      base::ProcessMetrics::CreateProcessMetrics(
-          handle, content::BrowserChildProcessHost::GetPortProvider()));
-#else
-  std::unique_ptr<base::ProcessMetrics> metrics(
-      base::ProcessMetrics::CreateProcessMetrics(handle));
-#endif
-  app_metrics_[pid] = std::make_unique<atom::ProcessMetric>(process_type, pid,
-                                                            std::move(metrics));
-}
-
-void App::ChildProcessDisconnected(base::ProcessId pid) {
-  app_metrics_.erase(pid);
-}
-
-base::FilePath App::GetAppPath() const {
-  return app_path_;
-}
-
-void App::SetAppPath(const base::FilePath& app_path) {
-  app_path_ = app_path;
-}
-
-base::FilePath App::GetPath(mate::Arguments* args, const std::string& name) {
-  bool succeed = false;
-  base::FilePath path;
-  int key = GetPathConstant(name);
-  if (key >= 0)
-    succeed = PathService::Get(key, &path);
-  if (!succeed)
-    args->ThrowError("Failed to get '" + name + "' path");
-  return path;
-}
-
-void App::SetPath(mate::Arguments* args,
-                  const std::string& name,
-                  const base::FilePath& path) {
-  if (!path.IsAbsolute()) {
-    args->ThrowError("Path must be absolute");
-    return;
-  }
-
-  bool succeed = false;
-  int key = GetPathConstant(name);
-  if (key >= 0)
-    succeed = PathService::OverrideAndCreateIfNeeded(key, path, true, false);
-  if (!succeed)
-    args->ThrowError("Failed to set path");
-}
-
-void App::SetDesktopName(const std::string& desktop_name) {
-#if defined(OS_LINUX)
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  env->SetVar("CHROME_DESKTOP", desktop_name);
-#endif
-}
-
-std::string App::GetLocale() {
-  return g_browser_process->GetApplicationLocale();
-}
-
-void App::OnSecondInstance(const base::CommandLine::StringVector& cmd,
-                           const base::FilePath& cwd) {
-  Emit("second-instance", cmd, cwd);
-}
-
-bool App::HasSingleInstanceLock() const {
-  if (process_singleton_)
-    return true;
-  return false;
-}
-
-bool App::RequestSingleInstanceLock() {
-  if (HasSingleInstanceLock())
-    return true;
-
-  base::FilePath user_dir;
-  PathService::Get(brightray::DIR_USER_DATA, &user_dir);
-
-  auto cb = base::Bind(&App::OnSecondInstance, base::Unretained(this));
-
-  process_singleton_.reset(new ProcessSingleton(
-      user_dir, base::Bind(NotificationCallbackWrapper, cb)));
-
-  switch (process_singleton_->NotifyOtherProcessOrCreate()) {
-    case ProcessSingleton::NotifyResult::LOCK_ERROR:
-    case ProcessSingleton::NotifyResult::PROFILE_IN_USE:
-    case ProcessSingleton::NotifyResult::PROCESS_NOTIFIED: {
-      process_singleton_.reset();
-      return false;
-    }
-    case ProcessSingleton::NotifyResult::PROCESS_NONE:
-    default:  // Shouldn't be needed, but VS warns if it is not there.
-      return true;
-  }
-}
-
-void App::ReleaseSingleInstanceLock() {
-  if (process_singleton_) {
-    process_singleton_->Cleanup();
-    process_singleton_.reset();
-  }
-}
-
-bool App::Relaunch(mate::Arguments* js_args) {
-  // Parse parameters.
-  bool override_argv = false;
-  base::FilePath exec_path;
-  relauncher::StringVector args;
-
-  mate::Dictionary options;
-  if (js_args->GetNext(&options)) {
-    if (options.Get("execPath", &exec_path) | options.Get("args", &args))
-      override_argv = true;
-  }
-
-  if (!override_argv) {
-    const relauncher::StringVector& argv = atom::AtomCommandLine::argv();
-    return relauncher::RelaunchApp(argv);
-  }
-
-  relauncher::StringVector argv;
-  argv.reserve(1 + args.size());
-
-  if (exec_path.empty()) {
-    base::FilePath current_exe_path;
-    PathService::Get(base::FILE_EXE, &current_exe_path);
-    argv.push_back(current_exe_path.value());
-  } else {
-    argv.push_back(exec_path.value());
-  }
-
-  argv.insert(argv.end(), args.begin(), args.end());
-
-  return relauncher::RelaunchApp(argv);
-}
-
-void App::DisableHardwareAcceleration(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.disableHardwareAcceleration() can only be called "
-        "before app is ready");
-    return;
-  }
-  content::GpuDataManager::GetInstance()->DisableHardwareAcceleration();
-}
-
-void App::DisableDomainBlockingFor3DAPIs(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.disableDomainBlockingFor3DAPIs() can only be called "
-        "before app is ready");
-    return;
-  }
-  content::GpuDataManagerImpl::GetInstance()
-      ->DisableDomainBlockingFor3DAPIsForTesting();
-}
-
-bool App::IsAccessibilitySupportEnabled() {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-  return ax_state->IsAccessibleBrowser();
-}
-
-void App::SetAccessibilitySupportEnabled(bool enabled) {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-  if (enabled) {
-    ax_state->OnScreenReaderDetected();
-  } else {
-    ax_state->DisableAccessibility();
-  }
-  Browser::Get()->OnAccessibilitySupportChanged();
-}
-
-Browser::LoginItemSettings App::GetLoginItemSettings(mate::Arguments* args) {
-  Browser::LoginItemSettings options;
-  args->GetNext(&options);
-  return Browser::Get()->GetLoginItemSettings(options);
-}
-
-#if defined(USE_NSS_CERTS)
-void App::ImportCertificate(const base::DictionaryValue& options,
-                            const net::CompletionCallback& callback) {
-  auto browser_context = AtomBrowserContext::From("", false);
-  if (!certificate_manager_model_) {
-    auto copy = base::DictionaryValue::From(
-        base::Value::ToUniquePtrValue(options.Clone()));
-    CertificateManagerModel::Create(
-        browser_context.get(),
-        base::Bind(&App::OnCertificateManagerModelCreated,
-                   base::Unretained(this), base::Passed(&copy), callback));
-    return;
-  }
-
-  int rv = ImportIntoCertStore(certificate_manager_model_.get(), options);
-  callback.Run(rv);
-}
-
-void App::OnCertificateManagerModelCreated(
-    std::unique_ptr<base::DictionaryValue> options,
-    const net::CompletionCallback& callback,
-    std::unique_ptr<CertificateManagerModel> model) {
-  certificate_manager_model_ = std::move(model);
-  int rv =
-      ImportIntoCertStore(certificate_manager_model_.get(), *(options.get()));
-  callback.Run(rv);
-}
-#endif
-
-#if defined(OS_WIN)
-v8::Local<v8::Value> App::GetJumpListSettings() {
-  JumpList jump_list(Browser::Get()->GetAppUserModelID());
-
-  int min_items = 10;
-  std::vector<JumpListItem> removed_items;
-  if (jump_list.Begin(&min_items, &removed_items)) {
-    // We don't actually want to change anything, so abort the transaction.
-    jump_list.Abort();
-  } else {
-    LOG(ERROR) << "Failed to begin Jump List transaction.";
-  }
-
-  auto dict = mate::Dictionary::CreateEmpty(isolate());
-  dict.Set("minItems", min_items);
-  dict.Set("removedItems", mate::ConvertToV8(isolate(), removed_items));
-  return dict.GetHandle();
-}
-
-JumpListResult App::SetJumpList(v8::Local<v8::Value> val,
-                                mate::Arguments* args) {
-  std::vector<JumpListCategory> categories;
-  bool delete_jump_list = val->IsNull();
-  if (!delete_jump_list &&
-      !mate::ConvertFromV8(args->isolate(), val, &categories)) {
-    args->ThrowError("Argument must be null or an array of categories");
-    return JumpListResult::ARGUMENT_ERROR;
-  }
-
-  JumpList jump_list(Browser::Get()->GetAppUserModelID());
-
-  if (delete_jump_list) {
-    return jump_list.Delete() ? JumpListResult::SUCCESS
-                              : JumpListResult::GENERIC_ERROR;
-  }
-
-  // Start a transaction that updates the JumpList of this application.
-  if (!jump_list.Begin())
-    return JumpListResult::GENERIC_ERROR;
-
-  JumpListResult result = jump_list.AppendCategories(categories);
-  // AppendCategories may have failed to add some categories, but it's better
-  // to have something than nothing so try to commit the changes anyway.
-  if (!jump_list.Commit()) {
-    LOG(ERROR) << "Failed to commit changes to custom Jump List.";
-    // It's more useful to return the earlier error code that might give
-    // some indication as to why the transaction actually failed, so don't
-    // overwrite it with a "generic error" code here.
-    if (result == JumpListResult::SUCCESS)
-      result = JumpListResult::GENERIC_ERROR;
-  }
-
-  return result;
-}
-#endif  // defined(OS_WIN)
-
-void App::GetFileIcon(const base::FilePath& path, mate::Arguments* args) {
-  mate::Dictionary options;
-  IconLoader::IconSize icon_size;
-  FileIconCallback callback;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  base::FilePath normalized_path = path.NormalizePathSeparators();
-
-  if (!args->GetNext(&options)) {
-    icon_size = IconLoader::IconSize::NORMAL;
-  } else {
-    std::string icon_size_string;
-    options.Get("size", &icon_size_string);
-    icon_size = GetIconSizeByString(icon_size_string);
-  }
-
-  if (!args->GetNext(&callback)) {
-    args->ThrowError("Missing required callback function");
-    return;
-  }
-
-  auto* icon_manager = g_browser_process->GetIconManager();
-  gfx::Image* icon =
-      icon_manager->LookupIconFromFilepath(normalized_path, icon_size);
-  if (icon) {
-    callback.Run(v8::Null(isolate()), *icon);
-  } else {
-    icon_manager->LoadIcon(
-        normalized_path, icon_size,
-        base::Bind(&OnIconDataAvailable, isolate(), callback),
-        &cancelable_task_tracker_);
-  }
-}
-
-std::vector<mate::Dictionary> App::GetAppMetrics(v8::Isolate* isolate) {
-  std::vector<mate::Dictionary> result;
-  int processor_count = base::SysInfo::NumberOfProcessors();
-
-  for (const auto& process_metric : app_metrics_) {
-    mate::Dictionary pid_dict = mate::Dictionary::CreateEmpty(isolate);
-    mate::Dictionary memory_dict = mate::Dictionary::CreateEmpty(isolate);
-    mate::Dictionary cpu_dict = mate::Dictionary::CreateEmpty(isolate);
-
-    pid_dict.SetHidden("simple", true);
-    memory_dict.SetHidden("simple", true);
-    cpu_dict.SetHidden("simple", true);
-
-    memory_dict.Set(
-        "workingSetSize",
-        static_cast<double>(
-            process_metric.second->metrics->GetWorkingSetSize() >> 10));
-    memory_dict.Set(
-        "peakWorkingSetSize",
-        static_cast<double>(
-            process_metric.second->metrics->GetPeakWorkingSetSize() >> 10));
-
-    size_t private_bytes, shared_bytes;
-    if (process_metric.second->metrics->GetMemoryBytes(&private_bytes,
-                                                       &shared_bytes)) {
-      memory_dict.Set("privateBytes", static_cast<double>(private_bytes >> 10));
-      memory_dict.Set("sharedBytes", static_cast<double>(shared_bytes >> 10));
-    }
-
-    pid_dict.Set("memory", memory_dict);
-    cpu_dict.Set(
-        "percentCPUUsage",
-        process_metric.second->metrics->GetPlatformIndependentCPUUsage() /
-            processor_count);
-
-#if !defined(OS_WIN)
-    cpu_dict.Set("idleWakeupsPerSecond",
-                 process_metric.second->metrics->GetIdleWakeupsPerSecond());
-#else
-    // Chrome's underlying process_metrics.cc will throw a non-fatal warning
-    // that this method isn't implemented on Windows, so set it to 0 instead
-    // of calling it
-    cpu_dict.Set("idleWakeupsPerSecond", 0);
-#endif
-
-    pid_dict.Set("cpu", cpu_dict);
-    pid_dict.Set("pid", process_metric.second->pid);
-    pid_dict.Set("type", content::GetProcessTypeNameInEnglish(
-                             process_metric.second->type));
-    result.push_back(pid_dict);
-  }
-
-  return result;
-}
-
-v8::Local<v8::Value> App::GetGPUFeatureStatus(v8::Isolate* isolate) {
-  auto status = content::GetFeatureStatus();
-  base::DictionaryValue temp;
-  return mate::ConvertToV8(isolate, status ? *status : temp);
-}
-
-void App::EnableMixedSandbox(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.enableMixedSandbox() can only be called "
-        "before app is ready");
-    return;
-  }
-
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  if (command_line->HasSwitch(::switches::kNoSandbox)) {
-#if defined(OS_WIN)
-    const base::CommandLine::CharType* noSandboxArg = L"--no-sandbox";
-#else
-    const base::CommandLine::CharType* noSandboxArg = "--no-sandbox";
-#endif
-
-    // Remove the --no-sandbox switch
-    base::CommandLine::StringVector modified_command_line;
-    for (auto& arg : command_line->argv()) {
-      if (arg.compare(noSandboxArg) != 0) {
-        modified_command_line.push_back(arg);
-      }
-    }
-    command_line->InitFromArgv(modified_command_line);
-  }
-  command_line->AppendSwitch(switches::kEnableMixedSandbox);
-}
-
-#if defined(OS_MACOSX)
-bool App::MoveToApplicationsFolder(mate::Arguments* args) {
-  return ui::cocoa::AtomBundleMover::Move(args);
-}
-
-bool App::IsInApplicationsFolder() {
-  return ui::cocoa::AtomBundleMover::IsCurrentAppInApplicationsFolder();
-}
-#endif
-
-// static
-mate::Handle<App> App::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new App(isolate));
-}
-
-// static
-void App::BuildPrototype(v8::Isolate* isolate,
-                         v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "App"));
-  auto browser = base::Unretained(Browser::Get());
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("quit", base::Bind(&Browser::Quit, browser))
-      .SetMethod("exit", base::Bind(&Browser::Exit, browser))
-      .SetMethod("focus", base::Bind(&Browser::Focus, browser))
-      .SetMethod("getVersion", base::Bind(&Browser::GetVersion, browser))
-      .SetMethod("setVersion", base::Bind(&Browser::SetVersion, browser))
-      .SetMethod("getName", base::Bind(&Browser::GetName, browser))
-      .SetMethod("setName", base::Bind(&Browser::SetName, browser))
-      .SetMethod("isReady", base::Bind(&Browser::is_ready, browser))
-      .SetMethod("whenReady", base::Bind(&Browser::WhenReady, browser))
-      .SetMethod("addRecentDocument",
-                 base::Bind(&Browser::AddRecentDocument, browser))
-      .SetMethod("clearRecentDocuments",
-                 base::Bind(&Browser::ClearRecentDocuments, browser))
-      .SetMethod("setAppUserModelId",
-                 base::Bind(&Browser::SetAppUserModelID, browser))
-      .SetMethod("isDefaultProtocolClient",
-                 base::Bind(&Browser::IsDefaultProtocolClient, browser))
-      .SetMethod("setAsDefaultProtocolClient",
-                 base::Bind(&Browser::SetAsDefaultProtocolClient, browser))
-      .SetMethod("removeAsDefaultProtocolClient",
-                 base::Bind(&Browser::RemoveAsDefaultProtocolClient, browser))
-      .SetMethod("setBadgeCount", base::Bind(&Browser::SetBadgeCount, browser))
-      .SetMethod("getBadgeCount", base::Bind(&Browser::GetBadgeCount, browser))
-      .SetMethod("getLoginItemSettings", &App::GetLoginItemSettings)
-      .SetMethod("setLoginItemSettings",
-                 base::Bind(&Browser::SetLoginItemSettings, browser))
-#if defined(OS_MACOSX)
-      .SetMethod("hide", base::Bind(&Browser::Hide, browser))
-      .SetMethod("show", base::Bind(&Browser::Show, browser))
-      .SetMethod("setUserActivity",
-                 base::Bind(&Browser::SetUserActivity, browser))
-      .SetMethod("getCurrentActivityType",
-                 base::Bind(&Browser::GetCurrentActivityType, browser))
-      .SetMethod("invalidateCurrentActivity",
-                 base::Bind(&Browser::InvalidateCurrentActivity, browser))
-      .SetMethod("updateCurrentActivity",
-                 base::Bind(&Browser::UpdateCurrentActivity, browser))
-      .SetMethod("setAboutPanelOptions",
-                 base::Bind(&Browser::SetAboutPanelOptions, browser))
-#endif
-#if defined(OS_WIN)
-      .SetMethod("setUserTasks", base::Bind(&Browser::SetUserTasks, browser))
-      .SetMethod("getJumpListSettings", &App::GetJumpListSettings)
-      .SetMethod("setJumpList", &App::SetJumpList)
-#endif
-#if defined(OS_LINUX)
-      .SetMethod("isUnityRunning",
-                 base::Bind(&Browser::IsUnityRunning, browser))
-#endif
-      .SetMethod("setAppPath", &App::SetAppPath)
-      .SetMethod("getAppPath", &App::GetAppPath)
-      .SetMethod("setPath", &App::SetPath)
-      .SetMethod("getPath", &App::GetPath)
-      .SetMethod("setDesktopName", &App::SetDesktopName)
-      .SetMethod("getLocale", &App::GetLocale)
-#if defined(USE_NSS_CERTS)
-      .SetMethod("importCertificate", &App::ImportCertificate)
-#endif
-      .SetMethod("hasSingleInstanceLock", &App::HasSingleInstanceLock)
-      .SetMethod("requestSingleInstanceLock", &App::RequestSingleInstanceLock)
-      .SetMethod("releaseSingleInstanceLock", &App::ReleaseSingleInstanceLock)
-      .SetMethod("relaunch", &App::Relaunch)
-      .SetMethod("isAccessibilitySupportEnabled",
-                 &App::IsAccessibilitySupportEnabled)
-      .SetMethod("setAccessibilitySupportEnabled",
-                 &App::SetAccessibilitySupportEnabled)
-      .SetMethod("disableHardwareAcceleration",
-                 &App::DisableHardwareAcceleration)
-      .SetMethod("disableDomainBlockingFor3DAPIs",
-                 &App::DisableDomainBlockingFor3DAPIs)
-      .SetMethod("getFileIcon", &App::GetFileIcon)
-      .SetMethod("getAppMetrics", &App::GetAppMetrics)
-      .SetMethod("getGPUFeatureStatus", &App::GetGPUFeatureStatus)
-// TODO(juturu): Remove in 2.0, deprecate before then with warnings
-#if defined(OS_MACOSX)
-      .SetMethod("moveToApplicationsFolder", &App::MoveToApplicationsFolder)
-      .SetMethod("isInApplicationsFolder", &App::IsInApplicationsFolder)
-#endif
-#if defined(MAS_BUILD)
-      .SetMethod("startAccessingSecurityScopedResource",
-                 &App::StartAccessingSecurityScopedResource)
-#endif
-      .SetMethod("enableMixedSandbox", &App::EnableMixedSandbox);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void AppendSwitch(const std::string& switch_string, mate::Arguments* args) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  if (base::EndsWith(switch_string, "-path",
-                     base::CompareCase::INSENSITIVE_ASCII) ||
-      switch_string == network::switches::kLogNetLog) {
-    base::FilePath path;
-    args->GetNext(&path);
-    command_line->AppendSwitchPath(switch_string, path);
-    return;
-  }
-
-  std::string value;
-  if (args->GetNext(&value))
-    command_line->AppendSwitchASCII(switch_string, value);
-  else
-    command_line->AppendSwitch(switch_string);
-}
-
-#if defined(OS_MACOSX)
-int DockBounce(const std::string& type) {
-  int request_id = -1;
-  if (type == "critical")
-    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_CRITICAL);
-  else if (type == "informational")
-    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_INFORMATIONAL);
-  return request_id;
-}
-
-void DockSetMenu(atom::api::Menu* menu) {
-  Browser::Get()->DockSetMenu(menu->model());
-}
-#endif
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("App", atom::api::App::GetConstructor(isolate)->GetFunction());
-  dict.Set("app", atom::api::App::Create(isolate));
-  dict.SetMethod("appendSwitch", &AppendSwitch);
-  dict.SetMethod("appendArgument", base::Bind(&base::CommandLine::AppendArg,
-                                              base::Unretained(command_line)));
-#if defined(OS_MACOSX)
-  auto browser = base::Unretained(Browser::Get());
-  dict.SetMethod("dockBounce", &DockBounce);
-  dict.SetMethod("dockCancelBounce",
-                 base::Bind(&Browser::DockCancelBounce, browser));
-  dict.SetMethod("dockDownloadFinished",
-                 base::Bind(&Browser::DockDownloadFinished, browser));
-  dict.SetMethod("dockSetBadgeText",
-                 base::Bind(&Browser::DockSetBadgeText, browser));
-  dict.SetMethod("dockGetBadgeText",
-                 base::Bind(&Browser::DockGetBadgeText, browser));
-  dict.SetMethod("dockHide", base::Bind(&Browser::DockHide, browser));
-  dict.SetMethod("dockShow", base::Bind(&Browser::DockShow, browser));
-  dict.SetMethod("dockIsVisible", base::Bind(&Browser::DockIsVisible, browser));
-  dict.SetMethod("dockSetMenu", &DockSetMenu);
-  dict.SetMethod("dockSetIcon", base::Bind(&Browser::DockSetIcon, browser));
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_app, Initialize)
removed in remote
  base   100644 5faf8ebb10e2cc48d6b2f7c259ed727906235d1f atom/browser/api/atom_api_app.h
  our    100644 ee0ad42c05fe33be17146b79cbe3422953516621 atom/browser/api/atom_api_app.h
@@ -1,242 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_APP_H_
-#define ATOM_BROWSER_API_ATOM_API_APP_H_
-
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/browser_observer.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/promise_util.h"
-#include "base/process/process_iterator.h"
-#include "base/task/cancelable_task_tracker.h"
-#include "chrome/browser/icon_manager.h"
-#include "chrome/browser/process_singleton.h"
-#include "content/public/browser/browser_child_process_observer.h"
-#include "content/public/browser/gpu_data_manager_observer.h"
-#include "content/public/browser/render_process_host.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "net/base/completion_callback.h"
-#include "net/ssl/client_cert_identity.h"
-
-#if defined(USE_NSS_CERTS)
-#include "chrome/browser/certificate_manager_model.h"
-#endif
-
-namespace base {
-class FilePath;
-}
-
-namespace mate {
-class Arguments;
-}  // namespace mate
-
-namespace atom {
-
-#if defined(OS_WIN)
-enum class JumpListResult : int;
-#endif
-
-struct ProcessMetric {
-  int type;
-  base::ProcessId pid;
-  std::unique_ptr<base::ProcessMetrics> metrics;
-
-  ProcessMetric(int type,
-                base::ProcessId pid,
-                std::unique_ptr<base::ProcessMetrics> metrics);
-  ~ProcessMetric();
-};
-
-namespace api {
-
-class App : public AtomBrowserClient::Delegate,
-            public mate::EventEmitter<App>,
-            public BrowserObserver,
-            public content::GpuDataManagerObserver,
-            public content::BrowserChildProcessObserver {
- public:
-  using FileIconCallback =
-      base::Callback<void(v8::Local<v8::Value>, const gfx::Image&)>;
-
-  static mate::Handle<App> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(USE_NSS_CERTS)
-  void OnCertificateManagerModelCreated(
-      std::unique_ptr<base::DictionaryValue> options,
-      const net::CompletionCallback& callback,
-      std::unique_ptr<CertificateManagerModel> model);
-#endif
-
-  base::FilePath GetAppPath() const;
-  void RenderProcessReady(content::RenderProcessHost* host);
-  void RenderProcessDisconnected(base::ProcessId host_pid);
-  void PreMainMessageLoopRun();
-
- protected:
-  explicit App(v8::Isolate* isolate);
-  ~App() override;
-
-  // BrowserObserver:
-  void OnBeforeQuit(bool* prevent_default) override;
-  void OnWillQuit(bool* prevent_default) override;
-  void OnWindowAllClosed() override;
-  void OnQuit() override;
-  void OnOpenFile(bool* prevent_default, const std::string& file_path) override;
-  void OnOpenURL(const std::string& url) override;
-  void OnActivate(bool has_visible_windows) override;
-  void OnWillFinishLaunching() override;
-  void OnFinishLaunching(const base::DictionaryValue& launch_info) override;
-  void OnLogin(scoped_refptr<LoginHandler> login_handler,
-               const base::DictionaryValue& request_details) override;
-  void OnAccessibilitySupportChanged() override;
-  void OnPreMainMessageLoopRun() override;
-#if defined(OS_MACOSX)
-  void OnWillContinueUserActivity(bool* prevent_default,
-                                  const std::string& type) override;
-  void OnDidFailToContinueUserActivity(const std::string& type,
-                                       const std::string& error) override;
-  void OnContinueUserActivity(bool* prevent_default,
-                              const std::string& type,
-                              const base::DictionaryValue& user_info) override;
-  void OnUserActivityWasContinued(
-      const std::string& type,
-      const base::DictionaryValue& user_info) override;
-  void OnUpdateUserActivityState(
-      bool* prevent_default,
-      const std::string& type,
-      const base::DictionaryValue& user_info) override;
-  void OnNewWindowForTab() override;
-#endif
-
-  // content::ContentBrowserClient:
-  void AllowCertificateError(
-      content::WebContents* web_contents,
-      int cert_error,
-      const net::SSLInfo& ssl_info,
-      const GURL& request_url,
-      content::ResourceType resource_type,
-      bool strict_enforcement,
-      bool expired_previous_decision,
-      const base::Callback<void(content::CertificateRequestResultType)>&
-          callback) override;
-  void SelectClientCertificate(
-      content::WebContents* web_contents,
-      net::SSLCertRequestInfo* cert_request_info,
-      net::ClientCertIdentityList client_certs,
-      std::unique_ptr<content::ClientCertificateDelegate> delegate) override;
-  bool CanCreateWindow(content::RenderFrameHost* opener,
-                       const GURL& opener_url,
-                       const GURL& opener_top_level_frame_url,
-                       const GURL& source_origin,
-                       content::mojom::WindowContainerType container_type,
-                       const GURL& target_url,
-                       const content::Referrer& referrer,
-                       const std::string& frame_name,
-                       WindowOpenDisposition disposition,
-                       const blink::mojom::WindowFeatures& features,
-                       const std::vector<std::string>& additional_features,
-                       const scoped_refptr<network::ResourceRequestBody>& body,
-                       bool user_gesture,
-                       bool opener_suppressed,
-                       bool* no_javascript_access) override;
-
-  // content::GpuDataManagerObserver:
-  void OnGpuProcessCrashed(base::TerminationStatus status) override;
-
-  // content::BrowserChildProcessObserver:
-  void BrowserChildProcessLaunchedAndConnected(
-      const content::ChildProcessData& data) override;
-  void BrowserChildProcessHostDisconnected(
-      const content::ChildProcessData& data) override;
-  void BrowserChildProcessCrashed(const content::ChildProcessData& data,
-                                  int exit_code) override;
-  void BrowserChildProcessKilled(const content::ChildProcessData& data,
-                                 int exit_code) override;
-
- private:
-  void SetAppPath(const base::FilePath& app_path);
-  void ChildProcessLaunched(int process_type, base::ProcessHandle handle);
-  void ChildProcessDisconnected(base::ProcessId pid);
-
-  // Get/Set the pre-defined path in PathService.
-  base::FilePath GetPath(mate::Arguments* args, const std::string& name);
-  void SetPath(mate::Arguments* args,
-               const std::string& name,
-               const base::FilePath& path);
-
-  void SetDesktopName(const std::string& desktop_name);
-  std::string GetLocale();
-  void OnSecondInstance(const base::CommandLine::StringVector& cmd,
-                        const base::FilePath& cwd);
-  bool HasSingleInstanceLock() const;
-  bool RequestSingleInstanceLock();
-  void ReleaseSingleInstanceLock();
-  bool Relaunch(mate::Arguments* args);
-  void DisableHardwareAcceleration(mate::Arguments* args);
-  void DisableDomainBlockingFor3DAPIs(mate::Arguments* args);
-  bool IsAccessibilitySupportEnabled();
-  void SetAccessibilitySupportEnabled(bool enabled);
-  Browser::LoginItemSettings GetLoginItemSettings(mate::Arguments* args);
-#if defined(USE_NSS_CERTS)
-  void ImportCertificate(const base::DictionaryValue& options,
-                         const net::CompletionCallback& callback);
-#endif
-  void GetFileIcon(const base::FilePath& path, mate::Arguments* args);
-
-  std::vector<mate::Dictionary> GetAppMetrics(v8::Isolate* isolate);
-  v8::Local<v8::Value> GetGPUFeatureStatus(v8::Isolate* isolate);
-  void EnableMixedSandbox(mate::Arguments* args);
-
-#if defined(OS_MACOSX)
-  bool MoveToApplicationsFolder(mate::Arguments* args);
-  bool IsInApplicationsFolder();
-#endif
-#if defined(MAS_BUILD)
-  base::Callback<void()> StartAccessingSecurityScopedResource(
-      mate::Arguments* args);
-#endif
-
-#if defined(OS_WIN)
-  // Get the current Jump List settings.
-  v8::Local<v8::Value> GetJumpListSettings();
-
-  // Set or remove a custom Jump List for the application.
-  JumpListResult SetJumpList(v8::Local<v8::Value> val, mate::Arguments* args);
-#endif  // defined(OS_WIN)
-
-  std::unique_ptr<ProcessSingleton> process_singleton_;
-
-#if defined(USE_NSS_CERTS)
-  std::unique_ptr<CertificateManagerModel> certificate_manager_model_;
-#endif
-
-  // Tracks tasks requesting file icons.
-  base::CancelableTaskTracker cancelable_task_tracker_;
-
-  base::FilePath app_path_;
-
-  using ProcessMetricMap =
-      std::unordered_map<base::ProcessId, std::unique_ptr<atom::ProcessMetric>>;
-  ProcessMetricMap app_metrics_;
-
-  DISALLOW_COPY_AND_ASSIGN(App);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_APP_H_
removed in remote
  base   100644 1a02a54d45337fb64aefe91db454e77a7edf8fb7 atom/browser/api/atom_api_auto_updater.cc
  our    100644 3bee34247e9289fcf5349854c5e6cd69f4b66a0d atom/browser/api/atom_api_auto_updater.cc
@@ -1,155 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_auto_updater.h"
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/node_includes.h"
-#include "base/time/time.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::Time> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::Time& val) {
-    v8::MaybeLocal<v8::Value> date =
-        v8::Date::New(isolate->GetCurrentContext(), val.ToJsTime());
-    if (date.IsEmpty())
-      return v8::Null(isolate);
-    else
-      return date.ToLocalChecked();
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-AutoUpdater::AutoUpdater(v8::Isolate* isolate) {
-  auto_updater::AutoUpdater::SetDelegate(this);
-  Init(isolate);
-}
-
-AutoUpdater::~AutoUpdater() {
-  auto_updater::AutoUpdater::SetDelegate(nullptr);
-}
-
-void AutoUpdater::OnError(const std::string& message) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
-  mate::EmitEvent(
-      isolate(), GetWrapper(), "error",
-      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked(),
-      // Message is also emitted to keep compatibility with old code.
-      message);
-}
-
-void AutoUpdater::OnError(const std::string& message,
-                          const int code,
-                          const std::string& domain) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
-  auto errorObject =
-      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked();
-
-  // add two new params for better error handling
-  errorObject->Set(mate::StringToV8(isolate(), "code"),
-                   v8::Integer::New(isolate(), code));
-  errorObject->Set(mate::StringToV8(isolate(), "domain"),
-                   mate::StringToV8(isolate(), domain));
-
-  mate::EmitEvent(isolate(), GetWrapper(), "error", errorObject, message);
-}
-
-void AutoUpdater::OnCheckingForUpdate() {
-  Emit("checking-for-update");
-}
-
-void AutoUpdater::OnUpdateAvailable() {
-  Emit("update-available");
-}
-
-void AutoUpdater::OnUpdateNotAvailable() {
-  Emit("update-not-available");
-}
-
-void AutoUpdater::OnUpdateDownloaded(const std::string& release_notes,
-                                     const std::string& release_name,
-                                     const base::Time& release_date,
-                                     const std::string& url) {
-  Emit("update-downloaded", release_notes, release_name, release_date, url,
-       // Keep compatibility with old APIs.
-       base::Bind(&AutoUpdater::QuitAndInstall, base::Unretained(this)));
-}
-
-void AutoUpdater::OnWindowAllClosed() {
-  QuitAndInstall();
-}
-
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {
-  auto_updater::AutoUpdater::SetFeedURL(args);
-}
-
-void AutoUpdater::QuitAndInstall() {
-  Emit("before-quit-for-update");
-
-  // If we don't have any window then quitAndInstall immediately.
-  if (WindowList::IsEmpty()) {
-    auto_updater::AutoUpdater::QuitAndInstall();
-    return;
-  }
-
-  // Otherwise do the restart after all windows have been closed.
-  WindowList::AddObserver(this);
-  WindowList::CloseAllWindows();
-}
-
-// static
-mate::Handle<AutoUpdater> AutoUpdater::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new AutoUpdater(isolate));
-}
-
-// static
-void AutoUpdater::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "AutoUpdater"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("checkForUpdates", &auto_updater::AutoUpdater::CheckForUpdates)
-      .SetMethod("getFeedURL", &auto_updater::AutoUpdater::GetFeedURL)
-      .SetMethod("setFeedURL", &AutoUpdater::SetFeedURL)
-      .SetMethod("quitAndInstall", &AutoUpdater::QuitAndInstall);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::AutoUpdater;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("autoUpdater", AutoUpdater::Create(isolate));
-  dict.Set("AutoUpdater", AutoUpdater::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_auto_updater, Initialize)
removed in remote
  base   100644 95b91041e9e36c3a1b21cbcd8f8b559eca193f8a atom/browser/api/atom_api_auto_updater.h
  our    100644 d8875ae0e38457365e0b55d854aae9f672a025e2 atom/browser/api/atom_api_auto_updater.h
@@ -1,61 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
-#define ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
-
-#include <string>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/browser/auto_updater.h"
-#include "atom/browser/window_list_observer.h"
-#include "native_mate/arguments.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-namespace api {
-
-class AutoUpdater : public mate::EventEmitter<AutoUpdater>,
-                    public auto_updater::Delegate,
-                    public WindowListObserver {
- public:
-  static mate::Handle<AutoUpdater> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit AutoUpdater(v8::Isolate* isolate);
-  ~AutoUpdater() override;
-
-  // Delegate implementations.
-  void OnError(const std::string& error) override;
-  void OnError(const std::string& message,
-               const int code,
-               const std::string& domain) override;
-  void OnCheckingForUpdate() override;
-  void OnUpdateAvailable() override;
-  void OnUpdateNotAvailable() override;
-  void OnUpdateDownloaded(const std::string& release_notes,
-                          const std::string& release_name,
-                          const base::Time& release_date,
-                          const std::string& update_url) override;
-
-  // WindowListObserver:
-  void OnWindowAllClosed() override;
-
- private:
-  std::string GetFeedURL();
-  void SetFeedURL(mate::Arguments* args);
-  void QuitAndInstall();
-
-  DISALLOW_COPY_AND_ASSIGN(AutoUpdater);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
removed in remote
  base   100644 937a87ea2131194d5edef3e9cab6ecfcff8fc34e atom/browser/api/atom_api_content_tracing.cc
  our    100644 d340b167a5f35fa05280c1195c81542bfc74f0b6 atom/browser/api/atom_api_content_tracing.cc
@@ -1,79 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <set>
-#include <string>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "content/public/browser/tracing_controller.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using content::TracingController;
-
-namespace mate {
-
-template <>
-struct Converter<base::trace_event::TraceConfig> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::trace_event::TraceConfig* out) {
-    Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    std::string category_filter, trace_options;
-    if (!options.Get("categoryFilter", &category_filter) ||
-        !options.Get("traceOptions", &trace_options))
-      return false;
-    *out = base::trace_event::TraceConfig(category_filter, trace_options);
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-using CompletionCallback = base::Callback<void(const base::FilePath&)>;
-
-scoped_refptr<TracingController::TraceDataEndpoint> GetTraceDataEndpoint(
-    const base::FilePath& path,
-    const CompletionCallback& callback) {
-  base::FilePath result_file_path = path;
-  if (result_file_path.empty() && !base::CreateTemporaryFile(&result_file_path))
-    LOG(ERROR) << "Creating temporary file failed";
-
-  return TracingController::CreateFileEndpoint(
-      result_file_path, base::Bind(callback, result_file_path));
-}
-
-void StopRecording(const base::FilePath& path,
-                   const CompletionCallback& callback) {
-  TracingController::GetInstance()->StopTracing(
-      GetTraceDataEndpoint(path, callback));
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  auto controller = base::Unretained(TracingController::GetInstance());
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("getCategories",
-                 base::Bind(&TracingController::GetCategories, controller));
-  dict.SetMethod("startRecording",
-                 base::Bind(&TracingController::StartTracing, controller));
-  dict.SetMethod("stopRecording", &StopRecording);
-  dict.SetMethod(
-      "getTraceBufferUsage",
-      base::Bind(&TracingController::GetTraceBufferUsage, controller));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_content_tracing, Initialize)
removed in remote
  base   100644 e49a2ee2f6763dba123ca45aead308c1955f6bb3 atom/browser/api/atom_api_cookies.cc
  our    100644 daccf443927abdf444845613b6e2916d167f96f3 atom/browser/api/atom_api_cookies.cc
@@ -1,328 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_cookies.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/request_context_delegate.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/time/time.h"
-#include "base/values.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/cookies/canonical_cookie.h"
-#include "net/cookies/cookie_store.h"
-#include "net/cookies/cookie_util.h"
-#include "net/url_request/url_request_context.h"
-#include "net/url_request/url_request_context_getter.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-template <>
-struct Converter<atom::api::Cookies::Error> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::api::Cookies::Error val) {
-    if (val == atom::api::Cookies::SUCCESS)
-      return v8::Null(isolate);
-    else
-      return v8::Exception::Error(StringToV8(isolate, "Setting cookie failed"));
-  }
-};
-
-template <>
-struct Converter<net::CanonicalCookie> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CanonicalCookie& val) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("name", val.Name());
-    dict.Set("value", val.Value());
-    dict.Set("domain", val.Domain());
-    dict.Set("hostOnly", net::cookie_util::DomainIsHostOnly(val.Domain()));
-    dict.Set("path", val.Path());
-    dict.Set("secure", val.IsSecure());
-    dict.Set("httpOnly", val.IsHttpOnly());
-    dict.Set("session", !val.IsPersistent());
-    if (val.IsPersistent())
-      dict.Set("expirationDate", val.ExpiryDate().ToDoubleT());
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<net::CookieChangeCause> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CookieChangeCause& val) {
-    switch (val) {
-      case net::CookieChangeCause::INSERTED:
-      case net::CookieChangeCause::EXPLICIT:
-        return mate::StringToV8(isolate, "explicit");
-      case net::CookieChangeCause::OVERWRITE:
-        return mate::StringToV8(isolate, "overwrite");
-      case net::CookieChangeCause::EXPIRED:
-        return mate::StringToV8(isolate, "expired");
-      case net::CookieChangeCause::EVICTED:
-        return mate::StringToV8(isolate, "evicted");
-      case net::CookieChangeCause::EXPIRED_OVERWRITE:
-        return mate::StringToV8(isolate, "expired-overwrite");
-      default:
-        return mate::StringToV8(isolate, "unknown");
-    }
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// Returns whether |domain| matches |filter|.
-bool MatchesDomain(std::string filter, const std::string& domain) {
-  // Add a leading '.' character to the filter domain if it doesn't exist.
-  if (net::cookie_util::DomainIsHostOnly(filter))
-    filter.insert(0, ".");
-
-  std::string sub_domain(domain);
-  // Strip any leading '.' character from the input cookie domain.
-  if (!net::cookie_util::DomainIsHostOnly(sub_domain))
-    sub_domain = sub_domain.substr(1);
-
-  // Now check whether the domain argument is a subdomain of the filter domain.
-  for (sub_domain.insert(0, "."); sub_domain.length() >= filter.length();) {
-    if (sub_domain == filter)
-      return true;
-    const size_t next_dot = sub_domain.find('.', 1);  // Skip over leading dot.
-    sub_domain.erase(0, next_dot);
-  }
-  return false;
-}
-
-// Returns whether |cookie| matches |filter|.
-bool MatchesCookie(const base::DictionaryValue* filter,
-                   const net::CanonicalCookie& cookie) {
-  std::string str;
-  bool b;
-  if (filter->GetString("name", &str) && str != cookie.Name())
-    return false;
-  if (filter->GetString("path", &str) && str != cookie.Path())
-    return false;
-  if (filter->GetString("domain", &str) && !MatchesDomain(str, cookie.Domain()))
-    return false;
-  if (filter->GetBoolean("secure", &b) && b != cookie.IsSecure())
-    return false;
-  if (filter->GetBoolean("session", &b) && b != !cookie.IsPersistent())
-    return false;
-  return true;
-}
-
-// Helper to returns the CookieStore.
-inline net::CookieStore* GetCookieStore(
-    scoped_refptr<net::URLRequestContextGetter> getter) {
-  return getter->GetURLRequestContext()->cookie_store();
-}
-
-// Run |callback| on UI thread.
-void RunCallbackInUI(const base::Closure& callback) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
-}
-
-// Remove cookies from |list| not matching |filter|, and pass it to |callback|.
-void FilterCookies(std::unique_ptr<base::DictionaryValue> filter,
-                   const Cookies::GetCallback& callback,
-                   const net::CookieList& list) {
-  net::CookieList result;
-  for (const auto& cookie : list) {
-    if (MatchesCookie(filter.get(), cookie))
-      result.push_back(cookie);
-  }
-  RunCallbackInUI(base::Bind(callback, Cookies::SUCCESS, result));
-}
-
-// Receives cookies matching |filter| in IO thread.
-void GetCookiesOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                    std::unique_ptr<base::DictionaryValue> filter,
-                    const Cookies::GetCallback& callback) {
-  std::string url;
-  filter->GetString("url", &url);
-
-  auto filtered_callback =
-      base::Bind(FilterCookies, base::Passed(&filter), callback);
-
-  // Empty url will match all url cookies.
-  if (url.empty())
-    GetCookieStore(getter)->GetAllCookiesAsync(filtered_callback);
-  else
-    GetCookieStore(getter)->GetAllCookiesForURLAsync(GURL(url),
-                                                     filtered_callback);
-}
-
-// Removes cookie with |url| and |name| in IO thread.
-void RemoveCookieOnIOThread(scoped_refptr<net::URLRequestContextGetter> getter,
-                            const GURL& url,
-                            const std::string& name,
-                            const base::Closure& callback) {
-  GetCookieStore(getter)->DeleteCookieAsync(
-      url, name, base::BindOnce(RunCallbackInUI, callback));
-}
-
-// Callback of SetCookie.
-void OnSetCookie(const Cookies::SetCallback& callback, bool success) {
-  RunCallbackInUI(
-      base::Bind(callback, success ? Cookies::SUCCESS : Cookies::FAILED));
-}
-
-// Flushes cookie store in IO thread.
-void FlushCookieStoreOnIOThread(
-    scoped_refptr<net::URLRequestContextGetter> getter,
-    const base::Closure& callback) {
-  GetCookieStore(getter)->FlushStore(base::BindOnce(RunCallbackInUI, callback));
-}
-
-// Sets cookie with |details| in IO thread.
-void SetCookieOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                   std::unique_ptr<base::DictionaryValue> details,
-                   const Cookies::SetCallback& callback) {
-  std::string url, name, value, domain, path;
-  bool secure = false;
-  bool http_only = false;
-  double creation_date;
-  double expiration_date;
-  double last_access_date;
-  details->GetString("url", &url);
-  details->GetString("name", &name);
-  details->GetString("value", &value);
-  details->GetString("domain", &domain);
-  details->GetString("path", &path);
-  details->GetBoolean("secure", &secure);
-  details->GetBoolean("httpOnly", &http_only);
-
-  base::Time creation_time;
-  if (details->GetDouble("creationDate", &creation_date)) {
-    creation_time = (creation_date == 0)
-                        ? base::Time::UnixEpoch()
-                        : base::Time::FromDoubleT(creation_date);
-  }
-
-  base::Time expiration_time;
-  if (details->GetDouble("expirationDate", &expiration_date)) {
-    expiration_time = (expiration_date == 0)
-                          ? base::Time::UnixEpoch()
-                          : base::Time::FromDoubleT(expiration_date);
-  }
-
-  base::Time last_access_time;
-  if (details->GetDouble("lastAccessDate", &last_access_date)) {
-    last_access_time = (last_access_date == 0)
-                           ? base::Time::UnixEpoch()
-                           : base::Time::FromDoubleT(last_access_date);
-  }
-
-  std::unique_ptr<net::CanonicalCookie> canonical_cookie(
-      net::CanonicalCookie::CreateSanitizedCookie(
-          GURL(url), name, value, domain, path, creation_time, expiration_time,
-          last_access_time, secure, http_only,
-          net::CookieSameSite::DEFAULT_MODE, net::COOKIE_PRIORITY_DEFAULT));
-  auto completion_callback = base::BindOnce(OnSetCookie, callback);
-  if (!canonical_cookie || !canonical_cookie->IsCanonical()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  if (url.empty()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  if (name.empty()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  GetCookieStore(getter)->SetCanonicalCookieAsync(
-      std::move(canonical_cookie), secure, http_only,
-      std::move(completion_callback));
-}
-
-}  // namespace
-
-Cookies::Cookies(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : browser_context_(browser_context) {
-  Init(isolate);
-  cookie_change_subscription_ =
-      browser_context->GetRequestContextDelegate()
-          ->RegisterCookieChangeCallback(
-              base::Bind(&Cookies::OnCookieChanged, base::Unretained(this)));
-}
-
-Cookies::~Cookies() {}
-
-void Cookies::Get(const base::DictionaryValue& filter,
-                  const GetCallback& callback) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(filter.Clone()));
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(GetCookiesOnIO, base::RetainedRef(getter), std::move(copy),
-                     callback));
-}
-
-void Cookies::Remove(const GURL& url,
-                     const std::string& name,
-                     const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(RemoveCookieOnIOThread, base::RetainedRef(getter), url,
-                     name, callback));
-}
-
-void Cookies::Set(const base::DictionaryValue& details,
-                  const SetCallback& callback) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(details.Clone()));
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(SetCookieOnIO, base::RetainedRef(getter), std::move(copy),
-                     callback));
-}
-
-void Cookies::FlushStore(const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(FlushCookieStoreOnIOThread, base::RetainedRef(getter),
-                     callback));
-}
-
-void Cookies::OnCookieChanged(const CookieDetails* details) {
-  Emit("changed", *(details->cookie), details->cause, details->removed);
-}
-
-// static
-mate::Handle<Cookies> Cookies::Create(v8::Isolate* isolate,
-                                      AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new Cookies(isolate, browser_context));
-}
-
-// static
-void Cookies::BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Cookies"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("get", &Cookies::Get)
-      .SetMethod("remove", &Cookies::Remove)
-      .SetMethod("set", &Cookies::Set)
-      .SetMethod("flushStore", &Cookies::FlushStore);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 302fd1b25110ceec6a1124c02c35d8475ed623b6 atom/browser/api/atom_api_cookies.h
  our    100644 8a83a64ca1012e11cb9629ea172f578eca545abe atom/browser/api/atom_api_cookies.h
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_COOKIES_H_
-#define ATOM_BROWSER_API_ATOM_API_COOKIES_H_
-
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/net/cookie_details.h"
-#include "base/callback_list.h"
-#include "native_mate/handle.h"
-#include "net/cookies/canonical_cookie.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace net {
-class URLRequestContextGetter;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class Cookies : public mate::TrackableObject<Cookies> {
- public:
-  enum Error {
-    SUCCESS,
-    FAILED,
-  };
-
-  using GetCallback = base::Callback<void(Error, const net::CookieList&)>;
-  using SetCallback = base::Callback<void(Error)>;
-
-  static mate::Handle<Cookies> Create(v8::Isolate* isolate,
-                                      AtomBrowserContext* browser_context);
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Cookies(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Cookies() override;
-
-  void Get(const base::DictionaryValue& filter, const GetCallback& callback);
-  void Remove(const GURL& url,
-              const std::string& name,
-              const base::Closure& callback);
-  void Set(const base::DictionaryValue& details, const SetCallback& callback);
-  void FlushStore(const base::Closure& callback);
-
-  // AtomBrowserContext::RegisterCookieChangeCallback subscription:
-  void OnCookieChanged(const CookieDetails*);
-
- private:
-  std::unique_ptr<base::CallbackList<void(const CookieDetails*)>::Subscription>
-      cookie_change_subscription_;
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(Cookies);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_COOKIES_H_
removed in remote
  base   100644 eab60311f3dd16070428a4fbd3bc4ba942f23c51 atom/browser/api/atom_api_debugger.cc
  our    100644 603382d8a7ac5de596cfdc4ca419f5243287166e atom/browser/api/atom_api_debugger.cc
@@ -1,177 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_debugger.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/json/json_reader.h"
-#include "base/json/json_writer.h"
-#include "base/memory/ptr_util.h"
-#include "content/public/browser/devtools_agent_host.h"
-#include "content/public/browser/web_contents.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-#include "atom/common/node_includes.h"
-
-using content::DevToolsAgentHost;
-
-namespace atom {
-
-namespace api {
-
-Debugger::Debugger(v8::Isolate* isolate, content::WebContents* web_contents)
-    : web_contents_(web_contents) {
-  Init(isolate);
-}
-
-Debugger::~Debugger() {}
-
-void Debugger::AgentHostClosed(DevToolsAgentHost* agent_host) {
-  std::string detach_reason = "target closed";
-  Emit("detach", detach_reason);
-}
-
-void Debugger::DispatchProtocolMessage(DevToolsAgentHost* agent_host,
-                                       const std::string& message) {
-  DCHECK(agent_host == agent_host_.get());
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  std::unique_ptr<base::Value> parsed_message = base::JSONReader::Read(message);
-  if (!parsed_message || !parsed_message->is_dict())
-    return;
-  base::DictionaryValue* dict =
-      static_cast<base::DictionaryValue*>(parsed_message.get());
-  int id;
-  if (!dict->GetInteger("id", &id)) {
-    std::string method;
-    if (!dict->GetString("method", &method))
-      return;
-    base::DictionaryValue* params_value = nullptr;
-    base::DictionaryValue params;
-    if (dict->GetDictionary("params", &params_value))
-      params.Swap(params_value);
-    Emit("message", method, params);
-  } else {
-    auto send_command_callback = pending_requests_[id];
-    pending_requests_.erase(id);
-    if (send_command_callback.is_null())
-      return;
-    base::DictionaryValue* error_body = nullptr;
-    base::DictionaryValue error;
-    if (dict->GetDictionary("error", &error_body))
-      error.Swap(error_body);
-
-    base::DictionaryValue* result_body = nullptr;
-    base::DictionaryValue result;
-    if (dict->GetDictionary("result", &result_body))
-      result.Swap(result_body);
-    send_command_callback.Run(error, result);
-  }
-}
-
-void Debugger::Attach(mate::Arguments* args) {
-  std::string protocol_version;
-  args->GetNext(&protocol_version);
-
-  if (!protocol_version.empty() &&
-      !DevToolsAgentHost::IsSupportedProtocolVersion(protocol_version)) {
-    args->ThrowError("Requested protocol version is not supported");
-    return;
-  }
-  agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents_);
-  if (!agent_host_.get()) {
-    args->ThrowError("No target available");
-    return;
-  }
-  if (agent_host_->IsAttached()) {
-    args->ThrowError("Another debugger is already attached to this target");
-    return;
-  }
-
-  agent_host_->AttachClient(this);
-}
-
-bool Debugger::IsAttached() {
-  return agent_host_.get() ? agent_host_->IsAttached() : false;
-}
-
-void Debugger::Detach() {
-  if (!agent_host_.get())
-    return;
-  agent_host_->DetachClient(this);
-  AgentHostClosed(agent_host_.get());
-  agent_host_ = nullptr;
-}
-
-void Debugger::SendCommand(mate::Arguments* args) {
-  if (!agent_host_.get())
-    return;
-
-  std::string method;
-  if (!args->GetNext(&method)) {
-    args->ThrowError();
-    return;
-  }
-  base::DictionaryValue command_params;
-  args->GetNext(&command_params);
-  SendCommandCallback callback;
-  args->GetNext(&callback);
-
-  base::DictionaryValue request;
-  int request_id = ++previous_request_id_;
-  pending_requests_[request_id] = callback;
-  request.SetInteger("id", request_id);
-  request.SetString("method", method);
-  if (!command_params.empty())
-    request.Set("params", base::WrapUnique(command_params.DeepCopy()));
-
-  std::string json_args;
-  base::JSONWriter::Write(request, &json_args);
-  agent_host_->DispatchProtocolMessage(this, json_args);
-}
-
-// static
-mate::Handle<Debugger> Debugger::Create(v8::Isolate* isolate,
-                                        content::WebContents* web_contents) {
-  return mate::CreateHandle(isolate, new Debugger(isolate, web_contents));
-}
-
-// static
-void Debugger::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Debugger"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("attach", &Debugger::Attach)
-      .SetMethod("isAttached", &Debugger::IsAttached)
-      .SetMethod("detach", &Debugger::Detach)
-      .SetMethod("sendCommand", &Debugger::SendCommand);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Debugger;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary(isolate, exports)
-      .Set("Debugger", Debugger::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_debugger, Initialize);
removed in remote
  base   100644 5454108e8b0907056f69f95ac40bfd0ffd59e4a6 atom/browser/api/atom_api_debugger.h
  our    100644 d3774dae9dc58ed005274bd756b1b40cb7ca7b0e atom/browser/api/atom_api_debugger.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
-#define ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/callback.h"
-#include "base/values.h"
-#include "content/public/browser/devtools_agent_host_client.h"
-#include "native_mate/handle.h"
-
-namespace content {
-class DevToolsAgentHost;
-class WebContents;
-}  // namespace content
-
-namespace mate {
-class Arguments;
-}
-
-namespace atom {
-
-namespace api {
-
-class Debugger : public mate::TrackableObject<Debugger>,
-                 public content::DevToolsAgentHostClient {
- public:
-  using SendCommandCallback =
-      base::Callback<void(const base::DictionaryValue&,
-                          const base::DictionaryValue&)>;
-
-  static mate::Handle<Debugger> Create(v8::Isolate* isolate,
-                                       content::WebContents* web_contents);
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Debugger(v8::Isolate* isolate, content::WebContents* web_contents);
-  ~Debugger() override;
-
-  // content::DevToolsAgentHostClient:
-  void AgentHostClosed(content::DevToolsAgentHost* agent_host) override;
-  void DispatchProtocolMessage(content::DevToolsAgentHost* agent_host,
-                               const std::string& message) override;
-
- private:
-  using PendingRequestMap = std::map<int, SendCommandCallback>;
-
-  void Attach(mate::Arguments* args);
-  bool IsAttached();
-  void Detach();
-  void SendCommand(mate::Arguments* args);
-
-  content::WebContents* web_contents_;  // Weak Reference.
-  scoped_refptr<content::DevToolsAgentHost> agent_host_;
-
-  PendingRequestMap pending_requests_;
-  int previous_request_id_ = 0;
-
-  DISALLOW_COPY_AND_ASSIGN(Debugger);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
removed in remote
  base   100644 cdae6f0c44cd962f0a512df70bfe2bd79f603a5f atom/browser/api/atom_api_desktop_capturer.cc
  our    100644 135b4edd11048a4635f9017f569f4b4ae644a09c atom/browser/api/atom_api_desktop_capturer.cc
@@ -1,207 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_desktop_capturer.h"
-
-#include <vector>
-
-using base::PlatformThreadRef;
-
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/media/desktop_media_list.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/desktop_capture.h"
-#include "native_mate/dictionary.h"
-#include "third_party/webrtc/modules/desktop_capture/desktop_capture_options.h"
-#include "third_party/webrtc/modules/desktop_capture/desktop_capturer.h"
-#if defined(OS_WIN)
-#include "third_party/webrtc/modules/desktop_capture/win/dxgi_duplicator_controller.h"
-#include "third_party/webrtc/modules/desktop_capture/win/screen_capturer_win_directx.h"
-#include "ui/display/win/display_info.h"
-#endif  // defined(OS_WIN)
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<atom::api::DesktopCapturer::Source> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const atom::api::DesktopCapturer::Source& source) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    content::DesktopMediaID id = source.media_list_source.id;
-    dict.Set("name", base::UTF16ToUTF8(source.media_list_source.name));
-    dict.Set("id", id.ToString());
-    dict.Set("thumbnail",
-             atom::api::NativeImage::Create(
-                 isolate, gfx::Image(source.media_list_source.thumbnail)));
-    dict.Set("display_id", source.display_id);
-    return ConvertToV8(isolate, dict);
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void EmitFinished(
-    const std::vector<atom::api::DesktopCapturer::Source>& sources,
-    atom::api::DesktopCapturer* cap) {
-  cap->Emit("finished", sources);
-}
-
-void StartHandlingTask(bool capture_window,
-                       bool capture_screen,
-                       const gfx::Size& thumbnail_size,
-                       atom::api::DesktopCapturer* cap) {
-#if defined(OS_WIN)
-  if (content::desktop_capture::CreateDesktopCaptureOptions()
-      .allow_directx_capturer()) {
-    // DxgiDuplicatorController should be alive in this scope according to
-    // screen_capturer_win.cc.
-    auto duplicator = webrtc::DxgiDuplicatorController::Instance();
-    cap->using_directx_capturer_ =
-        webrtc::ScreenCapturerWinDirectx::IsSupported();
-  }
-#endif  // defined(OS_WIN)
-  std::unique_ptr<webrtc::DesktopCapturer> screen_capturer(
-      capture_screen ? content::desktop_capture::CreateScreenCapturer()
-                     : nullptr);
-  std::unique_ptr<webrtc::DesktopCapturer> window_capturer(
-      capture_window ? content::desktop_capture::CreateWindowCapturer()
-                     : nullptr);
-  cap->media_list_.reset(new NativeDesktopMediaList(
-      std::move(screen_capturer), std::move(window_capturer)));
-
-  cap->media_list_->SetThumbnailSize(thumbnail_size);
-  cap->media_list_->StartUpdating(cap);
-}
-
-void OnRefreshFinishedTask(atom::api::DesktopCapturer* cap) {
-  const auto media_list_sources = cap->media_list_->GetSources();
-  std::vector<atom::api::DesktopCapturer::Source> sources;
-  for (const auto& media_list_source : media_list_sources) {
-    sources.emplace_back(
-        atom::api::DesktopCapturer::Source{media_list_source, std::string()});
-  }
-
-#if defined(OS_WIN)
-  // Gather the same unique screen IDs used by the electron.screen API in order
-  // to provide an association between it and desktopCapturer/getUserMedia.
-  // This is only required when using the DirectX capturer, otherwise the IDs
-  // across the APIs already match.
-  if (cap->using_directx_capturer_) {
-    std::vector<std::string> device_names;
-    // Crucially, this list of device names will be in the same order as
-    // |media_list_sources|.
-    webrtc::DxgiDuplicatorController::Instance()->GetDeviceNames(&device_names);
-    int device_name_index = 0;
-    for (auto& source : sources) {
-      if (source.media_list_source.id.type ==
-          content::DesktopMediaID::TYPE_SCREEN) {
-        const auto& device_name = device_names[device_name_index++];
-        std::wstring wide_device_name;
-        base::UTF8ToWide(device_name.c_str(), device_name.size(),
-                         &wide_device_name);
-        const int64_t device_id =
-            display::win::DisplayInfo::DeviceIdFromDeviceName(
-                wide_device_name.c_str());
-        source.display_id = base::Int64ToString(device_id);
-      }
-    }
-  }
-#elif defined(OS_MACOSX)
-  // On Mac, the IDs across the APIs match.
-  for (auto& source : sources) {
-    if (source.media_list_source.id.type ==
-        content::DesktopMediaID::TYPE_SCREEN) {
-      source.display_id = base::Int64ToString(source.media_list_source.id.id);
-    }
-  }
-#endif  // defined(OS_WIN)
-  // TODO(ajmacd): Add Linux support. The IDs across APIs differ but Chrome only
-  // supports capturing the entire desktop on Linux. Revisit this if individual
-  // screen support is added.
-
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                                   base::Bind(EmitFinished, sources, cap));
-}
-
-}  // namespace
-
-namespace atom {
-
-namespace api {
-
-DesktopCapturer::DesktopCapturer(v8::Isolate* isolate) {
-  Init(isolate);
-  capture_thread_ = base::CreateSequencedTaskRunnerWithTraits(
-      {base::WithBaseSyncPrimitives(), base::MayBlock(),
-       base::TaskPriority::USER_VISIBLE});
-}
-
-DesktopCapturer::~DesktopCapturer() {}
-
-void DesktopCapturer::StartHandling(bool capture_window,
-                                    bool capture_screen,
-                                    const gfx::Size& thumbnail_size) {
-  capture_thread_->PostTask(
-      FROM_HERE, base::BindOnce(StartHandlingTask, capture_window,
-                                capture_screen, thumbnail_size, this));
-}
-
-void DesktopCapturer::OnSourceAdded(int index) {}
-
-void DesktopCapturer::OnSourceRemoved(int index) {}
-
-void DesktopCapturer::OnSourceMoved(int old_index, int new_index) {}
-
-void DesktopCapturer::OnSourceNameChanged(int index) {}
-
-void DesktopCapturer::OnSourceThumbnailChanged(int index) {}
-
-bool DesktopCapturer::OnRefreshFinished() {
-  capture_thread_->PostTask(FROM_HERE,
-                            base::BindOnce(OnRefreshFinishedTask, this));
-  return false;
-}
-
-// static
-mate::Handle<DesktopCapturer> DesktopCapturer::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new DesktopCapturer(isolate));
-}
-
-// static
-void DesktopCapturer::BuildPrototype(
-    v8::Isolate* isolate,
-    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "DesktopCapturer"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("startHandling", &DesktopCapturer::StartHandling);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("desktopCapturer", atom::api::DesktopCapturer::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_desktop_capturer, Initialize);
removed in remote
  base   100644 c22c8a44835f66cb44a711ff5775b7274809ebe3 atom/browser/api/atom_api_desktop_capturer.h
  our    100644 88960e46d49dd0b68c51647be18066a2d097ce79 atom/browser/api/atom_api_desktop_capturer.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
-#define ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
-
-#include <string>
-
-#include "atom/browser/api/event_emitter.h"
-#include "chrome/browser/media/desktop_media_list_observer.h"
-#include "chrome/browser/media/native_desktop_media_list.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-namespace api {
-
-class DesktopCapturer : public mate::EventEmitter<DesktopCapturer>,
-                        public DesktopMediaListObserver {
- public:
-  struct Source {
-    DesktopMediaList::Source media_list_source;
-    // Will be an empty string if not available.
-    std::string display_id;
-  };
-
-  static mate::Handle<DesktopCapturer> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  void StartHandling(bool capture_window,
-                     bool capture_screen,
-                     const gfx::Size& thumbnail_size);
-
-  std::unique_ptr<DesktopMediaList> media_list_;
-#if defined(OS_WIN)
-  bool using_directx_capturer_ = false;
-#endif  // defined(OS_WIN)
-
- protected:
-  explicit DesktopCapturer(v8::Isolate* isolate);
-  ~DesktopCapturer() override;
-
-  // DesktopMediaListObserver overrides.
-  void OnSourceAdded(int index) override;
-  void OnSourceRemoved(int index) override;
-  void OnSourceMoved(int old_index, int new_index) override;
-  void OnSourceNameChanged(int index) override;
-  void OnSourceThumbnailChanged(int index) override;
-  bool OnRefreshFinished() override;
-
- private:
-  scoped_refptr<base::SequencedTaskRunner> capture_thread_;
-
-  DISALLOW_COPY_AND_ASSIGN(DesktopCapturer);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
removed in remote
  base   100644 0a544c56468cb67dce5793a15535a772bc2b17de atom/browser/api/atom_api_dialog.cc
  our    100644 bdbaffbb5bd3889082a985189a3688ca1f91e66d atom/browser/api/atom_api_dialog.cc
@@ -1,142 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/certificate_trust.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/ui/message_box.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<file_dialog::Filter> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     file_dialog::Filter* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    if (!dict.Get("name", &(out->first)))
-      return false;
-    if (!dict.Get("extensions", &(out->second)))
-      return false;
-    return true;
-  }
-};
-
-template <>
-struct Converter<file_dialog::DialogSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     file_dialog::DialogSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    dict.Get("window", &(out->parent_window));
-    dict.Get("title", &(out->title));
-    dict.Get("message", &(out->message));
-    dict.Get("buttonLabel", &(out->button_label));
-    dict.Get("nameFieldLabel", &(out->name_field_label));
-    dict.Get("defaultPath", &(out->default_path));
-    dict.Get("filters", &(out->filters));
-    dict.Get("properties", &(out->properties));
-    dict.Get("showsTagField", &(out->shows_tag_field));
-#if defined(MAS_BUILD)
-    dict.Get("securityScopedBookmarks", &(out->security_scoped_bookmarks));
-#endif
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void ShowMessageBox(int type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    atom::NativeWindow* window,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  atom::MessageBoxCallback callback;
-  if (mate::Converter<atom::MessageBoxCallback>::FromV8(args->isolate(), peek,
-                                                        &callback)) {
-    atom::ShowMessageBox(window, static_cast<atom::MessageBoxType>(type),
-                         buttons, default_id, cancel_id, options, title,
-                         message, detail, checkbox_label, checkbox_checked,
-                         icon, callback);
-  } else {
-    int chosen = atom::ShowMessageBox(
-        window, static_cast<atom::MessageBoxType>(type), buttons, default_id,
-        cancel_id, options, title, message, detail, icon);
-    args->Return(chosen);
-  }
-}
-
-void ShowOpenDialog(const file_dialog::DialogSettings& settings,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  file_dialog::OpenDialogCallback callback;
-  if (mate::Converter<file_dialog::OpenDialogCallback>::FromV8(
-          args->isolate(), peek, &callback)) {
-    file_dialog::ShowOpenDialog(settings, callback);
-  } else {
-    std::vector<base::FilePath> paths;
-    if (file_dialog::ShowOpenDialog(settings, &paths))
-      args->Return(paths);
-  }
-}
-
-void ShowSaveDialog(const file_dialog::DialogSettings& settings,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  file_dialog::SaveDialogCallback callback;
-  if (mate::Converter<file_dialog::SaveDialogCallback>::FromV8(
-          args->isolate(), peek, &callback)) {
-    file_dialog::ShowSaveDialog(settings, callback);
-  } else {
-    base::FilePath path;
-    if (file_dialog::ShowSaveDialog(settings, &path))
-      args->Return(path);
-  }
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("showMessageBox", &ShowMessageBox);
-  dict.SetMethod("showErrorBox", &atom::ShowErrorBox);
-  dict.SetMethod("showOpenDialog", &ShowOpenDialog);
-  dict.SetMethod("showSaveDialog", &ShowSaveDialog);
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  dict.SetMethod("showCertificateTrustDialog",
-                 &certificate_trust::ShowCertificateTrust);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_dialog, Initialize)
removed in remote
  base   100644 3edd5f9c25492f490dbda270295b17040d4c4e38 atom/browser/api/atom_api_download_item.cc
  our    100644 4fa4d5517b4adbf5ee7e3f68489f53d3de9d5e12 atom/browser/api/atom_api_download_item.cc
@@ -1,241 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_download_item.h"
-
-#include <map>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/dictionary.h"
-#include "net/base/filename_util.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<download::DownloadItem::DownloadState> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      download::DownloadItem::DownloadState state) {
-    std::string download_state;
-    switch (state) {
-      case download::DownloadItem::IN_PROGRESS:
-        download_state = "progressing";
-        break;
-      case download::DownloadItem::COMPLETE:
-        download_state = "completed";
-        break;
-      case download::DownloadItem::CANCELLED:
-        download_state = "cancelled";
-        break;
-      case download::DownloadItem::INTERRUPTED:
-        download_state = "interrupted";
-        break;
-      default:
-        break;
-    }
-    return ConvertToV8(isolate, download_state);
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-std::map<uint32_t, v8::Global<v8::Object>> g_download_item_objects;
-
-}  // namespace
-
-DownloadItem::DownloadItem(v8::Isolate* isolate,
-                           download::DownloadItem* download_item)
-    : download_item_(download_item) {
-  download_item_->AddObserver(this);
-  Init(isolate);
-  AttachAsUserData(download_item);
-}
-
-DownloadItem::~DownloadItem() {
-  if (download_item_) {
-    // Destroyed by either garbage collection or destroy().
-    download_item_->RemoveObserver(this);
-    download_item_->Remove();
-  }
-
-  // Remove from the global map.
-  g_download_item_objects.erase(weak_map_id());
-}
-
-void DownloadItem::OnDownloadUpdated(download::DownloadItem* item) {
-  if (download_item_->IsDone()) {
-    Emit("done", item->GetState());
-    // Destroy the item once item is downloaded.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
-                                                  GetDestroyClosure());
-  } else {
-    Emit("updated", item->GetState());
-  }
-}
-
-void DownloadItem::OnDownloadDestroyed(download::DownloadItem* download_item) {
-  download_item_ = nullptr;
-  // Destroy the native class immediately when downloadItem is destroyed.
-  delete this;
-}
-
-void DownloadItem::Pause() {
-  download_item_->Pause();
-}
-
-bool DownloadItem::IsPaused() const {
-  return download_item_->IsPaused();
-}
-
-void DownloadItem::Resume() {
-  download_item_->Resume();
-}
-
-bool DownloadItem::CanResume() const {
-  return download_item_->CanResume();
-}
-
-void DownloadItem::Cancel() {
-  download_item_->Cancel(true);
-}
-
-int64_t DownloadItem::GetReceivedBytes() const {
-  return download_item_->GetReceivedBytes();
-}
-
-int64_t DownloadItem::GetTotalBytes() const {
-  return download_item_->GetTotalBytes();
-}
-
-std::string DownloadItem::GetMimeType() const {
-  return download_item_->GetMimeType();
-}
-
-bool DownloadItem::HasUserGesture() const {
-  return download_item_->HasUserGesture();
-}
-
-std::string DownloadItem::GetFilename() const {
-  return base::UTF16ToUTF8(
-      net::GenerateFileName(GetURL(), GetContentDisposition(), std::string(),
-                            download_item_->GetSuggestedFilename(),
-                            GetMimeType(), "download")
-          .LossyDisplayName());
-}
-
-std::string DownloadItem::GetContentDisposition() const {
-  return download_item_->GetContentDisposition();
-}
-
-const GURL& DownloadItem::GetURL() const {
-  return download_item_->GetURL();
-}
-
-const std::vector<GURL>& DownloadItem::GetURLChain() const {
-  return download_item_->GetUrlChain();
-}
-
-download::DownloadItem::DownloadState DownloadItem::GetState() const {
-  return download_item_->GetState();
-}
-
-bool DownloadItem::IsDone() const {
-  return download_item_->IsDone();
-}
-
-void DownloadItem::SetSavePath(const base::FilePath& path) {
-  save_path_ = path;
-}
-
-base::FilePath DownloadItem::GetSavePath() const {
-  return save_path_;
-}
-
-std::string DownloadItem::GetLastModifiedTime() const {
-  return download_item_->GetLastModifiedTime();
-}
-
-std::string DownloadItem::GetETag() const {
-  return download_item_->GetETag();
-}
-
-double DownloadItem::GetStartTime() const {
-  return download_item_->GetStartTime().ToDoubleT();
-}
-
-// static
-void DownloadItem::BuildPrototype(v8::Isolate* isolate,
-                                  v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "DownloadItem"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("pause", &DownloadItem::Pause)
-      .SetMethod("isPaused", &DownloadItem::IsPaused)
-      .SetMethod("resume", &DownloadItem::Resume)
-      .SetMethod("canResume", &DownloadItem::CanResume)
-      .SetMethod("cancel", &DownloadItem::Cancel)
-      .SetMethod("getReceivedBytes", &DownloadItem::GetReceivedBytes)
-      .SetMethod("getTotalBytes", &DownloadItem::GetTotalBytes)
-      .SetMethod("getMimeType", &DownloadItem::GetMimeType)
-      .SetMethod("hasUserGesture", &DownloadItem::HasUserGesture)
-      .SetMethod("getFilename", &DownloadItem::GetFilename)
-      .SetMethod("getContentDisposition", &DownloadItem::GetContentDisposition)
-      .SetMethod("getURL", &DownloadItem::GetURL)
-      .SetMethod("getURLChain", &DownloadItem::GetURLChain)
-      .SetMethod("getState", &DownloadItem::GetState)
-      .SetMethod("isDone", &DownloadItem::IsDone)
-      .SetMethod("setSavePath", &DownloadItem::SetSavePath)
-      .SetMethod("getSavePath", &DownloadItem::GetSavePath)
-      .SetMethod("getLastModifiedTime", &DownloadItem::GetLastModifiedTime)
-      .SetMethod("getETag", &DownloadItem::GetETag)
-      .SetMethod("getStartTime", &DownloadItem::GetStartTime);
-}
-
-// static
-mate::Handle<DownloadItem> DownloadItem::Create(v8::Isolate* isolate,
-                                                download::DownloadItem* item) {
-  auto* existing = TrackableObject::FromWrappedClass(isolate, item);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<DownloadItem*>(existing));
-
-  auto handle = mate::CreateHandle(isolate, new DownloadItem(isolate, item));
-
-  // Reference this object in case it got garbage collected.
-  g_download_item_objects[handle->weak_map_id()] =
-      v8::Global<v8::Object>(isolate, handle.ToV8());
-  return handle;
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary(isolate, exports)
-      .Set("DownloadItem",
-           atom::api::DownloadItem::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_download_item, Initialize);
removed in remote
  base   100644 64469b9b34d1bd413ee7a4af3873da6a6f3e0132 atom/browser/api/atom_api_download_item.h
  our    100644 45ed54faf1918f877b953db86b1dd250cbd80879 atom/browser/api/atom_api_download_item.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
-#define ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/files/file_path.h"
-#include "components/download/public/common/download_item.h"
-#include "native_mate/handle.h"
-#include "url/gurl.h"
-
-namespace atom {
-
-namespace api {
-
-class DownloadItem : public mate::TrackableObject<DownloadItem>,
-                     public download::DownloadItem::Observer {
- public:
-  static mate::Handle<DownloadItem> Create(v8::Isolate* isolate,
-                                           download::DownloadItem* item);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  void Pause();
-  bool IsPaused() const;
-  void Resume();
-  bool CanResume() const;
-  void Cancel();
-  int64_t GetReceivedBytes() const;
-  int64_t GetTotalBytes() const;
-  std::string GetMimeType() const;
-  bool HasUserGesture() const;
-  std::string GetFilename() const;
-  std::string GetContentDisposition() const;
-  const GURL& GetURL() const;
-  const std::vector<GURL>& GetURLChain() const;
-  download::DownloadItem::DownloadState GetState() const;
-  bool IsDone() const;
-  void SetSavePath(const base::FilePath& path);
-  base::FilePath GetSavePath() const;
-  std::string GetLastModifiedTime() const;
-  std::string GetETag() const;
-  double GetStartTime() const;
-
- protected:
-  DownloadItem(v8::Isolate* isolate, download::DownloadItem* download_item);
-  ~DownloadItem() override;
-
-  // Override download::DownloadItem::Observer methods
-  void OnDownloadUpdated(download::DownloadItem* download) override;
-  void OnDownloadDestroyed(download::DownloadItem* download) override;
-
- private:
-  base::FilePath save_path_;
-  download::DownloadItem* download_item_;
-
-  DISALLOW_COPY_AND_ASSIGN(DownloadItem);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
removed in remote
  base   100644 f5a03e4abf9010c3bd371e0778ab684d2dd2418e atom/browser/api/atom_api_global_shortcut.cc
  our    100644 4fc7532d9e346ee9d2c02cfac450042073897b99 atom/browser/api/atom_api_global_shortcut.cc
@@ -1,103 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_global_shortcut.h"
-
-#include <string>
-
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "base/stl_util.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using extensions::GlobalShortcutListener;
-
-namespace atom {
-
-namespace api {
-
-GlobalShortcut::GlobalShortcut(v8::Isolate* isolate) {
-  Init(isolate);
-}
-
-GlobalShortcut::~GlobalShortcut() {
-  UnregisterAll();
-}
-
-void GlobalShortcut::OnKeyPressed(const ui::Accelerator& accelerator) {
-  if (accelerator_callback_map_.find(accelerator) ==
-      accelerator_callback_map_.end()) {
-    // This should never occur, because if it does, GlobalGlobalShortcutListener
-    // notifes us with wrong accelerator.
-    NOTREACHED();
-    return;
-  }
-  accelerator_callback_map_[accelerator].Run();
-}
-
-bool GlobalShortcut::Register(const ui::Accelerator& accelerator,
-                              const base::Closure& callback) {
-  if (!GlobalShortcutListener::GetInstance()->RegisterAccelerator(accelerator,
-                                                                  this)) {
-    return false;
-  }
-
-  accelerator_callback_map_[accelerator] = callback;
-  return true;
-}
-
-void GlobalShortcut::Unregister(const ui::Accelerator& accelerator) {
-  if (!ContainsKey(accelerator_callback_map_, accelerator))
-    return;
-
-  accelerator_callback_map_.erase(accelerator);
-  GlobalShortcutListener::GetInstance()->UnregisterAccelerator(accelerator,
-                                                               this);
-}
-
-bool GlobalShortcut::IsRegistered(const ui::Accelerator& accelerator) {
-  return ContainsKey(accelerator_callback_map_, accelerator);
-}
-
-void GlobalShortcut::UnregisterAll() {
-  accelerator_callback_map_.clear();
-  GlobalShortcutListener::GetInstance()->UnregisterAccelerators(this);
-}
-
-// static
-mate::Handle<GlobalShortcut> GlobalShortcut::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new GlobalShortcut(isolate));
-}
-
-// static
-void GlobalShortcut::BuildPrototype(v8::Isolate* isolate,
-                                    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "GlobalShortcut"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("register", &GlobalShortcut::Register)
-      .SetMethod("isRegistered", &GlobalShortcut::IsRegistered)
-      .SetMethod("unregister", &GlobalShortcut::Unregister)
-      .SetMethod("unregisterAll", &GlobalShortcut::UnregisterAll);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("globalShortcut", atom::api::GlobalShortcut::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_global_shortcut, Initialize)
removed in remote
  base   100644 d7057b0003208a1915d4912827dc7595722e258e atom/browser/api/atom_api_global_shortcut.h
  our    100644 b023aec4a8436b83152c812c9ec1d3af478cda80 atom/browser/api/atom_api_global_shortcut.h
@@ -1,54 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
-#define ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/callback.h"
-#include "chrome/browser/extensions/global_shortcut_listener.h"
-#include "native_mate/handle.h"
-#include "ui/base/accelerators/accelerator.h"
-
-namespace atom {
-
-namespace api {
-
-class GlobalShortcut : public extensions::GlobalShortcutListener::Observer,
-                       public mate::TrackableObject<GlobalShortcut> {
- public:
-  static mate::Handle<GlobalShortcut> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit GlobalShortcut(v8::Isolate* isolate);
-  ~GlobalShortcut() override;
-
- private:
-  typedef std::map<ui::Accelerator, base::Closure> AcceleratorCallbackMap;
-
-  bool Register(const ui::Accelerator& accelerator,
-                const base::Closure& callback);
-  bool IsRegistered(const ui::Accelerator& accelerator);
-  void Unregister(const ui::Accelerator& accelerator);
-  void UnregisterAll();
-
-  // GlobalShortcutListener::Observer implementation.
-  void OnKeyPressed(const ui::Accelerator& accelerator) override;
-
-  AcceleratorCallbackMap accelerator_callback_map_;
-
-  DISALLOW_COPY_AND_ASSIGN(GlobalShortcut);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
removed in remote
  base   100644 e40ba17f464fe562f644d0cf2222c63281b5d48e atom/browser/api/atom_api_menu.cc
  our    100644 1c4f4fcf41e55be7d355d8940d14f3e9cb1c2b28 atom/browser/api/atom_api_menu.cc
@@ -1,231 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_menu.h"
-
-#include "atom/browser/native_window.h"
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "native_mate/constructor.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-Menu::Menu(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : model_(new AtomMenuModel(this)) {
-  InitWith(isolate, wrapper);
-  model_->AddObserver(this);
-}
-
-Menu::~Menu() {
-  if (model_) {
-    model_->RemoveObserver(this);
-  }
-}
-
-void Menu::AfterInit(v8::Isolate* isolate) {
-  mate::Dictionary wrappable(isolate, GetWrapper());
-  mate::Dictionary delegate;
-  if (!wrappable.Get("delegate", &delegate))
-    return;
-
-  delegate.Get("isCommandIdChecked", &is_checked_);
-  delegate.Get("isCommandIdEnabled", &is_enabled_);
-  delegate.Get("isCommandIdVisible", &is_visible_);
-  delegate.Get("getAcceleratorForCommandId", &get_accelerator_);
-  delegate.Get("executeCommand", &execute_command_);
-  delegate.Get("menuWillShow", &menu_will_show_);
-}
-
-bool Menu::IsCommandIdChecked(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_checked_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::IsCommandIdEnabled(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_enabled_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::IsCommandIdVisible(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_visible_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::GetAcceleratorForCommandIdWithParams(
-    int command_id,
-    bool use_default_accelerator,
-    ui::Accelerator* accelerator) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  v8::Local<v8::Value> val =
-      get_accelerator_.Run(GetWrapper(), command_id, use_default_accelerator);
-  return mate::ConvertFromV8(isolate(), val, accelerator);
-}
-
-void Menu::ExecuteCommand(int command_id, int flags) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  execute_command_.Run(GetWrapper(),
-                       mate::internal::CreateEventFromFlags(isolate(), flags),
-                       command_id);
-}
-
-void Menu::MenuWillShow(ui::SimpleMenuModel* source) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  menu_will_show_.Run(GetWrapper());
-}
-
-void Menu::InsertItemAt(int index,
-                        int command_id,
-                        const base::string16& label) {
-  model_->InsertItemAt(index, command_id, label);
-}
-
-void Menu::InsertSeparatorAt(int index) {
-  model_->InsertSeparatorAt(index, ui::NORMAL_SEPARATOR);
-}
-
-void Menu::InsertCheckItemAt(int index,
-                             int command_id,
-                             const base::string16& label) {
-  model_->InsertCheckItemAt(index, command_id, label);
-}
-
-void Menu::InsertRadioItemAt(int index,
-                             int command_id,
-                             const base::string16& label,
-                             int group_id) {
-  model_->InsertRadioItemAt(index, command_id, label, group_id);
-}
-
-void Menu::InsertSubMenuAt(int index,
-                           int command_id,
-                           const base::string16& label,
-                           Menu* menu) {
-  menu->parent_ = this;
-  model_->InsertSubMenuAt(index, command_id, label, menu->model_.get());
-}
-
-void Menu::SetIcon(int index, const gfx::Image& image) {
-  model_->SetIcon(index, image);
-}
-
-void Menu::SetSublabel(int index, const base::string16& sublabel) {
-  model_->SetSublabel(index, sublabel);
-}
-
-void Menu::SetRole(int index, const base::string16& role) {
-  model_->SetRole(index, role);
-}
-
-void Menu::Clear() {
-  model_->Clear();
-}
-
-int Menu::GetIndexOfCommandId(int command_id) {
-  return model_->GetIndexOfCommandId(command_id);
-}
-
-int Menu::GetItemCount() const {
-  return model_->GetItemCount();
-}
-
-int Menu::GetCommandIdAt(int index) const {
-  return model_->GetCommandIdAt(index);
-}
-
-base::string16 Menu::GetLabelAt(int index) const {
-  return model_->GetLabelAt(index);
-}
-
-base::string16 Menu::GetSublabelAt(int index) const {
-  return model_->GetSublabelAt(index);
-}
-
-bool Menu::IsItemCheckedAt(int index) const {
-  return model_->IsItemCheckedAt(index);
-}
-
-bool Menu::IsEnabledAt(int index) const {
-  return model_->IsEnabledAt(index);
-}
-
-bool Menu::IsVisibleAt(int index) const {
-  return model_->IsVisibleAt(index);
-}
-
-void Menu::OnMenuWillClose() {
-  Emit("menu-will-close");
-}
-
-void Menu::OnMenuWillShow() {
-  Emit("menu-will-show");
-}
-
-// static
-void Menu::BuildPrototype(v8::Isolate* isolate,
-                          v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Menu"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("insertItem", &Menu::InsertItemAt)
-      .SetMethod("insertCheckItem", &Menu::InsertCheckItemAt)
-      .SetMethod("insertRadioItem", &Menu::InsertRadioItemAt)
-      .SetMethod("insertSeparator", &Menu::InsertSeparatorAt)
-      .SetMethod("insertSubMenu", &Menu::InsertSubMenuAt)
-      .SetMethod("setIcon", &Menu::SetIcon)
-      .SetMethod("setSublabel", &Menu::SetSublabel)
-      .SetMethod("setRole", &Menu::SetRole)
-      .SetMethod("clear", &Menu::Clear)
-      .SetMethod("getIndexOfCommandId", &Menu::GetIndexOfCommandId)
-      .SetMethod("getItemCount", &Menu::GetItemCount)
-      .SetMethod("getCommandIdAt", &Menu::GetCommandIdAt)
-      .SetMethod("getLabelAt", &Menu::GetLabelAt)
-      .SetMethod("getSublabelAt", &Menu::GetSublabelAt)
-      .SetMethod("isItemCheckedAt", &Menu::IsItemCheckedAt)
-      .SetMethod("isEnabledAt", &Menu::IsEnabledAt)
-      .SetMethod("isVisibleAt", &Menu::IsVisibleAt)
-      .SetMethod("popupAt", &Menu::PopupAt)
-      .SetMethod("closePopupAt", &Menu::ClosePopupAt);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Menu;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  Menu::SetConstructor(isolate, base::Bind(&Menu::New));
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Menu", Menu::GetConstructor(isolate)->GetFunction());
-#if defined(OS_MACOSX)
-  dict.SetMethod("setApplicationMenu", &Menu::SetApplicationMenu);
-  dict.SetMethod("sendActionToFirstResponder",
-                 &Menu::SendActionToFirstResponder);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_menu, Initialize)
removed in remote
  base   100644 1ae708863a732c55d9a6fc56c70bcd691350a921 atom/browser/api/atom_api_menu.h
  our    100644 26f2b679b6b7fc561e7f6e454afb2c40f475ee94 atom/browser/api/atom_api_menu.h
@@ -1,138 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/browser/api/atom_api_top_level_window.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/callback.h"
-
-namespace atom {
-
-namespace api {
-
-class Menu : public mate::TrackableObject<Menu>,
-             public AtomMenuModel::Delegate,
-             public AtomMenuModel::Observer {
- public:
-  static mate::WrappableBase* New(mate::Arguments* args);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(OS_MACOSX)
-  // Set the global menubar.
-  static void SetApplicationMenu(Menu* menu);
-
-  // Fake sending an action from the application menu.
-  static void SendActionToFirstResponder(const std::string& action);
-#endif
-
-  AtomMenuModel* model() const { return model_.get(); }
-
- protected:
-  Menu(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~Menu() override;
-
-  // mate::Wrappable:
-  void AfterInit(v8::Isolate* isolate) override;
-
-  // ui::SimpleMenuModel::Delegate:
-  bool IsCommandIdChecked(int command_id) const override;
-  bool IsCommandIdEnabled(int command_id) const override;
-  bool IsCommandIdVisible(int command_id) const override;
-  bool GetAcceleratorForCommandIdWithParams(
-      int command_id,
-      bool use_default_accelerator,
-      ui::Accelerator* accelerator) const override;
-  void ExecuteCommand(int command_id, int event_flags) override;
-  void MenuWillShow(ui::SimpleMenuModel* source) override;
-
-  virtual void PopupAt(TopLevelWindow* window,
-                       int x,
-                       int y,
-                       int positioning_item,
-                       const base::Closure& callback) = 0;
-  virtual void ClosePopupAt(int32_t window_id) = 0;
-
-  std::unique_ptr<AtomMenuModel> model_;
-  Menu* parent_ = nullptr;
-
-  // Observable:
-  void OnMenuWillClose() override;
-  void OnMenuWillShow() override;
-
- private:
-  void InsertItemAt(int index, int command_id, const base::string16& label);
-  void InsertSeparatorAt(int index);
-  void InsertCheckItemAt(int index,
-                         int command_id,
-                         const base::string16& label);
-  void InsertRadioItemAt(int index,
-                         int command_id,
-                         const base::string16& label,
-                         int group_id);
-  void InsertSubMenuAt(int index,
-                       int command_id,
-                       const base::string16& label,
-                       Menu* menu);
-  void SetIcon(int index, const gfx::Image& image);
-  void SetSublabel(int index, const base::string16& sublabel);
-  void SetRole(int index, const base::string16& role);
-  void Clear();
-  int GetIndexOfCommandId(int command_id);
-  int GetItemCount() const;
-  int GetCommandIdAt(int index) const;
-  base::string16 GetLabelAt(int index) const;
-  base::string16 GetSublabelAt(int index) const;
-  bool IsItemCheckedAt(int index) const;
-  bool IsEnabledAt(int index) const;
-  bool IsVisibleAt(int index) const;
-
-  // Stored delegate methods.
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_checked_;
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_enabled_;
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_visible_;
-  base::Callback<v8::Local<v8::Value>(v8::Local<v8::Value>, int, bool)>
-      get_accelerator_;
-  base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>, int)>
-      execute_command_;
-  base::Callback<void(v8::Local<v8::Value>)> menu_will_show_;
-
-  DISALLOW_COPY_AND_ASSIGN(Menu);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-template <>
-struct Converter<atom::AtomMenuModel*> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::AtomMenuModel** out) {
-    // null would be tranfered to NULL.
-    if (val->IsNull()) {
-      *out = nullptr;
-      return true;
-    }
-
-    atom::api::Menu* menu;
-    if (!Converter<atom::api::Menu*>::FromV8(isolate, val, &menu))
-      return false;
-    *out = menu->model();
-    return true;
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_H_
removed in remote
  base   100644 85227fa2a9d9fe74c2b8f0cc0255e95fbbc47bf8 atom/browser/api/atom_api_menu_mac.h
  our    100644 6ba895676c54d6f05f819ddd084a1d2400e054ea atom/browser/api/atom_api_menu_mac.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
-
-#include "atom/browser/api/atom_api_menu.h"
-
-#include <map>
-#include <string>
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-using base::scoped_nsobject;
-
-namespace atom {
-
-namespace api {
-
-class MenuMac : public Menu {
- protected:
-  MenuMac(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~MenuMac() override;
-
-  void PopupAt(TopLevelWindow* window,
-               int x,
-               int y,
-               int positioning_item,
-               const base::Closure& callback) override;
-  void PopupOnUI(const base::WeakPtr<NativeWindow>& native_window,
-                 int32_t window_id,
-                 int x,
-                 int y,
-                 int positioning_item,
-                 base::Closure callback);
-  void ClosePopupAt(int32_t window_id) override;
-
- private:
-  friend class Menu;
-
-  void OnClosed(int32_t window_id, base::Closure callback);
-
-  scoped_nsobject<AtomMenuController> menu_controller_;
-
-  // window ID -> open context menu
-  std::map<int32_t, scoped_nsobject<AtomMenuController>> popup_controllers_;
-
-  base::WeakPtrFactory<MenuMac> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuMac);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
removed in remote
  base   100644 71c677b0476e642eeb98122304318fd0e553d83b atom/browser/api/atom_api_menu_mac.mm
  our    100644 2b63b8a6cefe6265d96399dc6b70ab3ffdc352c3 atom/browser/api/atom_api_menu_mac.mm
@@ -1,171 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/api/atom_api_menu_mac.h"
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/mac/scoped_sending_event.h"
-#include "base/message_loop/message_loop.h"
-#include "base/strings/sys_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/web_contents.h"
-
-#include "atom/common/node_includes.h"
-
-using content::BrowserThread;
-
-namespace {
-
-static scoped_nsobject<NSMenu> applicationMenu_;
-
-}  // namespace
-
-namespace atom {
-
-namespace api {
-
-MenuMac::MenuMac(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : Menu(isolate, wrapper), weak_factory_(this) {}
-
-MenuMac::~MenuMac() = default;
-
-void MenuMac::PopupAt(TopLevelWindow* window,
-                      int x,
-                      int y,
-                      int positioning_item,
-                      const base::Closure& callback) {
-  NativeWindow* native_window = window->window();
-  if (!native_window)
-    return;
-
-  auto popup = base::Bind(&MenuMac::PopupOnUI, weak_factory_.GetWeakPtr(),
-                          native_window->GetWeakPtr(), window->weak_map_id(), x,
-                          y, positioning_item, callback);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, popup);
-}
-
-void MenuMac::PopupOnUI(const base::WeakPtr<NativeWindow>& native_window,
-                        int32_t window_id,
-                        int x,
-                        int y,
-                        int positioning_item,
-                        base::Closure callback) {
-  if (!native_window)
-    return;
-  NSWindow* nswindow = native_window->GetNativeWindow();
-
-  auto close_callback = base::Bind(
-      &MenuMac::OnClosed, weak_factory_.GetWeakPtr(), window_id, callback);
-  popup_controllers_[window_id] = base::scoped_nsobject<AtomMenuController>([
-      [AtomMenuController alloc] initWithModel:model()
-                         useDefaultAccelerator:NO]);
-  NSMenu* menu = [popup_controllers_[window_id] menu];
-  NSView* view = [nswindow contentView];
-
-  // Which menu item to show.
-  NSMenuItem* item = nil;
-  if (positioning_item < [menu numberOfItems] && positioning_item >= 0)
-    item = [menu itemAtIndex:positioning_item];
-
-  // (-1, -1) means showing on mouse location.
-  NSPoint position;
-  if (x == -1 || y == -1) {
-    position = [view convertPoint:[nswindow mouseLocationOutsideOfEventStream]
-                         fromView:nil];
-  } else {
-    position = NSMakePoint(x, [view frame].size.height - y);
-  }
-
-  // If no preferred item is specified, try to show all of the menu items.
-  if (!positioning_item) {
-    CGFloat windowBottom = CGRectGetMinY([view window].frame);
-    CGFloat lowestMenuPoint = windowBottom + position.y - [menu size].height;
-    CGFloat screenBottom = CGRectGetMinY([view window].screen.frame);
-    CGFloat distanceFromBottom = lowestMenuPoint - screenBottom;
-    if (distanceFromBottom < 0)
-      position.y = position.y - distanceFromBottom + 4;
-  }
-
-  // Place the menu left of cursor if it is overflowing off right of screen.
-  CGFloat windowLeft = CGRectGetMinX([view window].frame);
-  CGFloat rightmostMenuPoint = windowLeft + position.x + [menu size].width;
-  CGFloat screenRight = CGRectGetMaxX([view window].screen.frame);
-  if (rightmostMenuPoint > screenRight)
-    position.x = position.x - [menu size].width;
-
-  [popup_controllers_[window_id] setCloseCallback:close_callback];
-  // Make sure events can be pumped while the menu is up.
-  base::MessageLoop::ScopedNestableTaskAllower allow(
-      base::MessageLoop::current());
-
-  // One of the events that could be pumped is |window.close()|.
-  // User-initiated event-tracking loops protect against this by
-  // setting flags in -[CrApplication sendEvent:], but since
-  // web-content menus are initiated by IPC message the setup has to
-  // be done manually.
-  base::mac::ScopedSendingEvent sendingEventScoper;
-
-  // Don't emit unresponsive event when showing menu.
-  atom::UnresponsiveSuppressor suppressor;
-  [menu popUpMenuPositioningItem:item atLocation:position inView:view];
-}
-
-void MenuMac::ClosePopupAt(int32_t window_id) {
-  auto controller = popup_controllers_.find(window_id);
-  if (controller != popup_controllers_.end()) {
-    // Close the controller for the window.
-    [controller->second cancel];
-  } else if (window_id == -1) {
-    // Or just close all opened controllers.
-    for (auto it = popup_controllers_.begin();
-         it != popup_controllers_.end();) {
-      // The iterator is invalidated after the call.
-      [(it++)->second cancel];
-    }
-  }
-}
-
-void MenuMac::OnClosed(int32_t window_id, base::Closure callback) {
-  popup_controllers_.erase(window_id);
-  callback.Run();
-}
-
-// static
-void Menu::SetApplicationMenu(Menu* base_menu) {
-  MenuMac* menu = static_cast<MenuMac*>(base_menu);
-  base::scoped_nsobject<AtomMenuController> menu_controller([
-      [AtomMenuController alloc] initWithModel:menu->model_.get()
-                         useDefaultAccelerator:YES]);
-
-  NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];
-  [currentRunLoop cancelPerformSelector:@selector(setMainMenu:)
-                                 target:NSApp
-                               argument:applicationMenu_];
-  applicationMenu_.reset([[menu_controller menu] retain]);
-  [[NSRunLoop currentRunLoop]
-      performSelector:@selector(setMainMenu:)
-               target:NSApp
-             argument:applicationMenu_
-                order:0
-                modes:[NSArray arrayWithObject:NSDefaultRunLoopMode]];
-
-  // Ensure the menu_controller_ is destroyed after main menu is set.
-  menu_controller.swap(menu->menu_controller_);
-}
-
-// static
-void Menu::SendActionToFirstResponder(const std::string& action) {
-  SEL selector = NSSelectorFromString(base::SysUTF8ToNSString(action));
-  [NSApp sendAction:selector to:nil from:[NSApp mainMenu]];
-}
-
-// static
-mate::WrappableBase* Menu::New(mate::Arguments* args) {
-  return new MenuMac(args->isolate(), args->GetThis());
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 4a3a97dd906e6f2fb1ad27df2cdc7d79d53e2e46 atom/browser/api/atom_api_menu_views.cc
  our    100644 3da7dc2842fa4561e037aa67f290d0cc6ca71014 atom/browser/api/atom_api_menu_views.cc
@@ -1,82 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_menu_views.h"
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "ui/display/screen.h"
-
-using views::MenuRunner;
-
-namespace atom {
-
-namespace api {
-
-MenuViews::MenuViews(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : Menu(isolate, wrapper), weak_factory_(this) {}
-
-MenuViews::~MenuViews() = default;
-
-void MenuViews::PopupAt(TopLevelWindow* window,
-                        int x,
-                        int y,
-                        int positioning_item,
-                        const base::Closure& callback) {
-  auto* native_window = static_cast<NativeWindowViews*>(window->window());
-  if (!native_window)
-    return;
-
-  // (-1, -1) means showing on mouse location.
-  gfx::Point location;
-  if (x == -1 || y == -1) {
-    location = display::Screen::GetScreen()->GetCursorScreenPoint();
-  } else {
-    gfx::Point origin = native_window->GetContentBounds().origin();
-    location = gfx::Point(origin.x() + x, origin.y() + y);
-  }
-
-  int flags = MenuRunner::CONTEXT_MENU | MenuRunner::HAS_MNEMONICS;
-
-  // Don't emit unresponsive event when showing menu.
-  atom::UnresponsiveSuppressor suppressor;
-
-  // Show the menu.
-  int32_t window_id = window->weak_map_id();
-  auto close_callback = base::Bind(
-      &MenuViews::OnClosed, weak_factory_.GetWeakPtr(), window_id, callback);
-  menu_runners_[window_id] =
-      std::make_unique<MenuRunner>(model(), flags, close_callback);
-  menu_runners_[window_id]->RunMenuAt(
-      native_window->widget(), NULL, gfx::Rect(location, gfx::Size()),
-      views::MENU_ANCHOR_TOPLEFT, ui::MENU_SOURCE_MOUSE);
-}
-
-void MenuViews::ClosePopupAt(int32_t window_id) {
-  auto runner = menu_runners_.find(window_id);
-  if (runner != menu_runners_.end()) {
-    // Close the runner for the window.
-    runner->second->Cancel();
-  } else if (window_id == -1) {
-    // Or just close all opened runners.
-    for (auto it = menu_runners_.begin(); it != menu_runners_.end();) {
-      // The iterator is invalidated after the call.
-      (it++)->second->Cancel();
-    }
-  }
-}
-
-void MenuViews::OnClosed(int32_t window_id, base::Closure callback) {
-  menu_runners_.erase(window_id);
-  callback.Run();
-}
-
-// static
-mate::WrappableBase* Menu::New(mate::Arguments* args) {
-  return new MenuViews(args->isolate(), args->GetThis());
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 e4d17c77ca6555dd9e1cd34763e53999485e432f atom/browser/api/atom_api_menu_views.h
  our    100644 0a34c19cef31db7fb0d6e05a3ff0cb8d31fc31da atom/browser/api/atom_api_menu_views.h
@@ -1,47 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
-
-#include <map>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "base/memory/weak_ptr.h"
-#include "ui/display/screen.h"
-#include "ui/views/controls/menu/menu_runner.h"
-
-namespace atom {
-
-namespace api {
-
-class MenuViews : public Menu {
- public:
-  MenuViews(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~MenuViews() override;
-
- protected:
-  void PopupAt(TopLevelWindow* window,
-               int x,
-               int y,
-               int positioning_item,
-               const base::Closure& callback) override;
-  void ClosePopupAt(int32_t window_id) override;
-
- private:
-  void OnClosed(int32_t window_id, base::Closure callback);
-
-  // window ID -> open context menu
-  std::map<int32_t, std::unique_ptr<views::MenuRunner>> menu_runners_;
-
-  base::WeakPtrFactory<MenuViews> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuViews);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
removed in remote
  base   100644 31b35e10cea8ae631406aa28e98937694b9739f7 atom/browser/api/atom_api_power_monitor.cc
  our    100644 8145a09501fc5ac24b7fe66985c1b892d5806772 atom/browser/api/atom_api_power_monitor.cc
@@ -1,150 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_power_monitor.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "base/power_monitor/power_monitor.h"
-#include "base/power_monitor/power_monitor_device_source.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-template <>
-struct Converter<ui::IdleState> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const ui::IdleState& in) {
-    switch (in) {
-      case ui::IDLE_STATE_ACTIVE:
-        return mate::StringToV8(isolate, "active");
-      case ui::IDLE_STATE_IDLE:
-        return mate::StringToV8(isolate, "idle");
-      case ui::IDLE_STATE_LOCKED:
-        return mate::StringToV8(isolate, "locked");
-      case ui::IDLE_STATE_UNKNOWN:
-      default:
-        return mate::StringToV8(isolate, "unknown");
-    }
-  }
-};
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-PowerMonitor::PowerMonitor(v8::Isolate* isolate) {
-#if defined(OS_LINUX)
-  SetShutdownHandler(
-      base::Bind(&PowerMonitor::ShouldShutdown, base::Unretained(this)));
-#elif defined(OS_MACOSX)
-  Browser::Get()->SetShutdownHandler(
-      base::Bind(&PowerMonitor::ShouldShutdown, base::Unretained(this)));
-#endif
-  base::PowerMonitor::Get()->AddObserver(this);
-  Init(isolate);
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  InitPlatformSpecificMonitors();
-#endif
-}
-
-PowerMonitor::~PowerMonitor() {
-  base::PowerMonitor::Get()->RemoveObserver(this);
-}
-
-bool PowerMonitor::ShouldShutdown() {
-  return !Emit("shutdown");
-}
-
-#if defined(OS_LINUX)
-void PowerMonitor::BlockShutdown() {
-  PowerObserverLinux::BlockShutdown();
-}
-
-void PowerMonitor::UnblockShutdown() {
-  PowerObserverLinux::UnblockShutdown();
-}
-#endif
-
-void PowerMonitor::OnPowerStateChange(bool on_battery_power) {
-  if (on_battery_power)
-    Emit("on-battery");
-  else
-    Emit("on-ac");
-}
-
-void PowerMonitor::OnSuspend() {
-  Emit("suspend");
-}
-
-void PowerMonitor::OnResume() {
-  Emit("resume");
-}
-
-void PowerMonitor::QuerySystemIdleState(v8::Isolate* isolate,
-                                        int idle_threshold,
-                                        const ui::IdleCallback& callback) {
-  if (idle_threshold > 0) {
-    ui::CalculateIdleState(idle_threshold, callback);
-  } else {
-    isolate->ThrowException(v8::Exception::TypeError(mate::StringToV8(
-        isolate, "Invalid idle threshold, must be greater than 0")));
-  }
-}
-
-void PowerMonitor::QuerySystemIdleTime(const ui::IdleTimeCallback& callback) {
-  ui::CalculateIdleTime(callback);
-}
-
-// static
-v8::Local<v8::Value> PowerMonitor::Create(v8::Isolate* isolate) {
-  if (!Browser::Get()->is_ready()) {
-    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate,
-        "Cannot require \"powerMonitor\" module before app is ready")));
-    return v8::Null(isolate);
-  }
-
-  return mate::CreateHandle(isolate, new PowerMonitor(isolate)).ToV8();
-}
-
-// static
-void PowerMonitor::BuildPrototype(v8::Isolate* isolate,
-                                  v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "PowerMonitor"));
-
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-#if defined(OS_LINUX)
-      .SetMethod("blockShutdown", &PowerMonitor::BlockShutdown)
-      .SetMethod("unblockShutdown", &PowerMonitor::UnblockShutdown)
-#endif
-      .SetMethod("querySystemIdleState", &PowerMonitor::QuerySystemIdleState)
-      .SetMethod("querySystemIdleTime", &PowerMonitor::QuerySystemIdleTime);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::PowerMonitor;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("powerMonitor", PowerMonitor::Create(isolate));
-  dict.Set("PowerMonitor",
-           PowerMonitor::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_power_monitor, Initialize)
removed in remote
  base   100644 8fb52eeec95eecb193130e3692d535f539420e81 atom/browser/api/atom_api_power_monitor.h
  our    100644 c7a6169d88b712cbcb9600c4458959ea38fb15fb atom/browser/api/atom_api_power_monitor.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
-#define ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/lib/power_observer.h"
-#include "base/compiler_specific.h"
-#include "native_mate/handle.h"
-#include "ui/base/idle/idle.h"
-
-namespace atom {
-
-namespace api {
-
-class PowerMonitor : public mate::TrackableObject<PowerMonitor>,
-                     public PowerObserver {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit PowerMonitor(v8::Isolate* isolate);
-  ~PowerMonitor() override;
-
-  // Called by native calles.
-  bool ShouldShutdown();
-
-#if defined(OS_LINUX)
-  // Private JS APIs.
-  void BlockShutdown();
-  void UnblockShutdown();
-#endif
-
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  void InitPlatformSpecificMonitors();
-#endif
-
-  // base::PowerObserver implementations:
-  void OnPowerStateChange(bool on_battery_power) override;
-  void OnSuspend() override;
-  void OnResume() override;
-
- private:
-  void QuerySystemIdleState(v8::Isolate* isolate,
-                            int idle_threshold,
-                            const ui::IdleCallback& callback);
-  void QuerySystemIdleTime(const ui::IdleTimeCallback& callback);
-
-#if defined(OS_WIN)
-  // Static callback invoked when a message comes in to our messaging window.
-  static LRESULT CALLBACK WndProcStatic(HWND hwnd,
-                                        UINT message,
-                                        WPARAM wparam,
-                                        LPARAM lparam);
-
-  LRESULT CALLBACK WndProc(HWND hwnd,
-                           UINT message,
-                           WPARAM wparam,
-                           LPARAM lparam);
-
-  // The window class of |window_|.
-  ATOM atom_;
-
-  // The handle of the module that contains the window procedure of |window_|.
-  HMODULE instance_;
-
-  // The window used for processing events.
-  HWND window_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(PowerMonitor);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
removed in remote
  base   100644 58983e6c846a8b161b4f74b271ba978846bfa2dc atom/browser/api/atom_api_power_save_blocker.cc
  our    100644 0b06a9f583782b55296498159059e35b8f27f186 atom/browser/api/atom_api_power_save_blocker.cc
@@ -1,137 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_power_save_blocker.h"
-
-#include <string>
-
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<device::mojom::WakeLockType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     device::mojom::WakeLockType* out) {
-    std::string type;
-    if (!ConvertFromV8(isolate, val, &type))
-      return false;
-    if (type == "prevent-app-suspension")
-      *out = device::mojom::WakeLockType::kPreventAppSuspension;
-    else if (type == "prevent-display-sleep")
-      *out = device::mojom::WakeLockType::kPreventDisplaySleep;
-    else
-      return false;
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-PowerSaveBlocker::PowerSaveBlocker(v8::Isolate* isolate)
-    : current_blocker_type_(
-          device::mojom::WakeLockType::kPreventAppSuspension) {
-  Init(isolate);
-}
-
-PowerSaveBlocker::~PowerSaveBlocker() {}
-
-void PowerSaveBlocker::UpdatePowerSaveBlocker() {
-  if (power_save_blocker_types_.empty()) {
-    power_save_blocker_.reset();
-    return;
-  }
-
-  // |WakeLockType::kPreventAppSuspension| keeps system active, but allows
-  // screen to be turned off.
-  // |WakeLockType::kPreventDisplaySleep| keeps system and screen active, has a
-  // higher precedence level than |WakeLockType::kPreventAppSuspension|.
-  //
-  // Only the highest-precedence blocker type takes effect.
-  device::mojom::WakeLockType new_blocker_type =
-      device::mojom::WakeLockType::kPreventAppSuspension;
-  for (const auto& element : power_save_blocker_types_) {
-    if (element.second ==
-        device::mojom::WakeLockType::kPreventDisplaySleep) {
-      new_blocker_type =
-          device::mojom::WakeLockType::kPreventDisplaySleep;
-      break;
-    }
-  }
-
-  if (!power_save_blocker_ || new_blocker_type != current_blocker_type_) {
-    auto new_blocker = std::make_unique<device::PowerSaveBlocker>(
-        new_blocker_type, device::mojom::WakeLockReason::kOther,
-        ATOM_PRODUCT_NAME, base::ThreadTaskRunnerHandle::Get(),
-        // This task runner may be used by some device service
-        // implementation bits to interface with dbus client code, which in
-        // turn imposes some subtle thread affinity on the clients. We
-        // therefore require a single-thread runner.
-        base::CreateSingleThreadTaskRunnerWithTraits(
-            {base::MayBlock(), base::TaskPriority::BACKGROUND}));
-    power_save_blocker_.swap(new_blocker);
-    current_blocker_type_ = new_blocker_type;
-  }
-}
-
-int PowerSaveBlocker::Start(device::mojom::WakeLockType type) {
-  static int count = 0;
-  power_save_blocker_types_[count] = type;
-  UpdatePowerSaveBlocker();
-  return count++;
-}
-
-bool PowerSaveBlocker::Stop(int id) {
-  bool success = power_save_blocker_types_.erase(id) > 0;
-  UpdatePowerSaveBlocker();
-  return success;
-}
-
-bool PowerSaveBlocker::IsStarted(int id) {
-  return power_save_blocker_types_.find(id) != power_save_blocker_types_.end();
-}
-
-// static
-mate::Handle<PowerSaveBlocker> PowerSaveBlocker::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new PowerSaveBlocker(isolate));
-}
-
-// static
-void PowerSaveBlocker::BuildPrototype(
-    v8::Isolate* isolate,
-    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "PowerSaveBlocker"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("start", &PowerSaveBlocker::Start)
-      .SetMethod("stop", &PowerSaveBlocker::Stop)
-      .SetMethod("isStarted", &PowerSaveBlocker::IsStarted);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("powerSaveBlocker", atom::api::PowerSaveBlocker::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_power_save_blocker, Initialize);
removed in remote
  base   100644 a698d746ceb0a64ed4a29aa87f512cc64f5a6b86 atom/browser/api/atom_api_power_save_blocker.h
  our    100644 d56222db95dedca78f3274bf509c6384c3ff833e atom/browser/api/atom_api_power_save_blocker.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
-#define ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
-
-#include <map>
-#include <memory>
-
-#include "atom/browser/api/trackable_object.h"
-#include "native_mate/handle.h"
-#include "services/device/wake_lock/power_save_blocker/power_save_blocker.h"
-
-namespace mate {
-class Dictionary;
-}
-
-namespace atom {
-
-namespace api {
-
-class PowerSaveBlocker : public mate::TrackableObject<PowerSaveBlocker> {
- public:
-  static mate::Handle<PowerSaveBlocker> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit PowerSaveBlocker(v8::Isolate* isolate);
-  ~PowerSaveBlocker() override;
-
- private:
-  void UpdatePowerSaveBlocker();
-  int Start(device::mojom::WakeLockType type);
-  bool Stop(int id);
-  bool IsStarted(int id);
-
-  std::unique_ptr<device::PowerSaveBlocker> power_save_blocker_;
-
-  // Current blocker type used by |power_save_blocker_|
-  device::mojom::WakeLockType current_blocker_type_;
-
-  // Map from id to the corresponding blocker type for each request.
-  using WakeLockTypeMap = std::map<int, device::mojom::WakeLockType>;
-  WakeLockTypeMap power_save_blocker_types_;
-
-  DISALLOW_COPY_AND_ASSIGN(PowerSaveBlocker);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
removed in remote
  base   100644 09da9c71cadbc204787cf20a4fec584d45696476 atom/browser/api/atom_api_protocol.cc
  our    100644 5e1f991ad8dcd611467b691fff48656e3cc299ff atom/browser/api/atom_api_protocol.cc
@@ -1,248 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_protocol.h"
-
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/net/url_request_async_asar_job.h"
-#include "atom/browser/net/url_request_buffer_job.h"
-#include "atom/browser/net/url_request_fetch_job.h"
-#include "atom/browser/net/url_request_stream_job.h"
-#include "atom/browser/net/url_request_string_job.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/strings/string_util.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "native_mate/dictionary.h"
-#include "url/url_util.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// List of registered custom standard schemes.
-std::vector<std::string> g_standard_schemes;
-
-}  // namespace
-
-std::vector<std::string> GetStandardSchemes() {
-  return g_standard_schemes;
-}
-
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args) {
-  g_standard_schemes = schemes;
-
-  mate::Dictionary opts;
-  bool secure = false;
-  args->GetNext(&opts) && opts.Get("secure", &secure);
-
-  // Dynamically register the schemes.
-  auto* policy = content::ChildProcessSecurityPolicy::GetInstance();
-  for (const std::string& scheme : schemes) {
-    url::AddStandardScheme(scheme.c_str(), url::SCHEME_WITHOUT_PORT);
-    if (secure) {
-      url::AddSecureScheme(scheme.c_str());
-    }
-    policy->RegisterWebSafeScheme(scheme);
-  }
-
-  // Add the schemes to command line switches, so child processes can also
-  // register them.
-  base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
-      atom::switches::kStandardSchemes, base::JoinString(schemes, ","));
-  if (secure) {
-    base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
-        atom::switches::kSecureSchemes, base::JoinString(schemes, ","));
-  }
-}
-
-Protocol::Protocol(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : browser_context_(browser_context), weak_factory_(this) {
-  Init(isolate);
-}
-
-Protocol::~Protocol() {}
-
-void Protocol::RegisterServiceWorkerSchemes(
-    const std::vector<std::string>& schemes) {
-  atom::AtomBrowserClient::SetCustomServiceWorkerSchemes(schemes);
-}
-
-void Protocol::UnregisterProtocol(const std::string& scheme,
-                                  mate::Arguments* args) {
-  CompletionCallback callback;
-  args->GetNext(&callback);
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&Protocol::UnregisterProtocolInIO,
-                     base::RetainedRef(getter), scheme),
-      base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-}
-
-// static
-Protocol::ProtocolError Protocol::UnregisterProtocolInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-      request_context_getter->job_factory());
-  if (!job_factory->HasProtocolHandler(scheme))
-    return PROTOCOL_NOT_REGISTERED;
-  job_factory->SetProtocolHandler(scheme, nullptr);
-  return PROTOCOL_OK;
-}
-
-void Protocol::IsProtocolHandled(const std::string& scheme,
-                                 const BooleanCallback& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::Bind(&Protocol::IsProtocolHandledInIO, base::RetainedRef(getter),
-                 scheme),
-      callback);
-}
-
-// static
-bool Protocol::IsProtocolHandledInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  return request_context_getter->job_factory()->IsHandledProtocol(scheme);
-}
-
-void Protocol::UninterceptProtocol(const std::string& scheme,
-                                   mate::Arguments* args) {
-  CompletionCallback callback;
-  args->GetNext(&callback);
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&Protocol::UninterceptProtocolInIO,
-                     base::RetainedRef(getter), scheme),
-      base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-}
-
-// static
-Protocol::ProtocolError Protocol::UninterceptProtocolInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  return static_cast<AtomURLRequestJobFactory*>(
-             request_context_getter->job_factory())
-                 ->UninterceptProtocol(scheme)
-             ? PROTOCOL_OK
-             : PROTOCOL_NOT_INTERCEPTED;
-}
-
-void Protocol::OnIOCompleted(const CompletionCallback& callback,
-                             ProtocolError error) {
-  // The completion callback is optional.
-  if (callback.is_null())
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  if (error == PROTOCOL_OK) {
-    callback.Run(v8::Null(isolate()));
-  } else {
-    std::string str = ErrorCodeToString(error);
-    callback.Run(v8::Exception::Error(mate::StringToV8(isolate(), str)));
-  }
-}
-
-std::string Protocol::ErrorCodeToString(ProtocolError error) {
-  switch (error) {
-    case PROTOCOL_FAIL:
-      return "Failed to manipulate protocol factory";
-    case PROTOCOL_REGISTERED:
-      return "The scheme has been registered";
-    case PROTOCOL_NOT_REGISTERED:
-      return "The scheme has not been registered";
-    case PROTOCOL_INTERCEPTED:
-      return "The scheme has been intercepted";
-    case PROTOCOL_NOT_INTERCEPTED:
-      return "The scheme has not been intercepted";
-    default:
-      return "Unexpected error";
-  }
-}
-
-// static
-mate::Handle<Protocol> Protocol::Create(v8::Isolate* isolate,
-                                        AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new Protocol(isolate, browser_context));
-}
-
-// static
-void Protocol::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Protocol"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("registerServiceWorkerSchemes",
-                 &Protocol::RegisterServiceWorkerSchemes)
-      .SetMethod("registerStringProtocol",
-                 &Protocol::RegisterProtocol<URLRequestStringJob>)
-      .SetMethod("registerBufferProtocol",
-                 &Protocol::RegisterProtocol<URLRequestBufferJob>)
-      .SetMethod("registerFileProtocol",
-                 &Protocol::RegisterProtocol<URLRequestAsyncAsarJob>)
-      .SetMethod("registerHttpProtocol",
-                 &Protocol::RegisterProtocol<URLRequestFetchJob>)
-      .SetMethod("registerStreamProtocol",
-                 &Protocol::RegisterProtocol<URLRequestStreamJob>)
-      .SetMethod("unregisterProtocol", &Protocol::UnregisterProtocol)
-      .SetMethod("isProtocolHandled", &Protocol::IsProtocolHandled)
-      .SetMethod("interceptStringProtocol",
-                 &Protocol::InterceptProtocol<URLRequestStringJob>)
-      .SetMethod("interceptBufferProtocol",
-                 &Protocol::InterceptProtocol<URLRequestBufferJob>)
-      .SetMethod("interceptFileProtocol",
-                 &Protocol::InterceptProtocol<URLRequestAsyncAsarJob>)
-      .SetMethod("interceptHttpProtocol",
-                 &Protocol::InterceptProtocol<URLRequestFetchJob>)
-      .SetMethod("interceptStreamProtocol",
-                 &Protocol::InterceptProtocol<URLRequestStreamJob>)
-      .SetMethod("uninterceptProtocol", &Protocol::UninterceptProtocol);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args) {
-  if (atom::Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "protocol.registerStandardSchemes should be called before "
-        "app is ready");
-    return;
-  }
-
-  atom::api::RegisterStandardSchemes(schemes, args);
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.SetMethod("registerStandardSchemes", &RegisterStandardSchemes);
-  dict.SetMethod("getStandardSchemes", &atom::api::GetStandardSchemes);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_protocol, Initialize)
removed in remote
  base   100644 107fbf1ce7125ab3426edc893acb358ec8edfeee atom/browser/api/atom_api_protocol.h
  our    100644 deaf680c996ce0dd74af45e7c7c95f711884bb07 atom/browser/api/atom_api_protocol.h
@@ -1,199 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
-#define ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/net/atom_url_request_job_factory.h"
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "net/url_request/url_request_context.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace atom {
-
-namespace api {
-
-std::vector<std::string> GetStandardSchemes();
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args);
-
-class Protocol : public mate::TrackableObject<Protocol> {
- public:
-  using Handler =
-      base::Callback<void(const base::DictionaryValue&, v8::Local<v8::Value>)>;
-  using CompletionCallback = base::Callback<void(v8::Local<v8::Value>)>;
-  using BooleanCallback = base::Callback<void(bool)>;
-
-  static mate::Handle<Protocol> Create(v8::Isolate* isolate,
-                                       AtomBrowserContext* browser_context);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Protocol(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Protocol() override;
-
- private:
-  // Possible errors.
-  enum ProtocolError {
-    PROTOCOL_OK,    // no error
-    PROTOCOL_FAIL,  // operation failed, should never occur
-    PROTOCOL_REGISTERED,
-    PROTOCOL_NOT_REGISTERED,
-    PROTOCOL_INTERCEPTED,
-    PROTOCOL_NOT_INTERCEPTED,
-  };
-
-  // The protocol handler that will create a protocol handler for certain
-  // request job.
-  template <typename RequestJob>
-  class CustomProtocolHandler
-      : public net::URLRequestJobFactory::ProtocolHandler {
-   public:
-    CustomProtocolHandler(v8::Isolate* isolate,
-                          net::URLRequestContextGetter* request_context,
-                          const Handler& handler)
-        : isolate_(isolate),
-          request_context_(request_context),
-          handler_(handler) {}
-    ~CustomProtocolHandler() override {}
-
-    net::URLRequestJob* MaybeCreateJob(
-        net::URLRequest* request,
-        net::NetworkDelegate* network_delegate) const override {
-      RequestJob* request_job = new RequestJob(request, network_delegate);
-      request_job->SetHandlerInfo(isolate_, request_context_, handler_);
-      return request_job;
-    }
-
-   private:
-    v8::Isolate* isolate_;
-    net::URLRequestContextGetter* request_context_;
-    Protocol::Handler handler_;
-
-    DISALLOW_COPY_AND_ASSIGN(CustomProtocolHandler);
-  };
-
-  // Register schemes that can handle service worker.
-  void RegisterServiceWorkerSchemes(const std::vector<std::string>& schemes);
-
-  // Register the protocol with certain request job.
-  template <typename RequestJob>
-  void RegisterProtocol(const std::string& scheme,
-                        const Handler& handler,
-                        mate::Arguments* args) {
-    CompletionCallback callback;
-    args->GetNext(&callback);
-    auto* getter = browser_context_->GetRequestContext();
-    content::BrowserThread::PostTaskAndReplyWithResult(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&Protocol::RegisterProtocolInIO<RequestJob>,
-                       base::RetainedRef(getter), isolate(), scheme, handler),
-        base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-  }
-  template <typename RequestJob>
-  static ProtocolError RegisterProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      v8::Isolate* isolate,
-      const std::string& scheme,
-      const Handler& handler) {
-    auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-        request_context_getter->job_factory());
-    if (job_factory->IsHandledProtocol(scheme))
-      return PROTOCOL_REGISTERED;
-    auto protocol_handler = std::make_unique<CustomProtocolHandler<RequestJob>>(
-        isolate, request_context_getter.get(), handler);
-    if (job_factory->SetProtocolHandler(scheme, std::move(protocol_handler)))
-      return PROTOCOL_OK;
-    else
-      return PROTOCOL_FAIL;
-  }
-
-  // Unregister the protocol handler that handles |scheme|.
-  void UnregisterProtocol(const std::string& scheme, mate::Arguments* args);
-  static ProtocolError UnregisterProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Whether the protocol has handler registered.
-  void IsProtocolHandled(const std::string& scheme,
-                         const BooleanCallback& callback);
-  static bool IsProtocolHandledInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Replace the protocol handler with a new one.
-  template <typename RequestJob>
-  void InterceptProtocol(const std::string& scheme,
-                         const Handler& handler,
-                         mate::Arguments* args) {
-    CompletionCallback callback;
-    args->GetNext(&callback);
-    auto* getter = browser_context_->GetRequestContext();
-    content::BrowserThread::PostTaskAndReplyWithResult(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&Protocol::InterceptProtocolInIO<RequestJob>,
-                       base::RetainedRef(getter), isolate(), scheme, handler),
-        base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-  }
-  template <typename RequestJob>
-  static ProtocolError InterceptProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      v8::Isolate* isolate,
-      const std::string& scheme,
-      const Handler& handler) {
-    auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-        request_context_getter->job_factory());
-    if (!job_factory->IsHandledProtocol(scheme))
-      return PROTOCOL_NOT_REGISTERED;
-    // It is possible a protocol is handled but can not be intercepted.
-    if (!job_factory->HasProtocolHandler(scheme))
-      return PROTOCOL_FAIL;
-    auto protocol_handler = std::make_unique<CustomProtocolHandler<RequestJob>>(
-        isolate, request_context_getter.get(), handler);
-    if (!job_factory->InterceptProtocol(scheme, std::move(protocol_handler)))
-      return PROTOCOL_INTERCEPTED;
-    return PROTOCOL_OK;
-  }
-
-  // Restore the |scheme| to its original protocol handler.
-  void UninterceptProtocol(const std::string& scheme, mate::Arguments* args);
-  static ProtocolError UninterceptProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Convert error code to JS exception and call the callback.
-  void OnIOCompleted(const CompletionCallback& callback, ProtocolError error);
-
-  // Convert error code to string.
-  std::string ErrorCodeToString(ProtocolError error);
-
-  base::WeakPtr<Protocol> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }
-
-  scoped_refptr<AtomBrowserContext> browser_context_;
-  base::WeakPtrFactory<Protocol> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(Protocol);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
removed in remote
  base   100644 407a71f0cc4134a0eeaabfd69e3240e0cee83367 atom/browser/api/atom_api_screen.cc
  our    100644 65a11eed0cce32cc08b188155a97f6a51f2c03f1 atom/browser/api/atom_api_screen.cc
@@ -1,172 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_screen.h"
-
-#include <algorithm>
-#include <string>
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "base/bind.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/gfx/geometry/point.h"
-
-#if defined(OS_WIN)
-#include "ui/display/win/screen_win.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// Find an item in container according to its ID.
-template <class T>
-typename T::iterator FindById(T* container, int id) {
-  auto predicate = [id](const typename T::value_type& item) -> bool {
-    return item.id() == id;
-  };
-  return std::find_if(container->begin(), container->end(), predicate);
-}
-
-// Convert the changed_metrics bitmask to string array.
-std::vector<std::string> MetricsToArray(uint32_t metrics) {
-  std::vector<std::string> array;
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_BOUNDS)
-    array.push_back("bounds");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_WORK_AREA)
-    array.push_back("workArea");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR)
-    array.push_back("scaleFactor");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_ROTATION)
-    array.push_back("rotation");
-  return array;
-}
-
-}  // namespace
-
-Screen::Screen(v8::Isolate* isolate, display::Screen* screen)
-    : screen_(screen) {
-  screen_->AddObserver(this);
-  Init(isolate);
-}
-
-Screen::~Screen() {
-  screen_->RemoveObserver(this);
-}
-
-gfx::Point Screen::GetCursorScreenPoint() {
-  return screen_->GetCursorScreenPoint();
-}
-
-display::Display Screen::GetPrimaryDisplay() {
-  return screen_->GetPrimaryDisplay();
-}
-
-std::vector<display::Display> Screen::GetAllDisplays() {
-  return screen_->GetAllDisplays();
-}
-
-display::Display Screen::GetDisplayNearestPoint(const gfx::Point& point) {
-  return screen_->GetDisplayNearestPoint(point);
-}
-
-display::Display Screen::GetDisplayMatching(const gfx::Rect& match_rect) {
-  return screen_->GetDisplayMatching(match_rect);
-}
-
-#if defined(OS_WIN)
-
-static gfx::Rect ScreenToDIPRect(atom::NativeWindow* window,
-                                 const gfx::Rect& rect) {
-  HWND hwnd = window ? window->GetAcceleratedWidget() : nullptr;
-  return display::win::ScreenWin::ScreenToDIPRect(hwnd, rect);
-}
-
-static gfx::Rect DIPToScreenRect(atom::NativeWindow* window,
-                                 const gfx::Rect& rect) {
-  HWND hwnd = window ? window->GetAcceleratedWidget() : nullptr;
-  return display::win::ScreenWin::DIPToScreenRect(hwnd, rect);
-}
-
-#endif
-
-void Screen::OnDisplayAdded(const display::Display& new_display) {
-  Emit("display-added", new_display);
-}
-
-void Screen::OnDisplayRemoved(const display::Display& old_display) {
-  Emit("display-removed", old_display);
-}
-
-void Screen::OnDisplayMetricsChanged(const display::Display& display,
-                                     uint32_t changed_metrics) {
-  Emit("display-metrics-changed", display, MetricsToArray(changed_metrics));
-}
-
-// static
-v8::Local<v8::Value> Screen::Create(v8::Isolate* isolate) {
-  if (!Browser::Get()->is_ready()) {
-    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate, "Cannot require \"screen\" module before app is ready")));
-    return v8::Null(isolate);
-  }
-
-  display::Screen* screen = display::Screen::GetScreen();
-  if (!screen) {
-    isolate->ThrowException(v8::Exception::Error(
-        mate::StringToV8(isolate, "Failed to get screen information")));
-    return v8::Null(isolate);
-  }
-
-  return mate::CreateHandle(isolate, new Screen(isolate, screen)).ToV8();
-}
-
-// static
-void Screen::BuildPrototype(v8::Isolate* isolate,
-                            v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Screen"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("getCursorScreenPoint", &Screen::GetCursorScreenPoint)
-      .SetMethod("getPrimaryDisplay", &Screen::GetPrimaryDisplay)
-      .SetMethod("getAllDisplays", &Screen::GetAllDisplays)
-      .SetMethod("getDisplayNearestPoint", &Screen::GetDisplayNearestPoint)
-#if defined(OS_WIN)
-      .SetMethod("screenToDipPoint", &display::win::ScreenWin::ScreenToDIPPoint)
-      .SetMethod("dipToScreenPoint", &display::win::ScreenWin::DIPToScreenPoint)
-      .SetMethod("screenToDipRect", &ScreenToDIPRect)
-      .SetMethod("dipToScreenRect", &DIPToScreenRect)
-#endif
-      .SetMethod("getDisplayMatching", &Screen::GetDisplayMatching);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Screen;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("screen", Screen::Create(isolate));
-  dict.Set("Screen", Screen::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_screen, Initialize)
removed in remote
  base   100644 f724130fa7fca10cd2d088d05eadd15d0e9016c7 atom/browser/api/atom_api_screen.h
  our    100644 33c322abf4dc072f187004e28dd5f5a2583b45ce atom/browser/api/atom_api_screen.h
@@ -1,59 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_SCREEN_H_
-#define ATOM_BROWSER_API_ATOM_API_SCREEN_H_
-
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "native_mate/handle.h"
-#include "ui/display/display_observer.h"
-#include "ui/display/screen.h"
-
-namespace gfx {
-class Point;
-class Rect;
-class Screen;
-}  // namespace gfx
-
-namespace atom {
-
-namespace api {
-
-class Screen : public mate::EventEmitter<Screen>,
-               public display::DisplayObserver {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Screen(v8::Isolate* isolate, display::Screen* screen);
-  ~Screen() override;
-
-  gfx::Point GetCursorScreenPoint();
-  display::Display GetPrimaryDisplay();
-  std::vector<display::Display> GetAllDisplays();
-  display::Display GetDisplayNearestPoint(const gfx::Point& point);
-  display::Display GetDisplayMatching(const gfx::Rect& match_rect);
-
-  // display::DisplayObserver:
-  void OnDisplayAdded(const display::Display& new_display) override;
-  void OnDisplayRemoved(const display::Display& old_display) override;
-  void OnDisplayMetricsChanged(const display::Display& display,
-                               uint32_t changed_metrics) override;
-
- private:
-  display::Screen* screen_;
-
-  DISALLOW_COPY_AND_ASSIGN(Screen);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_SCREEN_H_
removed in remote
  base   100644 0f104c760724cb83d421f9ed0225eaa8568898fe atom/browser/api/atom_api_session.cc
  our    100644 658f913bb60b66ae1bf3aae97d7d9158e56f7ee0 atom/browser/api/atom_api_session.cc
@@ -1,865 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_session.h"
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_cookies.h"
-#include "atom/browser/api/atom_api_download_item.h"
-#include "atom/browser/api/atom_api_protocol.h"
-#include "atom/browser/api/atom_api_web_request.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/net/atom_cert_verifier.h"
-#include "atom/browser/session_preferences.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/files/file_path.h"
-#include "base/guid.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "brightray/browser/media/media_device_id_salt.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/common/pref_names.h"
-#include "components/download/public/common/download_danger_type.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_item_utils.h"
-#include "content/public/browser/download_manager_delegate.h"
-#include "content/public/browser/storage_partition.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/base/load_flags.h"
-#include "net/disk_cache/disk_cache.h"
-#include "net/dns/host_cache.h"
-#include "net/http/http_auth_handler_factory.h"
-#include "net/http/http_auth_preferences.h"
-#include "net/proxy_resolution/proxy_config_service_fixed.h"
-#include "net/proxy_resolution/proxy_service.h"
-#include "net/url_request/static_http_user_agent_settings.h"
-#include "net/url_request/url_request_context.h"
-#include "net/url_request/url_request_context_getter.h"
-#include "services/network/throttling/network_conditions.h"
-#include "services/network/throttling/throttling_controller.h"
-#include "ui/base/l10n/l10n_util.h"
-
-using atom::api::Cookies;
-using content::BrowserThread;
-using content::StoragePartition;
-
-namespace {
-
-struct ClearStorageDataOptions {
-  GURL origin;
-  uint32_t storage_types = StoragePartition::REMOVE_DATA_MASK_ALL;
-  uint32_t quota_types = StoragePartition::QUOTA_MANAGED_STORAGE_MASK_ALL;
-};
-
-struct ClearAuthCacheOptions {
-  std::string type;
-  GURL origin;
-  std::string realm;
-  base::string16 username;
-  base::string16 password;
-  net::HttpAuth::Scheme auth_scheme;
-};
-
-uint32_t GetStorageMask(const std::vector<std::string>& storage_types) {
-  uint32_t storage_mask = 0;
-  for (const auto& it : storage_types) {
-    auto type = base::ToLowerASCII(it);
-    if (type == "appcache")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_APPCACHE;
-    else if (type == "cookies")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_COOKIES;
-    else if (type == "filesystem")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;
-    else if (type == "indexdb")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;
-    else if (type == "localstorage")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;
-    else if (type == "shadercache")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;
-    else if (type == "websql")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_WEBSQL;
-    else if (type == "serviceworkers")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;
-    else if (type == "cachestorage")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_CACHE_STORAGE;
-  }
-  return storage_mask;
-}
-
-uint32_t GetQuotaMask(const std::vector<std::string>& quota_types) {
-  uint32_t quota_mask = 0;
-  for (const auto& it : quota_types) {
-    auto type = base::ToLowerASCII(it);
-    if (type == "temporary")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY;
-    else if (type == "persistent")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;
-    else if (type == "syncable")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_SYNCABLE;
-  }
-  return quota_mask;
-}
-
-net::HttpAuth::Scheme GetAuthSchemeFromString(const std::string& scheme) {
-  if (scheme == "basic")
-    return net::HttpAuth::AUTH_SCHEME_BASIC;
-  if (scheme == "digest")
-    return net::HttpAuth::AUTH_SCHEME_DIGEST;
-  if (scheme == "ntlm")
-    return net::HttpAuth::AUTH_SCHEME_NTLM;
-  if (scheme == "negotiate")
-    return net::HttpAuth::AUTH_SCHEME_NEGOTIATE;
-  return net::HttpAuth::AUTH_SCHEME_MAX;
-}
-
-void SetUserAgentInIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                      const std::string& accept_lang,
-                      const std::string& user_agent) {
-  getter->GetURLRequestContext()->set_http_user_agent_settings(
-      new net::StaticHttpUserAgentSettings(
-          net::HttpUtil::GenerateAcceptLanguageHeader(accept_lang),
-          user_agent));
-}
-
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<ClearStorageDataOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ClearStorageDataOptions* out) {
-    mate::Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    options.Get("origin", &out->origin);
-    std::vector<std::string> types;
-    if (options.Get("storages", &types))
-      out->storage_types = GetStorageMask(types);
-    if (options.Get("quotas", &types))
-      out->quota_types = GetQuotaMask(types);
-    return true;
-  }
-};
-
-template <>
-struct Converter<ClearAuthCacheOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ClearAuthCacheOptions* out) {
-    mate::Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    options.Get("type", &out->type);
-    options.Get("origin", &out->origin);
-    options.Get("realm", &out->realm);
-    options.Get("username", &out->username);
-    options.Get("password", &out->password);
-    std::string scheme;
-    if (options.Get("scheme", &scheme))
-      out->auth_scheme = GetAuthSchemeFromString(scheme);
-    return true;
-  }
-};
-
-template <>
-struct Converter<net::ProxyConfig> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     net::ProxyConfig* out) {
-    std::string proxy_rules, proxy_bypass_rules;
-    GURL pac_url;
-    mate::Dictionary options;
-    // Fallback to previous API when passed String.
-    // https://git.io/vuhjj
-    if (ConvertFromV8(isolate, val, &proxy_rules)) {
-      pac_url = GURL(proxy_rules);  // Assume it is PAC script if it is URL.
-    } else if (ConvertFromV8(isolate, val, &options)) {
-      options.Get("pacScript", &pac_url);
-      options.Get("proxyRules", &proxy_rules);
-      options.Get("proxyBypassRules", &proxy_bypass_rules);
-    } else {
-      return false;
-    }
-
-    // pacScript takes precedence over proxyRules.
-    if (!pac_url.is_empty() && pac_url.is_valid()) {
-      out->set_pac_url(pac_url);
-    } else {
-      out->proxy_rules().ParseFromString(proxy_rules);
-      out->proxy_rules().bypass_rules.ParseFromString(proxy_bypass_rules);
-    }
-    return true;
-  }
-};
-
-template <>
-struct Converter<atom::VerifyRequestParams> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::VerifyRequestParams val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("hostname", val.hostname);
-    dict.Set("certificate", val.certificate);
-    dict.Set("verificationResult", val.default_result);
-    dict.Set("errorCode", val.error_code);
-    return dict.GetHandle();
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-const char kPersistPrefix[] = "persist:";
-
-// Referenced session objects.
-std::map<uint32_t, v8::Global<v8::Object>> g_sessions;
-
-class ResolveProxyHelper {
- public:
-  ResolveProxyHelper(AtomBrowserContext* browser_context,
-                     const GURL& url,
-                     const Session::ResolveProxyCallback& callback)
-      : callback_(callback),
-        original_thread_(base::ThreadTaskRunnerHandle::Get()) {
-    scoped_refptr<net::URLRequestContextGetter> context_getter =
-        browser_context->GetRequestContext();
-    context_getter->GetNetworkTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ResolveProxyHelper::ResolveProxy,
-                                  base::Unretained(this), context_getter, url));
-  }
-
-  void OnResolveProxyCompleted(int result) {
-    std::string proxy;
-    if (result == net::OK)
-      proxy = proxy_info_.ToPacString();
-    original_thread_->PostTask(FROM_HERE, base::BindOnce(callback_, proxy));
-    delete this;
-  }
-
- private:
-  void ResolveProxy(scoped_refptr<net::URLRequestContextGetter> context_getter,
-                    const GURL& url) {
-    DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-    net::ProxyResolutionService* proxy_service =
-        context_getter->GetURLRequestContext()->proxy_resolution_service();
-    net::CompletionCallback completion_callback = base::Bind(
-        &ResolveProxyHelper::OnResolveProxyCompleted, base::Unretained(this));
-
-    // Start the request.
-    int result = proxy_service->ResolveProxy(url, "GET", &proxy_info_,
-                                             completion_callback, &pac_req_,
-                                             nullptr, net::NetLogWithSource());
-
-    // Completed synchronously.
-    if (result != net::ERR_IO_PENDING)
-      completion_callback.Run(result);
-  }
-
-  Session::ResolveProxyCallback callback_;
-  net::ProxyInfo proxy_info_;
-  net::ProxyResolutionService::Request* pac_req_;
-  scoped_refptr<base::SingleThreadTaskRunner> original_thread_;
-
-  DISALLOW_COPY_AND_ASSIGN(ResolveProxyHelper);
-};
-
-// Runs the callback in UI thread.
-void RunCallbackInUI(const base::Callback<void()>& callback) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
-}
-template <typename... T>
-void RunCallbackInUI(const base::Callback<void(T...)>& callback, T... result) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, result...));
-}
-
-// Callback of HttpCache::GetBackend.
-void OnGetBackend(disk_cache::Backend** backend_ptr,
-                  Session::CacheAction action,
-                  const net::CompletionCallback& callback,
-                  int result) {
-  if (result != net::OK) {
-    RunCallbackInUI(callback, result);
-  } else if (backend_ptr && *backend_ptr) {
-    if (action == Session::CacheAction::CLEAR) {
-      (*backend_ptr)
-          ->DoomAllEntries(base::Bind(&RunCallbackInUI<int>, callback));
-    } else if (action == Session::CacheAction::STATS) {
-      base::StringPairs stats;
-      (*backend_ptr)->GetStats(&stats);
-      for (const auto& stat : stats) {
-        if (stat.first == "Current size") {
-          int current_size;
-          base::StringToInt(stat.second, &current_size);
-          RunCallbackInUI(callback, current_size);
-          break;
-        }
-      }
-    }
-  } else {
-    RunCallbackInUI<int>(callback, net::ERR_FAILED);
-  }
-}
-
-void DoCacheActionInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    Session::CacheAction action,
-    const net::CompletionCallback& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* http_cache = request_context->http_transaction_factory()->GetCache();
-  if (!http_cache)
-    RunCallbackInUI<int>(callback, net::ERR_FAILED);
-
-  // Call GetBackend and make the backend's ptr accessable in OnGetBackend.
-  using BackendPtr = disk_cache::Backend*;
-  auto** backend_ptr = new BackendPtr(nullptr);
-  net::CompletionCallback on_get_backend =
-      base::Bind(&OnGetBackend, base::Owned(backend_ptr), action, callback);
-  int rv = http_cache->GetBackend(backend_ptr, on_get_backend);
-  if (rv != net::ERR_IO_PENDING)
-    on_get_backend.Run(net::OK);
-}
-
-void SetProxyInIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                  const net::ProxyConfig& config,
-                  const base::Closure& callback) {
-  auto* proxy_service =
-      getter->GetURLRequestContext()->proxy_resolution_service();
-  proxy_service->ResetConfigService(
-      base::WrapUnique(new net::ProxyConfigServiceFixed(config)));
-  // Refetches and applies the new pac script if provided.
-  proxy_service->ForceReloadProxyConfig();
-  RunCallbackInUI(callback);
-}
-
-void SetCertVerifyProcInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const AtomCertVerifier::VerifyProc& proc) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  static_cast<AtomCertVerifier*>(request_context->cert_verifier())
-      ->SetVerifyProc(proc);
-}
-
-void ClearHostResolverCacheInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const base::Closure& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* cache = request_context->host_resolver()->GetHostCache();
-  if (cache) {
-    cache->clear();
-    DCHECK_EQ(0u, cache->size());
-    if (!callback.is_null())
-      RunCallbackInUI(callback);
-  }
-}
-
-void ClearAuthCacheInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const ClearAuthCacheOptions& options,
-    const base::Closure& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* network_session =
-      request_context->http_transaction_factory()->GetSession();
-  if (network_session) {
-    if (options.type == "password") {
-      auto* auth_cache = network_session->http_auth_cache();
-      if (!options.origin.is_empty()) {
-        auth_cache->Remove(
-            options.origin, options.realm, options.auth_scheme,
-            net::AuthCredentials(options.username, options.password));
-      } else {
-        auth_cache->ClearEntriesAddedWithin(base::TimeDelta::Max());
-      }
-    } else if (options.type == "clientCertificate") {
-      auto* client_auth_cache = network_session->ssl_client_auth_cache();
-      client_auth_cache->Remove(net::HostPortPair::FromURL(options.origin));
-    }
-    network_session->CloseAllConnections();
-  }
-  if (!callback.is_null())
-    RunCallbackInUI(callback);
-}
-
-void AllowNTLMCredentialsForDomainsInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const std::string& domains) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* auth_handler = request_context->http_auth_handler_factory();
-  if (auth_handler) {
-    auto* auth_preferences = const_cast<net::HttpAuthPreferences*>(
-        auth_handler->http_auth_preferences());
-    if (auth_preferences)
-      auth_preferences->SetServerWhitelist(domains);
-  }
-}
-
-void OnClearStorageDataDone(const base::Closure& callback) {
-  if (!callback.is_null())
-    callback.Run();
-}
-
-void DownloadIdCallback(content::DownloadManager* download_manager,
-                        const base::FilePath& path,
-                        const std::vector<GURL>& url_chain,
-                        const std::string& mime_type,
-                        int64_t offset,
-                        int64_t length,
-                        const std::string& last_modified,
-                        const std::string& etag,
-                        const base::Time& start_time,
-                        uint32_t id) {
-  download_manager->CreateDownloadItem(
-      base::GenerateGUID(), id, path, path, url_chain, GURL(), GURL(), GURL(),
-      GURL(), mime_type, mime_type, start_time, base::Time(), etag,
-      last_modified, offset, length, std::string(),
-      download::DownloadItem::INTERRUPTED,
-      download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-      download::DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT, false, base::Time(),
-      false, std::vector<download::DownloadItem::ReceivedSlice>());
-}
-
-void SetDevToolsNetworkEmulationClientIdInIO(
-    brightray::URLRequestContextGetter* url_request_context_getter,
-    const std::string& client_id) {
-  if (!url_request_context_getter)
-    return;
-  net::URLRequestContext* context =
-      url_request_context_getter->GetURLRequestContext();
-  AtomNetworkDelegate* network_delegate =
-      static_cast<AtomNetworkDelegate*>(context->network_delegate());
-  network_delegate->SetDevToolsNetworkEmulationClientId(client_id);
-}
-
-void DestroyGlobalHandle(v8::Isolate* isolate,
-                         const v8::Global<v8::Value>& global_handle) {
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  if (!global_handle.IsEmpty()) {
-    v8::Local<v8::Value> local_handle = global_handle.Get(isolate);
-    if (local_handle->IsObject()) {
-      v8::Local<v8::Object> object = local_handle->ToObject();
-      void* ptr = object->GetAlignedPointerFromInternalField(0);
-      if (!ptr)
-        return;
-      delete static_cast<mate::WrappableBase*>(ptr);
-      object->SetAlignedPointerInInternalField(0, nullptr);
-    }
-  }
-}
-
-}  // namespace
-
-Session::Session(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : devtools_network_emulation_client_id_(base::GenerateGUID()),
-      browser_context_(browser_context) {
-  // Observe DownloadManager to get download notifications.
-  content::BrowserContext::GetDownloadManager(browser_context)
-      ->AddObserver(this);
-
-  new SessionPreferences(browser_context);
-
-  Init(isolate);
-  AttachAsUserData(browser_context);
-}
-
-Session::~Session() {
-  content::BrowserContext::GetDownloadManager(browser_context())
-      ->RemoveObserver(this);
-  DestroyGlobalHandle(isolate(), cookies_);
-  DestroyGlobalHandle(isolate(), web_request_);
-  DestroyGlobalHandle(isolate(), protocol_);
-  g_sessions.erase(weak_map_id());
-}
-
-void Session::OnDownloadCreated(content::DownloadManager* manager,
-                                download::DownloadItem* item) {
-  if (item->IsSavePackageDownload())
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto handle = DownloadItem::Create(isolate(), item);
-  if (item->GetState() == download::DownloadItem::INTERRUPTED)
-    handle->SetSavePath(item->GetTargetFilePath());
-  content::WebContents* web_contents =
-      content::DownloadItemUtils::GetWebContents(item);
-  bool prevent_default = Emit("will-download", handle, web_contents);
-  if (prevent_default) {
-    item->Cancel(true);
-    item->Remove();
-  }
-}
-
-void Session::ResolveProxy(const GURL& url, ResolveProxyCallback callback) {
-  new ResolveProxyHelper(browser_context(), url, callback);
-}
-
-template <Session::CacheAction action>
-void Session::DoCacheAction(const net::CompletionCallback& callback) {
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&DoCacheActionInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     action, callback));
-}
-
-void Session::ClearStorageData(mate::Arguments* args) {
-  // clearStorageData([options, callback])
-  ClearStorageDataOptions options;
-  base::Closure callback;
-  args->GetNext(&options);
-  args->GetNext(&callback);
-
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
-  if (options.storage_types & StoragePartition::REMOVE_DATA_MASK_COOKIES) {
-    // Reset media device id salt when cookies are cleared.
-    // https://w3c.github.io/mediacapture-main/#dom-mediadeviceinfo-deviceid
-    brightray::MediaDeviceIDSalt::Reset(browser_context()->prefs());
-  }
-  storage_partition->ClearData(
-      options.storage_types, options.quota_types, options.origin,
-      content::StoragePartition::OriginMatcherFunction(), base::Time(),
-      base::Time::Max(), base::Bind(&OnClearStorageDataDone, callback));
-}
-
-void Session::FlushStorageData() {
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
-  storage_partition->Flush();
-}
-
-void Session::SetProxy(const net::ProxyConfig& config,
-                       const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetProxyInIO, base::RetainedRef(getter), config,
-                     callback));
-}
-
-void Session::SetDownloadPath(const base::FilePath& path) {
-  browser_context_->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
-                                         path);
-}
-
-void Session::EnableNetworkEmulation(const mate::Dictionary& options) {
-  std::unique_ptr<network::NetworkConditions> conditions;
-  bool offline = false;
-  double latency = 0.0, download_throughput = 0.0, upload_throughput = 0.0;
-  if (options.Get("offline", &offline) && offline) {
-    conditions.reset(new network::NetworkConditions(offline));
-  } else {
-    options.Get("latency", &latency);
-    options.Get("downloadThroughput", &download_throughput);
-    options.Get("uploadThroughput", &upload_throughput);
-    conditions.reset(new network::NetworkConditions(
-        false, latency, download_throughput, upload_throughput));
-  }
-
-  network::ThrottlingController::SetConditions(
-      devtools_network_emulation_client_id_, std::move(conditions));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetDevToolsNetworkEmulationClientIdInIO,
-                     base::RetainedRef(browser_context_->GetRequestContext()),
-                     devtools_network_emulation_client_id_));
-}
-
-void Session::DisableNetworkEmulation() {
-  auto conditions = std::make_unique<network::NetworkConditions>();
-  network::ThrottlingController::SetConditions(
-      devtools_network_emulation_client_id_, std::move(conditions));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetDevToolsNetworkEmulationClientIdInIO,
-                     base::RetainedRef(browser_context_->GetRequestContext()),
-                     std::string()));
-}
-
-void Session::SetCertVerifyProc(v8::Local<v8::Value> val,
-                                mate::Arguments* args) {
-  AtomCertVerifier::VerifyProc proc;
-  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &proc))) {
-    args->ThrowError("Must pass null or function");
-    return;
-  }
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetCertVerifyProcInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     proc));
-}
-
-void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,
-                                          mate::Arguments* args) {
-  AtomPermissionManager::RequestHandler handler;
-  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &handler))) {
-    args->ThrowError("Must pass null or function");
-    return;
-  }
-  auto* permission_manager = static_cast<AtomPermissionManager*>(
-      browser_context()->GetPermissionManager());
-  permission_manager->SetPermissionRequestHandler(handler);
-}
-
-void Session::ClearHostResolverCache(mate::Arguments* args) {
-  base::Closure callback;
-  args->GetNext(&callback);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&ClearHostResolverCacheInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     callback));
-}
-
-void Session::ClearAuthCache(mate::Arguments* args) {
-  ClearAuthCacheOptions options;
-  if (!args->GetNext(&options)) {
-    args->ThrowError("Must specify options object");
-    return;
-  }
-  base::Closure callback;
-  args->GetNext(&callback);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&ClearAuthCacheInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     options, callback));
-}
-
-void Session::AllowNTLMCredentialsForDomains(const std::string& domains) {
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AllowNTLMCredentialsForDomainsInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     domains));
-}
-
-void Session::SetUserAgent(const std::string& user_agent,
-                           mate::Arguments* args) {
-  browser_context_->SetUserAgent(user_agent);
-
-  std::string accept_lang = g_browser_process->GetApplicationLocale();
-  args->GetNext(&accept_lang);
-
-  scoped_refptr<brightray::URLRequestContextGetter> getter(
-      browser_context_->GetRequestContext());
-  getter->GetNetworkTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&SetUserAgentInIO, getter, accept_lang, user_agent));
-}
-
-std::string Session::GetUserAgent() {
-  return browser_context_->GetUserAgent();
-}
-
-void Session::GetBlobData(const std::string& uuid,
-                          const AtomBlobReader::CompletionCallback& callback) {
-  if (callback.is_null())
-    return;
-
-  AtomBlobReader* blob_reader = browser_context()->GetBlobReader();
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AtomBlobReader::StartReading,
-                     base::Unretained(blob_reader), uuid, callback));
-}
-
-void Session::CreateInterruptedDownload(const mate::Dictionary& options) {
-  int64_t offset = 0, length = 0;
-  double start_time = 0.0;
-  std::string mime_type, last_modified, etag;
-  base::FilePath path;
-  std::vector<GURL> url_chain;
-  options.Get("path", &path);
-  options.Get("urlChain", &url_chain);
-  options.Get("mimeType", &mime_type);
-  options.Get("offset", &offset);
-  options.Get("length", &length);
-  options.Get("lastModified", &last_modified);
-  options.Get("eTag", &etag);
-  options.Get("startTime", &start_time);
-  if (path.empty() || url_chain.empty() || length == 0) {
-    isolate()->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate(), "Must pass non-empty path, urlChain and length.")));
-    return;
-  }
-  if (offset >= length) {
-    isolate()->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate(), "Must pass an offset value less than length.")));
-    return;
-  }
-  auto* download_manager =
-      content::BrowserContext::GetDownloadManager(browser_context());
-  download_manager->GetDelegate()->GetNextId(base::Bind(
-      &DownloadIdCallback, download_manager, path, url_chain, mime_type, offset,
-      length, last_modified, etag, base::Time::FromDoubleT(start_time)));
-}
-
-void Session::SetPreloads(
-    const std::vector<base::FilePath::StringType>& preloads) {
-  auto* prefs = SessionPreferences::FromBrowserContext(browser_context());
-  DCHECK(prefs);
-  prefs->set_preloads(preloads);
-}
-
-std::vector<base::FilePath::StringType> Session::GetPreloads() const {
-  auto* prefs = SessionPreferences::FromBrowserContext(browser_context());
-  DCHECK(prefs);
-  return prefs->preloads();
-}
-
-v8::Local<v8::Value> Session::Cookies(v8::Isolate* isolate) {
-  if (cookies_.IsEmpty()) {
-    auto handle = Cookies::Create(isolate, browser_context());
-    cookies_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, cookies_);
-}
-
-v8::Local<v8::Value> Session::Protocol(v8::Isolate* isolate) {
-  if (protocol_.IsEmpty()) {
-    auto handle = atom::api::Protocol::Create(isolate, browser_context());
-    protocol_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, protocol_);
-}
-
-v8::Local<v8::Value> Session::WebRequest(v8::Isolate* isolate) {
-  if (web_request_.IsEmpty()) {
-    auto handle = atom::api::WebRequest::Create(isolate, browser_context());
-    web_request_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, web_request_);
-}
-
-// static
-mate::Handle<Session> Session::CreateFrom(v8::Isolate* isolate,
-                                          AtomBrowserContext* browser_context) {
-  auto* existing = TrackableObject::FromWrappedClass(isolate, browser_context);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<Session*>(existing));
-
-  auto handle =
-      mate::CreateHandle(isolate, new Session(isolate, browser_context));
-
-  // The Sessions should never be garbage collected, since the common pattern is
-  // to use partition strings, instead of using the Session object directly.
-  g_sessions[handle->weak_map_id()] =
-      v8::Global<v8::Object>(isolate, handle.ToV8());
-
-  return handle;
-}
-
-// static
-mate::Handle<Session> Session::FromPartition(
-    v8::Isolate* isolate,
-    const std::string& partition,
-    const base::DictionaryValue& options) {
-  scoped_refptr<AtomBrowserContext> browser_context;
-  if (partition.empty()) {
-    browser_context = AtomBrowserContext::From("", false, options);
-  } else if (base::StartsWith(partition, kPersistPrefix,
-                              base::CompareCase::SENSITIVE)) {
-    std::string name = partition.substr(8);
-    browser_context = AtomBrowserContext::From(name, false, options);
-  } else {
-    browser_context = AtomBrowserContext::From(partition, true, options);
-  }
-  return CreateFrom(isolate, browser_context.get());
-}
-
-// static
-void Session::BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Session"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("resolveProxy", &Session::ResolveProxy)
-      .SetMethod("getCacheSize", &Session::DoCacheAction<CacheAction::STATS>)
-      .SetMethod("clearCache", &Session::DoCacheAction<CacheAction::CLEAR>)
-      .SetMethod("clearStorageData", &Session::ClearStorageData)
-      .SetMethod("flushStorageData", &Session::FlushStorageData)
-      .SetMethod("setProxy", &Session::SetProxy)
-      .SetMethod("setDownloadPath", &Session::SetDownloadPath)
-      .SetMethod("enableNetworkEmulation", &Session::EnableNetworkEmulation)
-      .SetMethod("disableNetworkEmulation", &Session::DisableNetworkEmulation)
-      .SetMethod("setCertificateVerifyProc", &Session::SetCertVerifyProc)
-      .SetMethod("setPermissionRequestHandler",
-                 &Session::SetPermissionRequestHandler)
-      .SetMethod("clearHostResolverCache", &Session::ClearHostResolverCache)
-      .SetMethod("clearAuthCache", &Session::ClearAuthCache)
-      .SetMethod("allowNTLMCredentialsForDomains",
-                 &Session::AllowNTLMCredentialsForDomains)
-      .SetMethod("setUserAgent", &Session::SetUserAgent)
-      .SetMethod("getUserAgent", &Session::GetUserAgent)
-      .SetMethod("getBlobData", &Session::GetBlobData)
-      .SetMethod("createInterruptedDownload",
-                 &Session::CreateInterruptedDownload)
-      .SetMethod("setPreloads", &Session::SetPreloads)
-      .SetMethod("getPreloads", &Session::GetPreloads)
-      .SetProperty("cookies", &Session::Cookies)
-      .SetProperty("protocol", &Session::Protocol)
-      .SetProperty("webRequest", &Session::WebRequest);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Session;
-
-v8::Local<v8::Value> FromPartition(const std::string& partition,
-                                   mate::Arguments* args) {
-  if (!atom::Browser::Get()->is_ready()) {
-    args->ThrowError("Session can only be received when app is ready");
-    return v8::Null(args->isolate());
-  }
-  base::DictionaryValue options;
-  args->GetNext(&options);
-  return Session::FromPartition(args->isolate(), partition, options).ToV8();
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Session", Session::GetConstructor(isolate)->GetFunction());
-  dict.Set("Cookies", Cookies::GetConstructor(isolate)->GetFunction());
-  dict.SetMethod("fromPartition", &FromPartition);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_session, Initialize)
removed in remote
  base   100644 02d8ba5cdec0dca3a0c11cf128ab12d61684b61d atom/browser/api/atom_api_session.h
  our    100644 6c8247c5c4a90e643712dd47d000d37d181a147b atom/browser/api/atom_api_session.h
@@ -1,118 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_SESSION_H_
-#define ATOM_BROWSER_API_ATOM_API_SESSION_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_blob_reader.h"
-#include "base/values.h"
-#include "content/public/browser/download_manager.h"
-#include "native_mate/handle.h"
-#include "net/base/completion_callback.h"
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace net {
-class ProxyConfig;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class Session : public mate::TrackableObject<Session>,
-                public content::DownloadManager::Observer {
- public:
-  using ResolveProxyCallback = base::Callback<void(std::string)>;
-
-  enum class CacheAction {
-    CLEAR,
-    STATS,
-  };
-
-  // Gets or creates Session from the |browser_context|.
-  static mate::Handle<Session> CreateFrom(v8::Isolate* isolate,
-                                          AtomBrowserContext* browser_context);
-
-  // Gets the Session of |partition|.
-  static mate::Handle<Session> FromPartition(
-      v8::Isolate* isolate,
-      const std::string& partition,
-      const base::DictionaryValue& options = base::DictionaryValue());
-
-  AtomBrowserContext* browser_context() const { return browser_context_.get(); }
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Methods.
-  void ResolveProxy(const GURL& url, ResolveProxyCallback callback);
-  template <CacheAction action>
-  void DoCacheAction(const net::CompletionCallback& callback);
-  void ClearStorageData(mate::Arguments* args);
-  void FlushStorageData();
-  void SetProxy(const net::ProxyConfig& config, const base::Closure& callback);
-  void SetDownloadPath(const base::FilePath& path);
-  void EnableNetworkEmulation(const mate::Dictionary& options);
-  void DisableNetworkEmulation();
-  void SetCertVerifyProc(v8::Local<v8::Value> proc, mate::Arguments* args);
-  void SetPermissionRequestHandler(v8::Local<v8::Value> val,
-                                   mate::Arguments* args);
-  void ClearHostResolverCache(mate::Arguments* args);
-  void ClearAuthCache(mate::Arguments* args);
-  void AllowNTLMCredentialsForDomains(const std::string& domains);
-  void SetUserAgent(const std::string& user_agent, mate::Arguments* args);
-  std::string GetUserAgent();
-  void GetBlobData(const std::string& uuid,
-                   const AtomBlobReader::CompletionCallback& callback);
-  void CreateInterruptedDownload(const mate::Dictionary& options);
-  void SetPreloads(const std::vector<base::FilePath::StringType>& preloads);
-  std::vector<base::FilePath::StringType> GetPreloads() const;
-  v8::Local<v8::Value> Cookies(v8::Isolate* isolate);
-  v8::Local<v8::Value> Protocol(v8::Isolate* isolate);
-  v8::Local<v8::Value> WebRequest(v8::Isolate* isolate);
-
- protected:
-  Session(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Session() override;
-
-  // content::DownloadManager::Observer:
-  void OnDownloadCreated(content::DownloadManager* manager,
-                         download::DownloadItem* item) override;
-
- private:
-  // Cached object.
-  v8::Global<v8::Value> cookies_;
-  v8::Global<v8::Value> protocol_;
-  v8::Global<v8::Value> web_request_;
-
-  // The X-DevTools-Emulate-Network-Conditions-Client-Id.
-  std::string devtools_network_emulation_client_id_;
-
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(Session);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_SESSION_H_
removed in remote
  base   100644 5f351f4850499922ca36ae3643561cdb0d08b8d0 atom/browser/api/atom_api_tray.cc
  our    100644 552563bacfcda3120cbb6aa63822fff8b4a9beaa atom/browser/api/atom_api_tray.cc
@@ -1,262 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_tray.h"
-
-#include <string>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "atom/browser/browser.h"
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/constructor.h"
-#include "native_mate/dictionary.h"
-#include "ui/gfx/image/image.h"
-
-namespace mate {
-
-template <>
-struct Converter<atom::TrayIcon::HighlightMode> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::TrayIcon::HighlightMode* out) {
-    std::string mode;
-    if (ConvertFromV8(isolate, val, &mode)) {
-      if (mode == "always") {
-        *out = atom::TrayIcon::HighlightMode::ALWAYS;
-        return true;
-      }
-      if (mode == "selection") {
-        *out = atom::TrayIcon::HighlightMode::SELECTION;
-        return true;
-      }
-      if (mode == "never") {
-        *out = atom::TrayIcon::HighlightMode::NEVER;
-        return true;
-      }
-    }
-    return false;
-  }
-};
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-Tray::Tray(v8::Isolate* isolate,
-           v8::Local<v8::Object> wrapper,
-           mate::Handle<NativeImage> image)
-    : tray_icon_(TrayIcon::Create()) {
-  SetImage(isolate, image);
-  tray_icon_->AddObserver(this);
-
-  InitWith(isolate, wrapper);
-}
-
-Tray::~Tray() {
-  // Destroy the native tray in next tick.
-  base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE,
-                                                  tray_icon_.release());
-}
-
-// static
-mate::WrappableBase* Tray::New(mate::Handle<NativeImage> image,
-                               mate::Arguments* args) {
-  if (!Browser::Get()->is_ready()) {
-    args->ThrowError("Cannot create Tray before app is ready");
-    return nullptr;
-  }
-  return new Tray(args->isolate(), args->GetThis(), image);
-}
-
-void Tray::OnClicked(const gfx::Rect& bounds,
-                     const gfx::Point& location,
-                     int modifiers) {
-  EmitWithFlags("click", modifiers, bounds, location);
-}
-
-void Tray::OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {
-  EmitWithFlags("double-click", modifiers, bounds);
-}
-
-void Tray::OnRightClicked(const gfx::Rect& bounds, int modifiers) {
-  EmitWithFlags("right-click", modifiers, bounds);
-}
-
-void Tray::OnBalloonShow() {
-  Emit("balloon-show");
-}
-
-void Tray::OnBalloonClicked() {
-  Emit("balloon-click");
-}
-
-void Tray::OnBalloonClosed() {
-  Emit("balloon-closed");
-}
-
-void Tray::OnDrop() {
-  Emit("drop");
-}
-
-void Tray::OnDropFiles(const std::vector<std::string>& files) {
-  Emit("drop-files", files);
-}
-
-void Tray::OnDropText(const std::string& text) {
-  Emit("drop-text", text);
-}
-
-void Tray::OnMouseEntered(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-enter", modifiers, location);
-}
-
-void Tray::OnMouseExited(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-leave", modifiers, location);
-}
-
-void Tray::OnMouseMoved(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-move", modifiers, location);
-}
-
-void Tray::OnDragEntered() {
-  Emit("drag-enter");
-}
-
-void Tray::OnDragExited() {
-  Emit("drag-leave");
-}
-
-void Tray::OnDragEnded() {
-  Emit("drag-end");
-}
-
-void Tray::SetImage(v8::Isolate* isolate, mate::Handle<NativeImage> image) {
-#if defined(OS_WIN)
-  tray_icon_->SetImage(image->GetHICON(GetSystemMetrics(SM_CXSMICON)));
-#else
-  tray_icon_->SetImage(image->image());
-#endif
-}
-
-void Tray::SetPressedImage(v8::Isolate* isolate,
-                           mate::Handle<NativeImage> image) {
-#if defined(OS_WIN)
-  tray_icon_->SetPressedImage(image->GetHICON(GetSystemMetrics(SM_CXSMICON)));
-#else
-  tray_icon_->SetPressedImage(image->image());
-#endif
-}
-
-void Tray::SetToolTip(const std::string& tool_tip) {
-  tray_icon_->SetToolTip(tool_tip);
-}
-
-void Tray::SetTitle(const std::string& title) {
-  tray_icon_->SetTitle(title);
-}
-
-void Tray::SetHighlightMode(TrayIcon::HighlightMode mode) {
-  tray_icon_->SetHighlightMode(mode);
-}
-
-void Tray::SetIgnoreDoubleClickEvents(bool ignore) {
-#if defined(OS_MACOSX)
-  tray_icon_->SetIgnoreDoubleClickEvents(ignore);
-#endif
-}
-
-bool Tray::GetIgnoreDoubleClickEvents() {
-#if defined(OS_MACOSX)
-  return tray_icon_->GetIgnoreDoubleClickEvents();
-#else
-  return false;
-#endif
-}
-
-void Tray::DisplayBalloon(mate::Arguments* args,
-                          const mate::Dictionary& options) {
-  mate::Handle<NativeImage> icon;
-  options.Get("icon", &icon);
-  base::string16 title, content;
-  if (!options.Get("title", &title) || !options.Get("content", &content)) {
-    args->ThrowError("'title' and 'content' must be defined");
-    return;
-  }
-
-#if defined(OS_WIN)
-  tray_icon_->DisplayBalloon(
-      icon.IsEmpty() ? NULL : icon->GetHICON(GetSystemMetrics(SM_CXSMICON)),
-      title, content);
-#else
-  tray_icon_->DisplayBalloon(icon.IsEmpty() ? gfx::Image() : icon->image(),
-                             title, content);
-#endif
-}
-
-void Tray::PopUpContextMenu(mate::Arguments* args) {
-  mate::Handle<Menu> menu;
-  args->GetNext(&menu);
-  gfx::Point pos;
-  args->GetNext(&pos);
-  tray_icon_->PopUpContextMenu(pos, menu.IsEmpty() ? nullptr : menu->model());
-}
-
-void Tray::SetContextMenu(v8::Isolate* isolate, mate::Handle<Menu> menu) {
-  menu_.Reset(isolate, menu.ToV8());
-  tray_icon_->SetContextMenu(menu->model());
-}
-
-gfx::Rect Tray::GetBounds() {
-  return tray_icon_->GetBounds();
-}
-
-// static
-void Tray::BuildPrototype(v8::Isolate* isolate,
-                          v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Tray"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("setImage", &Tray::SetImage)
-      .SetMethod("setPressedImage", &Tray::SetPressedImage)
-      .SetMethod("setToolTip", &Tray::SetToolTip)
-      .SetMethod("setTitle", &Tray::SetTitle)
-      .SetMethod("setHighlightMode", &Tray::SetHighlightMode)
-      .SetMethod("setIgnoreDoubleClickEvents",
-                 &Tray::SetIgnoreDoubleClickEvents)
-      .SetMethod("getIgnoreDoubleClickEvents",
-                 &Tray::GetIgnoreDoubleClickEvents)
-      .SetMethod("displayBalloon", &Tray::DisplayBalloon)
-      .SetMethod("popUpContextMenu", &Tray::PopUpContextMenu)
-      .SetMethod("setContextMenu", &Tray::SetContextMenu)
-      .SetMethod("getBounds", &Tray::GetBounds);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Tray;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  Tray::SetConstructor(isolate, base::Bind(&Tray::New));
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Tray", Tray::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_tray, Initialize)
removed in remote
  base   100644 0e0d153ad0d3adf3944961d2482f554cc8e01650 atom/browser/api/atom_api_tray.h
  our    100644 2ccb836d6299ef4b88c652f3c14c47d4f50a689c atom/browser/api/atom_api_tray.h
@@ -1,91 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_TRAY_H_
-#define ATOM_BROWSER_API_ATOM_API_TRAY_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/ui/tray_icon.h"
-#include "atom/browser/ui/tray_icon_observer.h"
-#include "native_mate/handle.h"
-
-namespace gfx {
-class Image;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace atom {
-
-class TrayIcon;
-
-namespace api {
-
-class Menu;
-class NativeImage;
-
-class Tray : public mate::TrackableObject<Tray>, public TrayIconObserver {
- public:
-  static mate::WrappableBase* New(mate::Handle<NativeImage> image,
-                                  mate::Arguments* args);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Tray(v8::Isolate* isolate,
-       v8::Local<v8::Object> wrapper,
-       mate::Handle<NativeImage> image);
-  ~Tray() override;
-
-  // TrayIconObserver:
-  void OnClicked(const gfx::Rect& bounds,
-                 const gfx::Point& location,
-                 int modifiers) override;
-  void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) override;
-  void OnRightClicked(const gfx::Rect& bounds, int modifiers) override;
-  void OnBalloonShow() override;
-  void OnBalloonClicked() override;
-  void OnBalloonClosed() override;
-  void OnDrop() override;
-  void OnDropFiles(const std::vector<std::string>& files) override;
-  void OnDropText(const std::string& text) override;
-  void OnDragEntered() override;
-  void OnDragExited() override;
-  void OnDragEnded() override;
-  void OnMouseEntered(const gfx::Point& location, int modifiers) override;
-  void OnMouseExited(const gfx::Point& location, int modifiers) override;
-  void OnMouseMoved(const gfx::Point& location, int modifiers) override;
-
-  void SetImage(v8::Isolate* isolate, mate::Handle<NativeImage> image);
-  void SetPressedImage(v8::Isolate* isolate, mate::Handle<NativeImage> image);
-  void SetToolTip(const std::string& tool_tip);
-  void SetTitle(const std::string& title);
-  void SetHighlightMode(TrayIcon::HighlightMode mode);
-  void SetIgnoreDoubleClickEvents(bool ignore);
-  bool GetIgnoreDoubleClickEvents();
-  void DisplayBalloon(mate::Arguments* args, const mate::Dictionary& options);
-  void PopUpContextMenu(mate::Arguments* args);
-  void SetContextMenu(v8::Isolate* isolate, mate::Handle<Menu> menu);
-  gfx::Rect GetBounds();
-
- private:
-  v8::Global<v8::Object> menu_;
-  std::unique_ptr<TrayIcon> tray_icon_;
-
-  DISALLOW_COPY_AND_ASSIGN(Tray);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_TRAY_H_
removed in remote
  base   100644 db561708086ec253d80ba6d961556eaf892ff106 atom/browser/api/atom_api_web_contents.cc
  our    100644 20a1ac2e672f08ffea528b6e094ba530ff8083d1 atom/browser/api/atom_api_web_contents.cc
@@ -1,2132 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_web_contents.h"
-
-#include <set>
-#include <string>
-
-// We have problems with redefinition of ssize_t between node.h and
-// port_chromium.h, and the latter was introduced by leveldb.mojom.h.
-// The best solution is to not include content/browser/frame_host/ headers
-// and node.h in the same file, but for now I'm just working around the
-// problem.
-#if defined(OS_WIN)
-#define COMPONENTS_SERVICES_LEVELDB_PUBLIC_INTERFACES_LEVELDB_MOJOM_H_
-#define COMPONENTS_LEVELDB_PUBLIC_INTERFACES_LEVELDB_MOJOM_H_
-#endif
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/api/atom_api_debugger.h"
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_javascript_dialog_manager.h"
-#include "atom/browser/child_web_contents_tracker.h"
-#include "atom/browser/lib/bluetooth_chooser.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#if defined(ENABLE_OSR)
-#include "atom/browser/osr/osr_output_device.h"
-#include "atom/browser/osr/osr_render_widget_host_view.h"
-#include "atom/browser/osr/osr_web_contents_view.h"
-#endif
-#include "atom/browser/ui/drag_util.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "atom/browser/web_view_guest_delegate.h"
-#include "atom/common/api/api_messages.h"
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/color_util.h"
-#include "atom/common/mouse_util.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/network_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/message_loop/message_loop.h"
-#include "base/process/process_handle.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/values.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/printing/print_preview_message_handler.h"
-#include "chrome/browser/printing/print_view_manager_basic.h"
-#include "chrome/browser/ssl/security_state_tab_helper.h"
-#include "content/browser/frame_host/frame_tree_node.h"
-#include "content/browser/frame_host/render_frame_host_manager.h"
-#include "content/browser/renderer_host/render_widget_host_impl.h"
-#include "content/browser/renderer_host/render_widget_host_view_base.h"
-#include "content/common/view_messages.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/download_request_utils.h"
-#include "content/public/browser/favicon_status.h"
-#include "content/public/browser/native_web_keyboard_event.h"
-#include "content/public/browser/navigation_details.h"
-#include "content/public/browser/navigation_entry.h"
-#include "content/public/browser/navigation_handle.h"
-#include "content/public/browser/plugin_service.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/render_widget_host_view.h"
-#include "content/public/browser/service_worker_context.h"
-#include "content/public/browser/site_instance.h"
-#include "content/public/browser/storage_partition.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/context_menu_params.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/url_request/url_request_context.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/web/WebFindOptions.h"
-#include "ui/display/screen.h"
-#include "ui/events/base_event_utils.h"
-
-#if !defined(OS_MACOSX)
-#include "ui/aura/window.h"
-#endif
-
-#if defined(OS_LINUX) || defined(OS_WIN)
-#include "content/public/common/renderer_preferences.h"
-#include "ui/gfx/font_render_params.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace {
-
-struct PrintSettings {
-  bool silent;
-  bool print_background;
-  base::string16 device_name;
-};
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<PrintSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     PrintSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    dict.Get("silent", &(out->silent));
-    dict.Get("printBackground", &(out->print_background));
-    dict.Get("deviceName", &(out->device_name));
-    return true;
-  }
-};
-
-template <>
-struct Converter<printing::PrinterBasicInfo> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const printing::PrinterBasicInfo& val) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("name", val.printer_name);
-    dict.Set("description", val.printer_description);
-    dict.Set("status", val.printer_status);
-    dict.Set("isDefault", val.is_default ? true : false);
-    dict.Set("options", val.options);
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<WindowOpenDisposition> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   WindowOpenDisposition val) {
-    std::string disposition = "other";
-    switch (val) {
-      case WindowOpenDisposition::CURRENT_TAB:
-        disposition = "default";
-        break;
-      case WindowOpenDisposition::NEW_FOREGROUND_TAB:
-        disposition = "foreground-tab";
-        break;
-      case WindowOpenDisposition::NEW_BACKGROUND_TAB:
-        disposition = "background-tab";
-        break;
-      case WindowOpenDisposition::NEW_POPUP:
-      case WindowOpenDisposition::NEW_WINDOW:
-        disposition = "new-window";
-        break;
-      case WindowOpenDisposition::SAVE_TO_DISK:
-        disposition = "save-to-disk";
-        break;
-      default:
-        break;
-    }
-    return mate::ConvertToV8(isolate, disposition);
-  }
-};
-
-template <>
-struct Converter<content::SavePageType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::SavePageType* out) {
-    std::string save_type;
-    if (!ConvertFromV8(isolate, val, &save_type))
-      return false;
-    save_type = base::ToLowerASCII(save_type);
-    if (save_type == "htmlonly") {
-      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;
-    } else if (save_type == "htmlcomplete") {
-      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;
-    } else if (save_type == "mhtml") {
-      *out = content::SAVE_PAGE_TYPE_AS_MHTML;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-template <>
-struct Converter<atom::api::WebContents::Type> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::api::WebContents::Type val) {
-    using Type = atom::api::WebContents::Type;
-    std::string type = "";
-    switch (val) {
-      case Type::BACKGROUND_PAGE:
-        type = "backgroundPage";
-        break;
-      case Type::BROWSER_WINDOW:
-        type = "window";
-        break;
-      case Type::BROWSER_VIEW:
-        type = "browserView";
-        break;
-      case Type::REMOTE:
-        type = "remote";
-        break;
-      case Type::WEB_VIEW:
-        type = "webview";
-        break;
-      case Type::OFF_SCREEN:
-        type = "offscreen";
-        break;
-      default:
-        break;
-    }
-    return mate::ConvertToV8(isolate, type);
-  }
-
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::api::WebContents::Type* out) {
-    using Type = atom::api::WebContents::Type;
-    std::string type;
-    if (!ConvertFromV8(isolate, val, &type))
-      return false;
-    if (type == "backgroundPage") {
-      *out = Type::BACKGROUND_PAGE;
-    } else if (type == "browserView") {
-      *out = Type::BROWSER_VIEW;
-    } else if (type == "webview") {
-      *out = Type::WEB_VIEW;
-#if defined(ENABLE_OSR)
-    } else if (type == "offscreen") {
-      *out = Type::OFF_SCREEN;
-#endif
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-content::ServiceWorkerContext* GetServiceWorkerContext(
-    const content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  auto* site_instance = web_contents->GetSiteInstance();
-  if (!context || !site_instance)
-    return nullptr;
-
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(context, site_instance);
-  if (!storage_partition)
-    return nullptr;
-
-  return storage_partition->GetServiceWorkerContext();
-}
-
-// Called when CapturePage is done.
-void OnCapturePageDone(const base::Callback<void(const gfx::Image&)>& callback,
-                       const SkBitmap& bitmap) {
-  // Hack to enable transparency in captured image
-  // TODO(nitsakh) Remove hack once fixed in chromium
-  const_cast<SkBitmap&>(bitmap).setAlphaType(kPremul_SkAlphaType);
-  callback.Run(gfx::Image::CreateFrom1xBitmap(bitmap));
-}
-
-}  // namespace
-
-struct WebContents::FrameDispatchHelper {
-  WebContents* api_web_contents;
-  content::RenderFrameHost* rfh;
-
-  bool Send(IPC::Message* msg) { return rfh->Send(msg); }
-
-  void OnSetTemporaryZoomLevel(double level, IPC::Message* reply_msg) {
-    api_web_contents->OnSetTemporaryZoomLevel(rfh, level, reply_msg);
-  }
-
-  void OnGetZoomLevel(IPC::Message* reply_msg) {
-    api_web_contents->OnGetZoomLevel(rfh, reply_msg);
-  }
-
-  void OnRendererMessageSync(const base::string16& channel,
-                             const base::ListValue& args,
-                             IPC::Message* message) {
-    api_web_contents->OnRendererMessageSync(rfh, channel, args, message);
-  }
-};
-
-WebContents::WebContents(v8::Isolate* isolate,
-                         content::WebContents* web_contents,
-                         Type type)
-    : content::WebContentsObserver(web_contents), type_(type) {
-  const mate::Dictionary options = mate::Dictionary::CreateEmpty(isolate);
-  if (type == REMOTE) {
-    web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
-    Init(isolate);
-    AttachAsUserData(web_contents);
-    InitZoomController(web_contents, options);
-  } else {
-    auto session = Session::CreateFrom(isolate, GetBrowserContext());
-    session_.Reset(isolate, session.ToV8());
-    InitWithSessionAndOptions(isolate, web_contents, session, options);
-  }
-}
-
-WebContents::WebContents(v8::Isolate* isolate,
-                         const mate::Dictionary& options) {
-  // Read options.
-  options.Get("backgroundThrottling", &background_throttling_);
-
-  // FIXME(zcbenz): We should read "type" parameter for better design, but
-  // on Windows we have encountered a compiler bug that if we read "type"
-  // from |options| and then set |type_|, a memory corruption will happen
-  // and Electron will soon crash.
-  // Remvoe this after we upgraded to use VS 2015 Update 3.
-  bool b = false;
-  if (options.Get("isGuest", &b) && b)
-    type_ = WEB_VIEW;
-  else if (options.Get("isBackgroundPage", &b) && b)
-    type_ = BACKGROUND_PAGE;
-  else if (options.Get("isBrowserView", &b) && b)
-    type_ = BROWSER_VIEW;
-#if defined(ENABLE_OSR)
-  else if (options.Get(options::kOffscreen, &b) && b)
-    type_ = OFF_SCREEN;
-#endif
-
-  // Init embedder earlier
-  options.Get("embedder", &embedder_);
-
-  // Whether to enable DevTools.
-  options.Get("devTools", &enable_devtools_);
-
-  // Obtain the session.
-  std::string partition;
-  mate::Handle<api::Session> session;
-  if (options.Get("session", &session) && !session.IsEmpty()) {
-  } else if (options.Get("partition", &partition)) {
-    session = Session::FromPartition(isolate, partition);
-  } else {
-    // Use the default session if not specified.
-    session = Session::FromPartition(isolate, "");
-  }
-  session_.Reset(isolate, session.ToV8());
-
-  content::WebContents* web_contents;
-  if (IsGuest()) {
-    scoped_refptr<content::SiteInstance> site_instance =
-        content::SiteInstance::CreateForURL(session->browser_context(),
-                                            GURL("chrome-guest://fake-host"));
-    content::WebContents::CreateParams params(session->browser_context(),
-                                              site_instance);
-    guest_delegate_.reset(
-        new WebViewGuestDelegate(embedder_->web_contents(), this));
-    params.guest_delegate = guest_delegate_.get();
-
-#if defined(ENABLE_OSR)
-    if (embedder_ && embedder_->IsOffScreen()) {
-      auto* view = new OffScreenWebContentsView(
-          false, base::Bind(&WebContents::OnPaint, base::Unretained(this)));
-      params.view = view;
-      params.delegate_view = view;
-
-      web_contents = content::WebContents::Create(params);
-      view->SetWebContents(web_contents);
-    } else {
-#endif
-      web_contents = content::WebContents::Create(params);
-#if defined(ENABLE_OSR)
-    }
-  } else if (IsOffScreen()) {
-    bool transparent = false;
-    options.Get("transparent", &transparent);
-
-    content::WebContents::CreateParams params(session->browser_context());
-    auto* view = new OffScreenWebContentsView(
-        transparent, base::Bind(&WebContents::OnPaint, base::Unretained(this)));
-    params.view = view;
-    params.delegate_view = view;
-
-    web_contents = content::WebContents::Create(params);
-    view->SetWebContents(web_contents);
-#endif
-  } else {
-    content::WebContents::CreateParams params(session->browser_context());
-    web_contents = content::WebContents::Create(params);
-  }
-
-  InitWithSessionAndOptions(isolate, web_contents, session, options);
-}
-
-void WebContents::InitZoomController(content::WebContents* web_contents,
-                                     const mate::Dictionary& options) {
-  WebContentsZoomController::CreateForWebContents(web_contents);
-  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);
-  double zoom_factor;
-  if (options.Get(options::kZoomFactor, &zoom_factor))
-    zoom_controller_->SetDefaultZoomFactor(zoom_factor);
-}
-
-void WebContents::InitWithSessionAndOptions(v8::Isolate* isolate,
-                                            content::WebContents* web_contents,
-                                            mate::Handle<api::Session> session,
-                                            const mate::Dictionary& options) {
-  Observe(web_contents);
-  InitWithWebContents(web_contents, session->browser_context(), IsGuest());
-
-  managed_web_contents()->GetView()->SetDelegate(this);
-
-  auto* prefs = web_contents->GetMutableRendererPrefs();
-  prefs->accept_languages = g_browser_process->GetApplicationLocale();
-
-#if defined(OS_LINUX) || defined(OS_WIN)
-  // Update font settings.
-  CR_DEFINE_STATIC_LOCAL(
-      const gfx::FontRenderParams, params,
-      (gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr)));
-  prefs->should_antialias_text = params.antialiasing;
-  prefs->use_subpixel_positioning = params.subpixel_positioning;
-  prefs->hinting = params.hinting;
-  prefs->use_autohinter = params.autohinter;
-  prefs->use_bitmaps = params.use_bitmaps;
-  prefs->subpixel_rendering = params.subpixel_rendering;
-#endif
-
-  // Save the preferences in C++.
-  new WebContentsPreferences(web_contents, options);
-
-  // Initialize permission helper.
-  WebContentsPermissionHelper::CreateForWebContents(web_contents);
-  // Initialize security state client.
-  SecurityStateTabHelper::CreateForWebContents(web_contents);
-  // Initialize zoom controller.
-  InitZoomController(web_contents, options);
-
-  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
-
-  if (IsGuest()) {
-    NativeWindow* owner_window = nullptr;
-    if (embedder_) {
-      // New WebContents's owner_window is the embedder's owner_window.
-      auto* relay =
-          NativeWindowRelay::FromWebContents(embedder_->web_contents());
-      if (relay)
-        owner_window = relay->window.get();
-    }
-    if (owner_window)
-      SetOwnerWindow(owner_window);
-  }
-
-  Init(isolate);
-  AttachAsUserData(web_contents);
-}
-
-WebContents::~WebContents() {
-  // The destroy() is called.
-  if (managed_web_contents()) {
-    managed_web_contents()->GetView()->SetDelegate(nullptr);
-
-    RenderViewDeleted(web_contents()->GetRenderViewHost());
-
-    if (type_ == BROWSER_WINDOW && owner_window()) {
-      for (ExtendedWebContentsObserver& observer : observers_)
-        observer.OnCloseContents();
-    } else {
-      DestroyWebContents(!IsGuest() /* async */);
-    }
-    // The WebContentsDestroyed will not be called automatically because we
-    // destroy the webContents in the next tick. So we have to manually
-    // call it here to make sure "destroyed" event is emitted.
-    WebContentsDestroyed();
-  }
-}
-
-void WebContents::DestroyWebContents(bool async) {
-  // This event is only for internal use, which is emitted when WebContents is
-  // being destroyed.
-  Emit("will-destroy");
-  ResetManagedWebContents(async);
-}
-
-bool WebContents::DidAddMessageToConsole(content::WebContents* source,
-                                         int32_t level,
-                                         const base::string16& message,
-                                         int32_t line_no,
-                                         const base::string16& source_id) {
-  return Emit("console-message", level, message, line_no, source_id);
-}
-
-void WebContents::OnCreateWindow(
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const std::vector<std::string>& features,
-    const scoped_refptr<network::ResourceRequestBody>& body) {
-  if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-    Emit("-new-window", target_url, frame_name, disposition, features, body,
-         referrer);
-  else
-    Emit("new-window", target_url, frame_name, disposition, features);
-}
-
-void WebContents::WebContentsCreated(content::WebContents* source_contents,
-                                     int opener_render_process_id,
-                                     int opener_render_frame_id,
-                                     const std::string& frame_name,
-                                     const GURL& target_url,
-                                     content::WebContents* new_contents) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto api_web_contents = CreateFrom(isolate(), new_contents, BROWSER_WINDOW);
-  Emit("-web-contents-created", api_web_contents, target_url, frame_name);
-}
-
-void WebContents::AddNewContents(content::WebContents* source,
-                                 content::WebContents* new_contents,
-                                 WindowOpenDisposition disposition,
-                                 const gfx::Rect& initial_rect,
-                                 bool user_gesture,
-                                 bool* was_blocked) {
-  new ChildWebContentsTracker(new_contents);
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto api_web_contents = CreateFrom(isolate(), new_contents);
-  if (Emit("-add-new-contents", api_web_contents, disposition, user_gesture,
-           initial_rect.x(), initial_rect.y(), initial_rect.width(),
-           initial_rect.height())) {
-    api_web_contents->DestroyWebContents(true /* async */);
-  }
-}
-
-content::WebContents* WebContents::OpenURLFromTab(
-    content::WebContents* source,
-    const content::OpenURLParams& params) {
-  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {
-    if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-      Emit("-new-window", params.url, "", params.disposition);
-    else
-      Emit("new-window", params.url, "", params.disposition);
-    return nullptr;
-  }
-
-  // Give user a chance to cancel navigation.
-  if (Emit("will-navigate", params.url))
-    return nullptr;
-
-  // Don't load the URL if the web contents was marked as destroyed from a
-  // will-navigate event listener
-  if (IsDestroyed())
-    return nullptr;
-
-  return CommonWebContentsDelegate::OpenURLFromTab(source, params);
-}
-
-void WebContents::BeforeUnloadFired(content::WebContents* tab,
-                                    bool proceed,
-                                    bool* proceed_to_fire_unload) {
-  if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-    *proceed_to_fire_unload = proceed;
-  else
-    *proceed_to_fire_unload = true;
-}
-
-void WebContents::MoveContents(content::WebContents* source,
-                               const gfx::Rect& pos) {
-  Emit("move", pos);
-}
-
-void WebContents::CloseContents(content::WebContents* source) {
-  Emit("close");
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  HideAutofillPopup();
-#endif
-  if (managed_web_contents())
-    managed_web_contents()->GetView()->SetDelegate(nullptr);
-  for (ExtendedWebContentsObserver& observer : observers_)
-    observer.OnCloseContents();
-}
-
-void WebContents::ActivateContents(content::WebContents* source) {
-  Emit("activate");
-}
-
-void WebContents::UpdateTargetURL(content::WebContents* source,
-                                  const GURL& url) {
-  Emit("update-target-url", url);
-}
-
-bool WebContents::IsPopupOrPanel(const content::WebContents* source) const {
-  return type_ == BROWSER_WINDOW;
-}
-
-void WebContents::HandleKeyboardEvent(
-    content::WebContents* source,
-    const content::NativeWebKeyboardEvent& event) {
-  if (type_ == WEB_VIEW && embedder_) {
-    // Send the unhandled keyboard events back to the embedder.
-    embedder_->HandleKeyboardEvent(source, event);
-  } else {
-    // Go to the default keyboard handling.
-    CommonWebContentsDelegate::HandleKeyboardEvent(source, event);
-  }
-}
-
-content::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(
-    content::WebContents* source,
-    const content::NativeWebKeyboardEvent& event) {
-  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||
-      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {
-    bool prevent_default = Emit("before-input-event", event);
-    if (prevent_default) {
-      return content::KeyboardEventProcessingResult::HANDLED;
-    }
-  }
-
-  return content::KeyboardEventProcessingResult::NOT_HANDLED;
-}
-
-void WebContents::EnterFullscreenModeForTab(content::WebContents* source,
-                                            const GURL& origin) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(source);
-  auto callback = base::Bind(&WebContents::OnEnterFullscreenModeForTab,
-                             base::Unretained(this), source, origin);
-  permission_helper->RequestFullscreenPermission(callback);
-}
-
-void WebContents::OnEnterFullscreenModeForTab(content::WebContents* source,
-                                              const GURL& origin,
-                                              bool allowed) {
-  if (!allowed)
-    return;
-  CommonWebContentsDelegate::EnterFullscreenModeForTab(source, origin);
-  Emit("enter-html-full-screen");
-}
-
-void WebContents::ExitFullscreenModeForTab(content::WebContents* source) {
-  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);
-  Emit("leave-html-full-screen");
-}
-
-void WebContents::RendererUnresponsive(
-    content::WebContents* source,
-    content::RenderWidgetHost* render_widget_host) {
-  Emit("unresponsive");
-}
-
-void WebContents::RendererResponsive(
-    content::WebContents* source,
-    content::RenderWidgetHost* render_widget_host) {
-  Emit("responsive");
-  for (ExtendedWebContentsObserver& observer : observers_)
-    observer.OnRendererResponsive();
-}
-
-bool WebContents::HandleContextMenu(const content::ContextMenuParams& params) {
-  if (params.custom_context.is_pepper_menu) {
-    Emit("pepper-context-menu", std::make_pair(params, web_contents()),
-         base::Bind(&content::WebContents::NotifyContextMenuClosed,
-                    base::Unretained(web_contents()), params.custom_context));
-  } else {
-    Emit("context-menu", std::make_pair(params, web_contents()));
-  }
-
-  return true;
-}
-
-bool WebContents::OnGoToEntryOffset(int offset) {
-  GoToOffset(offset);
-  return false;
-}
-
-void WebContents::FindReply(content::WebContents* web_contents,
-                            int request_id,
-                            int number_of_matches,
-                            const gfx::Rect& selection_rect,
-                            int active_match_ordinal,
-                            bool final_update) {
-  if (!final_update)
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate());
-  result.Set("requestId", request_id);
-  result.Set("matches", number_of_matches);
-  result.Set("selectionArea", selection_rect);
-  result.Set("activeMatchOrdinal", active_match_ordinal);
-  result.Set("finalUpdate", final_update);  // Deprecate after 2.0
-  Emit("found-in-page", result);
-}
-
-bool WebContents::CheckMediaAccessPermission(content::WebContents* web_contents,
-                                             const GURL& security_origin,
-                                             content::MediaStreamType type) {
-  return true;
-}
-
-void WebContents::RequestMediaAccessPermission(
-    content::WebContents* web_contents,
-    const content::MediaStreamRequest& request,
-    const content::MediaResponseCallback& callback) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  permission_helper->RequestMediaAccessPermission(request, callback);
-}
-
-void WebContents::RequestToLockMouse(content::WebContents* web_contents,
-                                     bool user_gesture,
-                                     bool last_unlocked_by_target) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  permission_helper->RequestPointerLockPermission(user_gesture);
-}
-
-std::unique_ptr<content::BluetoothChooser> WebContents::RunBluetoothChooser(
-    content::RenderFrameHost* frame,
-    const content::BluetoothChooser::EventHandler& event_handler) {
-  return std::make_unique<BluetoothChooser>(this, event_handler);
-}
-
-content::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(
-    content::WebContents* source) {
-  if (!dialog_manager_)
-    dialog_manager_.reset(new AtomJavaScriptDialogManager(this));
-
-  return dialog_manager_.get();
-}
-
-void WebContents::BeforeUnloadFired(const base::TimeTicks& proceed_time) {
-  // Do nothing, we override this method just to avoid compilation error since
-  // there are two virtual functions named BeforeUnloadFired.
-}
-
-void WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {
-  auto* const impl = content::RenderWidgetHostImpl::FromID(
-      render_view_host->GetProcess()->GetID(),
-      render_view_host->GetRoutingID());
-  if (impl)
-    impl->disable_hidden_ = !background_throttling_;
-}
-
-void WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {
-  Emit("render-view-deleted", render_view_host->GetProcess()->GetID());
-}
-
-void WebContents::RenderProcessGone(base::TerminationStatus status) {
-  Emit("crashed", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);
-}
-
-void WebContents::PluginCrashed(const base::FilePath& plugin_path,
-                                base::ProcessId plugin_pid) {
-  content::WebPluginInfo info;
-  auto* plugin_service = content::PluginService::GetInstance();
-  plugin_service->GetPluginInfoByPath(plugin_path, &info);
-  Emit("plugin-crashed", info.name, info.version);
-}
-
-void WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,
-                                      const MediaPlayerId& id) {
-  Emit("media-started-playing");
-}
-
-void WebContents::MediaStoppedPlaying(
-    const MediaPlayerInfo& video_type,
-    const MediaPlayerId& id,
-    content::WebContentsObserver::MediaStoppedReason reason) {
-  Emit("media-paused");
-}
-
-void WebContents::DidChangeThemeColor(SkColor theme_color) {
-  if (theme_color != SK_ColorTRANSPARENT) {
-    Emit("did-change-theme-color", atom::ToRGBHex(theme_color));
-  } else {
-    Emit("did-change-theme-color", nullptr);
-  }
-}
-
-void WebContents::DocumentLoadedInFrame(
-    content::RenderFrameHost* render_frame_host) {
-  if (!render_frame_host->GetParent())
-    Emit("dom-ready");
-}
-
-void WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,
-                                const GURL& validated_url) {
-  bool is_main_frame = !render_frame_host->GetParent();
-  int frame_process_id = render_frame_host->GetProcess()->GetID();
-  int frame_routing_id = render_frame_host->GetRoutingID();
-  Emit("did-frame-finish-load", is_main_frame, frame_process_id,
-       frame_routing_id);
-
-  if (is_main_frame)
-    Emit("did-finish-load");
-}
-
-void WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,
-                              const GURL& url,
-                              int error_code,
-                              const base::string16& error_description) {
-  bool is_main_frame = !render_frame_host->GetParent();
-  int frame_process_id = render_frame_host->GetProcess()->GetID();
-  int frame_routing_id = render_frame_host->GetRoutingID();
-  Emit("did-fail-load", error_code, error_description, url, is_main_frame,
-       frame_process_id, frame_routing_id);
-}
-
-void WebContents::DidStartLoading() {
-  Emit("did-start-loading");
-}
-
-void WebContents::DidStopLoading() {
-  Emit("did-stop-loading");
-}
-
-void WebContents::DidStartNavigation(
-    content::NavigationHandle* navigation_handle) {
-  bool is_main_frame = navigation_handle->IsInMainFrame();
-  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();
-  content::FrameTreeNode* frame_tree_node =
-      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);
-  content::RenderFrameHostManager* render_manager =
-      frame_tree_node->render_manager();
-  content::RenderFrameHost* frame_host = nullptr;
-  if (render_manager) {
-    frame_host = render_manager->speculative_frame_host();
-    if (!frame_host)
-      frame_host = render_manager->current_frame_host();
-  }
-  int frame_process_id = -1, frame_routing_id = -1;
-  if (frame_host) {
-    frame_process_id = frame_host->GetProcess()->GetID();
-    frame_routing_id = frame_host->GetRoutingID();
-  }
-  bool is_same_document = navigation_handle->IsSameDocument();
-  auto url = navigation_handle->GetURL();
-  Emit("did-start-navigation", url, is_same_document, is_main_frame,
-       frame_process_id, frame_routing_id);
-}
-
-void WebContents::DidFinishNavigation(
-    content::NavigationHandle* navigation_handle) {
-  if (!navigation_handle->HasCommitted())
-    return;
-  bool is_main_frame = navigation_handle->IsInMainFrame();
-  content::RenderFrameHost* frame_host =
-      navigation_handle->GetRenderFrameHost();
-  int frame_process_id = -1, frame_routing_id = -1;
-  if (frame_host) {
-    frame_process_id = frame_host->GetProcess()->GetID();
-    frame_routing_id = frame_host->GetRoutingID();
-  }
-  if (!navigation_handle->IsErrorPage()) {
-    auto url = navigation_handle->GetURL();
-    bool is_same_document = navigation_handle->IsSameDocument();
-    if (is_same_document) {
-      Emit("did-navigate-in-page", url, is_main_frame, frame_process_id,
-           frame_routing_id);
-    } else {
-      const net::HttpResponseHeaders* http_response =
-          navigation_handle->GetResponseHeaders();
-      std::string http_status_text;
-      int http_response_code = -1;
-      if (http_response) {
-        http_status_text = http_response->GetStatusText();
-        http_response_code = http_response->response_code();
-      }
-      Emit("did-frame-navigate", url, http_response_code, http_status_text,
-           is_main_frame, frame_process_id, frame_routing_id);
-      if (is_main_frame) {
-        Emit("did-navigate", url, http_response_code, http_status_text);
-      }
-    }
-    if (IsGuest())
-      Emit("load-commit", url, is_main_frame);
-  } else {
-    auto url = navigation_handle->GetURL();
-    int code = navigation_handle->GetNetErrorCode();
-    auto description = net::ErrorToShortString(code);
-    Emit("did-fail-provisional-load", code, description, url, is_main_frame,
-         frame_process_id, frame_routing_id);
-
-    // Do not emit "did-fail-load" for canceled requests.
-    if (code != net::ERR_ABORTED)
-      Emit("did-fail-load", code, description, url, is_main_frame,
-           frame_process_id, frame_routing_id);
-  }
-}
-
-void WebContents::TitleWasSet(content::NavigationEntry* entry) {
-  base::string16 final_title;
-  bool explicit_set = true;
-  if (entry) {
-    auto title = entry->GetTitle();
-    auto url = entry->GetURL();
-    if (url.SchemeIsFile() && title.empty()) {
-      final_title = base::UTF8ToUTF16(url.ExtractFileName());
-      explicit_set = false;
-    } else {
-      final_title = title;
-    }
-  }
-  Emit("page-title-updated", final_title, explicit_set);
-}
-
-void WebContents::DidUpdateFaviconURL(
-    const std::vector<content::FaviconURL>& urls) {
-  std::set<GURL> unique_urls;
-  for (const auto& iter : urls) {
-    if (iter.icon_type != content::FaviconURL::IconType::kFavicon)
-      continue;
-    const GURL& url = iter.icon_url;
-    if (url.is_valid())
-      unique_urls.insert(url);
-  }
-  Emit("page-favicon-updated", unique_urls);
-}
-
-void WebContents::DevToolsReloadPage() {
-  Emit("devtools-reload-page");
-}
-
-void WebContents::DevToolsFocused() {
-  Emit("devtools-focused");
-}
-
-void WebContents::DevToolsOpened() {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto handle = WebContents::CreateFrom(
-      isolate(), managed_web_contents()->GetDevToolsWebContents());
-  devtools_web_contents_.Reset(isolate(), handle.ToV8());
-
-  // Set inspected tabID.
-  base::Value tab_id(ID());
-  managed_web_contents()->CallClientFunction("DevToolsAPI.setInspectedTabId",
-                                             &tab_id, nullptr, nullptr);
-
-  // Inherit owner window in devtools when it doesn't have one.
-  auto* devtools = managed_web_contents()->GetDevToolsWebContents();
-  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());
-  if (owner_window() && !has_window)
-    handle->SetOwnerWindow(devtools, owner_window());
-
-  Emit("devtools-opened");
-}
-
-void WebContents::DevToolsClosed() {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  devtools_web_contents_.Reset();
-
-  Emit("devtools-closed");
-}
-
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-void WebContents::ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                                    const gfx::RectF& bounds,
-                                    const std::vector<base::string16>& values,
-                                    const std::vector<base::string16>& labels) {
-  bool offscreen = IsOffScreen() || (embedder_ && embedder_->IsOffScreen());
-  gfx::RectF popup_bounds(bounds);
-  content::RenderFrameHost* embedder_frame_host = nullptr;
-  if (embedder_) {
-    auto* embedder_view = embedder_->web_contents()->GetMainFrame()->GetView();
-    auto* view = web_contents()->GetMainFrame()->GetView();
-    auto offset = view->GetViewBounds().origin() -
-                  embedder_view->GetViewBounds().origin();
-    popup_bounds.Offset(offset.x(), offset.y());
-    embedder_frame_host = embedder_->web_contents()->GetMainFrame();
-  }
-
-  CommonWebContentsDelegate::ShowAutofillPopup(
-      frame_host, embedder_frame_host, offscreen, popup_bounds, values, labels);
-}
-#endif
-
-bool WebContents::OnMessageReceived(const IPC::Message& message) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(WebContents, message)
-    IPC_MESSAGE_HANDLER_CODE(ViewHostMsg_SetCursor, OnCursorChange,
-                             handled = false)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-bool WebContents::OnMessageReceived(const IPC::Message& message,
-                                    content::RenderFrameHost* frame_host) {
-  bool handled = true;
-  FrameDispatchHelper helper = {this, frame_host};
-  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(WebContents, message, frame_host)
-    IPC_MESSAGE_HANDLER(AtomFrameHostMsg_Message, OnRendererMessage)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(AtomFrameHostMsg_Message_Sync, &helper,
-                                    FrameDispatchHelper::OnRendererMessageSync)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(
-        AtomFrameHostMsg_SetTemporaryZoomLevel, &helper,
-        FrameDispatchHelper::OnSetTemporaryZoomLevel)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(AtomFrameHostMsg_GetZoomLevel, &helper,
-                                    FrameDispatchHelper::OnGetZoomLevel)
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-    IPC_MESSAGE_HANDLER(AtomAutofillFrameHostMsg_ShowPopup, ShowAutofillPopup)
-    IPC_MESSAGE_HANDLER(AtomAutofillFrameHostMsg_HidePopup, HideAutofillPopup)
-#endif
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-// There are three ways of destroying a webContents:
-// 1. call webContents.destroy();
-// 2. garbage collection;
-// 3. user closes the window of webContents;
-// 4. the embedder detaches the frame.
-// For webview only #4 will happen, for BrowserWindow both #1 and #3 may
-// happen. The #2 should never happen for webContents, because webview is
-// managed by GuestViewManager, and BrowserWindow's webContents is managed
-// by api::BrowserWindow.
-// For #1, the destructor will do the cleanup work and we only need to make
-// sure "destroyed" event is emitted. For #3, the content::WebContents will
-// be destroyed on close, and WebContentsDestroyed would be called for it, so
-// we need to make sure the api::WebContents is also deleted.
-// For #4, the WebContents will be destroyed by embedder.
-void WebContents::WebContentsDestroyed() {
-  // Cleanup relationships with other parts.
-  RemoveFromWeakMap();
-
-  // We can not call Destroy here because we need to call Emit first, but we
-  // also do not want any method to be used, so just mark as destroyed here.
-  MarkDestroyed();
-
-  Emit("destroyed");
-
-  // For guest view based on OOPIF, the WebContents is released by the embedder
-  // frame, and we need to clear the reference to the memory.
-  if (IsGuest() && managed_web_contents()) {
-    managed_web_contents()->ReleaseWebContents();
-    ResetManagedWebContents(false);
-  }
-
-  // Destroy the native class in next tick.
-  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, GetDestroyClosure());
-}
-
-void WebContents::NavigationEntryCommitted(
-    const content::LoadCommittedDetails& details) {
-  Emit("navigation-entry-commited", details.entry->GetURL(),
-       details.is_same_document, details.did_replace_entry);
-}
-
-int WebContents::GetProcessID() const {
-  return web_contents()->GetMainFrame()->GetProcess()->GetID();
-}
-
-base::ProcessId WebContents::GetOSProcessID() const {
-  base::ProcessHandle process_handle =
-      web_contents()->GetMainFrame()->GetProcess()->GetHandle();
-  return base::GetProcId(process_handle);
-}
-
-WebContents::Type WebContents::GetType() const {
-  return type_;
-}
-
-bool WebContents::Equal(const WebContents* web_contents) const {
-  return ID() == web_contents->ID();
-}
-
-void WebContents::LoadURL(const GURL& url, const mate::Dictionary& options) {
-  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {
-    Emit("did-fail-load", static_cast<int>(net::ERR_INVALID_URL),
-         net::ErrorToShortString(net::ERR_INVALID_URL),
-         url.possibly_invalid_spec(), true);
-    return;
-  }
-
-  content::NavigationController::LoadURLParams params(url);
-
-  if (!options.Get("httpReferrer", &params.referrer)) {
-    GURL http_referrer;
-    if (options.Get("httpReferrer", &http_referrer))
-      params.referrer = content::Referrer(http_referrer.GetAsReferrer(),
-                                          blink::kWebReferrerPolicyDefault);
-  }
-
-  std::string user_agent;
-  if (options.Get("userAgent", &user_agent))
-    web_contents()->SetUserAgentOverride(user_agent);
-
-  std::string extra_headers;
-  if (options.Get("extraHeaders", &extra_headers))
-    params.extra_headers = extra_headers;
-
-  scoped_refptr<network::ResourceRequestBody> body;
-  if (options.Get("postData", &body)) {
-    params.post_data = body;
-    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;
-  }
-
-  GURL base_url_for_data_url;
-  if (options.Get("baseURLForDataURL", &base_url_for_data_url)) {
-    params.base_url_for_data_url = base_url_for_data_url;
-    params.load_type = content::NavigationController::LOAD_TYPE_DATA;
-  }
-
-  params.transition_type = ui::PAGE_TRANSITION_TYPED;
-  params.should_clear_history_list = true;
-  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
-  web_contents()->GetController().LoadURLWithParams(params);
-
-  // Set the background color of RenderWidgetHostView.
-  // We have to call it right after LoadURL because the RenderViewHost is only
-  // created after loading a page.
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (view) {
-    auto* web_preferences = WebContentsPreferences::From(web_contents());
-    std::string color_name;
-    if (web_preferences->GetPreference(options::kBackgroundColor,
-                                       &color_name)) {
-      view->SetBackgroundColor(ParseHexColor(color_name));
-    } else {
-      view->SetBackgroundColor(SK_ColorTRANSPARENT);
-    }
-  }
-}
-
-void WebContents::DownloadURL(const GURL& url) {
-  auto* browser_context = web_contents()->GetBrowserContext();
-  auto* download_manager =
-      content::BrowserContext::GetDownloadManager(browser_context);
-  std::unique_ptr<download::DownloadUrlParameters> download_params(
-      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(
-          web_contents(), url, NO_TRAFFIC_ANNOTATION_YET));
-  download_manager->DownloadUrl(std::move(download_params));
-}
-
-GURL WebContents::GetURL() const {
-  return web_contents()->GetURL();
-}
-
-base::string16 WebContents::GetTitle() const {
-  return web_contents()->GetTitle();
-}
-
-bool WebContents::IsLoading() const {
-  return web_contents()->IsLoading();
-}
-
-bool WebContents::IsLoadingMainFrame() const {
-  return web_contents()->IsLoadingToDifferentDocument();
-}
-
-bool WebContents::IsWaitingForResponse() const {
-  return web_contents()->IsWaitingForResponse();
-}
-
-void WebContents::Stop() {
-  web_contents()->Stop();
-}
-
-void WebContents::GoBack() {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoBack();
-}
-
-void WebContents::GoForward() {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoForward();
-}
-
-void WebContents::GoToOffset(int offset) {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoToOffset(offset);
-}
-
-const std::string WebContents::GetWebRTCIPHandlingPolicy() const {
-  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;
-}
-
-void WebContents::SetWebRTCIPHandlingPolicy(
-    const std::string& webrtc_ip_handling_policy) {
-  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)
-    return;
-  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =
-      webrtc_ip_handling_policy;
-
-  content::RenderViewHost* host = web_contents()->GetRenderViewHost();
-  if (host)
-    host->SyncRendererPrefs();
-}
-
-bool WebContents::IsCrashed() const {
-  return web_contents()->IsCrashed();
-}
-
-void WebContents::SetUserAgent(const std::string& user_agent,
-                               mate::Arguments* args) {
-  web_contents()->SetUserAgentOverride(user_agent);
-}
-
-std::string WebContents::GetUserAgent() {
-  return web_contents()->GetUserAgentOverride();
-}
-
-bool WebContents::SavePage(const base::FilePath& full_file_path,
-                           const content::SavePageType& save_type,
-                           const SavePageHandler::SavePageCallback& callback) {
-  auto* handler = new SavePageHandler(web_contents(), callback);
-  return handler->Handle(full_file_path, save_type);
-}
-
-void WebContents::OpenDevTools(mate::Arguments* args) {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  std::string state;
-  if (type_ == WEB_VIEW || !owner_window()) {
-    state = "detach";
-  }
-  if (args && args->Length() == 1) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("mode", &state);
-    }
-  }
-  managed_web_contents()->SetDockState(state);
-  managed_web_contents()->ShowDevTools();
-}
-
-void WebContents::CloseDevTools() {
-  if (type_ == REMOTE)
-    return;
-
-  managed_web_contents()->CloseDevTools();
-}
-
-bool WebContents::IsDevToolsOpened() {
-  if (type_ == REMOTE)
-    return false;
-
-  return managed_web_contents()->IsDevToolsViewShowing();
-}
-
-bool WebContents::IsDevToolsFocused() {
-  if (type_ == REMOTE)
-    return false;
-
-  return managed_web_contents()->GetView()->IsDevToolsViewFocused();
-}
-
-void WebContents::EnableDeviceEmulation(
-    const blink::WebDeviceEmulationParams& params) {
-  if (type_ == REMOTE)
-    return;
-
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    auto* widget_host =
-        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;
-    if (!widget_host)
-      return;
-    widget_host->Send(
-        new ViewMsg_EnableDeviceEmulation(widget_host->GetRoutingID(), params));
-  }
-}
-
-void WebContents::DisableDeviceEmulation() {
-  if (type_ == REMOTE)
-    return;
-
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    auto* widget_host =
-        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;
-    if (!widget_host)
-      return;
-    widget_host->Send(
-        new ViewMsg_DisableDeviceEmulation(widget_host->GetRoutingID()));
-  }
-}
-
-void WebContents::ToggleDevTools() {
-  if (IsDevToolsOpened())
-    CloseDevTools();
-  else
-    OpenDevTools(nullptr);
-}
-
-void WebContents::InspectElement(int x, int y) {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  if (!managed_web_contents()->GetDevToolsWebContents())
-    OpenDevTools(nullptr);
-  managed_web_contents()->InspectElement(x, y);
-}
-
-void WebContents::InspectServiceWorker() {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {
-    if (agent_host->GetType() ==
-        content::DevToolsAgentHost::kTypeServiceWorker) {
-      OpenDevTools(nullptr);
-      managed_web_contents()->AttachTo(agent_host);
-      break;
-    }
-  }
-}
-
-void WebContents::HasServiceWorker(const base::Callback<void(bool)>& callback) {
-  auto* context = GetServiceWorkerContext(web_contents());
-  if (!context)
-    return;
-
-  struct WrappedCallback {
-    base::Callback<void(bool)> callback_;
-    explicit WrappedCallback(const base::Callback<void(bool)>& callback)
-        : callback_(callback) {}
-    void Run(content::ServiceWorkerCapability capability) {
-      callback_.Run(capability !=
-                    content::ServiceWorkerCapability::NO_SERVICE_WORKER);
-      delete this;
-    }
-  };
-
-  auto* wrapped_callback = new WrappedCallback(callback);
-
-  context->CheckHasServiceWorker(
-      web_contents()->GetLastCommittedURL(), GURL::EmptyGURL(),
-      base::BindOnce(&WrappedCallback::Run,
-                     base::Unretained(wrapped_callback)));
-}
-
-void WebContents::UnregisterServiceWorker(
-    const base::Callback<void(bool)>& callback) {
-  auto* context = GetServiceWorkerContext(web_contents());
-  if (!context)
-    return;
-
-  context->UnregisterServiceWorker(web_contents()->GetLastCommittedURL(),
-                                   callback);
-}
-
-void WebContents::SetIgnoreMenuShortcuts(bool ignore) {
-  set_ignore_menu_shortcuts(ignore);
-}
-
-void WebContents::SetAudioMuted(bool muted) {
-  web_contents()->SetAudioMuted(muted);
-}
-
-bool WebContents::IsAudioMuted() {
-  return web_contents()->IsAudioMuted();
-}
-
-bool WebContents::IsCurrentlyAudible() {
-  return web_contents()->IsCurrentlyAudible();
-}
-
-void WebContents::Print(mate::Arguments* args) {
-  PrintSettings settings = {false, false, base::string16()};
-  if (args->Length() >= 1 && !args->GetNext(&settings)) {
-    args->ThrowError();
-    return;
-  }
-  auto* print_view_manager_basic_ptr =
-      printing::PrintViewManagerBasic::FromWebContents(web_contents());
-  if (args->Length() == 2) {
-    base::Callback<void(bool)> callback;
-    if (!args->GetNext(&callback)) {
-      args->ThrowError();
-      return;
-    }
-    print_view_manager_basic_ptr->SetCallback(callback);
-  }
-  print_view_manager_basic_ptr->PrintNow(
-      web_contents()->GetMainFrame(), settings.silent,
-      settings.print_background, settings.device_name);
-}
-
-std::vector<printing::PrinterBasicInfo> WebContents::GetPrinterList() {
-  std::vector<printing::PrinterBasicInfo> printers;
-  auto print_backend = printing::PrintBackend::CreateInstance(nullptr);
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  print_backend->EnumeratePrinters(&printers);
-  return printers;
-}
-
-void WebContents::PrintToPDF(const base::DictionaryValue& setting,
-                             const PrintToPDFCallback& callback) {
-  printing::PrintPreviewMessageHandler::FromWebContents(web_contents())
-      ->PrintToPDF(setting, callback);
-}
-
-void WebContents::AddWorkSpace(mate::Arguments* args,
-                               const base::FilePath& path) {
-  if (path.empty()) {
-    args->ThrowError("path cannot be empty");
-    return;
-  }
-  DevToolsAddFileSystem(path);
-}
-
-void WebContents::RemoveWorkSpace(mate::Arguments* args,
-                                  const base::FilePath& path) {
-  if (path.empty()) {
-    args->ThrowError("path cannot be empty");
-    return;
-  }
-  DevToolsRemoveFileSystem(path);
-}
-
-void WebContents::Undo() {
-  web_contents()->Undo();
-}
-
-void WebContents::Redo() {
-  web_contents()->Redo();
-}
-
-void WebContents::Cut() {
-  web_contents()->Cut();
-}
-
-void WebContents::Copy() {
-  web_contents()->Copy();
-}
-
-void WebContents::Paste() {
-  web_contents()->Paste();
-}
-
-void WebContents::PasteAndMatchStyle() {
-  web_contents()->PasteAndMatchStyle();
-}
-
-void WebContents::Delete() {
-  web_contents()->Delete();
-}
-
-void WebContents::SelectAll() {
-  web_contents()->SelectAll();
-}
-
-void WebContents::Unselect() {
-  web_contents()->CollapseSelection();
-}
-
-void WebContents::Replace(const base::string16& word) {
-  web_contents()->Replace(word);
-}
-
-void WebContents::ReplaceMisspelling(const base::string16& word) {
-  web_contents()->ReplaceMisspelling(word);
-}
-
-uint32_t WebContents::FindInPage(mate::Arguments* args) {
-  uint32_t request_id = GetNextRequestId();
-  base::string16 search_text;
-  blink::WebFindOptions options;
-  if (!args->GetNext(&search_text) || search_text.empty()) {
-    args->ThrowError("Must provide a non-empty search content");
-    return 0;
-  }
-
-  args->GetNext(&options);
-
-  web_contents()->Find(request_id, search_text, options);
-  return request_id;
-}
-
-void WebContents::StopFindInPage(content::StopFindAction action) {
-  web_contents()->StopFinding(action);
-}
-
-void WebContents::ShowDefinitionForSelection() {
-#if defined(OS_MACOSX)
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (view)
-    view->ShowDefinitionForSelection();
-#endif
-}
-
-void WebContents::CopyImageAt(int x, int y) {
-  auto* const host = web_contents()->GetMainFrame();
-  if (host)
-    host->CopyImageAt(x, y);
-}
-
-void WebContents::Focus() {
-  web_contents()->Focus();
-}
-
-#if !defined(OS_MACOSX)
-bool WebContents::IsFocused() const {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (!view)
-    return false;
-
-  if (GetType() != BACKGROUND_PAGE) {
-    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();
-    if (window && !window->IsVisible())
-      return false;
-  }
-
-  return view->HasFocus();
-}
-#endif
-
-void WebContents::TabTraverse(bool reverse) {
-  web_contents()->FocusThroughTabTraversal(reverse);
-}
-
-bool WebContents::SendIPCMessage(bool all_frames,
-                                 const base::string16& channel,
-                                 const base::ListValue& args) {
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    return frame_host->Send(new AtomFrameMsg_Message(
-        frame_host->GetRoutingID(), all_frames, channel, args));
-  }
-  return false;
-}
-
-void WebContents::SendInputEvent(v8::Isolate* isolate,
-                                 v8::Local<v8::Value> input_event) {
-  content::RenderWidgetHostView* view =
-      web_contents()->GetRenderWidgetHostView();
-  if (!view)
-    return;
-
-  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();
-  blink::WebInputEvent::Type type =
-      mate::GetWebInputEventType(isolate, input_event);
-  if (blink::WebInputEvent::IsMouseEventType(type)) {
-    blink::WebMouseEvent mouse_event;
-    if (mate::ConvertFromV8(isolate, input_event, &mouse_event)) {
-      if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);
-#endif
-      } else {
-        rwh->ForwardMouseEvent(mouse_event);
-      }
-      return;
-    }
-  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {
-    content::NativeWebKeyboardEvent keyboard_event(
-        blink::WebKeyboardEvent::kRawKeyDown,
-        blink::WebInputEvent::kNoModifiers, ui::EventTimeForNow());
-    if (mate::ConvertFromV8(isolate, input_event, &keyboard_event)) {
-      rwh->ForwardKeyboardEvent(keyboard_event);
-      return;
-    }
-  } else if (type == blink::WebInputEvent::kMouseWheel) {
-    blink::WebMouseWheelEvent mouse_wheel_event;
-    if (mate::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {
-      if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(
-            mouse_wheel_event);
-#endif
-      } else {
-        rwh->ForwardWheelEvent(mouse_wheel_event);
-      }
-      return;
-    }
-  }
-
-  isolate->ThrowException(
-      v8::Exception::Error(mate::StringToV8(isolate, "Invalid event object")));
-}
-
-void WebContents::BeginFrameSubscription(mate::Arguments* args) {
-  bool only_dirty = false;
-  FrameSubscriber::FrameCaptureCallback callback;
-
-  args->GetNext(&only_dirty);
-  if (!args->GetNext(&callback)) {
-    args->ThrowError();
-    return;
-  }
-
-  frame_subscriber_.reset(
-      new FrameSubscriber(isolate(), web_contents(), callback, only_dirty));
-}
-
-void WebContents::EndFrameSubscription() {
-  frame_subscriber_.reset();
-}
-
-void WebContents::StartDrag(const mate::Dictionary& item,
-                            mate::Arguments* args) {
-  base::FilePath file;
-  std::vector<base::FilePath> files;
-  if (!item.Get("files", &files) && item.Get("file", &file)) {
-    files.push_back(file);
-  }
-
-  mate::Handle<NativeImage> icon;
-  if (!item.Get("icon", &icon) && !file.empty()) {
-    // TODO(zcbenz): Set default icon from file.
-  }
-
-  // Error checking.
-  if (icon.IsEmpty()) {
-    args->ThrowError("Must specify 'icon' option");
-    return;
-  }
-
-#if defined(OS_MACOSX)
-  // NSWindow.dragImage requires a non-empty NSImage
-  if (icon->image().IsEmpty()) {
-    args->ThrowError("Must specify non-empty 'icon' option");
-    return;
-  }
-#endif
-
-  // Start dragging.
-  if (!files.empty()) {
-    base::MessageLoop::ScopedNestableTaskAllower allow(
-        base::MessageLoop::current());
-    DragFileItems(files, icon->image(), web_contents()->GetNativeView());
-  } else {
-    args->ThrowError("Must specify either 'file' or 'files' option");
-  }
-}
-
-void WebContents::CapturePage(mate::Arguments* args) {
-  gfx::Rect rect;
-  base::Callback<void(const gfx::Image&)> callback;
-
-  if (!(args->Length() == 1 && args->GetNext(&callback)) &&
-      !(args->Length() == 2 && args->GetNext(&rect) &&
-        args->GetNext(&callback))) {
-    args->ThrowError();
-    return;
-  }
-
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (!view) {
-    callback.Run(gfx::Image());
-    return;
-  }
-
-  // Capture full page if user doesn't specify a |rect|.
-  const gfx::Size view_size =
-      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();
-
-  // By default, the requested bitmap size is the view size in screen
-  // coordinates.  However, if there's more pixel detail available on the
-  // current system, increase the requested bitmap size to capture it all.
-  gfx::Size bitmap_size = view_size;
-  const gfx::NativeView native_view = view->GetNativeView();
-  const float scale = display::Screen::GetScreen()
-                          ->GetDisplayNearestView(native_view)
-                          .device_scale_factor();
-  if (scale > 1.0f)
-    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);
-
-  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,
-                        base::BindOnce(&OnCapturePageDone, callback));
-}
-
-void WebContents::OnCursorChange(const content::WebCursor& cursor) {
-  content::CursorInfo info;
-  cursor.GetCursorInfo(&info);
-
-  if (cursor.IsCustom()) {
-    Emit("cursor-changed", CursorTypeToString(info),
-         gfx::Image::CreateFrom1xBitmap(info.custom_image),
-         info.image_scale_factor,
-         gfx::Size(info.custom_image.width(), info.custom_image.height()),
-         info.hotspot);
-  } else {
-    Emit("cursor-changed", CursorTypeToString(info));
-  }
-}
-
-bool WebContents::IsGuest() const {
-  return type_ == WEB_VIEW;
-}
-
-void WebContents::AttachToIframe(content::WebContents* embedder_web_contents,
-                                 int embedder_frame_id) {
-  if (guest_delegate_)
-    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);
-}
-
-bool WebContents::IsOffScreen() const {
-#if defined(ENABLE_OSR)
-  return type_ == OFF_SCREEN;
-#else
-  return false;
-#endif
-}
-
-void WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {
-  Emit("paint", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));
-}
-
-void WebContents::StartPainting() {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetPainting(true);
-#endif
-}
-
-void WebContents::StopPainting() {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetPainting(false);
-#endif
-}
-
-bool WebContents::IsPainting() const {
-  if (!IsOffScreen())
-    return false;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  return osr_wcv && osr_wcv->IsPainting();
-#else
-  return false;
-#endif
-}
-
-void WebContents::SetFrameRate(int frame_rate) {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetFrameRate(frame_rate);
-#endif
-}
-
-int WebContents::GetFrameRate() const {
-  if (!IsOffScreen())
-    return 0;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  return osr_wcv ? osr_wcv->GetFrameRate() : 0;
-#else
-  return 0;
-#endif
-}
-
-void WebContents::Invalidate() {
-  if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();
-    if (osr_rwhv)
-      osr_rwhv->Invalidate();
-#endif
-  } else {
-    auto* const window = owner_window();
-    if (window)
-      window->Invalidate();
-  }
-}
-
-gfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) const {
-  if (IsOffScreen() && wc == web_contents()) {
-    auto* relay = NativeWindowRelay::FromWebContents(web_contents());
-    if (relay) {
-      return relay->window->GetSize();
-    }
-  }
-
-  return gfx::Size();
-}
-
-void WebContents::SetZoomLevel(double level) {
-  zoom_controller_->SetZoomLevel(level);
-}
-
-double WebContents::GetZoomLevel() const {
-  return zoom_controller_->GetZoomLevel();
-}
-
-void WebContents::SetZoomFactor(double factor) {
-  auto level = content::ZoomFactorToZoomLevel(factor);
-  SetZoomLevel(level);
-}
-
-double WebContents::GetZoomFactor() const {
-  auto level = GetZoomLevel();
-  return content::ZoomLevelToZoomFactor(level);
-}
-
-void WebContents::OnSetTemporaryZoomLevel(content::RenderFrameHost* rfh,
-                                          double level,
-                                          IPC::Message* reply_msg) {
-  zoom_controller_->SetTemporaryZoomLevel(level);
-  double new_level = zoom_controller_->GetZoomLevel();
-  AtomFrameHostMsg_SetTemporaryZoomLevel::WriteReplyParams(reply_msg,
-                                                           new_level);
-  rfh->Send(reply_msg);
-}
-
-void WebContents::OnGetZoomLevel(content::RenderFrameHost* rfh,
-                                 IPC::Message* reply_msg) {
-  AtomFrameHostMsg_GetZoomLevel::WriteReplyParams(reply_msg, GetZoomLevel());
-  rfh->Send(reply_msg);
-}
-
-v8::Local<v8::Value> WebContents::GetPreloadPath(v8::Isolate* isolate) const {
-  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {
-    base::FilePath::StringType preload;
-    if (web_preferences->GetPreloadPath(&preload)) {
-      return mate::ConvertToV8(isolate, preload);
-    }
-  }
-  return v8::Null(isolate);
-}
-
-v8::Local<v8::Value> WebContents::GetWebPreferences(
-    v8::Isolate* isolate) const {
-  auto* web_preferences = WebContentsPreferences::From(web_contents());
-  if (!web_preferences)
-    return v8::Null(isolate);
-  return mate::ConvertToV8(isolate, *web_preferences->preference());
-}
-
-v8::Local<v8::Value> WebContents::GetLastWebPreferences(
-    v8::Isolate* isolate) const {
-  auto* web_preferences = WebContentsPreferences::From(web_contents());
-  if (!web_preferences)
-    return v8::Null(isolate);
-  return mate::ConvertToV8(isolate, *web_preferences->last_preference());
-}
-
-v8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() const {
-  if (owner_window())
-    return BrowserWindow::From(isolate(), owner_window());
-  else
-    return v8::Null(isolate());
-}
-
-int32_t WebContents::ID() const {
-  return weak_map_id();
-}
-
-v8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {
-  return v8::Local<v8::Value>::New(isolate, session_);
-}
-
-content::WebContents* WebContents::HostWebContents() {
-  if (!embedder_)
-    return nullptr;
-  return embedder_->web_contents();
-}
-
-void WebContents::SetEmbedder(const WebContents* embedder) {
-  if (embedder) {
-    NativeWindow* owner_window = nullptr;
-    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());
-    if (relay) {
-      owner_window = relay->window.get();
-    }
-    if (owner_window)
-      SetOwnerWindow(owner_window);
-
-    content::RenderWidgetHostView* rwhv =
-        web_contents()->GetRenderWidgetHostView();
-    if (rwhv) {
-      rwhv->Hide();
-      rwhv->Show();
-    }
-  }
-}
-
-void WebContents::SetDevToolsWebContents(const WebContents* devtools) {
-  if (managed_web_contents())
-    managed_web_contents()->SetDevToolsWebContents(devtools->web_contents());
-}
-
-v8::Local<v8::Value> WebContents::GetNativeView() const {
-  gfx::NativeView ptr = web_contents()->GetNativeView();
-  auto buffer = node::Buffer::Copy(isolate(), reinterpret_cast<char*>(&ptr),
-                                   sizeof(gfx::NativeView));
-  if (buffer.IsEmpty())
-    return v8::Null(isolate());
-  else
-    return buffer.ToLocalChecked();
-}
-
-v8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {
-  if (devtools_web_contents_.IsEmpty())
-    return v8::Null(isolate);
-  else
-    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);
-}
-
-v8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {
-  if (debugger_.IsEmpty()) {
-    auto handle = atom::api::Debugger::Create(isolate, web_contents());
-    debugger_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, debugger_);
-}
-
-void WebContents::GrantOriginAccess(const GURL& url) {
-  content::ChildProcessSecurityPolicy::GetInstance()->GrantOrigin(
-      web_contents()->GetMainFrame()->GetProcess()->GetID(),
-      url::Origin::Create(url));
-}
-
-// static
-void WebContents::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebContents"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("getProcessId", &WebContents::GetProcessID)
-      .SetMethod("getOSProcessId", &WebContents::GetOSProcessID)
-      .SetMethod("equal", &WebContents::Equal)
-      .SetMethod("_loadURL", &WebContents::LoadURL)
-      .SetMethod("downloadURL", &WebContents::DownloadURL)
-      .SetMethod("_getURL", &WebContents::GetURL)
-      .SetMethod("getTitle", &WebContents::GetTitle)
-      .SetMethod("isLoading", &WebContents::IsLoading)
-      .SetMethod("isLoadingMainFrame", &WebContents::IsLoadingMainFrame)
-      .SetMethod("isWaitingForResponse", &WebContents::IsWaitingForResponse)
-      .SetMethod("_stop", &WebContents::Stop)
-      .SetMethod("_goBack", &WebContents::GoBack)
-      .SetMethod("_goForward", &WebContents::GoForward)
-      .SetMethod("_goToOffset", &WebContents::GoToOffset)
-      .SetMethod("isCrashed", &WebContents::IsCrashed)
-      .SetMethod("setUserAgent", &WebContents::SetUserAgent)
-      .SetMethod("getUserAgent", &WebContents::GetUserAgent)
-      .SetMethod("savePage", &WebContents::SavePage)
-      .SetMethod("openDevTools", &WebContents::OpenDevTools)
-      .SetMethod("closeDevTools", &WebContents::CloseDevTools)
-      .SetMethod("isDevToolsOpened", &WebContents::IsDevToolsOpened)
-      .SetMethod("isDevToolsFocused", &WebContents::IsDevToolsFocused)
-      .SetMethod("enableDeviceEmulation", &WebContents::EnableDeviceEmulation)
-      .SetMethod("disableDeviceEmulation", &WebContents::DisableDeviceEmulation)
-      .SetMethod("toggleDevTools", &WebContents::ToggleDevTools)
-      .SetMethod("inspectElement", &WebContents::InspectElement)
-      .SetMethod("setIgnoreMenuShortcuts", &WebContents::SetIgnoreMenuShortcuts)
-      .SetMethod("setAudioMuted", &WebContents::SetAudioMuted)
-      .SetMethod("isAudioMuted", &WebContents::IsAudioMuted)
-      .SetMethod("isCurrentlyAudible", &WebContents::IsCurrentlyAudible)
-      .SetMethod("undo", &WebContents::Undo)
-      .SetMethod("redo", &WebContents::Redo)
-      .SetMethod("cut", &WebContents::Cut)
-      .SetMethod("copy", &WebContents::Copy)
-      .SetMethod("paste", &WebContents::Paste)
-      .SetMethod("pasteAndMatchStyle", &WebContents::PasteAndMatchStyle)
-      .SetMethod("delete", &WebContents::Delete)
-      .SetMethod("selectAll", &WebContents::SelectAll)
-      .SetMethod("unselect", &WebContents::Unselect)
-      .SetMethod("replace", &WebContents::Replace)
-      .SetMethod("replaceMisspelling", &WebContents::ReplaceMisspelling)
-      .SetMethod("findInPage", &WebContents::FindInPage)
-      .SetMethod("stopFindInPage", &WebContents::StopFindInPage)
-      .SetMethod("focus", &WebContents::Focus)
-      .SetMethod("isFocused", &WebContents::IsFocused)
-      .SetMethod("tabTraverse", &WebContents::TabTraverse)
-      .SetMethod("_send", &WebContents::SendIPCMessage)
-      .SetMethod("sendInputEvent", &WebContents::SendInputEvent)
-      .SetMethod("beginFrameSubscription", &WebContents::BeginFrameSubscription)
-      .SetMethod("endFrameSubscription", &WebContents::EndFrameSubscription)
-      .SetMethod("startDrag", &WebContents::StartDrag)
-      .SetMethod("isGuest", &WebContents::IsGuest)
-      .SetMethod("attachToIframe", &WebContents::AttachToIframe)
-      .SetMethod("isOffscreen", &WebContents::IsOffScreen)
-      .SetMethod("startPainting", &WebContents::StartPainting)
-      .SetMethod("stopPainting", &WebContents::StopPainting)
-      .SetMethod("isPainting", &WebContents::IsPainting)
-      .SetMethod("setFrameRate", &WebContents::SetFrameRate)
-      .SetMethod("getFrameRate", &WebContents::GetFrameRate)
-      .SetMethod("invalidate", &WebContents::Invalidate)
-      .SetMethod("setZoomLevel", &WebContents::SetZoomLevel)
-      .SetMethod("_getZoomLevel", &WebContents::GetZoomLevel)
-      .SetMethod("setZoomFactor", &WebContents::SetZoomFactor)
-      .SetMethod("_getZoomFactor", &WebContents::GetZoomFactor)
-      .SetMethod("getType", &WebContents::GetType)
-      .SetMethod("_getPreloadPath", &WebContents::GetPreloadPath)
-      .SetMethod("getWebPreferences", &WebContents::GetWebPreferences)
-      .SetMethod("getLastWebPreferences", &WebContents::GetLastWebPreferences)
-      .SetMethod("getOwnerBrowserWindow", &WebContents::GetOwnerBrowserWindow)
-      .SetMethod("hasServiceWorker", &WebContents::HasServiceWorker)
-      .SetMethod("unregisterServiceWorker",
-                 &WebContents::UnregisterServiceWorker)
-      .SetMethod("inspectServiceWorker", &WebContents::InspectServiceWorker)
-      .SetMethod("print", &WebContents::Print)
-      .SetMethod("getPrinters", &WebContents::GetPrinterList)
-      .SetMethod("_printToPDF", &WebContents::PrintToPDF)
-      .SetMethod("addWorkSpace", &WebContents::AddWorkSpace)
-      .SetMethod("removeWorkSpace", &WebContents::RemoveWorkSpace)
-      .SetMethod("showDefinitionForSelection",
-                 &WebContents::ShowDefinitionForSelection)
-      .SetMethod("copyImageAt", &WebContents::CopyImageAt)
-      .SetMethod("capturePage", &WebContents::CapturePage)
-      .SetMethod("setEmbedder", &WebContents::SetEmbedder)
-      .SetMethod("setDevToolsWebContents", &WebContents::SetDevToolsWebContents)
-      .SetMethod("getNativeView", &WebContents::GetNativeView)
-      .SetMethod("setWebRTCIPHandlingPolicy",
-                 &WebContents::SetWebRTCIPHandlingPolicy)
-      .SetMethod("getWebRTCIPHandlingPolicy",
-                 &WebContents::GetWebRTCIPHandlingPolicy)
-      .SetMethod("_grantOriginAccess", &WebContents::GrantOriginAccess)
-      .SetProperty("id", &WebContents::ID)
-      .SetProperty("session", &WebContents::Session)
-      .SetProperty("hostWebContents", &WebContents::HostWebContents)
-      .SetProperty("devToolsWebContents", &WebContents::DevToolsWebContents)
-      .SetProperty("debugger", &WebContents::Debugger);
-}
-
-AtomBrowserContext* WebContents::GetBrowserContext() const {
-  return static_cast<AtomBrowserContext*>(web_contents()->GetBrowserContext());
-}
-
-void WebContents::OnRendererMessage(content::RenderFrameHost* frame_host,
-                                    const base::string16& channel,
-                                    const base::ListValue& args) {
-  // webContents.emit(channel, new Event(), args...);
-  Emit(base::UTF16ToUTF8(channel), args);
-}
-
-void WebContents::OnRendererMessageSync(content::RenderFrameHost* frame_host,
-                                        const base::string16& channel,
-                                        const base::ListValue& args,
-                                        IPC::Message* message) {
-  // webContents.emit(channel, new Event(sender, message), args...);
-  EmitWithSender(base::UTF16ToUTF8(channel), frame_host, message, args);
-}
-
-// static
-mate::Handle<WebContents> WebContents::CreateFrom(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents) {
-  // We have an existing WebContents object in JS.
-  auto* existing = TrackableObject::FromWrappedClass(isolate, web_contents);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<WebContents*>(existing));
-
-  // Otherwise create a new WebContents wrapper object.
-  return mate::CreateHandle(isolate,
-                            new WebContents(isolate, web_contents, REMOTE));
-}
-
-mate::Handle<WebContents> WebContents::CreateFrom(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents,
-    Type type) {
-  // Otherwise create a new WebContents wrapper object.
-  return mate::CreateHandle(isolate,
-                            new WebContents(isolate, web_contents, type));
-}
-
-// static
-mate::Handle<WebContents> WebContents::Create(v8::Isolate* isolate,
-                                              const mate::Dictionary& options) {
-  return mate::CreateHandle(isolate, new WebContents(isolate, options));
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::WebContents;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("WebContents", WebContents::GetConstructor(isolate)->GetFunction());
-  dict.SetMethod("create", &WebContents::Create);
-  dict.SetMethod("fromId", &mate::TrackableObject<WebContents>::FromWeakMapID);
-  dict.SetMethod("getAllWebContents",
-                 &mate::TrackableObject<WebContents>::GetAll);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_web_contents, Initialize)
removed in remote
  base   100644 b734dc304dffc731456fcdf519ad0448eca6695a atom/browser/api/atom_api_web_contents.h
  our    100644 7939f8268aa8c3371623e0c15f3b6001d7f1efa4 atom/browser/api/atom_api_web_contents.h
@@ -1,473 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
-#define ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/frame_subscriber.h"
-#include "atom/browser/api/save_page_handler.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/common_web_contents_delegate.h"
-#include "atom/browser/ui/autofill_popup.h"
-#include "base/observer_list.h"
-#include "content/common/cursors/webcursor.h"
-#include "content/public/browser/keyboard_event_processing_result.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/web_contents_observer.h"
-#include "content/public/common/favicon_url.h"
-#include "native_mate/handle.h"
-#include "printing/backend/print_backend.h"
-#include "ui/gfx/image/image.h"
-
-namespace blink {
-struct WebDeviceEmulationParams;
-}
-
-namespace brightray {
-class InspectableWebContents;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace network {
-class ResourceRequestBody;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-class AtomJavaScriptDialogManager;
-class WebContentsZoomController;
-class WebViewGuestDelegate;
-class FrameSubscriber;
-
-#if defined(ENABLE_OSR)
-class OffScreenWebContentsView;
-class OffScreenRenderWidgetHostView;
-#endif
-
-namespace api {
-
-// Certain events are only in WebContentsDelegate, provide our own Observer to
-// dispatch those events.
-class ExtendedWebContentsObserver {
- public:
-  virtual void OnCloseContents() {}
-  virtual void OnRendererResponsive() {}
-};
-
-// Wrapper around the content::WebContents.
-class WebContents : public mate::TrackableObject<WebContents>,
-                    public CommonWebContentsDelegate,
-                    public content::WebContentsObserver {
- public:
-  enum Type {
-    BACKGROUND_PAGE,  // A DevTools extension background page.
-    BROWSER_WINDOW,   // Used by BrowserWindow.
-    BROWSER_VIEW,     // Used by BrowserView.
-    REMOTE,           // Thin wrap around an existing WebContents.
-    WEB_VIEW,         // Used by <webview>.
-    OFF_SCREEN,       // Used for offscreen rendering
-  };
-
-  // For node.js callback function type: function(error, buffer)
-  using PrintToPDFCallback =
-      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
-
-  // Create from an existing WebContents.
-  static mate::Handle<WebContents> CreateFrom(
-      v8::Isolate* isolate,
-      content::WebContents* web_contents);
-  static mate::Handle<WebContents> CreateFrom(
-      v8::Isolate* isolate,
-      content::WebContents* web_contents,
-      Type type);
-
-  // Create a new WebContents.
-  static mate::Handle<WebContents> Create(v8::Isolate* isolate,
-                                          const mate::Dictionary& options);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Notifies to destroy any guest web contents before destroying self.
-  void DestroyWebContents(bool async);
-
-  int GetProcessID() const;
-  base::ProcessId GetOSProcessID() const;
-  Type GetType() const;
-  bool Equal(const WebContents* web_contents) const;
-  void LoadURL(const GURL& url, const mate::Dictionary& options);
-  void DownloadURL(const GURL& url);
-  GURL GetURL() const;
-  base::string16 GetTitle() const;
-  bool IsLoading() const;
-  bool IsLoadingMainFrame() const;
-  bool IsWaitingForResponse() const;
-  void Stop();
-  void ReloadIgnoringCache();
-  void GoBack();
-  void GoForward();
-  void GoToOffset(int offset);
-  const std::string GetWebRTCIPHandlingPolicy() const;
-  void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);
-  bool IsCrashed() const;
-  void SetUserAgent(const std::string& user_agent, mate::Arguments* args);
-  std::string GetUserAgent();
-  void InsertCSS(const std::string& css);
-  bool SavePage(const base::FilePath& full_file_path,
-                const content::SavePageType& save_type,
-                const SavePageHandler::SavePageCallback& callback);
-  void OpenDevTools(mate::Arguments* args);
-  void CloseDevTools();
-  bool IsDevToolsOpened();
-  bool IsDevToolsFocused();
-  void ToggleDevTools();
-  void EnableDeviceEmulation(const blink::WebDeviceEmulationParams& params);
-  void DisableDeviceEmulation();
-  void InspectElement(int x, int y);
-  void InspectServiceWorker();
-  void HasServiceWorker(const base::Callback<void(bool)>&);
-  void UnregisterServiceWorker(const base::Callback<void(bool)>&);
-  void SetIgnoreMenuShortcuts(bool ignore);
-  void SetAudioMuted(bool muted);
-  bool IsAudioMuted();
-  bool IsCurrentlyAudible();
-  void Print(mate::Arguments* args);
-  std::vector<printing::PrinterBasicInfo> GetPrinterList();
-  void SetEmbedder(const WebContents* embedder);
-  void SetDevToolsWebContents(const WebContents* devtools);
-  v8::Local<v8::Value> GetNativeView() const;
-
-  // Print current page as PDF.
-  void PrintToPDF(const base::DictionaryValue& setting,
-                  const PrintToPDFCallback& callback);
-
-  // DevTools workspace api.
-  void AddWorkSpace(mate::Arguments* args, const base::FilePath& path);
-  void RemoveWorkSpace(mate::Arguments* args, const base::FilePath& path);
-
-  // Editing commands.
-  void Undo();
-  void Redo();
-  void Cut();
-  void Copy();
-  void Paste();
-  void PasteAndMatchStyle();
-  void Delete();
-  void SelectAll();
-  void Unselect();
-  void Replace(const base::string16& word);
-  void ReplaceMisspelling(const base::string16& word);
-  uint32_t FindInPage(mate::Arguments* args);
-  void StopFindInPage(content::StopFindAction action);
-  void ShowDefinitionForSelection();
-  void CopyImageAt(int x, int y);
-
-  // Focus.
-  void Focus();
-  bool IsFocused() const;
-  void TabTraverse(bool reverse);
-
-  // Send messages to browser.
-  bool SendIPCMessage(bool all_frames,
-                      const base::string16& channel,
-                      const base::ListValue& args);
-
-  // Send WebInputEvent to the page.
-  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);
-
-  // Subscribe to the frame updates.
-  void BeginFrameSubscription(mate::Arguments* args);
-  void EndFrameSubscription();
-
-  // Dragging native items.
-  void StartDrag(const mate::Dictionary& item, mate::Arguments* args);
-
-  // Captures the page with |rect|, |callback| would be called when capturing is
-  // done.
-  void CapturePage(mate::Arguments* args);
-
-  // Methods for creating <webview>.
-  bool IsGuest() const;
-  void AttachToIframe(content::WebContents* embedder_web_contents,
-                      int embedder_frame_id);
-
-  // Methods for offscreen rendering
-  bool IsOffScreen() const;
-  void OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap);
-  void StartPainting();
-  void StopPainting();
-  bool IsPainting() const;
-  void SetFrameRate(int frame_rate);
-  int GetFrameRate() const;
-  void Invalidate();
-  gfx::Size GetSizeForNewRenderView(content::WebContents*) const override;
-
-  // Methods for zoom handling.
-  void SetZoomLevel(double level);
-  double GetZoomLevel() const;
-  void SetZoomFactor(double factor);
-  double GetZoomFactor() const;
-
-  // Callback triggered on permission response.
-  void OnEnterFullscreenModeForTab(content::WebContents* source,
-                                   const GURL& origin,
-                                   bool allowed);
-
-  // Create window with the given disposition.
-  void OnCreateWindow(const GURL& target_url,
-                      const content::Referrer& referrer,
-                      const std::string& frame_name,
-                      WindowOpenDisposition disposition,
-                      const std::vector<std::string>& features,
-                      const scoped_refptr<network::ResourceRequestBody>& body);
-
-  // Returns the preload script path of current WebContents.
-  v8::Local<v8::Value> GetPreloadPath(v8::Isolate* isolate) const;
-
-  // Returns the web preferences of current WebContents.
-  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate) const;
-  v8::Local<v8::Value> GetLastWebPreferences(v8::Isolate* isolate) const;
-
-  // Returns the owner window.
-  v8::Local<v8::Value> GetOwnerBrowserWindow() const;
-
-  // Grants the child process the capability to access URLs with the origin of
-  // the specified URL.
-  void GrantOriginAccess(const GURL& url);
-
-  // Properties.
-  int32_t ID() const;
-  v8::Local<v8::Value> Session(v8::Isolate* isolate);
-  content::WebContents* HostWebContents();
-  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);
-  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);
-
-  WebContentsZoomController* GetZoomController() { return zoom_controller_; }
-
-  void AddObserver(ExtendedWebContentsObserver* obs) {
-    observers_.AddObserver(obs);
-  }
-  void RemoveObserver(ExtendedWebContentsObserver* obs) {
-    observers_.RemoveObserver(obs);
-  }
-
- protected:
-  WebContents(v8::Isolate* isolate,
-              content::WebContents* web_contents,
-              Type type);
-  WebContents(v8::Isolate* isolate, const mate::Dictionary& options);
-  ~WebContents() override;
-
-  void InitWithSessionAndOptions(v8::Isolate* isolate,
-                                 content::WebContents* web_contents,
-                                 mate::Handle<class Session> session,
-                                 const mate::Dictionary& options);
-
-  // content::WebContentsDelegate:
-  bool DidAddMessageToConsole(content::WebContents* source,
-                              int32_t level,
-                              const base::string16& message,
-                              int32_t line_no,
-                              const base::string16& source_id) override;
-  void WebContentsCreated(content::WebContents* source_contents,
-                          int opener_render_process_id,
-                          int opener_render_frame_id,
-                          const std::string& frame_name,
-                          const GURL& target_url,
-                          content::WebContents* new_contents) override;
-  void AddNewContents(content::WebContents* source,
-                      content::WebContents* new_contents,
-                      WindowOpenDisposition disposition,
-                      const gfx::Rect& initial_rect,
-                      bool user_gesture,
-                      bool* was_blocked) override;
-  content::WebContents* OpenURLFromTab(
-      content::WebContents* source,
-      const content::OpenURLParams& params) override;
-  void BeforeUnloadFired(content::WebContents* tab,
-                         bool proceed,
-                         bool* proceed_to_fire_unload) override;
-  void MoveContents(content::WebContents* source,
-                    const gfx::Rect& pos) override;
-  void CloseContents(content::WebContents* source) override;
-  void ActivateContents(content::WebContents* contents) override;
-  void UpdateTargetURL(content::WebContents* source, const GURL& url) override;
-  bool IsPopupOrPanel(const content::WebContents* source) const override;
-  void HandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-  void EnterFullscreenModeForTab(content::WebContents* source,
-                                 const GURL& origin) override;
-  void ExitFullscreenModeForTab(content::WebContents* source) override;
-  void RendererUnresponsive(
-      content::WebContents* source,
-      content::RenderWidgetHost* render_widget_host) override;
-  void RendererResponsive(
-      content::WebContents* source,
-      content::RenderWidgetHost* render_widget_host) override;
-  bool HandleContextMenu(const content::ContextMenuParams& params) override;
-  bool OnGoToEntryOffset(int offset) override;
-  void FindReply(content::WebContents* web_contents,
-                 int request_id,
-                 int number_of_matches,
-                 const gfx::Rect& selection_rect,
-                 int active_match_ordinal,
-                 bool final_update) override;
-  bool CheckMediaAccessPermission(content::WebContents* web_contents,
-                                  const GURL& security_origin,
-                                  content::MediaStreamType type) override;
-  void RequestMediaAccessPermission(
-      content::WebContents* web_contents,
-      const content::MediaStreamRequest& request,
-      const content::MediaResponseCallback& callback) override;
-  void RequestToLockMouse(content::WebContents* web_contents,
-                          bool user_gesture,
-                          bool last_unlocked_by_target) override;
-  std::unique_ptr<content::BluetoothChooser> RunBluetoothChooser(
-      content::RenderFrameHost* frame,
-      const content::BluetoothChooser::EventHandler& handler) override;
-  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
-      content::WebContents* source) override;
-
-  // content::WebContentsObserver:
-  void BeforeUnloadFired(const base::TimeTicks& proceed_time) override;
-  void RenderViewCreated(content::RenderViewHost*) override;
-  void RenderViewDeleted(content::RenderViewHost*) override;
-  void RenderProcessGone(base::TerminationStatus status) override;
-  void DocumentLoadedInFrame(
-      content::RenderFrameHost* render_frame_host) override;
-  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
-                     const GURL& validated_url) override;
-  void DidFailLoad(content::RenderFrameHost* render_frame_host,
-                   const GURL& validated_url,
-                   int error_code,
-                   const base::string16& error_description) override;
-  void DidStartLoading() override;
-  void DidStopLoading() override;
-  void DidStartNavigation(
-      content::NavigationHandle* navigation_handle) override;
-  void DidFinishNavigation(
-      content::NavigationHandle* navigation_handle) override;
-  bool OnMessageReceived(const IPC::Message& message) override;
-  bool OnMessageReceived(const IPC::Message& message,
-                         content::RenderFrameHost* frame_host) override;
-  void WebContentsDestroyed() override;
-  void NavigationEntryCommitted(
-      const content::LoadCommittedDetails& load_details) override;
-  void TitleWasSet(content::NavigationEntry* entry) override;
-  void DidUpdateFaviconURL(
-      const std::vector<content::FaviconURL>& urls) override;
-  void PluginCrashed(const base::FilePath& plugin_path,
-                     base::ProcessId plugin_pid) override;
-  void MediaStartedPlaying(const MediaPlayerInfo& video_type,
-                           const MediaPlayerId& id) override;
-  void MediaStoppedPlaying(
-      const MediaPlayerInfo& video_type,
-      const MediaPlayerId& id,
-      content::WebContentsObserver::MediaStoppedReason reason) override;
-  void DidChangeThemeColor(SkColor theme_color) override;
-
-  // brightray::InspectableWebContentsDelegate:
-  void DevToolsReloadPage() override;
-
-  // brightray::InspectableWebContentsViewDelegate:
-  void DevToolsFocused() override;
-  void DevToolsOpened() override;
-  void DevToolsClosed() override;
-
-#if defined(TOOLKIT_VIEWS)
-  void ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                         const gfx::RectF& bounds,
-                         const std::vector<base::string16>& values,
-                         const std::vector<base::string16>& labels);
-#endif
-
- private:
-  struct FrameDispatchHelper;
-  AtomBrowserContext* GetBrowserContext() const;
-
-  uint32_t GetNextRequestId() { return ++request_id_; }
-
-#if defined(ENABLE_OSR)
-  OffScreenWebContentsView* GetOffScreenWebContentsView() const;
-  OffScreenRenderWidgetHostView* GetOffScreenRenderWidgetHostView() const;
-#endif
-
-  // Called when we receive a CursorChange message from chromium.
-  void OnCursorChange(const content::WebCursor& cursor);
-
-  // Called when received a message from renderer.
-  void OnRendererMessage(content::RenderFrameHost* frame_host,
-                         const base::string16& channel,
-                         const base::ListValue& args);
-
-  // Called when received a synchronous message from renderer.
-  void OnRendererMessageSync(content::RenderFrameHost* frame_host,
-                             const base::string16& channel,
-                             const base::ListValue& args,
-                             IPC::Message* message);
-
-  // Called when received a synchronous message from renderer to
-  // set temporary zoom level.
-  void OnSetTemporaryZoomLevel(content::RenderFrameHost* frame_host,
-                               double level,
-                               IPC::Message* reply_msg);
-
-  // Called when received a synchronous message from renderer to
-  // get the zoom level.
-  void OnGetZoomLevel(content::RenderFrameHost* frame_host,
-                      IPC::Message* reply_msg);
-
-  void InitZoomController(content::WebContents* web_contents,
-                          const mate::Dictionary& options);
-
-  v8::Global<v8::Value> session_;
-  v8::Global<v8::Value> devtools_web_contents_;
-  v8::Global<v8::Value> debugger_;
-
-  std::unique_ptr<AtomJavaScriptDialogManager> dialog_manager_;
-  std::unique_ptr<WebViewGuestDelegate> guest_delegate_;
-
-  std::unique_ptr<FrameSubscriber> frame_subscriber_;
-
-  // The host webcontents that may contain this webcontents.
-  WebContents* embedder_ = nullptr;
-
-  // The zoom controller for this webContents.
-  WebContentsZoomController* zoom_controller_ = nullptr;
-
-  // The type of current WebContents.
-  Type type_ = BROWSER_WINDOW;
-
-  // Request id used for findInPage request.
-  uint32_t request_id_ = 0;
-
-  // Whether background throttling is disabled.
-  bool background_throttling_ = true;
-
-  // Whether to enable devtools.
-  bool enable_devtools_ = true;
-
-  // Observers of this WebContents.
-  base::ObserverList<ExtendedWebContentsObserver> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContents);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
removed in remote
  base   100644 a987369ed82de17033e6dde512ddec31aa4e3dd9 atom/browser/api/atom_api_web_request.cc
  our    100644 c088196f833160ac964e67030fa083302dd090b0 atom/browser/api/atom_api_web_request.cc
@@ -1,146 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_web_request.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-template <>
-struct Converter<URLPattern> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     URLPattern* out) {
-    std::string pattern;
-    if (!ConvertFromV8(isolate, val, &pattern))
-      return false;
-    *out = URLPattern(URLPattern::SCHEME_ALL);
-    return out->Parse(pattern) == URLPattern::PARSE_SUCCESS;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-template <typename Method, typename Event, typename Listener>
-void CallNetworkDelegateMethod(
-    brightray::URLRequestContextGetter* url_request_context_getter,
-    Method method,
-    Event type,
-    URLPatterns patterns,
-    Listener listener) {
-  // Force creating network delegate.
-  net::URLRequestContext* context =
-      url_request_context_getter->GetURLRequestContext();
-  // Then call the method.
-  AtomNetworkDelegate* network_delegate =
-      static_cast<AtomNetworkDelegate*>(context->network_delegate());
-  (network_delegate->*method)(type, std::move(patterns), std::move(listener));
-}
-
-}  // namespace
-
-WebRequest::WebRequest(v8::Isolate* isolate,
-                       AtomBrowserContext* browser_context)
-    : browser_context_(browser_context) {
-  Init(isolate);
-}
-
-WebRequest::~WebRequest() {}
-
-template <AtomNetworkDelegate::SimpleEvent type>
-void WebRequest::SetSimpleListener(mate::Arguments* args) {
-  SetListener<AtomNetworkDelegate::SimpleListener>(
-      &AtomNetworkDelegate::SetSimpleListenerInIO, type, args);
-}
-
-template <AtomNetworkDelegate::ResponseEvent type>
-void WebRequest::SetResponseListener(mate::Arguments* args) {
-  SetListener<AtomNetworkDelegate::ResponseListener>(
-      &AtomNetworkDelegate::SetResponseListenerInIO, type, args);
-}
-
-template <typename Listener, typename Method, typename Event>
-void WebRequest::SetListener(Method method, Event type, mate::Arguments* args) {
-  // { urls }.
-  URLPatterns patterns;
-  mate::Dictionary dict;
-  args->GetNext(&dict) && dict.Get("urls", &patterns);
-
-  // Function or null.
-  v8::Local<v8::Value> value;
-  Listener listener;
-  if (!args->GetNext(&listener) &&
-      !(args->GetNext(&value) && value->IsNull())) {
-    args->ThrowError("Must pass null or a Function");
-    return;
-  }
-
-  brightray::URLRequestContextGetter* url_request_context_getter =
-      browser_context_->GetRequestContext();
-  if (!url_request_context_getter)
-    return;
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&CallNetworkDelegateMethod<Method, Event, Listener>,
-                     base::RetainedRef(url_request_context_getter), method,
-                     type, std::move(patterns), std::move(listener)));
-}
-
-// static
-mate::Handle<WebRequest> WebRequest::Create(
-    v8::Isolate* isolate,
-    AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new WebRequest(isolate, browser_context));
-}
-
-// static
-void WebRequest::BuildPrototype(v8::Isolate* isolate,
-                                v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebRequest"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("onBeforeRequest", &WebRequest::SetResponseListener<
-                                        AtomNetworkDelegate::kOnBeforeRequest>)
-      .SetMethod("onBeforeSendHeaders",
-                 &WebRequest::SetResponseListener<
-                     AtomNetworkDelegate::kOnBeforeSendHeaders>)
-      .SetMethod("onHeadersReceived",
-                 &WebRequest::SetResponseListener<
-                     AtomNetworkDelegate::kOnHeadersReceived>)
-      .SetMethod(
-          "onSendHeaders",
-          &WebRequest::SetSimpleListener<AtomNetworkDelegate::kOnSendHeaders>)
-      .SetMethod("onBeforeRedirect",
-                 &WebRequest::SetSimpleListener<
-                     AtomNetworkDelegate::kOnBeforeRedirect>)
-      .SetMethod("onResponseStarted",
-                 &WebRequest::SetSimpleListener<
-                     AtomNetworkDelegate::kOnResponseStarted>)
-      .SetMethod(
-          "onCompleted",
-          &WebRequest::SetSimpleListener<AtomNetworkDelegate::kOnCompleted>)
-      .SetMethod("onErrorOccurred", &WebRequest::SetSimpleListener<
-                                        AtomNetworkDelegate::kOnErrorOccurred>);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 9a6e17a0460585693465ae4a8f6f75c2871a738a atom/browser/api/atom_api_web_request.h
  our    100644 87fa08815877c80330e3155804295638b2da1094 atom/browser/api/atom_api_web_request.h
@@ -1,49 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
-#define ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#include "native_mate/arguments.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class WebRequest : public mate::TrackableObject<WebRequest> {
- public:
-  static mate::Handle<WebRequest> Create(v8::Isolate* isolate,
-                                         AtomBrowserContext* browser_context);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  WebRequest(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~WebRequest() override;
-
-  // C++ can not distinguish overloaded member function.
-  template <AtomNetworkDelegate::SimpleEvent type>
-  void SetSimpleListener(mate::Arguments* args);
-  template <AtomNetworkDelegate::ResponseEvent type>
-  void SetResponseListener(mate::Arguments* args);
-  template <typename Listener, typename Method, typename Event>
-  void SetListener(Method method, Event type, mate::Arguments* args);
-
- private:
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebRequest);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
removed in remote
  base   100644 e57c5ffb6bb4aea16b72f29e53ec48a269d2d08e atom/browser/api/atom_api_web_view_manager.cc
  our    100644 e24d6306f62a63331304617c969db410db0ae0c4 atom/browser/api/atom_api_web_view_manager.cc
@@ -1,58 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "content/public/browser/browser_context.h"
-#include "native_mate/dictionary.h"
-
-// Must be the last in the includes list.
-// See https://github.com/electron/electron/issues/10363
-#include "atom/common/node_includes.h"
-
-using atom::WebContentsPreferences;
-
-namespace {
-
-void AddGuest(int guest_instance_id,
-              int element_instance_id,
-              content::WebContents* embedder,
-              content::WebContents* guest_web_contents,
-              const base::DictionaryValue& options) {
-  auto* manager = atom::WebViewManager::GetWebViewManager(embedder);
-  if (manager)
-    manager->AddGuest(guest_instance_id, element_instance_id, embedder,
-                      guest_web_contents);
-
-  double zoom_factor;
-  if (options.GetDouble(atom::options::kZoomFactor, &zoom_factor)) {
-    atom::WebContentsZoomController::FromWebContents(guest_web_contents)
-        ->SetDefaultZoomFactor(zoom_factor);
-  }
-
-  WebContentsPreferences::From(guest_web_contents)->Merge(options);
-}
-
-void RemoveGuest(content::WebContents* embedder, int guest_instance_id) {
-  auto* manager = atom::WebViewManager::GetWebViewManager(embedder);
-  if (manager)
-    manager->RemoveGuest(guest_instance_id);
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("addGuest", &AddGuest);
-  dict.SetMethod("removeGuest", &RemoveGuest);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_web_view_manager, Initialize)
removed in remote
  base   100644 5c87292ea52ed33340846ab255d48ab2edfeebb6 atom/browser/api/event.cc
  our    100644 7b617034eca5a229fc9323bfd6d531ebded752d6 atom/browser/api/event.cc
@@ -1,81 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/event.h"
-
-#include "atom/common/api/api_messages.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-#include "native_mate/object_template_builder.h"
-
-namespace mate {
-
-Event::Event(v8::Isolate* isolate) {
-  Init(isolate);
-}
-
-Event::~Event() {}
-
-void Event::SetSenderAndMessage(content::RenderFrameHost* sender,
-                                IPC::Message* message) {
-  DCHECK(!sender_);
-  DCHECK(!message_);
-  sender_ = sender;
-  message_ = message;
-
-  Observe(content::WebContents::FromRenderFrameHost(sender));
-}
-
-void Event::RenderFrameDeleted(content::RenderFrameHost* rfh) {
-  if (sender_ != rfh)
-    return;
-  sender_ = nullptr;
-  message_ = nullptr;
-}
-
-void Event::RenderFrameHostChanged(content::RenderFrameHost* old_rfh,
-                                   content::RenderFrameHost* new_rfh) {
-  if (sender_ && sender_ == old_rfh)
-    sender_ = new_rfh;
-}
-
-void Event::FrameDeleted(content::RenderFrameHost* rfh) {
-  if (sender_ != rfh)
-    return;
-  sender_ = nullptr;
-  message_ = nullptr;
-}
-
-void Event::PreventDefault(v8::Isolate* isolate) {
-  GetWrapper()->Set(StringToV8(isolate, "defaultPrevented"), v8::True(isolate));
-}
-
-bool Event::SendReply(const base::ListValue& result) {
-  if (message_ == nullptr || sender_ == nullptr)
-    return false;
-
-  AtomFrameHostMsg_Message_Sync::WriteReplyParams(message_, result);
-  bool success = sender_->Send(message_);
-  message_ = nullptr;
-  sender_ = nullptr;
-  return success;
-}
-
-// static
-Handle<Event> Event::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new Event(isolate));
-}
-
-// static
-void Event::BuildPrototype(v8::Isolate* isolate,
-                           v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Event"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("preventDefault", &Event::PreventDefault)
-      .SetMethod("sendReply", &Event::SendReply);
-}
-
-}  // namespace mate
removed in remote
  base   100644 5cdc08324b72e4f20d5fb4e02af97624c2599c9d atom/browser/api/event.h
  our    100644 fbec8f27574691005d203adbafb50709f5c2d010 atom/browser/api/event.h
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_EVENT_H_
-#define ATOM_BROWSER_API_EVENT_H_
-
-#include "content/public/browser/web_contents_observer.h"
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-
-namespace IPC {
-class Message;
-}
-
-namespace mate {
-
-class Event : public Wrappable<Event>, public content::WebContentsObserver {
- public:
-  static Handle<Event> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Pass the sender and message to be replied.
-  void SetSenderAndMessage(content::RenderFrameHost* sender,
-                           IPC::Message* message);
-
-  // event.PreventDefault().
-  void PreventDefault(v8::Isolate* isolate);
-
-  // event.sendReply(array), used for replying synchronous message.
-  bool SendReply(const base::ListValue& result);
-
- protected:
-  explicit Event(v8::Isolate* isolate);
-  ~Event() override;
-
-  // content::WebContentsObserver implementations:
-  void RenderFrameDeleted(content::RenderFrameHost* rfh) override;
-  void RenderFrameHostChanged(content::RenderFrameHost* old_rfh,
-                              content::RenderFrameHost* new_rfh) override;
-  void FrameDeleted(content::RenderFrameHost* rfh) override;
-
- private:
-  // Replyer for the synchronous messages.
-  content::RenderFrameHost* sender_ = nullptr;
-  IPC::Message* message_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(Event);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_EVENT_H_
removed in remote
  base   100644 be7018dafa44af1d7e30b4722126e8ca0faea443 atom/browser/api/event_emitter.cc
  our    100644 c6e810b51225c8f89eaf53ac3e46381b52ba63b5 atom/browser/api/event_emitter.cc
@@ -1,82 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/event_emitter.h"
-
-#include "atom/browser/api/event.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "ui/events/event_constants.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace {
-
-v8::Persistent<v8::ObjectTemplate> event_template;
-
-void PreventDefault(mate::Arguments* args) {
-  mate::Dictionary self(args->isolate(), args->GetThis());
-  self.Set("defaultPrevented", true);
-}
-
-// Create a pure JavaScript Event object.
-v8::Local<v8::Object> CreateEventObject(v8::Isolate* isolate) {
-  if (event_template.IsEmpty()) {
-    event_template.Reset(
-        isolate,
-        ObjectTemplateBuilder(isolate, v8::ObjectTemplate::New(isolate))
-            .SetMethod("preventDefault", &PreventDefault)
-            .Build());
-  }
-
-  return v8::Local<v8::ObjectTemplate>::New(isolate, event_template)
-      ->NewInstance();
-}
-
-}  // namespace
-
-namespace internal {
-
-v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    content::RenderFrameHost* sender,
-                                    IPC::Message* message) {
-  v8::Local<v8::Object> event;
-  bool use_native_event = sender && message;
-
-  if (use_native_event) {
-    mate::Handle<mate::Event> native_event = mate::Event::Create(isolate);
-    native_event->SetSenderAndMessage(sender, message);
-    event = v8::Local<v8::Object>::Cast(native_event.ToV8());
-  } else {
-    event = CreateEventObject(isolate);
-  }
-  mate::Dictionary(isolate, event).Set("sender", object);
-  return event;
-}
-
-v8::Local<v8::Object> CreateCustomEvent(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> object,
-                                        v8::Local<v8::Object> custom_event) {
-  v8::Local<v8::Object> event = CreateEventObject(isolate);
-  (void)event->SetPrototype(custom_event->CreationContext(), custom_event);
-  mate::Dictionary(isolate, event).Set("sender", object);
-  return event;
-}
-
-v8::Local<v8::Object> CreateEventFromFlags(v8::Isolate* isolate, int flags) {
-  mate::Dictionary obj = mate::Dictionary::CreateEmpty(isolate);
-  obj.Set("shiftKey", static_cast<bool>(flags & ui::EF_SHIFT_DOWN));
-  obj.Set("ctrlKey", static_cast<bool>(flags & ui::EF_CONTROL_DOWN));
-  obj.Set("altKey", static_cast<bool>(flags & ui::EF_ALT_DOWN));
-  obj.Set("metaKey", static_cast<bool>(flags & ui::EF_COMMAND_DOWN));
-  return obj.GetHandle();
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 42816d42a45bd378be558f93f9e63c5bc28070ad atom/browser/api/event_emitter.h
  our    100644 5e4ca3b4ffcb184583ef386100eabda7a9e00da0 atom/browser/api/event_emitter.h
@@ -1,112 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_EVENT_EMITTER_H_
-#define ATOM_BROWSER_API_EVENT_EMITTER_H_
-
-#include <vector>
-
-#include "atom/common/api/event_emitter_caller.h"
-#include "native_mate/wrappable.h"
-
-namespace content {
-class RenderFrameHost;
-}
-
-namespace IPC {
-class Message;
-}
-
-namespace mate {
-
-namespace internal {
-
-v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    content::RenderFrameHost* sender,
-                                    IPC::Message* message);
-v8::Local<v8::Object> CreateCustomEvent(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> object,
-                                        v8::Local<v8::Object> event);
-v8::Local<v8::Object> CreateEventFromFlags(v8::Isolate* isolate, int flags);
-
-}  // namespace internal
-
-// Provide helperers to emit event in JavaScript.
-template <typename T>
-class EventEmitter : public Wrappable<T> {
- public:
-  typedef std::vector<v8::Local<v8::Value>> ValueArray;
-
-  // Make the convinient methods visible:
-  // https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members
-  v8::Isolate* isolate() const { return Wrappable<T>::isolate(); }
-  v8::Local<v8::Object> GetWrapper() const {
-    return Wrappable<T>::GetWrapper();
-  }
-
-  // this.emit(name, event, args...);
-  template <typename... Args>
-  bool EmitCustomEvent(const base::StringPiece& name,
-                       v8::Local<v8::Object> event,
-                       const Args&... args) {
-    return EmitWithEvent(
-        name, internal::CreateCustomEvent(isolate(), GetWrapper(), event),
-        args...);
-  }
-
-  // this.emit(name, new Event(flags), args...);
-  template <typename... Args>
-  bool EmitWithFlags(const base::StringPiece& name,
-                     int flags,
-                     const Args&... args) {
-    return EmitCustomEvent(
-        name, internal::CreateEventFromFlags(isolate(), flags), args...);
-  }
-
-  // this.emit(name, new Event(), args...);
-  template <typename... Args>
-  bool Emit(const base::StringPiece& name, const Args&... args) {
-    return EmitWithSender(name, nullptr, nullptr, args...);
-  }
-
-  // this.emit(name, new Event(sender, message), args...);
-  template <typename... Args>
-  bool EmitWithSender(const base::StringPiece& name,
-                      content::RenderFrameHost* sender,
-                      IPC::Message* message,
-                      const Args&... args) {
-    v8::Locker locker(isolate());
-    v8::HandleScope handle_scope(isolate());
-    v8::Local<v8::Object> wrapper = GetWrapper();
-    if (wrapper.IsEmpty()) {
-      return false;
-    }
-    v8::Local<v8::Object> event =
-        internal::CreateJSEvent(isolate(), wrapper, sender, message);
-    return EmitWithEvent(name, event, args...);
-  }
-
- protected:
-  EventEmitter() {}
-
- private:
-  // this.emit(name, event, args...);
-  template <typename... Args>
-  bool EmitWithEvent(const base::StringPiece& name,
-                     v8::Local<v8::Object> event,
-                     const Args&... args) {
-    v8::Locker locker(isolate());
-    v8::HandleScope handle_scope(isolate());
-    EmitEvent(isolate(), GetWrapper(), name, event, args...);
-    return event->Get(StringToV8(isolate(), "defaultPrevented"))
-        ->BooleanValue();
-  }
-
-  DISALLOW_COPY_AND_ASSIGN(EventEmitter);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_EVENT_EMITTER_H_
removed in remote
  base   100644 f81a8bea8b1a4f38f1dd842fb3bb588ed43c2ce9 atom/browser/api/frame_subscriber.cc
  our    100644 7bcb7ab9370a8b3fe245c9569c93dbbdac0a0697 atom/browser/api/frame_subscriber.cc
@@ -1,100 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/frame_subscriber.h"
-
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "components/viz/common/frame_sinks/copy_output_request.h"
-#include "components/viz/service/frame_sinks/frame_sink_manager_impl.h"
-#include "components/viz/service/surfaces/surface_manager.h"
-#include "content/browser/compositor/surface_utils.h"
-#include "content/browser/renderer_host/render_widget_host_view_base.h"
-#include "ui/gfx/geometry/rect_conversions.h"
-#include "ui/gfx/skbitmap_operations.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-FrameSubscriber::FrameSubscriber(v8::Isolate* isolate,
-                                 content::WebContents* web_contents,
-                                 const FrameCaptureCallback& callback,
-                                 bool only_dirty)
-    : content::WebContentsObserver(web_contents),
-      isolate_(isolate),
-      callback_(callback),
-      only_dirty_(only_dirty),
-      weak_ptr_factory_(this) {}
-
-FrameSubscriber::~FrameSubscriber() = default;
-
-gfx::Rect FrameSubscriber::GetDamageRect() {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (view == nullptr)
-    return gfx::Rect();
-
-  auto* view_base = static_cast<content::RenderWidgetHostViewBase*>(view);
-  viz::SurfaceManager* surface_manager =
-      content::GetFrameSinkManager()->surface_manager();
-  viz::Surface* surface =
-      surface_manager->GetSurfaceForId(view_base->GetCurrentSurfaceId());
-  if (surface == nullptr)
-    return gfx::Rect();
-
-  if (surface->HasActiveFrame()) {
-    const viz::CompositorFrame& frame = surface->GetActiveFrame();
-    viz::RenderPass* root_pass = frame.render_pass_list.back().get();
-    gfx::Size frame_size = root_pass->output_rect.size();
-    gfx::Rect damage_rect =
-        gfx::ToEnclosingRect(gfx::RectF(root_pass->damage_rect));
-    damage_rect.Intersect(gfx::Rect(frame_size));
-    return gfx::ScaleToEnclosedRect(damage_rect,
-                                    1.0f / frame.device_scale_factor());
-  } else {
-    return gfx::Rect();
-  }
-}
-
-void FrameSubscriber::DidReceiveCompositorFrame() {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (view == nullptr)
-    return;
-
-  view->CopyFromSurface(
-      gfx::Rect(), view->GetViewBounds().size(),
-      base::BindOnce(&FrameSubscriber::Done, weak_ptr_factory_.GetWeakPtr(),
-                     GetDamageRect()));
-}
-
-void FrameSubscriber::Done(const gfx::Rect& damage, const SkBitmap& frame) {
-  if (frame.drawsNothing())
-    return;
-
-  v8::Locker locker(isolate_);
-  v8::HandleScope handle_scope(isolate_);
-
-  const_cast<SkBitmap&>(frame).setAlphaType(kPremul_SkAlphaType);
-  const SkBitmap& bitmap = only_dirty_ ? SkBitmapOperations::CreateTiledBitmap(
-                                             frame, damage.x(), damage.y(),
-                                             damage.width(), damage.height())
-                                       : frame;
-
-  size_t rgb_row_size = bitmap.width() * bitmap.bytesPerPixel();
-  auto* source = static_cast<const char*>(bitmap.getPixels());
-
-  v8::MaybeLocal<v8::Object> buffer =
-      node::Buffer::Copy(isolate_, source, rgb_row_size * bitmap.height());
-  auto local_buffer = buffer.ToLocalChecked();
-
-  v8::Local<v8::Value> damage_rect =
-      mate::Converter<gfx::Rect>::ToV8(isolate_, damage);
-
-  callback_.Run(local_buffer, damage_rect);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 a803d75dff20f211df6708e2e27a58495ed9821f atom/browser/api/frame_subscriber.h
  our    100644 d3e82855417cb59c0449f1c1b685970ffaea2af6 atom/browser/api/frame_subscriber.h
@@ -1,52 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
-#define ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
-
-#include "content/public/browser/web_contents.h"
-
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "components/viz/common/frame_sinks/copy_output_result.h"
-#include "content/public/browser/web_contents_observer.h"
-#include "ui/gfx/image/image.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-namespace api {
-
-class WebContents;
-
-class FrameSubscriber : public content::WebContentsObserver {
- public:
-  using FrameCaptureCallback =
-      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
-
-  FrameSubscriber(v8::Isolate* isolate,
-                  content::WebContents* web_contents,
-                  const FrameCaptureCallback& callback,
-                  bool only_dirty);
-  ~FrameSubscriber() override;
-
- private:
-  gfx::Rect GetDamageRect();
-  void DidReceiveCompositorFrame() override;
-  void Done(const gfx::Rect& damage, const SkBitmap& frame);
-
-  v8::Isolate* isolate_;
-  FrameCaptureCallback callback_;
-  bool only_dirty_;
-
-  base::WeakPtrFactory<FrameSubscriber> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(FrameSubscriber);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
removed in remote
  base   100644 1e5bc094cf63f04bc98602a8ad29b1c34024b595 atom/browser/api/save_page_handler.cc
  our    100644 a0d8e283961d7ff79f78918907ab436d1e426b49 atom/browser/api/save_page_handler.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/save_page_handler.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_context.h"
-#include "base/callback.h"
-#include "base/files/file_path.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-namespace api {
-
-SavePageHandler::SavePageHandler(content::WebContents* web_contents,
-                                 const SavePageCallback& callback)
-    : web_contents_(web_contents), callback_(callback) {}
-
-SavePageHandler::~SavePageHandler() {}
-
-void SavePageHandler::OnDownloadCreated(content::DownloadManager* manager,
-                                        download::DownloadItem* item) {
-  // OnDownloadCreated is invoked during WebContents::SavePage, so the |item|
-  // here is the one stated by WebContents::SavePage.
-  item->AddObserver(this);
-}
-
-bool SavePageHandler::Handle(const base::FilePath& full_path,
-                             const content::SavePageType& save_type) {
-  auto* download_manager = content::BrowserContext::GetDownloadManager(
-      web_contents_->GetBrowserContext());
-  download_manager->AddObserver(this);
-  // Chromium will create a 'foo_files' directory under the directory of saving
-  // page 'foo.html' for holding other resource files of 'foo.html'.
-  base::FilePath saved_main_directory_path = full_path.DirName().Append(
-      full_path.RemoveExtension().BaseName().value() +
-      FILE_PATH_LITERAL("_files"));
-  bool result =
-      web_contents_->SavePage(full_path, saved_main_directory_path, save_type);
-  download_manager->RemoveObserver(this);
-  // If initialization fails which means fail to create |DownloadItem|, we need
-  // to delete the |SavePageHandler| instance to avoid memory-leak.
-  if (!result)
-    delete this;
-  return result;
-}
-
-void SavePageHandler::OnDownloadUpdated(download::DownloadItem* item) {
-  if (item->IsDone()) {
-    v8::Isolate* isolate = v8::Isolate::GetCurrent();
-    v8::Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    if (item->GetState() == download::DownloadItem::COMPLETE) {
-      callback_.Run(v8::Null(isolate));
-    } else {
-      v8::Local<v8::String> error_message =
-          v8::String::NewFromUtf8(isolate, "Fail to save page");
-      callback_.Run(v8::Exception::Error(error_message));
-    }
-    Destroy(item);
-  }
-}
-
-void SavePageHandler::Destroy(download::DownloadItem* item) {
-  item->RemoveObserver(this);
-  delete this;
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 dd1692a8badc4091578e8edb7d37e3618a4cf0fe atom/browser/api/save_page_handler.h
  our    100644 204d65bd6b1865686cd6600caa3423a75b5295fb atom/browser/api/save_page_handler.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
-#define ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
-
-#include <string>
-
-#include "components/download/public/common/download_item.h"
-#include "content/public/browser/download_manager.h"
-#include "content/public/browser/save_page_type.h"
-#include "v8/include/v8.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-namespace api {
-
-// A self-destroyed class for handling save page request.
-class SavePageHandler : public content::DownloadManager::Observer,
-                        public download::DownloadItem::Observer {
- public:
-  using SavePageCallback = base::Callback<void(v8::Local<v8::Value>)>;
-
-  SavePageHandler(content::WebContents* web_contents,
-                  const SavePageCallback& callback);
-  ~SavePageHandler() override;
-
-  bool Handle(const base::FilePath& full_path,
-              const content::SavePageType& save_type);
-
- private:
-  void Destroy(download::DownloadItem* item);
-
-  // content::DownloadManager::Observer:
-  void OnDownloadCreated(content::DownloadManager* manager,
-                         download::DownloadItem* item) override;
-
-  // download::DownloadItem::Observer:
-  void OnDownloadUpdated(download::DownloadItem* item) override;
-
-  content::WebContents* web_contents_;  // weak
-  SavePageCallback callback_;
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
removed in remote
  base   100644 77a936cde02cdbe5d845f9ab5b91abf9afaf359a atom/browser/api/trackable_object.cc
  our    100644 7955ddefcabe1a106d7dc7fd4d821d75a5f72300 atom/browser/api/trackable_object.cc
@@ -1,64 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/trackable_object.h"
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "base/bind.h"
-#include "base/supports_user_data.h"
-
-namespace mate {
-
-namespace {
-
-const char* kTrackedObjectKey = "TrackedObjectKey";
-
-class IDUserData : public base::SupportsUserData::Data {
- public:
-  explicit IDUserData(int32_t id) : id_(id) {}
-
-  operator int32_t() const { return id_; }
-
- private:
-  int32_t id_;
-
-  DISALLOW_COPY_AND_ASSIGN(IDUserData);
-};
-
-}  // namespace
-
-TrackableObjectBase::TrackableObjectBase() : weak_factory_(this) {
-  atom::AtomBrowserMainParts::Get()->RegisterDestructionCallback(
-      GetDestroyClosure());
-}
-
-TrackableObjectBase::~TrackableObjectBase() {}
-
-base::OnceClosure TrackableObjectBase::GetDestroyClosure() {
-  return base::BindOnce(&TrackableObjectBase::Destroy,
-                        weak_factory_.GetWeakPtr());
-}
-
-void TrackableObjectBase::Destroy() {
-  delete this;
-}
-
-void TrackableObjectBase::AttachAsUserData(base::SupportsUserData* wrapped) {
-  wrapped->SetUserData(kTrackedObjectKey,
-                       std::make_unique<IDUserData>(weak_map_id_));
-}
-
-// static
-int32_t TrackableObjectBase::GetIDFromWrappedClass(
-    base::SupportsUserData* wrapped) {
-  if (wrapped) {
-    auto* id =
-        static_cast<IDUserData*>(wrapped->GetUserData(kTrackedObjectKey));
-    if (id)
-      return *id;
-  }
-  return 0;
-}
-
-}  // namespace mate
removed in remote
  base   100644 7c4ed03fe052ee3299ed96742577ad68153a135e atom/browser/api/trackable_object.h
  our    100644 f0fd86d344cf34b9cece734cc9f0b25284cfd8d8 atom/browser/api/trackable_object.h
@@ -1,137 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
-#define ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
-
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/common/key_weak_map.h"
-#include "base/bind.h"
-#include "base/memory/weak_ptr.h"
-#include "native_mate/object_template_builder.h"
-
-namespace base {
-class SupportsUserData;
-}
-
-namespace mate {
-
-// Users should use TrackableObject instead.
-class TrackableObjectBase {
- public:
-  TrackableObjectBase();
-
-  // The ID in weak map.
-  int32_t weak_map_id() const { return weak_map_id_; }
-
-  // Wrap TrackableObject into a class that SupportsUserData.
-  void AttachAsUserData(base::SupportsUserData* wrapped);
-
-  // Get the weak_map_id from SupportsUserData.
-  static int32_t GetIDFromWrappedClass(base::SupportsUserData* wrapped);
-
- protected:
-  virtual ~TrackableObjectBase();
-
-  // Returns a closure that can destroy the native class.
-  base::OnceClosure GetDestroyClosure();
-
-  int32_t weak_map_id_ = 0;
-
- private:
-  void Destroy();
-
-  base::WeakPtrFactory<TrackableObjectBase> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrackableObjectBase);
-};
-
-// All instances of TrackableObject will be kept in a weak map and can be got
-// from its ID.
-template <typename T>
-class TrackableObject : public TrackableObjectBase,
-                        public mate::EventEmitter<T> {
- public:
-  // Mark the JS object as destroyed.
-  void MarkDestroyed() {
-    v8::Local<v8::Object> wrapper = Wrappable<T>::GetWrapper();
-    if (!wrapper.IsEmpty()) {
-      wrapper->SetAlignedPointerInInternalField(0, nullptr);
-    }
-  }
-
-  bool IsDestroyed() {
-    v8::Local<v8::Object> wrapper = Wrappable<T>::GetWrapper();
-    return wrapper->InternalFieldCount() == 0 ||
-           wrapper->GetAlignedPointerFromInternalField(0) == nullptr;
-  }
-
-  // Finds out the TrackableObject from its ID in weak map.
-  static T* FromWeakMapID(v8::Isolate* isolate, int32_t id) {
-    if (!weak_map_)
-      return nullptr;
-
-    v8::MaybeLocal<v8::Object> object = weak_map_->Get(isolate, id);
-    if (object.IsEmpty())
-      return nullptr;
-
-    T* self = nullptr;
-    mate::ConvertFromV8(isolate, object.ToLocalChecked(), &self);
-    return self;
-  }
-
-  // Finds out the TrackableObject from the class it wraps.
-  static T* FromWrappedClass(v8::Isolate* isolate,
-                             base::SupportsUserData* wrapped) {
-    int32_t id = GetIDFromWrappedClass(wrapped);
-    if (!id)
-      return nullptr;
-    return FromWeakMapID(isolate, id);
-  }
-
-  // Returns all objects in this class's weak map.
-  static std::vector<v8::Local<v8::Object>> GetAll(v8::Isolate* isolate) {
-    if (weak_map_)
-      return weak_map_->Values(isolate);
-    else
-      return std::vector<v8::Local<v8::Object>>();
-  }
-
-  // Removes this instance from the weak map.
-  void RemoveFromWeakMap() {
-    if (weak_map_ && weak_map_->Has(weak_map_id()))
-      weak_map_->Remove(weak_map_id());
-  }
-
- protected:
-  TrackableObject() { weak_map_id_ = ++next_id_; }
-
-  ~TrackableObject() override { RemoveFromWeakMap(); }
-
-  void InitWith(v8::Isolate* isolate, v8::Local<v8::Object> wrapper) override {
-    WrappableBase::InitWith(isolate, wrapper);
-    if (!weak_map_) {
-      weak_map_ = new atom::KeyWeakMap<int32_t>;
-    }
-    weak_map_->Set(isolate, weak_map_id_, wrapper);
-  }
-
- private:
-  static int32_t next_id_;
-  static atom::KeyWeakMap<int32_t>* weak_map_;  // leaked on purpose
-
-  DISALLOW_COPY_AND_ASSIGN(TrackableObject);
-};
-
-template <typename T>
-int32_t TrackableObject<T>::next_id_ = 0;
-
-template <typename T>
-atom::KeyWeakMap<int32_t>* TrackableObject<T>::weak_map_ = nullptr;
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
removed in remote
  base   100644 63a1ea46b163725ef2fa4797c6f4170f6ec23a99 atom/browser/atom_browser_client.cc
  our    100644 57c4ee582405e6d501ec23940ccb10689ecd64a1 atom/browser/atom_browser_client.cc
@@ -1,550 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_client.h"
-
-#if defined(OS_WIN)
-#include <shlobj.h>
-#endif
-
-#include "atom/browser/api/atom_api_app.h"
-#include "atom/browser/api/atom_api_protocol.h"
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_quota_permission_context.h"
-#include "atom/browser/atom_resource_dispatcher_host_delegate.h"
-#include "atom/browser/atom_speech_recognition_manager_delegate.h"
-#include "atom/browser/child_web_contents_tracker.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/session_preferences.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/google_api_key.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/files/file_util.h"
-#include "base/stl_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/printing/printing_message_filter.h"
-#include "chrome/browser/speech/tts_message_filter.h"
-#include "content/public/browser/browser_ppapi_host.h"
-#include "content/public/browser/client_certificate_delegate.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/resource_dispatcher_host.h"
-#include "content/public/browser/site_instance.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/content_paths.h"
-#include "content/public/common/content_switches.h"
-#include "content/public/common/url_constants.h"
-#include "content/public/common/web_preferences.h"
-#include "net/ssl/ssl_cert_request_info.h"
-#include "ppapi/host/ppapi_host.h"
-#include "services/network/public/cpp/resource_request_body.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "v8/include/v8.h"
-
-#if defined(USE_NSS_CERTS)
-#include "net/ssl/client_cert_store_nss.h"
-#elif defined(OS_WIN)
-#include "net/ssl/client_cert_store_win.h"
-#elif defined(OS_MACOSX)
-#include "net/ssl/client_cert_store_mac.h"
-#elif defined(USE_OPENSSL)
-#include "net/ssl/client_cert_store.h"
-#endif
-
-#if defined(ENABLE_PEPPER_FLASH)
-#include "chrome/browser/renderer_host/pepper/chrome_browser_pepper_host_factory.h"
-#endif  // defined(ENABLE_PEPPER_FLASH)
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// Next navigation should not restart renderer process.
-bool g_suppress_renderer_process_restart = false;
-
-// Custom schemes to be registered to handle service worker.
-std::string g_custom_service_worker_schemes = "";
-
-bool IsSameWebSite(content::BrowserContext* browser_context,
-                   const GURL& src_url,
-                   const GURL& dest_url) {
-  return content::SiteInstance::IsSameWebSite(browser_context, src_url,
-                                              dest_url) ||
-         // `IsSameWebSite` doesn't seem to work for some URIs such as `file:`,
-         // handle these scenarios by comparing only the site as defined by
-         // `GetSiteForURL`.
-         content::SiteInstance::GetSiteForURL(browser_context, dest_url) ==
-             src_url;
-}
-
-}  // namespace
-
-// static
-void AtomBrowserClient::SuppressRendererProcessRestartForOnce() {
-  g_suppress_renderer_process_restart = true;
-}
-
-void AtomBrowserClient::SetCustomServiceWorkerSchemes(
-    const std::vector<std::string>& schemes) {
-  g_custom_service_worker_schemes = base::JoinString(schemes, ",");
-}
-
-AtomBrowserClient::AtomBrowserClient() {}
-
-AtomBrowserClient::~AtomBrowserClient() {}
-
-content::WebContents* AtomBrowserClient::GetWebContentsFromProcessID(
-    int process_id) {
-  // If the process is a pending process, we should use the web contents
-  // for the frame host passed into OverrideSiteInstanceForNavigation.
-  if (base::ContainsKey(pending_processes_, process_id))
-    return pending_processes_[process_id];
-
-  // Certain render process will be created with no associated render view,
-  // for example: ServiceWorker.
-  return WebContentsPreferences::GetWebContentsFromProcessID(process_id);
-}
-
-bool AtomBrowserClient::ShouldCreateNewSiteInstance(
-    content::RenderFrameHost* render_frame_host,
-    content::BrowserContext* browser_context,
-    content::SiteInstance* current_instance,
-    const GURL& url) {
-  if (url.SchemeIs(url::kJavaScriptScheme))
-    // "javacript:" scheme should always use same SiteInstance
-    return false;
-
-  int process_id = current_instance->GetProcess()->GetID();
-  if (!IsRendererSandboxed(process_id)) {
-    if (!RendererUsesNativeWindowOpen(process_id)) {
-      // non-sandboxed renderers without native window.open should always create
-      // a new SiteInstance
-      return true;
-    }
-    auto* web_contents =
-        content::WebContents::FromRenderFrameHost(render_frame_host);
-    if (!ChildWebContentsTracker::IsChildWebContents(web_contents)) {
-      // Root WebContents should always create new process to make sure
-      // native addons are loaded correctly after reload / navigation.
-      // (Non-root WebContents opened by window.open() should try to
-      //  reuse process to allow synchronous cross-window scripting.)
-      return true;
-    }
-  }
-
-  // Create new a SiteInstance if navigating to a different site.
-  auto src_url = current_instance->GetSiteURL();
-  return !IsSameWebSite(browser_context, src_url, url);
-}
-
-void AtomBrowserClient::AddProcessPreferences(
-    int process_id,
-    AtomBrowserClient::ProcessPreferences prefs) {
-  process_preferences_[process_id] = prefs;
-}
-
-void AtomBrowserClient::RemoveProcessPreferences(int process_id) {
-  process_preferences_.erase(process_id);
-}
-
-bool AtomBrowserClient::IsProcessObserved(int process_id) {
-  return process_preferences_.find(process_id) != process_preferences_.end();
-}
-
-bool AtomBrowserClient::IsRendererSandboxed(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.sandbox;
-}
-
-bool AtomBrowserClient::RendererUsesNativeWindowOpen(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.native_window_open;
-}
-
-bool AtomBrowserClient::RendererDisablesPopups(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.disable_popups;
-}
-
-void AtomBrowserClient::RenderProcessWillLaunch(
-    content::RenderProcessHost* host,
-    service_manager::mojom::ServiceRequest* service_request) {
-  // When a render process is crashed, it might be reused.
-  int process_id = host->GetID();
-  if (IsProcessObserved(process_id))
-    return;
-
-  host->AddFilter(new printing::PrintingMessageFilter(process_id));
-  host->AddFilter(new TtsMessageFilter(process_id, host->GetBrowserContext()));
-
-  ProcessPreferences prefs;
-  auto* web_preferences =
-      WebContentsPreferences::From(GetWebContentsFromProcessID(process_id));
-  if (web_preferences) {
-    prefs.sandbox = web_preferences->IsEnabled(options::kSandbox);
-    prefs.native_window_open =
-        web_preferences->IsEnabled(options::kNativeWindowOpen);
-    prefs.disable_popups = web_preferences->IsEnabled("disablePopups");
-  }
-  AddProcessPreferences(host->GetID(), prefs);
-  // ensure the ProcessPreferences is removed later
-  host->AddObserver(this);
-}
-
-content::SpeechRecognitionManagerDelegate*
-AtomBrowserClient::CreateSpeechRecognitionManagerDelegate() {
-  return new AtomSpeechRecognitionManagerDelegate;
-}
-
-void AtomBrowserClient::OverrideWebkitPrefs(content::RenderViewHost* host,
-                                            content::WebPreferences* prefs) {
-  prefs->javascript_enabled = true;
-  prefs->web_security_enabled = true;
-  prefs->plugins_enabled = true;
-  prefs->dom_paste_enabled = true;
-  prefs->allow_scripts_to_close_windows = true;
-  prefs->javascript_can_access_clipboard = true;
-  prefs->local_storage_enabled = true;
-  prefs->databases_enabled = true;
-  prefs->application_cache_enabled = true;
-  prefs->allow_universal_access_from_file_urls = true;
-  prefs->allow_file_access_from_file_urls = true;
-  prefs->webgl1_enabled = true;
-  prefs->webgl2_enabled = true;
-  prefs->allow_running_insecure_content = false;
-  prefs->default_minimum_page_scale_factor = 1.f;
-  prefs->default_maximum_page_scale_factor = 1.f;
-  prefs->navigate_on_drag_drop = false;
-
-  // Custom preferences of guest page.
-  auto* web_contents = content::WebContents::FromRenderViewHost(host);
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  if (web_preferences)
-    web_preferences->OverrideWebkitPrefs(prefs);
-}
-
-void AtomBrowserClient::OverrideSiteInstanceForNavigation(
-    content::RenderFrameHost* rfh,
-    content::BrowserContext* browser_context,
-    const GURL& url,
-    bool has_request_started,
-    content::SiteInstance* candidate_instance,
-    content::SiteInstance** new_instance) {
-  if (g_suppress_renderer_process_restart) {
-    g_suppress_renderer_process_restart = false;
-    return;
-  }
-
-  content::SiteInstance* current_instance = rfh->GetSiteInstance();
-  if (!ShouldCreateNewSiteInstance(rfh, browser_context, current_instance, url))
-    return;
-
-  // Do we have an affinity site to manage ?
-  auto* web_contents = content::WebContents::FromRenderFrameHost(rfh);
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  std::string affinity;
-  if (web_preferences &&
-      web_preferences->GetPreference("affinity", &affinity) &&
-      !affinity.empty()) {
-    affinity = base::ToLowerASCII(affinity);
-    auto iter = site_per_affinities.find(affinity);
-    GURL dest_site = content::SiteInstance::GetSiteForURL(browser_context, url);
-    if (iter != site_per_affinities.end() &&
-        IsSameWebSite(browser_context, iter->second->GetSiteURL(), dest_site)) {
-      *new_instance = iter->second;
-    } else {
-      site_per_affinities[affinity] = candidate_instance;
-      *new_instance = candidate_instance;
-      // Remember the original web contents for the pending renderer process.
-      auto* pending_process = candidate_instance->GetProcess();
-      pending_processes_[pending_process->GetID()] = web_contents;
-    }
-  } else {
-    // OverrideSiteInstanceForNavigation will be called more than once during a
-    // navigation (currently twice, on request and when it's about to commit in
-    // the renderer), look at RenderFrameHostManager::GetFrameHostForNavigation.
-    // In the default mode we should resuse the same site instance until the
-    // request commits otherwise it will get destroyed. Currently there is no
-    // unique lifetime tracker for a navigation request during site instance
-    // creation. We check for the state of the request, which should be one of
-    // (WAITING_FOR_RENDERER_RESPONSE, STARTED, RESPONSE_STARTED, FAILED) along
-    // with the availability of a speculative render frame host.
-    if (has_request_started) {
-      *new_instance = current_instance;
-      return;
-    }
-
-    *new_instance = candidate_instance;
-    // Remember the original web contents for the pending renderer process.
-    auto* pending_process = candidate_instance->GetProcess();
-    pending_processes_[pending_process->GetID()] = web_contents;
-  }
-}
-
-void AtomBrowserClient::AppendExtraCommandLineSwitches(
-    base::CommandLine* command_line,
-    int process_id) {
-  // Make sure we're about to launch a known executable
-  {
-    base::FilePath child_path;
-    PathService::Get(content::CHILD_PROCESS_EXE, &child_path);
-
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    CHECK(base::MakeAbsoluteFilePath(command_line->GetProgram()) == child_path);
-  }
-
-  std::string process_type =
-      command_line->GetSwitchValueASCII(::switches::kProcessType);
-  if (process_type != ::switches::kRendererProcess)
-    return;
-
-  // Copy following switches to child process.
-  static const char* const kCommonSwitchNames[] = {switches::kStandardSchemes,
-                                                   switches::kEnableSandbox,
-                                                   switches::kSecureSchemes};
-  command_line->CopySwitchesFrom(*base::CommandLine::ForCurrentProcess(),
-                                 kCommonSwitchNames,
-                                 arraysize(kCommonSwitchNames));
-
-  // The registered service worker schemes.
-  if (!g_custom_service_worker_schemes.empty())
-    command_line->AppendSwitchASCII(switches::kRegisterServiceWorkerSchemes,
-                                    g_custom_service_worker_schemes);
-
-#if defined(OS_WIN)
-  // Append --app-user-model-id.
-  PWSTR current_app_id;
-  if (SUCCEEDED(GetCurrentProcessExplicitAppUserModelID(&current_app_id))) {
-    command_line->AppendSwitchNative(switches::kAppUserModelId, current_app_id);
-    CoTaskMemFree(current_app_id);
-  }
-#endif
-
-  if (delegate_) {
-    auto app_path = static_cast<api::App*>(delegate_)->GetAppPath();
-    command_line->AppendSwitchPath(switches::kAppPath, app_path);
-  }
-
-  content::WebContents* web_contents = GetWebContentsFromProcessID(process_id);
-  if (web_contents) {
-    auto* web_preferences = WebContentsPreferences::From(web_contents);
-    if (web_preferences)
-      web_preferences->AppendCommandLineSwitches(command_line);
-    SessionPreferences::AppendExtraCommandLineSwitches(
-        web_contents->GetBrowserContext(), command_line);
-  }
-}
-
-void AtomBrowserClient::DidCreatePpapiPlugin(content::BrowserPpapiHost* host) {
-#if defined(ENABLE_PEPPER_FLASH)
-  host->GetPpapiHost()->AddHostFactoryFilter(
-      base::WrapUnique(new ChromeBrowserPepperHostFactory(host)));
-#endif
-}
-
-void AtomBrowserClient::GetGeolocationRequestContext(
-    base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)>
-        callback) {
-  auto* io_thread = AtomBrowserMainParts::Get()->io_thread();
-  auto* context = io_thread->GetRequestContext();
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(callback), base::RetainedRef(context)));
-}
-
-std::string AtomBrowserClient::GetGeolocationApiKey() {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  std::string api_key;
-  if (!env->GetVar("GOOGLE_API_KEY", &api_key))
-    api_key = GOOGLEAPIS_API_KEY;
-  return api_key;
-}
-
-content::QuotaPermissionContext*
-AtomBrowserClient::CreateQuotaPermissionContext() {
-  return new AtomQuotaPermissionContext;
-}
-
-void AtomBrowserClient::AllowCertificateError(
-    content::WebContents* web_contents,
-    int cert_error,
-    const net::SSLInfo& ssl_info,
-    const GURL& request_url,
-    content::ResourceType resource_type,
-    bool strict_enforcement,
-    bool expired_previous_decision,
-    const base::Callback<void(content::CertificateRequestResultType)>&
-        callback) {
-  if (delegate_) {
-    delegate_->AllowCertificateError(
-        web_contents, cert_error, ssl_info, request_url, resource_type,
-        strict_enforcement, expired_previous_decision, callback);
-  }
-}
-
-void AtomBrowserClient::SelectClientCertificate(
-    content::WebContents* web_contents,
-    net::SSLCertRequestInfo* cert_request_info,
-    net::ClientCertIdentityList client_certs,
-    std::unique_ptr<content::ClientCertificateDelegate> delegate) {
-  if (!client_certs.empty() && delegate_) {
-    delegate_->SelectClientCertificate(web_contents, cert_request_info,
-                                       std::move(client_certs),
-                                       std::move(delegate));
-  }
-}
-
-void AtomBrowserClient::ResourceDispatcherHostCreated() {
-  resource_dispatcher_host_delegate_.reset(
-      new AtomResourceDispatcherHostDelegate);
-  content::ResourceDispatcherHost::Get()->SetDelegate(
-      resource_dispatcher_host_delegate_.get());
-}
-
-bool AtomBrowserClient::CanCreateWindow(
-    content::RenderFrameHost* opener,
-    const GURL& opener_url,
-    const GURL& opener_top_level_frame_url,
-    const GURL& source_origin,
-    content::mojom::WindowContainerType container_type,
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const blink::mojom::WindowFeatures& features,
-    const std::vector<std::string>& additional_features,
-    const scoped_refptr<network::ResourceRequestBody>& body,
-    bool user_gesture,
-    bool opener_suppressed,
-    bool* no_javascript_access) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  int opener_render_process_id = opener->GetProcess()->GetID();
-
-  if (IsRendererSandboxed(opener_render_process_id)) {
-    *no_javascript_access = false;
-    return true;
-  }
-
-  if (RendererUsesNativeWindowOpen(opener_render_process_id)) {
-    if (RendererDisablesPopups(opener_render_process_id)) {
-      // <webview> without allowpopups attribute should return
-      // null from window.open calls
-      return false;
-    } else {
-      *no_javascript_access = false;
-      return true;
-    }
-  }
-
-  if (delegate_) {
-    return delegate_->CanCreateWindow(
-        opener, opener_url, opener_top_level_frame_url, source_origin,
-        container_type, target_url, referrer, frame_name, disposition, features,
-        additional_features, body, user_gesture, opener_suppressed,
-        no_javascript_access);
-  }
-
-  return false;
-}
-
-void AtomBrowserClient::GetAdditionalAllowedSchemesForFileSystem(
-    std::vector<std::string>* additional_schemes) {
-  auto schemes_list = api::GetStandardSchemes();
-  if (!schemes_list.empty())
-    additional_schemes->insert(additional_schemes->end(), schemes_list.begin(),
-                               schemes_list.end());
-  additional_schemes->push_back(content::kChromeDevToolsScheme);
-}
-
-void AtomBrowserClient::SiteInstanceDeleting(
-    content::SiteInstance* site_instance) {
-  // We are storing weak_ptr, is it fundamental to maintain the map up-to-date
-  // when an instance is destroyed.
-  for (auto iter = site_per_affinities.begin();
-       iter != site_per_affinities.end(); ++iter) {
-    if (iter->second == site_instance) {
-      site_per_affinities.erase(iter);
-      break;
-    }
-  }
-}
-
-std::unique_ptr<net::ClientCertStore> AtomBrowserClient::CreateClientCertStore(
-    content::ResourceContext* resource_context) {
-#if defined(USE_NSS_CERTS)
-  return std::make_unique<net::ClientCertStoreNSS>(
-      net::ClientCertStoreNSS::PasswordDelegateFactory());
-#elif defined(OS_WIN)
-  return std::make_unique<net::ClientCertStoreWin>();
-#elif defined(OS_MACOSX)
-  return std::make_unique<net::ClientCertStoreMac>();
-#elif defined(USE_OPENSSL)
-  return std::unique_ptr<net::ClientCertStore>();
-#endif
-}
-
-brightray::BrowserMainParts* AtomBrowserClient::OverrideCreateBrowserMainParts(
-    const content::MainFunctionParams&) {
-  v8::V8::Initialize();  // Init V8 before creating main parts.
-  return new AtomBrowserMainParts;
-}
-
-void AtomBrowserClient::WebNotificationAllowed(
-    int render_process_id,
-    const base::Callback<void(bool, bool)>& callback) {
-  content::WebContents* web_contents =
-      WebContentsPreferences::GetWebContentsFromProcessID(render_process_id);
-  if (!web_contents) {
-    callback.Run(false, false);
-    return;
-  }
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  if (!permission_helper) {
-    callback.Run(false, false);
-    return;
-  }
-  permission_helper->RequestWebNotificationPermission(
-      base::Bind(callback, web_contents->IsAudioMuted()));
-}
-
-void AtomBrowserClient::RenderProcessHostDestroyed(
-    content::RenderProcessHost* host) {
-  int process_id = host->GetID();
-  pending_processes_.erase(process_id);
-  RemoveProcessPreferences(process_id);
-}
-
-void AtomBrowserClient::RenderProcessReady(content::RenderProcessHost* host) {
-  render_process_host_pids_[host->GetID()] = base::GetProcId(host->GetHandle());
-  if (delegate_) {
-    static_cast<api::App*>(delegate_)->RenderProcessReady(host);
-  }
-}
-
-void AtomBrowserClient::RenderProcessExited(content::RenderProcessHost* host,
-                                            base::TerminationStatus status,
-                                            int exit_code) {
-  auto host_pid = render_process_host_pids_.find(host->GetID());
-  if (host_pid != render_process_host_pids_.end()) {
-    if (delegate_) {
-      static_cast<api::App*>(delegate_)->RenderProcessDisconnected(
-          host_pid->second);
-    }
-    render_process_host_pids_.erase(host_pid);
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 8f62887ff6807f18226842d7042dbcef76d8a835 atom/browser/atom_browser_client.h
  our    100644 a0284cf3f72e9cd4292b636948f92bb09b97f0ae atom/browser/atom_browser_client.h
@@ -1,161 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
-#define ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
-
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "brightray/browser/browser_client.h"
-#include "content/public/browser/render_process_host_observer.h"
-#include "net/ssl/client_cert_identity.h"
-
-namespace content {
-class QuotaPermissionContext;
-class ClientCertificateDelegate;
-}  // namespace content
-
-namespace net {
-class SSLCertRequestInfo;
-}
-
-namespace atom {
-
-class AtomResourceDispatcherHostDelegate;
-
-class AtomBrowserClient : public brightray::BrowserClient,
-                          public content::RenderProcessHostObserver {
- public:
-  AtomBrowserClient();
-  ~AtomBrowserClient() override;
-
-  using Delegate = content::ContentBrowserClient;
-  void set_delegate(Delegate* delegate) { delegate_ = delegate; }
-
-  // Returns the WebContents for pending render processes.
-  content::WebContents* GetWebContentsFromProcessID(int process_id);
-
-  // Don't force renderer process to restart for once.
-  static void SuppressRendererProcessRestartForOnce();
-
-  // Custom schemes to be registered to handle service worker.
-  static void SetCustomServiceWorkerSchemes(
-      const std::vector<std::string>& schemes);
-
- protected:
-  // content::ContentBrowserClient:
-  void RenderProcessWillLaunch(
-      content::RenderProcessHost* host,
-      service_manager::mojom::ServiceRequest* service_request) override;
-  content::SpeechRecognitionManagerDelegate*
-  CreateSpeechRecognitionManagerDelegate() override;
-  void OverrideWebkitPrefs(content::RenderViewHost* render_view_host,
-                           content::WebPreferences* prefs) override;
-  void OverrideSiteInstanceForNavigation(
-      content::RenderFrameHost* render_frame_host,
-      content::BrowserContext* browser_context,
-      const GURL& dest_url,
-      bool has_request_started,
-      content::SiteInstance* candidate_instance,
-      content::SiteInstance** new_instance) override;
-  void AppendExtraCommandLineSwitches(base::CommandLine* command_line,
-                                      int child_process_id) override;
-  void DidCreatePpapiPlugin(content::BrowserPpapiHost* browser_host) override;
-  void GetGeolocationRequestContext(
-      base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)>
-          callback) override;
-  std::string GetGeolocationApiKey() override;
-  content::QuotaPermissionContext* CreateQuotaPermissionContext() override;
-  void AllowCertificateError(
-      content::WebContents* web_contents,
-      int cert_error,
-      const net::SSLInfo& ssl_info,
-      const GURL& request_url,
-      content::ResourceType resource_type,
-      bool strict_enforcement,
-      bool expired_previous_decision,
-      const base::Callback<void(content::CertificateRequestResultType)>&
-          callback) override;
-  void SelectClientCertificate(
-      content::WebContents* web_contents,
-      net::SSLCertRequestInfo* cert_request_info,
-      net::ClientCertIdentityList client_certs,
-      std::unique_ptr<content::ClientCertificateDelegate> delegate) override;
-  void ResourceDispatcherHostCreated() override;
-  bool CanCreateWindow(content::RenderFrameHost* opener,
-                       const GURL& opener_url,
-                       const GURL& opener_top_level_frame_url,
-                       const GURL& source_origin,
-                       content::mojom::WindowContainerType container_type,
-                       const GURL& target_url,
-                       const content::Referrer& referrer,
-                       const std::string& frame_name,
-                       WindowOpenDisposition disposition,
-                       const blink::mojom::WindowFeatures& features,
-                       const std::vector<std::string>& additional_features,
-                       const scoped_refptr<network::ResourceRequestBody>& body,
-                       bool user_gesture,
-                       bool opener_suppressed,
-                       bool* no_javascript_access) override;
-  void GetAdditionalAllowedSchemesForFileSystem(
-      std::vector<std::string>* schemes) override;
-  void SiteInstanceDeleting(content::SiteInstance* site_instance) override;
-  std::unique_ptr<net::ClientCertStore> CreateClientCertStore(
-      content::ResourceContext* resource_context) override;
-
-  // brightray::BrowserClient:
-  brightray::BrowserMainParts* OverrideCreateBrowserMainParts(
-      const content::MainFunctionParams&) override;
-  void WebNotificationAllowed(
-      int render_process_id,
-      const base::Callback<void(bool, bool)>& callback) override;
-
-  // content::RenderProcessHostObserver:
-  void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
-  void RenderProcessReady(content::RenderProcessHost* host) override;
-  void RenderProcessExited(content::RenderProcessHost* host,
-                           base::TerminationStatus status,
-                           int exit_code) override;
-
- private:
-  struct ProcessPreferences {
-    bool sandbox = false;
-    bool native_window_open = false;
-    bool disable_popups = false;
-  };
-
-  bool ShouldCreateNewSiteInstance(content::RenderFrameHost* render_frame_host,
-                                   content::BrowserContext* browser_context,
-                                   content::SiteInstance* current_instance,
-                                   const GURL& dest_url);
-  void AddProcessPreferences(int process_id, ProcessPreferences prefs);
-  void RemoveProcessPreferences(int process_id);
-  bool IsProcessObserved(int process_id);
-  bool IsRendererSandboxed(int process_id);
-  bool RendererUsesNativeWindowOpen(int process_id);
-  bool RendererDisablesPopups(int process_id);
-
-  // pending_render_process => web contents.
-  std::map<int, content::WebContents*> pending_processes_;
-
-  std::map<int, ProcessPreferences> process_preferences_;
-  std::map<int, base::ProcessId> render_process_host_pids_;
-
-  // list of site per affinity. weak_ptr to prevent instance locking
-  std::map<std::string, content::SiteInstance*> site_per_affinities;
-
-  std::unique_ptr<AtomResourceDispatcherHostDelegate>
-      resource_dispatcher_host_delegate_;
-
-  Delegate* delegate_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
removed in remote
  base   100644 d6724ff533841932f792488f19a3118dba5f379e atom/browser/atom_browser_context.cc
  our    100644 e036cbc8103f19a034ce386940462f8a23ea6807 atom/browser/atom_browser_context.cc
@@ -1,148 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_context.h"
-
-#include "atom/browser/atom_blob_reader.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_download_manager_delegate.h"
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/request_context_delegate.h"
-#include "atom/browser/special_storage_policy.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/files/file_path.h"
-#include "base/path_service.h"
-#include "base/strings/stringprintf.h"
-#include "chrome/common/chrome_paths.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "content/browser/blob_storage/chrome_blob_storage_context.h"
-#include "content/public/common/user_agent.h"
-
-namespace atom {
-
-namespace {
-
-std::string RemoveWhitespace(const std::string& str) {
-  std::string trimmed;
-  if (base::RemoveChars(str, " ", &trimmed))
-    return trimmed;
-  else
-    return str;
-}
-
-}  // namespace
-
-AtomBrowserContext::AtomBrowserContext(const std::string& partition,
-                                       bool in_memory,
-                                       const base::DictionaryValue& options)
-    : brightray::BrowserContext(partition, in_memory),
-      url_request_context_getter_(nullptr),
-      storage_policy_(new SpecialStoragePolicy) {
-  // Construct user agent string.
-  Browser* browser = Browser::Get();
-  std::string name = RemoveWhitespace(browser->GetName());
-  std::string user_agent;
-  if (name == ATOM_PRODUCT_NAME) {
-    user_agent = "Chrome/" CHROME_VERSION_STRING " " ATOM_PRODUCT_NAME
-                 "/" ATOM_VERSION_STRING;
-  } else {
-    user_agent = base::StringPrintf(
-        "%s/%s Chrome/%s " ATOM_PRODUCT_NAME "/" ATOM_VERSION_STRING,
-        name.c_str(), browser->GetVersion().c_str(), CHROME_VERSION_STRING);
-  }
-  user_agent_ = content::BuildUserAgentFromProduct(user_agent);
-
-  // Read options.
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-  bool use_cache = !command_line->HasSwitch(switches::kDisableHttpCache);
-  options.GetBoolean("cache", &use_cache);
-
-  request_context_delegate_.reset(new RequestContextDelegate(use_cache));
-
-  // Initialize Pref Registry in brightray.
-  InitPrefs();
-}
-
-AtomBrowserContext::~AtomBrowserContext() {
-  url_request_context_getter_->set_delegate(nullptr);
-}
-
-void AtomBrowserContext::SetUserAgent(const std::string& user_agent) {
-  user_agent_ = user_agent;
-}
-
-content::DownloadManagerDelegate*
-AtomBrowserContext::GetDownloadManagerDelegate() {
-  if (!download_manager_delegate_.get()) {
-    auto* download_manager = content::BrowserContext::GetDownloadManager(this);
-    download_manager_delegate_.reset(
-        new AtomDownloadManagerDelegate(download_manager));
-  }
-  return download_manager_delegate_.get();
-}
-
-content::BrowserPluginGuestManager* AtomBrowserContext::GetGuestManager() {
-  if (!guest_manager_)
-    guest_manager_.reset(new WebViewManager);
-  return guest_manager_.get();
-}
-
-content::PermissionManager* AtomBrowserContext::GetPermissionManager() {
-  if (!permission_manager_.get())
-    permission_manager_.reset(new AtomPermissionManager);
-  return permission_manager_.get();
-}
-
-storage::SpecialStoragePolicy* AtomBrowserContext::GetSpecialStoragePolicy() {
-  return storage_policy_.get();
-}
-
-void AtomBrowserContext::RegisterPrefs(PrefRegistrySimple* pref_registry) {
-  pref_registry->RegisterFilePathPref(prefs::kSelectFileLastDirectory,
-                                      base::FilePath());
-  base::FilePath download_dir;
-  PathService::Get(chrome::DIR_DEFAULT_DOWNLOADS, &download_dir);
-  pref_registry->RegisterFilePathPref(prefs::kDownloadDefaultDirectory,
-                                      download_dir);
-  pref_registry->RegisterDictionaryPref(prefs::kDevToolsFileSystemPaths);
-}
-
-std::string AtomBrowserContext::GetUserAgent() const {
-  return user_agent_;
-}
-
-void AtomBrowserContext::OnMainRequestContextCreated(
-    brightray::URLRequestContextGetter* getter) {
-  getter->set_delegate(request_context_delegate_.get());
-  url_request_context_getter_ = getter;
-}
-
-AtomBlobReader* AtomBrowserContext::GetBlobReader() {
-  if (!blob_reader_.get()) {
-    content::ChromeBlobStorageContext* blob_context =
-        content::ChromeBlobStorageContext::GetFor(this);
-    blob_reader_.reset(new AtomBlobReader(blob_context));
-  }
-  return blob_reader_.get();
-}
-
-// static
-scoped_refptr<AtomBrowserContext> AtomBrowserContext::From(
-    const std::string& partition,
-    bool in_memory,
-    const base::DictionaryValue& options) {
-  auto browser_context = brightray::BrowserContext::Get(partition, in_memory);
-  if (browser_context)
-    return static_cast<AtomBrowserContext*>(browser_context.get());
-
-  return new AtomBrowserContext(partition, in_memory, options);
-}
-
-}  // namespace atom
removed in remote
  base   100644 d959adbc753a6e4c4302f9013ede952c41439c1a atom/browser/atom_browser_context.h
  our    100644 9e6a841ceb8d11069a1a094bf7dbbd3a788918b3 atom/browser/atom_browser_context.h
@@ -1,78 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
-#define ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
-
-#include <string>
-#include <vector>
-
-#include "base/memory/scoped_refptr.h"
-#include "brightray/browser/browser_context.h"
-
-namespace storage {
-class SpecialStoragePolicy;
-}
-
-namespace atom {
-
-class AtomBlobReader;
-class AtomDownloadManagerDelegate;
-class AtomPermissionManager;
-class RequestContextDelegate;
-class SpecialStoragePolicy;
-class WebViewManager;
-
-class AtomBrowserContext : public brightray::BrowserContext {
- public:
-  // Get or create the BrowserContext according to its |partition| and
-  // |in_memory|. The |options| will be passed to constructor when there is no
-  // existing BrowserContext.
-  static scoped_refptr<AtomBrowserContext> From(
-      const std::string& partition,
-      bool in_memory,
-      const base::DictionaryValue& options = base::DictionaryValue());
-
-  void SetUserAgent(const std::string& user_agent);
-  AtomBlobReader* GetBlobReader();
-
-  // content::BrowserContext:
-  content::DownloadManagerDelegate* GetDownloadManagerDelegate() override;
-  content::BrowserPluginGuestManager* GetGuestManager() override;
-  content::PermissionManager* GetPermissionManager() override;
-  storage::SpecialStoragePolicy* GetSpecialStoragePolicy() override;
-
-  // brightray::BrowserContext:
-  void RegisterPrefs(PrefRegistrySimple* pref_registry) override;
-  std::string GetUserAgent() const override;
-  void OnMainRequestContextCreated(
-      brightray::URLRequestContextGetter* getter) override;
-
-  RequestContextDelegate* GetRequestContextDelegate() const {
-    return request_context_delegate_.get();
-  }
-
- protected:
-  AtomBrowserContext(const std::string& partition,
-                     bool in_memory,
-                     const base::DictionaryValue& options);
-  ~AtomBrowserContext() override;
-
- private:
-  brightray::URLRequestContextGetter* url_request_context_getter_;
-
-  std::unique_ptr<AtomDownloadManagerDelegate> download_manager_delegate_;
-  std::unique_ptr<WebViewManager> guest_manager_;
-  std::unique_ptr<AtomPermissionManager> permission_manager_;
-  scoped_refptr<storage::SpecialStoragePolicy> storage_policy_;
-  std::unique_ptr<AtomBlobReader> blob_reader_;
-  std::unique_ptr<RequestContextDelegate> request_context_delegate_;
-  std::string user_agent_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserContext);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
removed in remote
  base   100644 f45f6492a849486fd009b60f3e07918b76bda34e atom/browser/atom_browser_main_parts.cc
  our    100644 5229b19ca9af7845a3f2f13b7e0913f633b68b1d atom/browser/atom_browser_main_parts.cc
@@ -1,282 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include "atom/browser/api/atom_api_app.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/bridge_task_runner.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/javascript_environment.h"
-#include "atom/browser/node_debugger.h"
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/node_bindings.h"
-#include "base/command_line.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/browser_process.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/common/result_codes.h"
-#include "content/public/common/service_manager_connection.h"
-#include "services/device/public/mojom/constants.mojom.h"
-#include "services/service_manager/public/cpp/connector.h"
-#include "ui/base/idle/idle.h"
-#include "ui/base/l10n/l10n_util.h"
-
-#if defined(USE_X11)
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "ui/events/devices/x11/touch_factory_x11.h"
-#endif
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/browser/atom_web_ui_controller_factory.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-#if defined(OS_MACOSX)
-#include "atom/browser/ui/cocoa/views_delegate_mac.h"
-#else
-#include "brightray/browser/views/views_delegate.h"
-#endif
-
-// Must be included after all other headers.
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace {
-
-template <typename T>
-void Erase(T* container, typename T::iterator iter) {
-  container->erase(iter);
-}
-
-}  // namespace
-
-// static
-AtomBrowserMainParts* AtomBrowserMainParts::self_ = nullptr;
-
-AtomBrowserMainParts::AtomBrowserMainParts()
-    : fake_browser_process_(new BrowserProcess),
-      browser_(new Browser),
-      node_bindings_(NodeBindings::Create(NodeBindings::BROWSER)),
-      atom_bindings_(new AtomBindings(uv_default_loop())),
-      gc_timer_(true, true) {
-  DCHECK(!self_) << "Cannot have two AtomBrowserMainParts";
-  self_ = this;
-  // Register extension scheme as web safe scheme.
-  content::ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeScheme(
-      "chrome-extension");
-}
-
-AtomBrowserMainParts::~AtomBrowserMainParts() {
-  asar::ClearArchives();
-  // Leak the JavascriptEnvironment on exit.
-  // This is to work around the bug that V8 would be waiting for background
-  // tasks to finish on exit, while somehow it waits forever in Electron, more
-  // about this can be found at
-  // https://github.com/electron/electron/issues/4767. On the other handle there
-  // is actually no need to gracefully shutdown V8 on exit in the main process,
-  // we already ensured all necessary resources get cleaned up, and it would
-  // make quitting faster.
-  ignore_result(js_env_.release());
-}
-
-// static
-AtomBrowserMainParts* AtomBrowserMainParts::Get() {
-  DCHECK(self_);
-  return self_;
-}
-
-bool AtomBrowserMainParts::SetExitCode(int code) {
-  if (!exit_code_)
-    return false;
-
-  *exit_code_ = code;
-  return true;
-}
-
-int AtomBrowserMainParts::GetExitCode() {
-  return exit_code_ != nullptr ? *exit_code_ : 0;
-}
-
-void AtomBrowserMainParts::RegisterDestructionCallback(
-    base::OnceClosure callback) {
-  // The destructors should be called in reversed order, so dependencies between
-  // JavaScript objects can be correctly resolved.
-  // For example WebContentsView => WebContents => Session.
-  destructors_.insert(destructors_.begin(), std::move(callback));
-}
-
-int AtomBrowserMainParts::PreEarlyInitialization() {
-  const int result = brightray::BrowserMainParts::PreEarlyInitialization();
-  if (result != content::RESULT_CODE_NORMAL_EXIT)
-    return result;
-
-#if defined(OS_POSIX)
-  HandleSIGCHLD();
-#endif
-
-  return content::RESULT_CODE_NORMAL_EXIT;
-}
-
-void AtomBrowserMainParts::PostEarlyInitialization() {
-  brightray::BrowserMainParts::PostEarlyInitialization();
-
-  // Temporary set the bridge_task_runner_ as current thread's task runner,
-  // so we can fool gin::PerIsolateData to use it as its task runner, instead
-  // of getting current message loop's task runner, which is null for now.
-  bridge_task_runner_ = new BridgeTaskRunner;
-  base::ThreadTaskRunnerHandle handle(bridge_task_runner_);
-
-  // The ProxyResolverV8 has setup a complete V8 environment, in order to
-  // avoid conflicts we only initialize our V8 environment after that.
-  js_env_.reset(new JavascriptEnvironment);
-
-  node_bindings_->Initialize();
-
-  // Create the global environment.
-  node::Environment* env = node_bindings_->CreateEnvironment(
-      js_env_->context(), js_env_->platform());
-  node_env_.reset(new NodeEnvironment(env));
-
-  // Enable support for v8 inspector
-  node_debugger_.reset(new NodeDebugger(env));
-  node_debugger_->Start(js_env_->platform());
-
-  // Add Electron extended APIs.
-  atom_bindings_->BindTo(js_env_->isolate(), env->process_object());
-
-  // Load everything.
-  node_bindings_->LoadEnvironment(env);
-
-  // Wrap the uv loop with global env.
-  node_bindings_->set_uv_env(env);
-
-  // We already initialized the feature list in
-  // brightray::BrowserMainParts::PreEarlyInitialization(), but
-  // the user JS script would not have had a chance to alter the command-line
-  // switches at that point. Lets reinitialize it here to pick up the
-  // command-line changes.
-  base::FeatureList::ClearInstanceForTesting();
-  brightray::BrowserMainParts::InitializeFeatureList();
-}
-
-int AtomBrowserMainParts::PreCreateThreads() {
-  const int result = brightray::BrowserMainParts::PreCreateThreads();
-  if (!result) {
-    fake_browser_process_->SetApplicationLocale(
-        brightray::BrowserClient::Get()->GetApplicationLocale());
-  }
-
-#if defined(OS_MACOSX)
-  ui::InitIdleMonitor();
-#endif
-
-  return result;
-}
-
-void AtomBrowserMainParts::ToolkitInitialized() {
-  brightray::BrowserMainParts::ToolkitInitialized();
-#if defined(OS_MACOSX)
-  views_delegate_.reset(new ViewsDelegateMac);
-#else
-  views_delegate_.reset(new brightray::ViewsDelegate);
-#endif
-}
-
-void AtomBrowserMainParts::PreMainMessageLoopRun() {
-  js_env_->OnMessageLoopCreated();
-
-  // Run user's main script before most things get initialized, so we can have
-  // a chance to setup everything.
-  node_bindings_->PrepareMessageLoop();
-  node_bindings_->RunMessageLoop();
-
-#if defined(USE_X11)
-  ui::TouchFactory::SetTouchDeviceListFromCommandLine();
-#endif
-
-  // Start idle gc.
-  gc_timer_.Start(FROM_HERE, base::TimeDelta::FromMinutes(1),
-                  base::Bind(&v8::Isolate::LowMemoryNotification,
-                             base::Unretained(js_env_->isolate())));
-
-#if defined(ENABLE_PDF_VIEWER)
-  content::WebUIControllerFactory::RegisterFactory(
-      AtomWebUIControllerFactory::GetInstance());
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-  brightray::BrowserMainParts::PreMainMessageLoopRun();
-  bridge_task_runner_->MessageLoopIsReady();
-  bridge_task_runner_ = nullptr;
-
-#if defined(USE_X11)
-  libgtkui::GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
-#endif
-
-#if !defined(OS_MACOSX)
-  // The corresponding call in macOS is in AtomApplicationDelegate.
-  Browser::Get()->WillFinishLaunching();
-  Browser::Get()->DidFinishLaunching(base::DictionaryValue());
-#endif
-
-  // Notify observers that main thread message loop was initialized.
-  Browser::Get()->PreMainMessageLoopRun();
-}
-
-bool AtomBrowserMainParts::MainMessageLoopRun(int* result_code) {
-  exit_code_ = result_code;
-  return brightray::BrowserMainParts::MainMessageLoopRun(result_code);
-}
-
-void AtomBrowserMainParts::PostMainMessageLoopStart() {
-  brightray::BrowserMainParts::PostMainMessageLoopStart();
-#if defined(OS_POSIX)
-  HandleShutdownSignals();
-#endif
-  // TODO(deepak1556): Enable this optionally based on response
-  // from AtomPermissionManager.
-  GetGeolocationControl()->UserDidOptIntoLocationServices();
-}
-
-void AtomBrowserMainParts::PostMainMessageLoopRun() {
-  brightray::BrowserMainParts::PostMainMessageLoopRun();
-
-  js_env_->OnMessageLoopDestroying();
-
-#if defined(OS_MACOSX)
-  FreeAppDelegate();
-#endif
-
-  // Make sure destruction callbacks are called before message loop is
-  // destroyed, otherwise some objects that need to be deleted on IO thread
-  // won't be freed.
-  // We don't use ranged for loop because iterators are getting invalided when
-  // the callback runs.
-  for (auto iter = destructors_.begin(); iter != destructors_.end();) {
-    base::OnceClosure callback = std::move(*iter);
-    if (!callback.is_null())
-      std::move(callback).Run();
-    ++iter;
-  }
-}
-
-device::mojom::GeolocationControl*
-AtomBrowserMainParts::GetGeolocationControl() {
-  if (geolocation_control_)
-    return geolocation_control_.get();
-
-  auto request = mojo::MakeRequest(&geolocation_control_);
-  if (!content::ServiceManagerConnection::GetForProcess())
-    return geolocation_control_.get();
-
-  service_manager::Connector* connector =
-      content::ServiceManagerConnection::GetForProcess()->GetConnector();
-  connector->BindInterface(device::mojom::kServiceName, std::move(request));
-  return geolocation_control_.get();
-}
-
-}  // namespace atom
removed in remote
  base   100644 e1053a257b9130b6ff16560297a4dc1826ae9ea2 atom/browser/atom_browser_main_parts.h
  our    100644 e73f4581202e6853ffc6a51dbd9116c0ab2097d6 atom/browser/atom_browser_main_parts.h
@@ -1,123 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
-#define ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
-
-#include <list>
-#include <string>
-
-#include "base/callback.h"
-#include "base/timer/timer.h"
-#include "brightray/browser/browser_main_parts.h"
-#include "content/public/browser/browser_context.h"
-#include "services/device/public/mojom/geolocation_control.mojom.h"
-
-class BrowserProcess;
-
-#if defined(TOOLKIT_VIEWS)
-namespace brightray {
-class ViewsDelegate;
-}
-#endif
-
-namespace atom {
-
-class AtomBindings;
-class Browser;
-class JavascriptEnvironment;
-class NodeBindings;
-class NodeDebugger;
-class NodeEnvironment;
-class BridgeTaskRunner;
-
-#if defined(OS_MACOSX)
-class ViewsDelegateMac;
-#endif
-
-class AtomBrowserMainParts : public brightray::BrowserMainParts {
- public:
-  AtomBrowserMainParts();
-  ~AtomBrowserMainParts() override;
-
-  static AtomBrowserMainParts* Get();
-
-  // Sets the exit code, will fail if the message loop is not ready.
-  bool SetExitCode(int code);
-
-  // Gets the exit code
-  int GetExitCode();
-
-  // Register a callback that should be destroyed before JavaScript environment
-  // gets destroyed.
-  // Returns a closure that can be used to remove |callback| from the list.
-  void RegisterDestructionCallback(base::OnceClosure callback);
-
-  Browser* browser() { return browser_.get(); }
-
- protected:
-  // content::BrowserMainParts:
-  int PreEarlyInitialization() override;
-  void PostEarlyInitialization() override;
-  int PreCreateThreads() override;
-  void ToolkitInitialized() override;
-  void PreMainMessageLoopRun() override;
-  bool MainMessageLoopRun(int* result_code) override;
-  void PostMainMessageLoopStart() override;
-  void PostMainMessageLoopRun() override;
-#if defined(OS_MACOSX)
-  void PreMainMessageLoopStart() override;
-#endif
-
- private:
-#if defined(OS_POSIX)
-  // Set signal handlers.
-  void HandleSIGCHLD();
-  void HandleShutdownSignals();
-#endif
-
-#if defined(OS_MACOSX)
-  void FreeAppDelegate();
-#endif
-
-#if defined(OS_MACOSX)
-  std::unique_ptr<ViewsDelegateMac> views_delegate_;
-#else
-  std::unique_ptr<brightray::ViewsDelegate> views_delegate_;
-#endif
-
-  device::mojom::GeolocationControl* GetGeolocationControl();
-
-  // A fake BrowserProcess object that used to feed the source code from chrome.
-  std::unique_ptr<BrowserProcess> fake_browser_process_;
-
-  // The gin::PerIsolateData requires a task runner to create, so we feed it
-  // with a task runner that will post all work to main loop.
-  scoped_refptr<BridgeTaskRunner> bridge_task_runner_;
-
-  // Pointer to exit code.
-  int* exit_code_ = nullptr;
-
-  std::unique_ptr<Browser> browser_;
-  std::unique_ptr<JavascriptEnvironment> js_env_;
-  std::unique_ptr<NodeBindings> node_bindings_;
-  std::unique_ptr<AtomBindings> atom_bindings_;
-  std::unique_ptr<NodeEnvironment> node_env_;
-  std::unique_ptr<NodeDebugger> node_debugger_;
-
-  base::Timer gc_timer_;
-
-  // List of callbacks should be executed before destroying JS env.
-  std::list<base::OnceClosure> destructors_;
-
-  device::mojom::GeolocationControlPtr geolocation_control_;
-
-  static AtomBrowserMainParts* self_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserMainParts);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
removed in remote
  base   100644 d6e83fd968b0de926d54ab4a795bdb3e1adcfb2f atom/browser/atom_browser_main_parts_mac.mm
  our    100644 17a5681a16a987a3a0d490f15a021bfbfdc88861 atom/browser/atom_browser_main_parts_mac.mm
@@ -1,37 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/atom_application_delegate.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "ui/base/l10n/l10n_util_mac.h"
-
-namespace atom {
-
-void AtomBrowserMainParts::PreMainMessageLoopStart() {
-  // Force the NSApplication subclass to be used.
-  [AtomApplication sharedApplication];
-
-  // Set our own application delegate.
-  AtomApplicationDelegate* delegate = [[AtomApplicationDelegate alloc] init];
-  [NSApp setDelegate:delegate];
-
-  brightray::BrowserMainParts::PreMainMessageLoopStart();
-
-  // Prevent Cocoa from turning command-line arguments into
-  // |-application:openFiles:|, since we already handle them directly.
-  [[NSUserDefaults standardUserDefaults]
-      setObject:@"NO"
-         forKey:@"NSTreatUnknownArgumentsAsOpen"];
-}
-
-void AtomBrowserMainParts::FreeAppDelegate() {
-  [[NSApp delegate] release];
-  [NSApp setDelegate:nil];
-}
-
-}  // namespace atom
removed in remote
  base   100644 2a0dddc474837972c702399da259a8b44bb01369 atom/browser/atom_browser_main_parts_posix.cc
  our    100644 d79e60049f4db41b7b992c412cf271d461227115 atom/browser/atom_browser_main_parts_posix.cc
@@ -1,222 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Most code came from: chrome/browser/chrome_browser_main_posix.cc.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include <errno.h>
-#include <limits.h>
-#include <pthread.h>
-#include <signal.h>
-#include <sys/resource.h>
-#include <unistd.h>
-
-#include "atom/browser/browser.h"
-#include "base/posix/eintr_wrapper.h"
-#include "content/public/browser/browser_thread.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// See comment in |PreEarlyInitialization()|, where sigaction is called.
-void SIGCHLDHandler(int signal) {}
-
-// The OSX fork() implementation can crash in the child process before
-// fork() returns.  In that case, the shutdown pipe will still be
-// shared with the parent process.  To prevent child crashes from
-// causing parent shutdowns, |g_pipe_pid| is the pid for the process
-// which registered |g_shutdown_pipe_write_fd|.
-// See <http://crbug.com/175341>.
-pid_t g_pipe_pid = -1;
-int g_shutdown_pipe_write_fd = -1;
-int g_shutdown_pipe_read_fd = -1;
-
-// Common code between SIG{HUP, INT, TERM}Handler.
-void GracefulShutdownHandler(int signal) {
-  // Reinstall the default handler.  We had one shot at graceful shutdown.
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIG_DFL;
-  RAW_CHECK(sigaction(signal, &action, nullptr) == 0);
-
-  RAW_CHECK(g_pipe_pid == getpid());
-  RAW_CHECK(g_shutdown_pipe_write_fd != -1);
-  RAW_CHECK(g_shutdown_pipe_read_fd != -1);
-  size_t bytes_written = 0;
-  do {
-    int rv = HANDLE_EINTR(
-        write(g_shutdown_pipe_write_fd,
-              reinterpret_cast<const char*>(&signal) + bytes_written,
-              sizeof(signal) - bytes_written));
-    RAW_CHECK(rv >= 0);
-    bytes_written += rv;
-  } while (bytes_written < sizeof(signal));
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGHUPHandler(int signal) {
-  RAW_CHECK(signal == SIGHUP);
-  GracefulShutdownHandler(signal);
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGINTHandler(int signal) {
-  RAW_CHECK(signal == SIGINT);
-  GracefulShutdownHandler(signal);
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGTERMHandler(int signal) {
-  RAW_CHECK(signal == SIGTERM);
-  GracefulShutdownHandler(signal);
-}
-
-class ShutdownDetector : public base::PlatformThread::Delegate {
- public:
-  explicit ShutdownDetector(int shutdown_fd);
-
-  void ThreadMain() override;
-
- private:
-  const int shutdown_fd_;
-
-  DISALLOW_COPY_AND_ASSIGN(ShutdownDetector);
-};
-
-ShutdownDetector::ShutdownDetector(int shutdown_fd)
-    : shutdown_fd_(shutdown_fd) {
-  CHECK_NE(shutdown_fd_, -1);
-}
-
-// These functions are used to help us diagnose crash dumps that happen
-// during the shutdown process.
-NOINLINE void ShutdownFDReadError() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-NOINLINE void ShutdownFDClosedError() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-NOINLINE void ExitPosted() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-void ShutdownDetector::ThreadMain() {
-  base::PlatformThread::SetName("CrShutdownDetector");
-
-  int signal;
-  size_t bytes_read = 0;
-  do {
-    ssize_t ret = HANDLE_EINTR(
-        read(shutdown_fd_, reinterpret_cast<char*>(&signal) + bytes_read,
-             sizeof(signal) - bytes_read));
-    if (ret < 0) {
-      NOTREACHED() << "Unexpected error: " << strerror(errno);
-      ShutdownFDReadError();
-      break;
-    } else if (ret == 0) {
-      NOTREACHED() << "Unexpected closure of shutdown pipe.";
-      ShutdownFDClosedError();
-      break;
-    }
-    bytes_read += ret;
-  } while (bytes_read < sizeof(signal));
-  VLOG(1) << "Handling shutdown for signal " << signal << ".";
-  base::Closure task =
-      base::Bind(&Browser::Quit, base::Unretained(Browser::Get()));
-
-  if (!BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, task)) {
-    // Without a UI thread to post the exit task to, there aren't many
-    // options.  Raise the signal again.  The default handler will pick it up
-    // and cause an ungraceful exit.
-    RAW_LOG(WARNING, "No UI thread, exiting ungracefully.");
-    kill(getpid(), signal);
-
-    // The signal may be handled on another thread.  Give that a chance to
-    // happen.
-    sleep(3);
-
-    // We really should be dead by now.  For whatever reason, we're not. Exit
-    // immediately, with the exit status set to the signal number with bit 8
-    // set.  On the systems that we care about, this exit status is what is
-    // normally used to indicate an exit by this signal's default handler.
-    // This mechanism isn't a de jure standard, but even in the worst case, it
-    // should at least result in an immediate exit.
-    RAW_LOG(WARNING, "Still here, exiting really ungracefully.");
-    _exit(signal | (1 << 7));
-  }
-  ExitPosted();
-}
-
-}  // namespace
-
-void AtomBrowserMainParts::HandleSIGCHLD() {
-  // We need to accept SIGCHLD, even though our handler is a no-op because
-  // otherwise we cannot wait on children. (According to POSIX 2001.)
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIGCHLDHandler;
-  CHECK_EQ(sigaction(SIGCHLD, &action, nullptr), 0);
-}
-
-void AtomBrowserMainParts::HandleShutdownSignals() {
-  int pipefd[2];
-  int ret = pipe(pipefd);
-  if (ret < 0) {
-    PLOG(DFATAL) << "Failed to create pipe";
-  } else {
-    g_pipe_pid = getpid();
-    g_shutdown_pipe_read_fd = pipefd[0];
-    g_shutdown_pipe_write_fd = pipefd[1];
-#if !defined(ADDRESS_SANITIZER) && !defined(KEEP_SHADOW_STACKS)
-    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
-#else
-    // ASan instrumentation and -finstrument-functions (used for keeping the
-    // shadow stacks) bloat the stack frames, so we need to increase the stack
-    // size to avoid hitting the guard page.
-    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
-#endif
-    // TODO(viettrungluu,willchan): crbug.com/29675 - This currently leaks, so
-    // if you change this, you'll probably need to change the suppression.
-    if (!base::PlatformThread::CreateNonJoinable(
-            kShutdownDetectorThreadStackSize,
-            new ShutdownDetector(g_shutdown_pipe_read_fd))) {
-      LOG(DFATAL) << "Failed to create shutdown detector task.";
-    }
-  }
-  // Setup signal handlers for shutdown AFTER shutdown pipe is setup because
-  // it may be called right away after handler is set.
-
-  // If adding to this list of signal handlers, note the new signal probably
-  // needs to be reset in child processes. See
-  // base/process_util_posix.cc:LaunchProcess.
-
-  // We need to handle SIGTERM, because that is how many POSIX-based distros ask
-  // processes to quit gracefully at shutdown time.
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIGTERMHandler;
-  CHECK_EQ(sigaction(SIGTERM, &action, nullptr), 0);
-  // Also handle SIGINT - when the user terminates the browser via Ctrl+C. If
-  // the browser process is being debugged, GDB will catch the SIGINT first.
-  action.sa_handler = SIGINTHandler;
-  CHECK_EQ(sigaction(SIGINT, &action, nullptr), 0);
-  // And SIGHUP, for when the terminal disappears. On shutdown, many Linux
-  // distros send SIGHUP, SIGTERM, and then SIGKILL.
-  action.sa_handler = SIGHUPHandler;
-  CHECK_EQ(sigaction(SIGHUP, &action, nullptr), 0);
-}
-
-}  // namespace atom
removed in remote
  base   100644 16c0cf708b856286ed177b976141b8c87ad9a403 atom/browser/atom_download_manager_delegate.cc
  our    100644 83276affb18df31ebe64fad6c53960baad498582 atom/browser/atom_download_manager_delegate.cc
@@ -1,189 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_download_manager_delegate.h"
-
-#include <string>
-
-#include "atom/browser/api/atom_api_download_item.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/options_switches.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "base/task_scheduler/post_task.h"
-#include "chrome/common/pref_names.h"
-#include "components/download/public/common/download_danger_type.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_item_utils.h"
-#include "content/public/browser/download_manager.h"
-#include "net/base/filename_util.h"
-
-namespace atom {
-
-namespace {
-
-// Generate default file path to save the download.
-base::FilePath CreateDownloadPath(const GURL& url,
-                                  const std::string& content_disposition,
-                                  const std::string& suggested_filename,
-                                  const std::string& mime_type,
-                                  const base::FilePath& default_download_path) {
-  auto generated_name =
-      net::GenerateFileName(url, content_disposition, std::string(),
-                            suggested_filename, mime_type, "download");
-
-  if (!base::PathExists(default_download_path))
-    base::CreateDirectory(default_download_path);
-
-  return default_download_path.Append(generated_name);
-}
-
-}  // namespace
-
-AtomDownloadManagerDelegate::AtomDownloadManagerDelegate(
-    content::DownloadManager* manager)
-    : download_manager_(manager), weak_ptr_factory_(this) {}
-
-AtomDownloadManagerDelegate::~AtomDownloadManagerDelegate() {
-  if (download_manager_) {
-    DCHECK_EQ(static_cast<content::DownloadManagerDelegate*>(this),
-              download_manager_->GetDelegate());
-    download_manager_->SetDelegate(nullptr);
-    download_manager_ = nullptr;
-  }
-}
-
-void AtomDownloadManagerDelegate::GetItemSavePath(download::DownloadItem* item,
-                                                  base::FilePath* path) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  api::DownloadItem* download =
-      api::DownloadItem::FromWrappedClass(isolate, item);
-  if (download)
-    *path = download->GetSavePath();
-}
-
-void AtomDownloadManagerDelegate::OnDownloadPathGenerated(
-    uint32_t download_id,
-    const content::DownloadTargetCallback& callback,
-    const base::FilePath& default_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  auto* item = download_manager_->GetDownload(download_id);
-  if (!item)
-    return;
-
-  NativeWindow* window = nullptr;
-  content::WebContents* web_contents =
-      content::DownloadItemUtils::GetWebContents(item);
-  auto* relay =
-      web_contents ? NativeWindowRelay::FromWebContents(web_contents) : nullptr;
-  if (relay)
-    window = relay->window.get();
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  bool offscreen =
-      !web_preferences || web_preferences->IsEnabled(options::kOffscreen);
-
-  base::FilePath path;
-  GetItemSavePath(item, &path);
-  // Show save dialog if save path was not set already on item
-  file_dialog::DialogSettings settings;
-  settings.parent_window = window;
-  settings.force_detached = offscreen;
-  settings.title = item->GetURL().spec();
-  settings.default_path = default_path;
-  if (path.empty() && file_dialog::ShowSaveDialog(settings, &path)) {
-    // Remember the last selected download directory.
-    AtomBrowserContext* browser_context = static_cast<AtomBrowserContext*>(
-        download_manager_->GetBrowserContext());
-    browser_context->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
-                                          path.DirName());
-
-    v8::Isolate* isolate = v8::Isolate::GetCurrent();
-    v8::Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    api::DownloadItem* download_item =
-        api::DownloadItem::FromWrappedClass(isolate, item);
-    if (download_item)
-      download_item->SetSavePath(path);
-  }
-
-  // Running the DownloadTargetCallback with an empty FilePath signals that the
-  // download should be cancelled.
-  // If user cancels the file save dialog, run the callback with empty FilePath.
-  callback.Run(path, download::DownloadItem::TARGET_DISPOSITION_PROMPT,
-               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS, path,
-               path.empty() ? download::DOWNLOAD_INTERRUPT_REASON_USER_CANCELED
-                            : download::DOWNLOAD_INTERRUPT_REASON_NONE);
-}
-
-void AtomDownloadManagerDelegate::Shutdown() {
-  weak_ptr_factory_.InvalidateWeakPtrs();
-  download_manager_ = nullptr;
-}
-
-bool AtomDownloadManagerDelegate::DetermineDownloadTarget(
-    download::DownloadItem* download,
-    const content::DownloadTargetCallback& callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (!download->GetForcedFilePath().empty()) {
-    callback.Run(download->GetForcedFilePath(),
-                 download::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
-                 download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-                 download->GetForcedFilePath(),
-                 download::DOWNLOAD_INTERRUPT_REASON_NONE);
-    return true;
-  }
-
-  // Try to get the save path from JS wrapper.
-  base::FilePath save_path;
-  GetItemSavePath(download, &save_path);
-  if (!save_path.empty()) {
-    callback.Run(save_path,
-                 download::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
-                 download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-                 save_path, download::DOWNLOAD_INTERRUPT_REASON_NONE);
-    return true;
-  }
-
-  AtomBrowserContext* browser_context =
-      static_cast<AtomBrowserContext*>(download_manager_->GetBrowserContext());
-  base::FilePath default_download_path =
-      browser_context->prefs()->GetFilePath(prefs::kDownloadDefaultDirectory);
-
-  base::PostTaskWithTraitsAndReplyWithResult(
-      FROM_HERE,
-      {base::MayBlock(), base::TaskPriority::BACKGROUND,
-       base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},
-      base::BindOnce(&CreateDownloadPath, download->GetURL(),
-                     download->GetContentDisposition(),
-                     download->GetSuggestedFilename(), download->GetMimeType(),
-                     default_download_path),
-      base::BindOnce(&AtomDownloadManagerDelegate::OnDownloadPathGenerated,
-                     weak_ptr_factory_.GetWeakPtr(), download->GetId(),
-                     callback));
-  return true;
-}
-
-bool AtomDownloadManagerDelegate::ShouldOpenDownload(
-    download::DownloadItem* download,
-    const content::DownloadOpenDelayedCallback& callback) {
-  return true;
-}
-
-void AtomDownloadManagerDelegate::GetNextId(
-    const content::DownloadIdCallback& callback) {
-  static uint32_t next_id = download::DownloadItem::kInvalidId + 1;
-  callback.Run(next_id++);
-}
-
-}  // namespace atom
removed in remote
  base   100644 5ea3d50d5aee391e9eb8b975055e81e7b9a757b6 atom/browser/atom_download_manager_delegate.h
  our    100644 f1cc1190d4bfe26a1a906b1552c9ab46d71e5e50 atom/browser/atom_download_manager_delegate.h
@@ -1,53 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
-
-#include <string>
-
-#include "base/memory/weak_ptr.h"
-#include "content/public/browser/download_manager_delegate.h"
-
-namespace content {
-class DownloadManager;
-}
-
-namespace atom {
-
-class AtomDownloadManagerDelegate : public content::DownloadManagerDelegate {
- public:
-  using CreateDownloadPathCallback =
-      base::Callback<void(const base::FilePath&)>;
-
-  explicit AtomDownloadManagerDelegate(content::DownloadManager* manager);
-  ~AtomDownloadManagerDelegate() override;
-
-  void OnDownloadPathGenerated(uint32_t download_id,
-                               const content::DownloadTargetCallback& callback,
-                               const base::FilePath& default_path);
-
-  // content::DownloadManagerDelegate:
-  void Shutdown() override;
-  bool DetermineDownloadTarget(
-      download::DownloadItem* download,
-      const content::DownloadTargetCallback& callback) override;
-  bool ShouldOpenDownload(
-      download::DownloadItem* download,
-      const content::DownloadOpenDelayedCallback& callback) override;
-  void GetNextId(const content::DownloadIdCallback& callback) override;
-
- private:
-  // Get the save path set on the associated api::DownloadItem object
-  void GetItemSavePath(download::DownloadItem* item, base::FilePath* path);
-
-  content::DownloadManager* download_manager_;
-  base::WeakPtrFactory<AtomDownloadManagerDelegate> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomDownloadManagerDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
removed in remote
  base   100644 c21d1fb1181622c999e0072ef990465a35072aea atom/browser/atom_javascript_dialog_manager.cc
  our    100644 25fc326ebac3f2a5beb9199194067dae12c8229b atom/browser/atom_javascript_dialog_manager.cc
@@ -1,110 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_javascript_dialog_manager.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/message_box.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/options_switches.h"
-#include "base/bind.h"
-#include "base/strings/utf_string_conversions.h"
-#include "ui/gfx/image/image_skia.h"
-
-using content::JavaScriptDialogType;
-
-namespace atom {
-
-namespace {
-
-constexpr int kUserWantsNoMoreDialogs = -1;
-
-}  // namespace
-
-AtomJavaScriptDialogManager::AtomJavaScriptDialogManager(
-    api::WebContents* api_web_contents)
-    : api_web_contents_(api_web_contents) {}
-AtomJavaScriptDialogManager::~AtomJavaScriptDialogManager() = default;
-
-void AtomJavaScriptDialogManager::RunJavaScriptDialog(
-    content::WebContents* web_contents,
-    content::RenderFrameHost* rfh,
-    JavaScriptDialogType dialog_type,
-    const base::string16& message_text,
-    const base::string16& default_prompt_text,
-    DialogClosedCallback callback,
-    bool* did_suppress_message) {
-  auto origin_url = rfh->GetLastCommittedURL();
-  const std::string& origin = origin_url.GetOrigin().spec();
-  if (origin_counts_[origin] == kUserWantsNoMoreDialogs) {
-    return std::move(callback).Run(false, base::string16());
-  }
-
-  if (dialog_type != JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_ALERT &&
-      dialog_type != JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_CONFIRM) {
-    std::move(callback).Run(false, base::string16());
-    return;
-  }
-
-  std::vector<std::string> buttons = {"OK"};
-  if (dialog_type == JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_CONFIRM) {
-    buttons.push_back("Cancel");
-  }
-
-  origin_counts_[origin]++;
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  std::string checkbox;
-  if (origin_counts_[origin] > 1 && web_preferences &&
-      web_preferences->IsEnabled("safeDialogs") &&
-      !web_preferences->GetPreference("safeDialogsMessage", &checkbox)) {
-    checkbox = "Prevent this app from creating additional dialogs";
-  }
-
-  // Don't set parent for offscreen window.
-  NativeWindow* window = nullptr;
-  if (web_preferences && !web_preferences->IsEnabled(options::kOffscreen)) {
-    auto* relay = NativeWindowRelay::FromWebContents(web_contents);
-    if (relay)
-      window = relay->window.get();
-  }
-
-  atom::ShowMessageBox(
-      window, atom::MessageBoxType::MESSAGE_BOX_TYPE_NONE, buttons, -1, 0,
-      atom::MessageBoxOptions::MESSAGE_BOX_NONE, "",
-      base::UTF16ToUTF8(message_text), "", checkbox, false, gfx::ImageSkia(),
-      base::Bind(&AtomJavaScriptDialogManager::OnMessageBoxCallback,
-                 base::Unretained(this), base::Passed(std::move(callback)),
-                 origin));
-}
-
-void AtomJavaScriptDialogManager::RunBeforeUnloadDialog(
-    content::WebContents* web_contents,
-    content::RenderFrameHost* rfh,
-    bool is_reload,
-    DialogClosedCallback callback) {
-  bool default_prevented = api_web_contents_->Emit("will-prevent-unload");
-  std::move(callback).Run(default_prevented, base::string16());
-  return;
-}
-
-void AtomJavaScriptDialogManager::CancelDialogs(
-    content::WebContents* web_contents,
-    bool reset_state) {}
-
-void AtomJavaScriptDialogManager::OnMessageBoxCallback(
-    DialogClosedCallback callback,
-    const std::string& origin,
-    int code,
-    bool checkbox_checked) {
-  if (checkbox_checked)
-    origin_counts_[origin] = kUserWantsNoMoreDialogs;
-  std::move(callback).Run(code == 0, base::string16());
-}
-
-}  // namespace atom
removed in remote
  base   100644 c0a0dccf0fa9a3fa1a7e7504f81a9f9eef6b0fb9 atom/browser/atom_javascript_dialog_manager.h
  our    100644 2996b5d206ede6b19769ca0be224a59a6082a7bb atom/browser/atom_javascript_dialog_manager.h
@@ -1,51 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
-#define ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
-
-#include <map>
-#include <string>
-
-#include "content/public/browser/javascript_dialog_manager.h"
-
-namespace atom {
-
-namespace api {
-class WebContents;
-}
-
-class AtomJavaScriptDialogManager : public content::JavaScriptDialogManager {
- public:
-  explicit AtomJavaScriptDialogManager(api::WebContents* api_web_contents);
-  ~AtomJavaScriptDialogManager() override;
-
-  // content::JavaScriptDialogManager implementations.
-  void RunJavaScriptDialog(content::WebContents* web_contents,
-                           content::RenderFrameHost* rfh,
-                           content::JavaScriptDialogType dialog_type,
-                           const base::string16& message_text,
-                           const base::string16& default_prompt_text,
-                           DialogClosedCallback callback,
-                           bool* did_suppress_message) override;
-  void RunBeforeUnloadDialog(content::WebContents* web_contents,
-                             content::RenderFrameHost* rfh,
-                             bool is_reload,
-                             DialogClosedCallback callback) override;
-  void CancelDialogs(content::WebContents* web_contents,
-                     bool reset_state) override;
-
- private:
-  void OnMessageBoxCallback(DialogClosedCallback callback,
-                            const std::string& origin,
-                            int code,
-                            bool checkbox_checked);
-
-  api::WebContents* api_web_contents_;
-  std::map<std::string, int> origin_counts_;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
removed in remote
  base   100644 f7523c07ff8333e2582c6a492f154dd93982b489 atom/browser/atom_permission_manager.cc
  our    100644 218404434142cf1b0ab29610e873782712e3a876 atom/browser/atom_permission_manager.cc
@@ -1,212 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_permission_manager.h"
-
-#include <vector>
-
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/permission_type.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-namespace {
-
-bool WebContentsDestroyed(int process_id) {
-  content::WebContents* web_contents =
-      static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())
-          ->GetWebContentsFromProcessID(process_id);
-  if (!web_contents)
-    return true;
-  return web_contents->IsBeingDestroyed();
-}
-
-void PermissionRequestResponseCallbackWrapper(
-    const AtomPermissionManager::StatusCallback& callback,
-    const std::vector<blink::mojom::PermissionStatus>& vector) {
-  callback.Run(vector[0]);
-}
-
-}  // namespace
-
-class AtomPermissionManager::PendingRequest {
- public:
-  PendingRequest(content::RenderFrameHost* render_frame_host,
-                 const std::vector<content::PermissionType>& permissions,
-                 const StatusesCallback& callback)
-      : render_process_id_(render_frame_host->GetProcess()->GetID()),
-        callback_(callback),
-        results_(permissions.size(), blink::mojom::PermissionStatus::DENIED),
-        remaining_results_(permissions.size()) {}
-
-  void SetPermissionStatus(int permission_id,
-                           blink::mojom::PermissionStatus status) {
-    DCHECK(!IsComplete());
-
-    results_[permission_id] = status;
-    --remaining_results_;
-  }
-
-  int render_process_id() const { return render_process_id_; }
-
-  bool IsComplete() const { return remaining_results_ == 0; }
-
-  void RunCallback() const { callback_.Run(results_); }
-
- private:
-  int render_process_id_;
-  const StatusesCallback callback_;
-  std::vector<blink::mojom::PermissionStatus> results_;
-  size_t remaining_results_;
-};
-
-AtomPermissionManager::AtomPermissionManager() {}
-
-AtomPermissionManager::~AtomPermissionManager() {}
-
-void AtomPermissionManager::SetPermissionRequestHandler(
-    const RequestHandler& handler) {
-  if (handler.is_null() && !pending_requests_.IsEmpty()) {
-    for (PendingRequestsMap::const_iterator iter(&pending_requests_);
-         !iter.IsAtEnd(); iter.Advance()) {
-      auto* request = iter.GetCurrentValue();
-      if (!WebContentsDestroyed(request->render_process_id()))
-        request->RunCallback();
-    }
-    pending_requests_.Clear();
-  }
-  request_handler_ = handler;
-}
-
-int AtomPermissionManager::RequestPermission(
-    content::PermissionType permission,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const StatusCallback& response_callback) {
-  return RequestPermissionWithDetails(permission, render_frame_host,
-                                      requesting_origin, user_gesture, nullptr,
-                                      response_callback);
-}
-
-int AtomPermissionManager::RequestPermissionWithDetails(
-    content::PermissionType permission,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const base::DictionaryValue* details,
-    const StatusCallback& response_callback) {
-  return RequestPermissionsWithDetails(
-      std::vector<content::PermissionType>(1, permission), render_frame_host,
-      requesting_origin, user_gesture, details,
-      base::Bind(&PermissionRequestResponseCallbackWrapper, response_callback));
-}
-
-int AtomPermissionManager::RequestPermissions(
-    const std::vector<content::PermissionType>& permissions,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const StatusesCallback& response_callback) {
-  return RequestPermissionsWithDetails(permissions, render_frame_host,
-                                       requesting_origin, user_gesture, nullptr,
-                                       response_callback);
-}
-
-int AtomPermissionManager::RequestPermissionsWithDetails(
-    const std::vector<content::PermissionType>& permissions,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const base::DictionaryValue* details,
-    const StatusesCallback& response_callback) {
-  if (permissions.empty()) {
-    response_callback.Run(std::vector<blink::mojom::PermissionStatus>());
-    return kNoPendingOperation;
-  }
-
-  if (request_handler_.is_null()) {
-    std::vector<blink::mojom::PermissionStatus> statuses;
-    for (auto permission : permissions) {
-      if (permission == content::PermissionType::MIDI_SYSEX) {
-        content::ChildProcessSecurityPolicy::GetInstance()
-            ->GrantSendMidiSysExMessage(
-                render_frame_host->GetProcess()->GetID());
-      }
-      statuses.push_back(blink::mojom::PermissionStatus::GRANTED);
-    }
-    response_callback.Run(statuses);
-    return kNoPendingOperation;
-  }
-
-  auto* web_contents =
-      content::WebContents::FromRenderFrameHost(render_frame_host);
-  int request_id = pending_requests_.Add(std::make_unique<PendingRequest>(
-      render_frame_host, permissions, response_callback));
-
-  for (size_t i = 0; i < permissions.size(); ++i) {
-    auto permission = permissions[i];
-    if (permission == content::PermissionType::MIDI_SYSEX) {
-      content::ChildProcessSecurityPolicy::GetInstance()
-          ->GrantSendMidiSysExMessage(render_frame_host->GetProcess()->GetID());
-    }
-    const auto callback =
-        base::Bind(&AtomPermissionManager::OnPermissionResponse,
-                   base::Unretained(this), request_id, i);
-    if (details == nullptr) {
-      request_handler_.Run(web_contents, permission, callback,
-                           base::DictionaryValue());
-    } else {
-      request_handler_.Run(web_contents, permission, callback, *details);
-    }
-  }
-
-  return request_id;
-}
-
-void AtomPermissionManager::OnPermissionResponse(
-    int request_id,
-    int permission_id,
-    blink::mojom::PermissionStatus status) {
-  auto* pending_request = pending_requests_.Lookup(request_id);
-  if (!pending_request)
-    return;
-
-  pending_request->SetPermissionStatus(permission_id, status);
-  if (pending_request->IsComplete()) {
-    pending_request->RunCallback();
-    pending_requests_.Remove(request_id);
-  }
-}
-
-
-void AtomPermissionManager::ResetPermission(content::PermissionType permission,
-                                            const GURL& requesting_origin,
-                                            const GURL& embedding_origin) {}
-
-blink::mojom::PermissionStatus AtomPermissionManager::GetPermissionStatus(
-    content::PermissionType permission,
-    const GURL& requesting_origin,
-    const GURL& embedding_origin) {
-  return blink::mojom::PermissionStatus::GRANTED;
-}
-
-int AtomPermissionManager::SubscribePermissionStatusChange(
-    content::PermissionType permission,
-    const GURL& requesting_origin,
-    const GURL& embedding_origin,
-    const StatusCallback& callback) {
-  return -1;
-}
-
-void AtomPermissionManager::UnsubscribePermissionStatusChange(
-    int subscription_id) {}
-
-}  // namespace atom
removed in remote
  base   100644 e16893fd8bb5d9357f2648626f29d2d212db4048 atom/browser/atom_permission_manager.h
  our    100644 de23837330535539c2ab93a2bba4796be3f36e1e atom/browser/atom_permission_manager.h
@@ -1,104 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
-#define ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
-
-#include <map>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/containers/id_map.h"
-#include "base/values.h"
-#include "content/public/browser/permission_manager.h"
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-class AtomPermissionManager : public content::PermissionManager {
- public:
-  AtomPermissionManager();
-  ~AtomPermissionManager() override;
-
-  using StatusCallback = base::Callback<void(blink::mojom::PermissionStatus)>;
-  using StatusesCallback =
-      base::Callback<void(const std::vector<blink::mojom::PermissionStatus>&)>;
-  using RequestHandler = base::Callback<void(content::WebContents*,
-                                             content::PermissionType,
-                                             const StatusCallback&,
-                                             const base::DictionaryValue&)>;
-
-  // Handler to dispatch permission requests in JS.
-  void SetPermissionRequestHandler(const RequestHandler& handler);
-
-  // content::PermissionManager:
-  int RequestPermission(
-      content::PermissionType permission,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback)
-      override;
-  int RequestPermissionWithDetails(
-      content::PermissionType permission,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::DictionaryValue* details,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback);
-  int RequestPermissions(
-      const std::vector<content::PermissionType>& permissions,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::Callback<
-          void(const std::vector<blink::mojom::PermissionStatus>&)>& callback)
-      override;
-  int RequestPermissionsWithDetails(
-      const std::vector<content::PermissionType>& permissions,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::DictionaryValue* details,
-      const base::Callback<
-          void(const std::vector<blink::mojom::PermissionStatus>&)>& callback);
-
- protected:
-  void OnPermissionResponse(int request_id,
-                            int permission_id,
-                            blink::mojom::PermissionStatus status);
-
-  // content::PermissionManager:
-  void ResetPermission(content::PermissionType permission,
-                       const GURL& requesting_origin,
-                       const GURL& embedding_origin) override;
-  blink::mojom::PermissionStatus GetPermissionStatus(
-      content::PermissionType permission,
-      const GURL& requesting_origin,
-      const GURL& embedding_origin) override;
-  int SubscribePermissionStatusChange(
-      content::PermissionType permission,
-      const GURL& requesting_origin,
-      const GURL& embedding_origin,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback)
-      override;
-  void UnsubscribePermissionStatusChange(int subscription_id) override;
-
- private:
-  class PendingRequest;
-  using PendingRequestsMap = base::IDMap<std::unique_ptr<PendingRequest>>;
-
-  RequestHandler request_handler_;
-
-  PendingRequestsMap pending_requests_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomPermissionManager);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
removed in remote
  base   100644 8775f950ca9a0a1b00976d86b8045e1b49366ddc atom/browser/atom_quota_permission_context.cc
  our    100644 b8bf9d53f5653c68a4b867ed37c06330d7c9a0fb atom/browser/atom_quota_permission_context.cc
@@ -1,20 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_quota_permission_context.h"
-
-namespace atom {
-
-AtomQuotaPermissionContext::AtomQuotaPermissionContext() {}
-
-AtomQuotaPermissionContext::~AtomQuotaPermissionContext() {}
-
-void AtomQuotaPermissionContext::RequestQuotaPermission(
-    const content::StorageQuotaParams& params,
-    int render_process_id,
-    const PermissionCallback& callback) {
-  callback.Run(response::QUOTA_PERMISSION_RESPONSE_ALLOW);
-}
-
-}  // namespace atom
removed in remote
  base   100644 1246ea7bad589bbc1d7c76fa535fc4d449ee4a2c atom/browser/atom_quota_permission_context.h
  our    100644 1b04f8e05b16306be7dda4d646b2fed13a22ae5e atom/browser/atom_quota_permission_context.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
-#define ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
-
-#include "content/public/browser/quota_permission_context.h"
-#include "content/public/common/storage_quota_params.h"
-
-namespace atom {
-
-class AtomQuotaPermissionContext : public content::QuotaPermissionContext {
- public:
-  typedef content::QuotaPermissionContext::QuotaPermissionResponse response;
-
-  AtomQuotaPermissionContext();
-
-  // content::QuotaPermissionContext:
-  void RequestQuotaPermission(const content::StorageQuotaParams& params,
-                              int render_process_id,
-                              const PermissionCallback& callback) override;
-
- private:
-  ~AtomQuotaPermissionContext() override;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomQuotaPermissionContext);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
removed in remote
  base   100644 68576a52f248f69a1af66ebb901589d89a144ee9 atom/browser/atom_resource_dispatcher_host_delegate.cc
  our    100644 934b0ebaa49b711490c58fc73b91985633cba439 atom/browser/atom_resource_dispatcher_host_delegate.cc
@@ -1,145 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_resource_dispatcher_host_delegate.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/platform_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "net/base/escape.h"
-#include "url/gurl.h"
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/common/atom_constants.h"
-#include "base/strings/stringprintf.h"
-#include "content/public/browser/stream_info.h"
-#include "net/url_request/url_request.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-void OnOpenExternal(const GURL& escaped_url, bool allowed) {
-  if (allowed)
-    platform_util::OpenExternal(
-#if defined(OS_WIN)
-        base::UTF8ToUTF16(escaped_url.spec()),
-#else
-        escaped_url,
-#endif
-        true);
-}
-
-void HandleExternalProtocolInUI(
-    const GURL& url,
-    const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter,
-    bool has_user_gesture) {
-  content::WebContents* web_contents = web_contents_getter.Run();
-  if (!web_contents)
-    return;
-
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  if (!permission_helper)
-    return;
-
-  GURL escaped_url(net::EscapeExternalHandlerValue(url.spec()));
-  auto callback = base::Bind(&OnOpenExternal, escaped_url);
-  permission_helper->RequestOpenExternalPermission(callback, has_user_gesture,
-                                                   url);
-}
-
-#if defined(ENABLE_PDF_VIEWER)
-void OnPdfResourceIntercepted(
-    const GURL& original_url,
-    int render_process_host_id,
-    int render_frame_id,
-    const content::ResourceRequestInfo::WebContentsGetter&
-        web_contents_getter) {
-  content::WebContents* web_contents = web_contents_getter.Run();
-  if (!web_contents)
-    return;
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  if (!web_preferences || !web_preferences->IsEnabled(options::kPlugins)) {
-    auto* browser_context = web_contents->GetBrowserContext();
-    auto* download_manager =
-        content::BrowserContext::GetDownloadManager(browser_context);
-
-    download_manager->DownloadUrl(
-        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
-            web_contents, original_url, NO_TRAFFIC_ANNOTATION_YET));
-    return;
-  }
-
-  // The URL passes the original pdf resource url, that will be requested
-  // by the webui page.
-  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
-  content::NavigationController::LoadURLParams params(GURL(base::StringPrintf(
-      "%sindex.html?%s=%s", kPdfViewerUIOrigin, kPdfPluginSrc,
-      net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
-
-  content::RenderFrameHost* frame_host =
-      content::RenderFrameHost::FromID(render_process_host_id, render_frame_id);
-  if (!frame_host) {
-    return;
-  }
-
-  params.frame_tree_node_id = frame_host->GetFrameTreeNodeId();
-  web_contents->GetController().LoadURLWithParams(params);
-}
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace
-
-AtomResourceDispatcherHostDelegate::AtomResourceDispatcherHostDelegate() {}
-
-bool AtomResourceDispatcherHostDelegate::HandleExternalProtocol(
-    const GURL& url,
-    content::ResourceRequestInfo* info) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(&HandleExternalProtocolInUI, url,
-                                         info->GetWebContentsGetterForRequest(),
-                                         info->HasUserGesture()));
-  return true;
-}
-
-bool AtomResourceDispatcherHostDelegate::ShouldInterceptResourceAsStream(
-    net::URLRequest* request,
-    const std::string& mime_type,
-    GURL* origin,
-    std::string* payload) {
-#if defined(ENABLE_PDF_VIEWER)
-  const content::ResourceRequestInfo* info =
-      content::ResourceRequestInfo::ForRequest(request);
-
-  int render_process_host_id;
-  int render_frame_id;
-  if (!info->GetAssociatedRenderFrame(&render_process_host_id,
-                                      &render_frame_id)) {
-    return false;
-  }
-
-  if (mime_type == "application/pdf") {
-    *origin = GURL(kPdfViewerUIOrigin);
-    content::BrowserThread::PostTask(
-        BrowserThread::UI, FROM_HERE,
-        base::Bind(&OnPdfResourceIntercepted, request->url(),
-                   render_process_host_id, render_frame_id,
-                   info->GetWebContentsGetterForRequest()));
-    return true;
-  }
-#endif  // defined(ENABLE_PDF_VIEWER)
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 408b83c92d90565c1278192d0d9f85ac9d287849 atom/browser/atom_resource_dispatcher_host_delegate.h
  our    100644 eb91b27921e2bcc9761a6f20c949abfa49fcfd77 atom/browser/atom_resource_dispatcher_host_delegate.h
@@ -1,33 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
-
-#include <string>
-
-#include "content/public/browser/resource_dispatcher_host_delegate.h"
-
-namespace atom {
-
-class AtomResourceDispatcherHostDelegate
-    : public content::ResourceDispatcherHostDelegate {
- public:
-  AtomResourceDispatcherHostDelegate();
-
-  // content::ResourceDispatcherHostDelegate:
-  bool HandleExternalProtocol(const GURL& url,
-                              content::ResourceRequestInfo* info) override;
-  bool ShouldInterceptResourceAsStream(net::URLRequest* request,
-                                       const std::string& mime_type,
-                                       GURL* origin,
-                                       std::string* payload) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomResourceDispatcherHostDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
removed in remote
  base   100644 06727332f061a56811fc96ebfd61d8e1d2a14d52 atom/browser/atom_speech_recognition_manager_delegate.cc
  our    100644 8333211d9ed8295d5bf4b565962a0488044cad53 atom/browser/atom_speech_recognition_manager_delegate.cc
@@ -1,61 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_speech_recognition_manager_delegate.h"
-
-#include <string>
-
-#include "base/callback.h"
-
-namespace atom {
-
-AtomSpeechRecognitionManagerDelegate::AtomSpeechRecognitionManagerDelegate() {}
-
-AtomSpeechRecognitionManagerDelegate::~AtomSpeechRecognitionManagerDelegate() {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnEnvironmentEstimationComplete(
-    int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnSoundStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnSoundEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionResults(
-    int session_id,
-    const content::SpeechRecognitionResults& result) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionError(
-    int session_id,
-    const content::SpeechRecognitionError& error) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioLevelsChange(
-    int session_id,
-    float volume,
-    float noise_volume) {}
-
-void AtomSpeechRecognitionManagerDelegate::CheckRecognitionIsAllowed(
-    int session_id,
-    base::OnceCallback<void(bool ask_user, bool is_allowed)> callback) {
-  std::move(callback).Run(true, true);
-}
-
-content::SpeechRecognitionEventListener*
-AtomSpeechRecognitionManagerDelegate::GetEventListener() {
-  return this;
-}
-
-bool AtomSpeechRecognitionManagerDelegate::FilterProfanities(
-    int render_process_id) {
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 4c78e0eead107e1679184d855d032f10d5791f6d atom/browser/atom_speech_recognition_manager_delegate.h
  our    100644 10f812a99b8e0d420a99b89b137a460e68d00618 atom/browser/atom_speech_recognition_manager_delegate.h
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
-
-#include <string>
-
-#include "base/macros.h"
-#include "content/public/browser/speech_recognition_event_listener.h"
-#include "content/public/browser/speech_recognition_manager_delegate.h"
-
-namespace atom {
-
-class AtomSpeechRecognitionManagerDelegate
-    : public content::SpeechRecognitionManagerDelegate,
-      public content::SpeechRecognitionEventListener {
- public:
-  AtomSpeechRecognitionManagerDelegate();
-  ~AtomSpeechRecognitionManagerDelegate() override;
-
-  // content::SpeechRecognitionEventListener:
-  void OnRecognitionStart(int session_id) override;
-  void OnAudioStart(int session_id) override;
-  void OnEnvironmentEstimationComplete(int session_id) override;
-  void OnSoundStart(int session_id) override;
-  void OnSoundEnd(int session_id) override;
-  void OnAudioEnd(int session_id) override;
-  void OnRecognitionEnd(int session_id) override;
-  void OnRecognitionResults(
-      int session_id,
-      const content::SpeechRecognitionResults& result) override;
-  void OnRecognitionError(
-      int session_id,
-      const content::SpeechRecognitionError& error) override;
-  void OnAudioLevelsChange(int session_id,
-                           float volume,
-                           float noise_volume) override;
-
-  // content::SpeechRecognitionManagerDelegate:
-  void CheckRecognitionIsAllowed(
-      int session_id,
-      base::OnceCallback<void(bool ask_user, bool is_allowed)> callback)
-      override;
-  content::SpeechRecognitionEventListener* GetEventListener() override;
-  bool FilterProfanities(int render_process_id) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomSpeechRecognitionManagerDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
removed in remote
  base   100644 7dbfc5a6feba1b3ff343c10fda82e22ed3df596d atom/browser/auto_updater.cc
  our    100644 90ff157477890b572c917b26ce8d76f29feedef6 atom/browser/auto_updater.cc
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/auto_updater.h"
-
-namespace auto_updater {
-
-Delegate* AutoUpdater::delegate_ = nullptr;
-
-Delegate* AutoUpdater::GetDelegate() {
-  return delegate_;
-}
-
-void AutoUpdater::SetDelegate(Delegate* delegate) {
-  delegate_ = delegate;
-}
-
-#if !defined(OS_MACOSX) || defined(MAS_BUILD)
-std::string AutoUpdater::GetFeedURL() {
-  return "";
-}
-
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {}
-
-void AutoUpdater::CheckForUpdates() {}
-
-void AutoUpdater::QuitAndInstall() {}
-#endif
-
-}  // namespace auto_updater
removed in remote
  base   100644 d13c6f0c3305ca7d165708616a233a7004b13aa0 atom/browser/auto_updater.h
  our    100644 7be3e56db3e948e980c0647dc5c562416de4db16 atom/browser/auto_updater.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_AUTO_UPDATER_H_
-#define ATOM_BROWSER_AUTO_UPDATER_H_
-
-#include <map>
-#include <string>
-
-#include "base/macros.h"
-#include "build/build_config.h"
-#include "native_mate/arguments.h"
-
-namespace base {
-class Time;
-}
-
-namespace auto_updater {
-
-class Delegate {
- public:
-  // An error happened.
-  virtual void OnError(const std::string& error) {}
-
-  virtual void OnError(const std::string& error,
-                       const int code,
-                       const std::string& domain) {}
-
-  // Checking to see if there is an update
-  virtual void OnCheckingForUpdate() {}
-
-  // There is an update available and it is being downloaded
-  virtual void OnUpdateAvailable() {}
-
-  // There is no available update.
-  virtual void OnUpdateNotAvailable() {}
-
-  // There is a new update which has been downloaded.
-  virtual void OnUpdateDownloaded(const std::string& release_notes,
-                                  const std::string& release_name,
-                                  const base::Time& release_date,
-                                  const std::string& update_url) {}
-
- protected:
-  virtual ~Delegate() {}
-};
-
-class AutoUpdater {
- public:
-  typedef std::map<std::string, std::string> HeaderMap;
-
-  // Gets/Sets the delegate.
-  static Delegate* GetDelegate();
-  static void SetDelegate(Delegate* delegate);
-
-  static std::string GetFeedURL();
-  static void SetFeedURL(mate::Arguments* args);
-  static void CheckForUpdates();
-  static void QuitAndInstall();
-
- private:
-  static Delegate* delegate_;
-
-  DISALLOW_IMPLICIT_CONSTRUCTORS(AutoUpdater);
-};
-
-}  // namespace auto_updater
-
-#endif  // ATOM_BROWSER_AUTO_UPDATER_H_
removed in remote
  base   100644 a55cdd281265d2c5b1bad20e72dbdd135f886995 atom/browser/auto_updater_mac.mm
  our    100644 ff8ffb86373f44b8c1b7276a2459444de3aaff5b atom/browser/auto_updater_mac.mm
@@ -1,174 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/auto_updater.h"
-
-#import <ReactiveCocoa/NSObject+RACPropertySubscribing.h>
-#import <ReactiveCocoa/RACCommand.h>
-#import <ReactiveCocoa/RACSignal.h>
-#import <Squirrel/Squirrel.h>
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/bind.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/time/time.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-
-namespace auto_updater {
-
-namespace {
-
-// The gloal SQRLUpdater object.
-SQRLUpdater* g_updater = nil;
-
-}  // namespace
-
-namespace {
-
-bool g_update_available = false;
-std::string update_url_ = "";
-
-}  // namespace
-
-std::string AutoUpdater::GetFeedURL() {
-  return update_url_;
-}
-
-// static
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {
-  mate::Dictionary opts;
-  std::string feed;
-  HeaderMap requestHeaders;
-  std::string serverType = "default";
-  if (args->GetNext(&opts)) {
-    if (!opts.Get("url", &feed)) {
-      args->ThrowError(
-          "Expected options object to contain a 'url' string property in "
-          "setFeedUrl call");
-      return;
-    }
-    opts.Get("headers", &requestHeaders);
-    opts.Get("serverType", &serverType);
-    if (serverType != "default" && serverType != "json") {
-      args->ThrowError("Expected serverType to be 'default' or 'json'");
-      return;
-    }
-  } else if (args->GetNext(&feed)) {
-    args->GetNext(&requestHeaders);
-  } else {
-    args->ThrowError(
-        "Expected an options object with a 'url' property to be provided");
-    return;
-  }
-
-  Delegate* delegate = GetDelegate();
-  if (!delegate)
-    return;
-
-  update_url_ = feed;
-
-  NSURL* url = [NSURL URLWithString:base::SysUTF8ToNSString(feed)];
-  NSMutableURLRequest* urlRequest = [NSMutableURLRequest requestWithURL:url];
-
-  for (const auto& it : requestHeaders) {
-    [urlRequest setValue:base::SysUTF8ToNSString(it.second)
-        forHTTPHeaderField:base::SysUTF8ToNSString(it.first)];
-  }
-
-  if (g_updater)
-    [g_updater release];
-
-  // Initialize the SQRLUpdater.
-  @try {
-    if (serverType == "json") {
-      NSString* nsAppVersion =
-          base::SysUTF8ToNSString(atom::Browser::Get()->GetVersion());
-      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest
-                                                  forVersion:nsAppVersion];
-    } else {
-      // default
-      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest];
-    }
-  } @catch (NSException* error) {
-    delegate->OnError(base::SysNSStringToUTF8(error.reason));
-    return;
-  }
-
-  [[g_updater rac_valuesForKeyPath:@"state" observer:g_updater]
-      subscribeNext:^(NSNumber* stateNumber) {
-        int state = [stateNumber integerValue];
-        // Dispatching the event on main thread.
-        dispatch_async(dispatch_get_main_queue(), ^{
-          if (state == SQRLUpdaterStateCheckingForUpdate)
-            delegate->OnCheckingForUpdate();
-          else if (state == SQRLUpdaterStateDownloadingUpdate)
-            delegate->OnUpdateAvailable();
-        });
-      }];
-}
-
-// static
-void AutoUpdater::CheckForUpdates() {
-  Delegate* delegate = GetDelegate();
-  if (!delegate)
-    return;
-
-  [[[[g_updater.checkForUpdatesCommand execute:nil]
-      // Send a `nil` after everything...
-      concat:[RACSignal return:nil]]
-      // But only take the first value. If an update is sent, we'll get that.
-      // Otherwise, we'll get our inserted `nil` value.
-      take:1]
-      subscribeNext:^(SQRLDownloadedUpdate* downloadedUpdate) {
-        if (downloadedUpdate) {
-          g_update_available = true;
-          SQRLUpdate* update = downloadedUpdate.update;
-          // There is a new update that has been downloaded.
-          delegate->OnUpdateDownloaded(
-              base::SysNSStringToUTF8(update.releaseNotes),
-              base::SysNSStringToUTF8(update.releaseName),
-              base::Time::FromDoubleT(update.releaseDate.timeIntervalSince1970),
-              base::SysNSStringToUTF8(update.updateURL.absoluteString));
-        } else {
-          g_update_available = false;
-          // When the completed event is sent with no update, then we know there
-          // is no update available.
-          delegate->OnUpdateNotAvailable();
-        }
-      }
-      error:^(NSError* error) {
-        NSMutableString* failureString =
-            [NSMutableString stringWithString:error.localizedDescription];
-        if (error.localizedFailureReason) {
-          [failureString appendString:@": "];
-          [failureString appendString:error.localizedFailureReason];
-        }
-        if (error.localizedRecoverySuggestion) {
-          if (![failureString hasSuffix:@"."])
-            [failureString appendString:@"."];
-          [failureString appendString:@" "];
-          [failureString appendString:error.localizedRecoverySuggestion];
-        }
-        delegate->OnError(base::SysNSStringToUTF8(failureString), error.code,
-                          base::SysNSStringToUTF8(error.domain));
-      }];
-}
-
-void AutoUpdater::QuitAndInstall() {
-  Delegate* delegate = AutoUpdater::GetDelegate();
-  if (g_update_available) {
-    [[g_updater relaunchToInstallUpdate] subscribeError:^(NSError* error) {
-      if (delegate)
-        delegate->OnError(base::SysNSStringToUTF8(error.localizedDescription),
-                          error.code, base::SysNSStringToUTF8(error.domain));
-    }];
-  } else {
-    if (delegate)
-      delegate->OnError("No update available, can't quit and install");
-  }
-}
-
-}  // namespace auto_updater
removed in remote
  base   100644 36c8d17359e8eef3a52a682dcba692b51ce82378 atom/browser/bridge_task_runner.cc
  our    100644 c0b3cd750d9da13d2957865fd98b094ffbe7bcaf atom/browser/bridge_task_runner.cc
@@ -1,63 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/bridge_task_runner.h"
-
-#include "base/message_loop/message_loop.h"
-
-namespace atom {
-
-BridgeTaskRunner::BridgeTaskRunner() = default;
-BridgeTaskRunner::~BridgeTaskRunner() = default;
-
-void BridgeTaskRunner::MessageLoopIsReady() {
-  auto* message_loop = base::MessageLoop::current();
-  CHECK(message_loop);
-  for (TaskPair& task : tasks_) {
-    message_loop->task_runner()->PostDelayedTask(
-        std::get<0>(task), std::move(std::get<1>(task)), std::get<2>(task));
-  }
-  for (TaskPair& task : non_nestable_tasks_) {
-    message_loop->task_runner()->PostNonNestableDelayedTask(
-        std::get<0>(task), std::move(std::get<1>(task)), std::get<2>(task));
-  }
-}
-
-bool BridgeTaskRunner::PostDelayedTask(const base::Location& from_here,
-                                       base::OnceClosure task,
-                                       base::TimeDelta delay) {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop) {
-    tasks_.push_back(std::make_tuple(from_here, std::move(task), delay));
-    return true;
-  }
-
-  return message_loop->task_runner()->PostDelayedTask(from_here,
-                                                      std::move(task), delay);
-}
-
-bool BridgeTaskRunner::RunsTasksInCurrentSequence() const {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop)
-    return true;
-
-  return message_loop->task_runner()->RunsTasksInCurrentSequence();
-}
-
-bool BridgeTaskRunner::PostNonNestableDelayedTask(
-    const base::Location& from_here,
-    base::OnceClosure task,
-    base::TimeDelta delay) {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop) {
-    non_nestable_tasks_.push_back(
-        std::make_tuple(from_here, std::move(task), delay));
-    return true;
-  }
-
-  return message_loop->task_runner()->PostNonNestableDelayedTask(
-      from_here, std::move(task), delay);
-}
-
-}  // namespace atom
removed in remote
  base   100644 b69b33b29516a7bb866b7cca9e09d7a3d1726b3a atom/browser/bridge_task_runner.h
  our    100644 7c3049b3f8c2d22fa4803b409f2f62f840e8ea72 atom/browser/bridge_task_runner.h
@@ -1,48 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
-#define ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
-
-#include <tuple>
-#include <vector>
-
-#include "base/location.h"
-#include "base/single_thread_task_runner.h"
-#include "base/tuple.h"
-
-namespace atom {
-
-// Post all tasks to the current message loop's task runner if available,
-// otherwise delay the work until message loop is ready.
-class BridgeTaskRunner : public base::SingleThreadTaskRunner {
- public:
-  BridgeTaskRunner();
-
-  // Called when message loop is ready.
-  void MessageLoopIsReady();
-
-  // base::SingleThreadTaskRunner:
-  bool PostDelayedTask(const base::Location& from_here,
-                       base::OnceClosure task,
-                       base::TimeDelta delay) override;
-  bool RunsTasksInCurrentSequence() const override;
-  bool PostNonNestableDelayedTask(const base::Location& from_here,
-                                  base::OnceClosure task,
-                                  base::TimeDelta delay) override;
-
- private:
-  using TaskPair =
-      std::tuple<base::Location, base::OnceClosure, base::TimeDelta>;
-  ~BridgeTaskRunner() override;
-
-  std::vector<TaskPair> tasks_;
-  std::vector<TaskPair> non_nestable_tasks_;
-
-  DISALLOW_COPY_AND_ASSIGN(BridgeTaskRunner);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
removed in remote
  base   100644 e89f52283b3c8168ecc1e2d5340c81b75957630a atom/browser/browser.cc
  our    100644 ce35de64d60c6767ac52596c1b32e7bde5ceefa0 atom/browser/browser.cc
@@ -1,242 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/browser_observer.h"
-#include "atom/browser/login_handler.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "base/files/file_util.h"
-#include "base/message_loop/message_loop.h"
-#include "base/path_service.h"
-#include "base/run_loop.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "brightray/browser/brightray_paths.h"
-#include "brightray/common/application_info.h"
-
-namespace atom {
-
-Browser::LoginItemSettings::LoginItemSettings() = default;
-Browser::LoginItemSettings::~LoginItemSettings() = default;
-Browser::LoginItemSettings::LoginItemSettings(const LoginItemSettings& other) =
-    default;
-
-Browser::Browser() {
-  WindowList::AddObserver(this);
-}
-
-Browser::~Browser() {
-  WindowList::RemoveObserver(this);
-}
-
-// static
-Browser* Browser::Get() {
-  return AtomBrowserMainParts::Get()->browser();
-}
-
-void Browser::Quit() {
-  if (is_quiting_)
-    return;
-
-  is_quiting_ = HandleBeforeQuit();
-  if (!is_quiting_)
-    return;
-
-  if (atom::WindowList::IsEmpty())
-    NotifyAndShutdown();
-  else
-    atom::WindowList::CloseAllWindows();
-}
-
-void Browser::Exit(mate::Arguments* args) {
-  int code = 0;
-  args->GetNext(&code);
-
-  if (!AtomBrowserMainParts::Get()->SetExitCode(code)) {
-    // Message loop is not ready, quit directly.
-    exit(code);
-  } else {
-    // Prepare to quit when all windows have been closed.
-    is_quiting_ = true;
-
-    // Remember this caller so that we don't emit unrelated events.
-    is_exiting_ = true;
-
-    // Must destroy windows before quitting, otherwise bad things can happen.
-    if (atom::WindowList::IsEmpty()) {
-      Shutdown();
-    } else {
-      // Unlike Quit(), we do not ask to close window, but destroy the window
-      // without asking.
-      atom::WindowList::DestroyAllWindows();
-    }
-  }
-}
-
-void Browser::Shutdown() {
-  if (is_shutdown_)
-    return;
-
-  is_shutdown_ = true;
-  is_quiting_ = true;
-
-  for (BrowserObserver& observer : observers_)
-    observer.OnQuit();
-
-  if (base::ThreadTaskRunnerHandle::IsSet()) {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::MessageLoop::QuitWhenIdleClosure());
-  } else {
-    // There is no message loop available so we are in early stage.
-    exit(0);
-  }
-}
-
-std::string Browser::GetVersion() const {
-  std::string ret = brightray::GetOverriddenApplicationVersion();
-  if (ret.empty())
-    ret = GetExecutableFileVersion();
-  return ret;
-}
-
-void Browser::SetVersion(const std::string& version) {
-  brightray::OverrideApplicationVersion(version);
-}
-
-std::string Browser::GetName() const {
-  std::string ret = brightray::GetOverriddenApplicationName();
-  if (ret.empty())
-    ret = GetExecutableFileProductName();
-  return ret;
-}
-
-void Browser::SetName(const std::string& name) {
-  brightray::OverrideApplicationName(name);
-}
-
-int Browser::GetBadgeCount() {
-  return badge_count_;
-}
-
-bool Browser::OpenFile(const std::string& file_path) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnOpenFile(&prevent_default, file_path);
-
-  return prevent_default;
-}
-
-void Browser::OpenURL(const std::string& url) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnOpenURL(url);
-}
-
-void Browser::Activate(bool has_visible_windows) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnActivate(has_visible_windows);
-}
-
-void Browser::WillFinishLaunching() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillFinishLaunching();
-}
-
-void Browser::DidFinishLaunching(const base::DictionaryValue& launch_info) {
-  // Make sure the userData directory is created.
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  base::FilePath user_data;
-  if (PathService::Get(brightray::DIR_USER_DATA, &user_data))
-    base::CreateDirectoryAndGetError(user_data, nullptr);
-
-  is_ready_ = true;
-  if (ready_promise_) {
-    ready_promise_->Resolve();
-  }
-  for (BrowserObserver& observer : observers_)
-    observer.OnFinishLaunching(launch_info);
-}
-
-util::Promise* Browser::WhenReady(v8::Isolate* isolate) {
-  if (!ready_promise_) {
-    ready_promise_ = new util::Promise(isolate);
-    if (is_ready()) {
-      ready_promise_->Resolve();
-    }
-  }
-  return ready_promise_;
-}
-
-void Browser::OnAccessibilitySupportChanged() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnAccessibilitySupportChanged();
-}
-
-void Browser::RequestLogin(
-    scoped_refptr<LoginHandler> login_handler,
-    std::unique_ptr<base::DictionaryValue> request_details) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnLogin(login_handler, *(request_details.get()));
-}
-
-void Browser::PreMainMessageLoopRun() {
-  for (BrowserObserver& observer : observers_) {
-    observer.OnPreMainMessageLoopRun();
-  }
-}
-
-void Browser::NotifyAndShutdown() {
-  if (is_shutdown_)
-    return;
-
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillQuit(&prevent_default);
-
-  if (prevent_default) {
-    is_quiting_ = false;
-    return;
-  }
-
-  Shutdown();
-}
-
-bool Browser::HandleBeforeQuit() {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnBeforeQuit(&prevent_default);
-
-  return !prevent_default;
-}
-
-void Browser::OnWindowCloseCancelled(NativeWindow* window) {
-  if (is_quiting_)
-    // Once a beforeunload handler has prevented the closing, we think the quit
-    // is cancelled too.
-    is_quiting_ = false;
-}
-
-void Browser::OnWindowAllClosed() {
-  if (is_exiting_) {
-    Shutdown();
-  } else if (is_quiting_) {
-    NotifyAndShutdown();
-  } else {
-    for (BrowserObserver& observer : observers_)
-      observer.OnWindowAllClosed();
-  }
-}
-
-#if defined(OS_MACOSX)
-void Browser::NewWindowForTab() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnNewWindowForTab();
-}
-#endif
-
-}  // namespace atom
removed in remote
  base   100644 634e14e60262a3531bc99acf5ba74e2cf22d9b54 atom/browser/browser.h
  our    100644 aed7d25c37da59c0dd5e09940a064c329353a0b2 atom/browser/browser.h
@@ -1,295 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BROWSER_H_
-#define ATOM_BROWSER_BROWSER_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/browser_observer.h"
-#include "atom/browser/window_list_observer.h"
-#include "atom/common/promise_util.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "base/observer_list.h"
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "native_mate/arguments.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#include "base/files/file_path.h"
-#endif
-
-namespace base {
-class FilePath;
-}
-
-namespace gfx {
-class Image;
-}
-
-namespace atom {
-
-class AtomMenuModel;
-
-// This class is used for control application-wide operations.
-class Browser : public WindowListObserver {
- public:
-  Browser();
-  ~Browser() override;
-
-  static Browser* Get();
-
-  // Try to close all windows and quit the application.
-  void Quit();
-
-  // Exit the application immediately and set exit code.
-  void Exit(mate::Arguments* args);
-
-  // Cleanup everything and shutdown the application gracefully.
-  void Shutdown();
-
-  // Focus the application.
-  void Focus();
-
-  // Returns the version of the executable (or bundle).
-  std::string GetVersion() const;
-
-  // Overrides the application version.
-  void SetVersion(const std::string& version);
-
-  // Returns the application's name, default is just Electron.
-  std::string GetName() const;
-
-  // Overrides the application name.
-  void SetName(const std::string& name);
-
-  // Add the |path| to recent documents list.
-  void AddRecentDocument(const base::FilePath& path);
-
-  // Clear the recent documents list.
-  void ClearRecentDocuments();
-
-  // Set the application user model ID.
-  void SetAppUserModelID(const base::string16& name);
-
-  // Remove the default protocol handler registry key
-  bool RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                     mate::Arguments* args);
-
-  // Set as default handler for a protocol.
-  bool SetAsDefaultProtocolClient(const std::string& protocol,
-                                  mate::Arguments* args);
-
-  // Query the current state of default handler for a protocol.
-  bool IsDefaultProtocolClient(const std::string& protocol,
-                               mate::Arguments* args);
-
-  // Set/Get the badge count.
-  bool SetBadgeCount(int count);
-  int GetBadgeCount();
-
-  // Set/Get the login item settings of the app
-  struct LoginItemSettings {
-    bool open_at_login = false;
-    bool open_as_hidden = false;
-    bool restore_state = false;
-    bool opened_at_login = false;
-    bool opened_as_hidden = false;
-    base::string16 path;
-    std::vector<base::string16> args;
-
-    LoginItemSettings();
-    ~LoginItemSettings();
-    LoginItemSettings(const LoginItemSettings&);
-  };
-  void SetLoginItemSettings(LoginItemSettings settings);
-  LoginItemSettings GetLoginItemSettings(const LoginItemSettings& options);
-
-#if defined(OS_MACOSX)
-  // Set the handler which decides whether to shutdown.
-  void SetShutdownHandler(base::Callback<bool()> handler);
-
-  // Hide the application.
-  void Hide();
-
-  // Show the application.
-  void Show();
-
-  // Creates an activity and sets it as the one currently in use.
-  void SetUserActivity(const std::string& type,
-                       const base::DictionaryValue& user_info,
-                       mate::Arguments* args);
-
-  // Returns the type name of the current user activity.
-  std::string GetCurrentActivityType();
-
-  // Invalidates the current user activity.
-  void InvalidateCurrentActivity();
-
-  // Updates the current user activity
-  void UpdateCurrentActivity(const std::string& type,
-                             const base::DictionaryValue& user_info);
-
-  // Indicates that an user activity is about to be resumed.
-  bool WillContinueUserActivity(const std::string& type);
-
-  // Indicates a failure to resume a Handoff activity.
-  void DidFailToContinueUserActivity(const std::string& type,
-                                     const std::string& error);
-
-  // Resumes an activity via hand-off.
-  bool ContinueUserActivity(const std::string& type,
-                            const base::DictionaryValue& user_info);
-
-  // Indicates that an activity was continued on another device.
-  void UserActivityWasContinued(const std::string& type,
-                                const base::DictionaryValue& user_info);
-
-  // Gives an oportunity to update the Handoff payload.
-  bool UpdateUserActivityState(const std::string& type,
-                               const base::DictionaryValue& user_info);
-
-  // Bounce the dock icon.
-  enum BounceType {
-    BOUNCE_CRITICAL = 0,
-    BOUNCE_INFORMATIONAL = 10,
-  };
-  int DockBounce(BounceType type);
-  void DockCancelBounce(int request_id);
-
-  // Bounce the Downloads stack.
-  void DockDownloadFinished(const std::string& filePath);
-
-  // Set/Get dock's badge text.
-  void DockSetBadgeText(const std::string& label);
-  std::string DockGetBadgeText();
-
-  // Hide/Show dock.
-  void DockHide();
-  void DockShow();
-  bool DockIsVisible();
-
-  // Set docks' menu.
-  void DockSetMenu(AtomMenuModel* model);
-
-  // Set docks' icon.
-  void DockSetIcon(const gfx::Image& image);
-
-  void ShowAboutPanel();
-  void SetAboutPanelOptions(const base::DictionaryValue& options);
-#endif  // defined(OS_MACOSX)
-
-#if defined(OS_WIN)
-  struct UserTask {
-    base::FilePath program;
-    base::string16 arguments;
-    base::string16 title;
-    base::string16 description;
-    base::FilePath icon_path;
-    int icon_index;
-
-    UserTask();
-    UserTask(const UserTask&);
-    ~UserTask();
-  };
-
-  // Add a custom task to jump list.
-  bool SetUserTasks(const std::vector<UserTask>& tasks);
-
-  // Returns the application user model ID, if there isn't one, then create
-  // one from app's name.
-  // The returned string managed by Browser, and should not be modified.
-  PCWSTR GetAppUserModelID();
-#endif  // defined(OS_WIN)
-
-#if defined(OS_LINUX)
-  // Whether Unity launcher is running.
-  bool IsUnityRunning();
-#endif  // defined(OS_LINUX)
-
-  // Tell the application to open a file.
-  bool OpenFile(const std::string& file_path);
-
-  // Tell the application to open a url.
-  void OpenURL(const std::string& url);
-
-#if defined(OS_MACOSX)
-  // Tell the application to create a new window for a tab.
-  void NewWindowForTab();
-#endif  // defined(OS_MACOSX)
-
-  // Tell the application that application is activated with visible/invisible
-  // windows.
-  void Activate(bool has_visible_windows);
-
-  // Tell the application the loading has been done.
-  void WillFinishLaunching();
-  void DidFinishLaunching(const base::DictionaryValue& launch_info);
-
-  void OnAccessibilitySupportChanged();
-
-  // Request basic auth login.
-  void RequestLogin(scoped_refptr<LoginHandler> login_handler,
-                    std::unique_ptr<base::DictionaryValue> request_details);
-
-  void PreMainMessageLoopRun();
-
-  void AddObserver(BrowserObserver* obs) { observers_.AddObserver(obs); }
-
-  void RemoveObserver(BrowserObserver* obs) { observers_.RemoveObserver(obs); }
-
-  bool is_shutting_down() const { return is_shutdown_; }
-  bool is_quiting() const { return is_quiting_; }
-  bool is_ready() const { return is_ready_; }
-  util::Promise* WhenReady(v8::Isolate* isolate);
-
- protected:
-  // Returns the version of application bundle or executable file.
-  std::string GetExecutableFileVersion() const;
-
-  // Returns the name of application bundle or executable file.
-  std::string GetExecutableFileProductName() const;
-
-  // Send the will-quit message and then shutdown the application.
-  void NotifyAndShutdown();
-
-  // Send the before-quit message and start closing windows.
-  bool HandleBeforeQuit();
-
-  bool is_quiting_ = false;
-
- private:
-  // WindowListObserver implementations:
-  void OnWindowCloseCancelled(NativeWindow* window) override;
-  void OnWindowAllClosed() override;
-
-  // Observers of the browser.
-  base::ObserverList<BrowserObserver> observers_;
-
-  // Whether `app.exit()` has been called
-  bool is_exiting_ = false;
-
-  // Whether "ready" event has been emitted.
-  bool is_ready_ = false;
-
-  // The browser is being shutdown.
-  bool is_shutdown_ = false;
-
-  int badge_count_ = 0;
-
-  util::Promise* ready_promise_ = nullptr;
-
-#if defined(OS_MACOSX)
-  base::DictionaryValue about_panel_options_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(Browser);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BROWSER_H_
removed in remote
  base   100644 6c7d4abaf6456d96a25a68b153bcb4a40b63fff6 atom/browser/browser_linux.cc
  our    100644 0b4868f711ec24e6db3bf37f751c505c0ccc4115 atom/browser/browser_linux.cc
@@ -1,145 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/atom_version.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/process/launch.h"
-#include "brightray/common/application_info.h"
-
-#if defined(USE_X11)
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "chrome/browser/ui/libgtkui/unity_service.h"
-#endif
-
-namespace atom {
-
-const char kXdgSettings[] = "xdg-settings";
-const char kXdgSettingsDefaultSchemeHandler[] = "default-url-scheme-handler";
-
-bool LaunchXdgUtility(const std::vector<std::string>& argv, int* exit_code) {
-  *exit_code = EXIT_FAILURE;
-  int devnull = open("/dev/null", O_RDONLY);
-  if (devnull < 0)
-    return false;
-
-  base::LaunchOptions options;
-  options.fds_to_remap.push_back(std::make_pair(devnull, STDIN_FILENO));
-
-  base::Process process = base::LaunchProcess(argv, options);
-  close(devnull);
-
-  if (!process.IsValid())
-    return false;
-  return process.WaitForExit(exit_code);
-}
-
-bool SetDefaultWebClient(const std::string& protocol) {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-
-  std::vector<std::string> argv;
-  argv.push_back(kXdgSettings);
-  argv.push_back("set");
-  if (!protocol.empty()) {
-    argv.push_back(kXdgSettingsDefaultSchemeHandler);
-    argv.push_back(protocol);
-  }
-  argv.push_back(libgtkui::GetDesktopName(env.get()));
-
-  int exit_code;
-  bool ran_ok = LaunchXdgUtility(argv, &exit_code);
-  return ran_ok && exit_code == EXIT_SUCCESS;
-}
-
-void Browser::Focus() {
-  // Focus on the first visible window.
-  for (auto* const window : WindowList::GetWindows()) {
-    if (window->IsVisible()) {
-      window->Focus(true);
-      break;
-    }
-  }
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {}
-
-void Browser::ClearRecentDocuments() {}
-
-void Browser::SetAppUserModelID(const base::string16& name) {}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  return SetDefaultWebClient(protocol);
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-
-  if (protocol.empty())
-    return false;
-
-  std::vector<std::string> argv;
-  argv.push_back(kXdgSettings);
-  argv.push_back("check");
-  argv.push_back(kXdgSettingsDefaultSchemeHandler);
-  argv.push_back(protocol);
-  argv.push_back(libgtkui::GetDesktopName(env.get()));
-
-  std::string reply;
-  int success_code;
-  bool ran_ok = base::GetAppOutputWithExitCode(base::CommandLine(argv), &reply,
-                                               &success_code);
-
-  if (!ran_ok || success_code != EXIT_SUCCESS)
-    return false;
-
-  // Allow any reply that starts with "yes".
-  return base::StartsWith(reply, "yes", base::CompareCase::SENSITIVE) ? true
-                                                                      : false;
-}
-
-// Todo implement
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  return false;
-}
-
-bool Browser::SetBadgeCount(int count) {
-  if (IsUnityRunning()) {
-    unity::SetDownloadCount(count);
-    badge_count_ = count;
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  return LoginItemSettings();
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  return brightray::GetApplicationVersion();
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-bool Browser::IsUnityRunning() {
-  return unity::IsRunning();
-}
-
-}  // namespace atom
removed in remote
  base   100644 0294894fcd61a7255cd28ad6797ef4e32a279490 atom/browser/browser_mac.mm
  our    100644 27e347eccebf006336d5d110c81717ecc45af9c3 atom/browser/browser_mac.mm
@@ -1,346 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/atom_application_delegate.h"
-#include "atom/browser/mac/dict_util.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/platform_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "net/base/mac/url_conversions.h"
-#include "ui/gfx/image/image.h"
-#include "url/gurl.h"
-
-namespace atom {
-
-void Browser::SetShutdownHandler(base::Callback<bool()> handler) {
-  [[AtomApplication sharedApplication] setShutdownHandler:std::move(handler)];
-}
-
-void Browser::Focus() {
-  [[AtomApplication sharedApplication] activateIgnoringOtherApps:YES];
-}
-
-void Browser::Hide() {
-  [[AtomApplication sharedApplication] hide:nil];
-}
-
-void Browser::Show() {
-  [[AtomApplication sharedApplication] unhide:nil];
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {
-  NSString* path_string = base::mac::FilePathToNSString(path);
-  if (!path_string)
-    return;
-  NSURL* u = [NSURL fileURLWithPath:path_string];
-  if (!u)
-    return;
-  [[NSDocumentController sharedDocumentController] noteNewRecentDocumentURL:u];
-}
-
-void Browser::ClearRecentDocuments() {
-  [[NSDocumentController sharedDocumentController] clearRecentDocuments:nil];
-}
-
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  if (!Browser::IsDefaultProtocolClient(protocol, args))
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-  CFStringRef protocol_cf = base::mac::NSToCFCast(protocol_ns);
-  CFArrayRef bundleList = LSCopyAllHandlersForURLScheme(protocol_cf);
-  if (!bundleList) {
-    return false;
-  }
-  // On macOS, we can't query the default, but the handlers list seems to put
-  // Apple's defaults first, so we'll use the first option that isn't our bundle
-  CFStringRef other = nil;
-  for (CFIndex i = 0; i < CFArrayGetCount(bundleList); ++i) {
-    other =
-        base::mac::CFCast<CFStringRef>(CFArrayGetValueAtIndex(bundleList, i));
-    if (![identifier isEqualToString:(__bridge NSString*)other]) {
-      break;
-    }
-  }
-
-  // No other app was found set it to none instead of setting it back to itself.
-  if ([identifier isEqualToString:(__bridge NSString*)other]) {
-    other = base::mac::NSToCFCast(@"None");
-  }
-
-  OSStatus return_code = LSSetDefaultHandlerForURLScheme(protocol_cf, other);
-  return return_code == noErr;
-}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-  OSStatus return_code = LSSetDefaultHandlerForURLScheme(
-      base::mac::NSToCFCast(protocol_ns), base::mac::NSToCFCast(identifier));
-  return return_code == noErr;
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-
-  CFStringRef bundle =
-      LSCopyDefaultHandlerForURLScheme(base::mac::NSToCFCast(protocol_ns));
-  NSString* bundleId =
-      static_cast<NSString*>(base::mac::CFTypeRefToNSObjectAutorelease(bundle));
-  if (!bundleId)
-    return false;
-
-  // Ensure the comparison is case-insensitive
-  // as LS does not persist the case of the bundle id.
-  NSComparisonResult result = [bundleId caseInsensitiveCompare:identifier];
-  return result == NSOrderedSame;
-}
-
-void Browser::SetAppUserModelID(const base::string16& name) {}
-
-bool Browser::SetBadgeCount(int count) {
-  DockSetBadgeText(count != 0 ? base::IntToString(count) : "");
-  badge_count_ = count;
-  return true;
-}
-
-void Browser::SetUserActivity(const std::string& type,
-                              const base::DictionaryValue& user_info,
-                              mate::Arguments* args) {
-  std::string url_string;
-  args->GetNext(&url_string);
-
-  [[AtomApplication sharedApplication]
-      setCurrentActivity:base::SysUTF8ToNSString(type)
-            withUserInfo:DictionaryValueToNSDictionary(user_info)
-          withWebpageURL:net::NSURLWithGURL(GURL(url_string))];
-}
-
-std::string Browser::GetCurrentActivityType() {
-  if (@available(macOS 10.10, *)) {
-    NSUserActivity* userActivity =
-        [[AtomApplication sharedApplication] getCurrentActivity];
-    return base::SysNSStringToUTF8(userActivity.activityType);
-  } else {
-    return std::string();
-  }
-}
-
-void Browser::InvalidateCurrentActivity() {
-  [[AtomApplication sharedApplication] invalidateCurrentActivity];
-}
-
-void Browser::UpdateCurrentActivity(const std::string& type,
-                                    const base::DictionaryValue& user_info) {
-  [[AtomApplication sharedApplication]
-      updateCurrentActivity:base::SysUTF8ToNSString(type)
-               withUserInfo:DictionaryValueToNSDictionary(user_info)];
-}
-
-bool Browser::WillContinueUserActivity(const std::string& type) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillContinueUserActivity(&prevent_default, type);
-  return prevent_default;
-}
-
-void Browser::DidFailToContinueUserActivity(const std::string& type,
-                                            const std::string& error) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnDidFailToContinueUserActivity(type, error);
-}
-
-bool Browser::ContinueUserActivity(const std::string& type,
-                                   const base::DictionaryValue& user_info) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnContinueUserActivity(&prevent_default, type, user_info);
-  return prevent_default;
-}
-
-void Browser::UserActivityWasContinued(const std::string& type,
-                                       const base::DictionaryValue& user_info) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnUserActivityWasContinued(type, user_info);
-}
-
-bool Browser::UpdateUserActivityState(const std::string& type,
-                                      const base::DictionaryValue& user_info) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnUpdateUserActivityState(&prevent_default, type, user_info);
-  return prevent_default;
-}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  LoginItemSettings settings;
-#if defined(MAS_BUILD)
-  settings.open_at_login = platform_util::GetLoginItemEnabled();
-#else
-  settings.open_at_login =
-      base::mac::CheckLoginItemStatus(&settings.open_as_hidden);
-  settings.restore_state = base::mac::WasLaunchedAsLoginItemRestoreState();
-  settings.opened_at_login = base::mac::WasLaunchedAsLoginOrResumeItem();
-  settings.opened_as_hidden = base::mac::WasLaunchedAsHiddenLoginItem();
-#endif
-  return settings;
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {
-#if defined(MAS_BUILD)
-  platform_util::SetLoginItemEnabled(settings.open_at_login);
-#else
-  if (settings.open_at_login)
-    base::mac::AddToLoginItems(settings.open_as_hidden);
-  else
-    base::mac::RemoveFromLoginItems();
-#endif
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  return brightray::GetApplicationVersion();
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-int Browser::DockBounce(BounceType type) {
-  return [[AtomApplication sharedApplication]
-      requestUserAttention:static_cast<NSRequestUserAttentionType>(type)];
-}
-
-void Browser::DockCancelBounce(int request_id) {
-  [[AtomApplication sharedApplication] cancelUserAttentionRequest:request_id];
-}
-
-void Browser::DockSetBadgeText(const std::string& label) {
-  NSDockTile* tile = [[AtomApplication sharedApplication] dockTile];
-  [tile setBadgeLabel:base::SysUTF8ToNSString(label)];
-}
-
-void Browser::DockDownloadFinished(const std::string& filePath) {
-  [[NSDistributedNotificationCenter defaultCenter]
-      postNotificationName:@"com.apple.DownloadFileFinished"
-                    object:base::SysUTF8ToNSString(filePath)];
-}
-
-std::string Browser::DockGetBadgeText() {
-  NSDockTile* tile = [[AtomApplication sharedApplication] dockTile];
-  return base::SysNSStringToUTF8([tile badgeLabel]);
-}
-
-void Browser::DockHide() {
-  for (auto* const& window : WindowList::GetWindows())
-    [window->GetNativeWindow() setCanHide:NO];
-
-  ProcessSerialNumber psn = {0, kCurrentProcess};
-  TransformProcessType(&psn, kProcessTransformToUIElementApplication);
-}
-
-bool Browser::DockIsVisible() {
-  // Because DockShow has a slight delay this may not be true immediately
-  // after that call.
-  return ([[NSRunningApplication currentApplication] activationPolicy] ==
-          NSApplicationActivationPolicyRegular);
-}
-
-void Browser::DockShow() {
-  BOOL active = [[NSRunningApplication currentApplication] isActive];
-  ProcessSerialNumber psn = {0, kCurrentProcess};
-  if (active) {
-    // Workaround buggy behavior of TransformProcessType.
-    // http://stackoverflow.com/questions/7596643/
-    NSArray* runningApps = [NSRunningApplication
-        runningApplicationsWithBundleIdentifier:@"com.apple.dock"];
-    for (NSRunningApplication* app in runningApps) {
-      [app activateWithOptions:NSApplicationActivateIgnoringOtherApps];
-      break;
-    }
-    dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
-    dispatch_after(one_ms, dispatch_get_main_queue(), ^{
-      TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-      dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
-      dispatch_after(one_ms, dispatch_get_main_queue(), ^{
-        [[NSRunningApplication currentApplication]
-            activateWithOptions:NSApplicationActivateIgnoringOtherApps];
-      });
-    });
-  } else {
-    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-  }
-}
-
-void Browser::DockSetMenu(AtomMenuModel* model) {
-  AtomApplicationDelegate* delegate =
-      (AtomApplicationDelegate*)[NSApp delegate];
-  [delegate setApplicationDockMenu:model];
-}
-
-void Browser::DockSetIcon(const gfx::Image& image) {
-  [[AtomApplication sharedApplication]
-      setApplicationIconImage:image.AsNSImage()];
-}
-
-void Browser::ShowAboutPanel() {
-  NSDictionary* options = DictionaryValueToNSDictionary(about_panel_options_);
-
-  // Credits must be a NSAttributedString instead of NSString
-  id credits = options[@"Credits"];
-  if (credits != nil) {
-    NSMutableDictionary* mutable_options = [options mutableCopy];
-    mutable_options[@"Credits"] = [[[NSAttributedString alloc]
-        initWithString:(NSString*)credits] autorelease];
-    options = [NSDictionary dictionaryWithDictionary:mutable_options];
-  }
-
-  [[AtomApplication sharedApplication]
-      orderFrontStandardAboutPanelWithOptions:options];
-}
-
-void Browser::SetAboutPanelOptions(const base::DictionaryValue& options) {
-  about_panel_options_.Clear();
-
-  // Upper case option keys for orderFrontStandardAboutPanelWithOptions format
-  for (base::DictionaryValue::Iterator iter(options); !iter.IsAtEnd();
-       iter.Advance()) {
-    std::string key = iter.key();
-    if (!key.empty() && iter.value().is_string()) {
-      key[0] = base::ToUpperASCII(key[0]);
-      about_panel_options_.SetString(key, iter.value().GetString());
-    }
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 da327eb90a02ef65b1df28bff1c5169585417aa0 atom/browser/browser_observer.h
  our    100644 d518e8d6a7c6e8e30c09498883719a58c8a9f5e8 atom/browser/browser_observer.h
@@ -1,91 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BROWSER_OBSERVER_H_
-#define ATOM_BROWSER_BROWSER_OBSERVER_H_
-
-#include <string>
-
-#include "atom/browser/login_handler.h"
-#include "base/memory/scoped_refptr.h"
-#include "build/build_config.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace atom {
-
-class BrowserObserver {
- public:
-  // The browser is about to close all windows.
-  virtual void OnBeforeQuit(bool* prevent_default) {}
-
-  // The browser has closed all windows and will quit.
-  virtual void OnWillQuit(bool* prevent_default) {}
-
-  // The browser has closed all windows. If the browser is quiting, then this
-  // method will not be called, instead it will call OnWillQuit.
-  virtual void OnWindowAllClosed() {}
-
-  // The browser is quitting.
-  virtual void OnQuit() {}
-
-  // The browser has opened a file by double clicking in Finder or dragging the
-  // file to the Dock icon. (macOS only)
-  virtual void OnOpenFile(bool* prevent_default, const std::string& file_path) {
-  }
-
-  // Browser is used to open a url.
-  virtual void OnOpenURL(const std::string& url) {}
-
-  // The browser is activated with visible/invisible windows (usually by
-  // clicking on the dock icon).
-  virtual void OnActivate(bool has_visible_windows) {}
-
-  // The browser has finished loading.
-  virtual void OnWillFinishLaunching() {}
-  virtual void OnFinishLaunching(const base::DictionaryValue& launch_info) {}
-
-  // The browser requests HTTP login.
-  virtual void OnLogin(scoped_refptr<LoginHandler> login_handler,
-                       const base::DictionaryValue& request_details) {}
-
-  // The browser's accessibility suppport has changed.
-  virtual void OnAccessibilitySupportChanged() {}
-
-  // The app message loop is ready
-  virtual void OnPreMainMessageLoopRun() {}
-
-#if defined(OS_MACOSX)
-  // The browser wants to report that an user activity will resume. (macOS only)
-  virtual void OnWillContinueUserActivity(bool* prevent_default,
-                                          const std::string& type) {}
-  // The browser wants to report an user activity resuming error. (macOS only)
-  virtual void OnDidFailToContinueUserActivity(const std::string& type,
-                                               const std::string& error) {}
-  // The browser wants to resume a user activity via handoff. (macOS only)
-  virtual void OnContinueUserActivity(bool* prevent_default,
-                                      const std::string& type,
-                                      const base::DictionaryValue& user_info) {}
-  // The browser wants to notify that an user activity was resumed. (macOS only)
-  virtual void OnUserActivityWasContinued(
-      const std::string& type,
-      const base::DictionaryValue& user_info) {}
-  // The browser wants to update an user activity payload. (macOS only)
-  virtual void OnUpdateUserActivityState(
-      bool* prevent_default,
-      const std::string& type,
-      const base::DictionaryValue& user_info) {}
-  // User clicked the native macOS new tab button. (macOS only)
-  virtual void OnNewWindowForTab() {}
-#endif
-
- protected:
-  virtual ~BrowserObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BROWSER_OBSERVER_H_
removed in remote
  base   100644 9531406f8cd46494099b7e432ac6e96d610f9eee atom/browser/browser_win.cc
  our    100644 fc3b9f330a4958b0b1e30d41c2bebe091b135856 atom/browser/browser_win.cc
@@ -1,346 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>
-#include <shlobj.h>
-#include <shobjidl.h>
-
-#include "atom/browser/ui/win/jump_list.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/base_paths.h"
-#include "base/file_version_info.h"
-#include "base/files/file_path.h"
-#include "base/path_service.h"
-#include "base/strings/string_util.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/win/registry.h"
-#include "base/win/win_util.h"
-#include "base/win/windows_version.h"
-#include "brightray/common/application_info.h"
-
-namespace atom {
-
-namespace {
-
-BOOL CALLBACK WindowsEnumerationHandler(HWND hwnd, LPARAM param) {
-  DWORD target_process_id = *reinterpret_cast<DWORD*>(param);
-  DWORD process_id = 0;
-
-  GetWindowThreadProcessId(hwnd, &process_id);
-  if (process_id == target_process_id) {
-    SetFocus(hwnd);
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-bool GetProcessExecPath(base::string16* exe) {
-  base::FilePath path;
-  if (!PathService::Get(base::FILE_EXE, &path)) {
-    LOG(ERROR) << "Error getting app exe path";
-    return false;
-  }
-  *exe = path.value();
-  return true;
-}
-
-bool GetProtocolLaunchPath(mate::Arguments* args, base::string16* exe) {
-  if (!args->GetNext(exe) && !GetProcessExecPath(exe)) {
-    return false;
-  }
-
-  // Read in optional args arg
-  std::vector<base::string16> launch_args;
-  if (args->GetNext(&launch_args) && !launch_args.empty())
-    *exe = base::StringPrintf(L"\"%ls\" %ls \"%%1\"", exe->c_str(),
-                              base::JoinString(launch_args, L" ").c_str());
-  else
-    *exe = base::StringPrintf(L"\"%ls\" \"%%1\"", exe->c_str());
-  return true;
-}
-
-bool FormatCommandLineString(base::string16* exe,
-                             const std::vector<base::string16>& launch_args) {
-  if (exe->empty() && !GetProcessExecPath(exe)) {
-    return false;
-  }
-
-  if (!launch_args.empty()) {
-    *exe = base::StringPrintf(L"%ls %ls", exe->c_str(),
-                              base::JoinString(launch_args, L" ").c_str());
-  }
-
-  return true;
-}
-
-}  // namespace
-
-Browser::UserTask::UserTask() = default;
-Browser::UserTask::UserTask(const UserTask&) = default;
-Browser::UserTask::~UserTask() = default;
-
-void Browser::Focus() {
-  // On Windows we just focus on the first window found for this process.
-  DWORD pid = GetCurrentProcessId();
-  EnumWindows(&WindowsEnumerationHandler, reinterpret_cast<LPARAM>(&pid));
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {
-  if (base::win::GetVersion() < base::win::VERSION_WIN7)
-    return;
-
-  CComPtr<IShellItem> item;
-  HRESULT hr = SHCreateItemFromParsingName(path.value().c_str(), NULL,
-                                           IID_PPV_ARGS(&item));
-  if (SUCCEEDED(hr)) {
-    SHARDAPPIDINFO info;
-    info.psi = item;
-    info.pszAppID = GetAppUserModelID();
-    SHAddToRecentDocs(SHARD_APPIDINFO, &info);
-  }
-}
-
-void Browser::ClearRecentDocuments() {
-  CComPtr<IApplicationDestinations> destinations;
-  if (FAILED(destinations.CoCreateInstance(CLSID_ApplicationDestinations, NULL,
-                                           CLSCTX_INPROC_SERVER)))
-    return;
-  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
-    return;
-  destinations->RemoveAllDestinations();
-}
-
-void Browser::SetAppUserModelID(const base::string16& name) {
-  brightray::SetAppUserModelID(name);
-}
-
-bool Browser::SetUserTasks(const std::vector<UserTask>& tasks) {
-  JumpList jump_list(GetAppUserModelID());
-  if (!jump_list.Begin())
-    return false;
-
-  JumpListCategory category;
-  category.type = JumpListCategory::Type::TASKS;
-  category.items.reserve(tasks.size());
-  JumpListItem item;
-  item.type = JumpListItem::Type::TASK;
-  for (const auto& task : tasks) {
-    item.title = task.title;
-    item.path = task.program;
-    item.arguments = task.arguments;
-    item.icon_path = task.icon_path;
-    item.icon_index = task.icon_index;
-    item.description = task.description;
-    category.items.push_back(item);
-  }
-
-  jump_list.AppendCategory(category);
-  return jump_list.Commit();
-}
-
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = L"Software\\Classes\\";
-
-  // Command Key
-  base::string16 wprotocol = base::UTF8ToUTF16(protocol);
-  base::string16 shellPath = wprotocol + L"\\shell";
-  base::string16 cmdPath = keyPath + shellPath + L"\\open\\command";
-
-  base::win::RegKey classesKey;
-  base::win::RegKey commandKey;
-
-  if (FAILED(classesKey.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
-    // Classes key doesn't exist, that's concerning, but I guess
-    // we're not the default handler
-    return true;
-
-  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't even exist, we can confirm that it is not set
-    return true;
-
-  base::string16 keyVal;
-  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
-    // Default value not set, we can confirm that it is not set
-    return true;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  if (keyVal == exe) {
-    // Let's kill the key
-    if (FAILED(classesKey.DeleteKey(shellPath.c_str())))
-      return false;
-
-    // Let's clean up after ourselves
-    base::win::RegKey protocolKey;
-    base::string16 protocolPath = keyPath + wprotocol;
-
-    if (SUCCEEDED(
-            protocolKey.Open(root, protocolPath.c_str(), KEY_ALL_ACCESS))) {
-      protocolKey.DeleteValue(L"URL Protocol");
-
-      // Overwrite the default value to be empty, we can't delete it right away
-      protocolKey.WriteValue(L"", L"");
-      protocolKey.DeleteValue(L"");
-    }
-
-    // If now empty, delete the whole key
-    classesKey.DeleteEmptyKey(wprotocol.c_str());
-
-    return true;
-  } else {
-    return true;
-  }
-}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  // HKEY_CLASSES_ROOT
-  //    $PROTOCOL
-  //       (Default) = "URL:$NAME"
-  //       URL Protocol = ""
-  //       shell
-  //          open
-  //             command
-  //                (Default) = "$COMMAND" "%1"
-  //
-  // However, the "HKEY_CLASSES_ROOT" key can only be written by the
-  // Administrator user. So, we instead write to "HKEY_CURRENT_USER\
-  // Software\Classes", which is inherited by "HKEY_CLASSES_ROOT"
-  // anyway, and can be written by unprivileged users.
-
-  if (protocol.empty())
-    return false;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = base::UTF8ToUTF16("Software\\Classes\\" + protocol);
-  base::string16 urlDecl = base::UTF8ToUTF16("URL:" + protocol);
-
-  // Command Key
-  base::string16 cmdPath = keyPath + L"\\shell\\open\\command";
-
-  // Write information to registry
-  base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS);
-  if (FAILED(key.WriteValue(L"URL Protocol", L"")) ||
-      FAILED(key.WriteValue(L"", urlDecl.c_str())))
-    return false;
-
-  base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS);
-  if (FAILED(commandKey.WriteValue(L"", exe.c_str())))
-    return false;
-
-  return true;
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = base::UTF8ToUTF16("Software\\Classes\\" + protocol);
-
-  // Command Key
-  base::string16 cmdPath = keyPath + L"\\shell\\open\\command";
-
-  base::win::RegKey key;
-  base::win::RegKey commandKey;
-  if (FAILED(key.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't exist, we can confirm that it is not set
-    return false;
-
-  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't exist, we can confirm that it is not set
-    return false;
-
-  base::string16 keyVal;
-  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
-    // Default value not set, we can confirm that it is not set
-    return false;
-
-  // Default value is the same as current file path
-  return keyVal == exe;
-}
-
-bool Browser::SetBadgeCount(int count) {
-  return false;
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {
-  base::string16 keyPath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
-  base::win::RegKey key(HKEY_CURRENT_USER, keyPath.c_str(), KEY_ALL_ACCESS);
-
-  if (settings.open_at_login) {
-    base::string16 exe = settings.path;
-    if (FormatCommandLineString(&exe, settings.args)) {
-      key.WriteValue(GetAppUserModelID(), exe.c_str());
-    }
-  } else {
-    key.DeleteValue(GetAppUserModelID());
-  }
-}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  LoginItemSettings settings;
-  base::string16 keyPath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
-  base::win::RegKey key(HKEY_CURRENT_USER, keyPath.c_str(), KEY_ALL_ACCESS);
-  base::string16 keyVal;
-
-  if (!FAILED(key.ReadValue(GetAppUserModelID(), &keyVal))) {
-    base::string16 exe = options.path;
-    if (FormatCommandLineString(&exe, options.args)) {
-      settings.open_at_login = keyVal == exe;
-    }
-  }
-
-  return settings;
-}
-
-PCWSTR Browser::GetAppUserModelID() {
-  return brightray::GetRawAppUserModelID();
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  base::FilePath path;
-  if (PathService::Get(base::FILE_EXE, &path)) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    std::unique_ptr<FileVersionInfo> version_info(
-        FileVersionInfo::CreateFileVersionInfo(path));
-    return base::UTF16ToUTF8(version_info->product_version());
-  }
-
-  return ATOM_VERSION_STRING;
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-}  // namespace atom
removed in remote
  base   100644 62e854ac5655fb96bc5e3191425528e0ca222d96 atom/browser/common_web_contents_delegate.cc
  our    100644 b3b1195e044cd2c74b246aa13e9e85953d694477 atom/browser/common_web_contents_delegate.cc
@@ -1,536 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/common_web_contents_delegate.h"
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_dialog_helper.h"
-#include "atom/common/atom_constants.h"
-#include "atom/common/options_switches.h"
-#include "base/files/file_util.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/sequenced_task_runner_handle.h"
-#include "chrome/browser/printing/print_preview_message_handler.h"
-#include "chrome/browser/printing/print_view_manager_basic.h"
-#include "chrome/browser/ssl/security_state_tab_helper.h"
-#include "chrome/browser/ui/browser_dialogs.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_service.h"
-#include "components/prefs/scoped_user_pref_update.h"
-#include "components/security_state/content/content_utils.h"
-#include "components/security_state/core/security_state.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/security_style_explanation.h"
-#include "content/public/browser/security_style_explanations.h"
-#include "storage/browser/fileapi/isolated_context.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-const char kRootName[] = "<root>";
-
-struct FileSystem {
-  FileSystem() {}
-  FileSystem(const std::string& file_system_name,
-             const std::string& root_url,
-             const std::string& file_system_path)
-      : file_system_name(file_system_name),
-        root_url(root_url),
-        file_system_path(file_system_path) {}
-
-  std::string file_system_name;
-  std::string root_url;
-  std::string file_system_path;
-};
-
-std::string RegisterFileSystem(content::WebContents* web_contents,
-                               const base::FilePath& path) {
-  auto* isolated_context = storage::IsolatedContext::GetInstance();
-  std::string root_name(kRootName);
-  std::string file_system_id = isolated_context->RegisterFileSystemForPath(
-      storage::kFileSystemTypeNativeLocal, std::string(), path, &root_name);
-
-  content::ChildProcessSecurityPolicy* policy =
-      content::ChildProcessSecurityPolicy::GetInstance();
-  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
-  int renderer_id = render_view_host->GetProcess()->GetID();
-  policy->GrantReadFileSystem(renderer_id, file_system_id);
-  policy->GrantWriteFileSystem(renderer_id, file_system_id);
-  policy->GrantCreateFileForFileSystem(renderer_id, file_system_id);
-  policy->GrantDeleteFromFileSystem(renderer_id, file_system_id);
-
-  if (!policy->CanReadFile(renderer_id, path))
-    policy->GrantReadFile(renderer_id, path);
-
-  return file_system_id;
-}
-
-FileSystem CreateFileSystemStruct(content::WebContents* web_contents,
-                                  const std::string& file_system_id,
-                                  const std::string& file_system_path) {
-  const GURL origin = web_contents->GetURL().GetOrigin();
-  std::string file_system_name =
-      storage::GetIsolatedFileSystemName(origin, file_system_id);
-  std::string root_url = storage::GetIsolatedFileSystemRootURIString(
-      origin, file_system_id, kRootName);
-  return FileSystem(file_system_name, root_url, file_system_path);
-}
-
-std::unique_ptr<base::DictionaryValue> CreateFileSystemValue(
-    const FileSystem& file_system) {
-  std::unique_ptr<base::DictionaryValue> file_system_value(
-      new base::DictionaryValue());
-  file_system_value->SetString("fileSystemName", file_system.file_system_name);
-  file_system_value->SetString("rootURL", file_system.root_url);
-  file_system_value->SetString("fileSystemPath", file_system.file_system_path);
-  return file_system_value;
-}
-
-void WriteToFile(const base::FilePath& path, const std::string& content) {
-  base::AssertBlockingAllowed();
-  DCHECK(!path.empty());
-
-  base::WriteFile(path, content.data(), content.size());
-}
-
-void AppendToFile(const base::FilePath& path, const std::string& content) {
-  base::AssertBlockingAllowed();
-  DCHECK(!path.empty());
-
-  base::AppendToFile(path, content.data(), content.size());
-}
-
-PrefService* GetPrefService(content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  return static_cast<atom::AtomBrowserContext*>(context)->prefs();
-}
-
-std::set<std::string> GetAddedFileSystemPaths(
-    content::WebContents* web_contents) {
-  auto* pref_service = GetPrefService(web_contents);
-  const base::DictionaryValue* file_system_paths_value =
-      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);
-  std::set<std::string> result;
-  if (file_system_paths_value) {
-    base::DictionaryValue::Iterator it(*file_system_paths_value);
-    for (; !it.IsAtEnd(); it.Advance()) {
-      result.insert(it.key());
-    }
-  }
-  return result;
-}
-
-bool IsDevToolsFileSystemAdded(content::WebContents* web_contents,
-                               const std::string& file_system_path) {
-  auto file_system_paths = GetAddedFileSystemPaths(web_contents);
-  return file_system_paths.find(file_system_path) != file_system_paths.end();
-}
-
-}  // namespace
-
-CommonWebContentsDelegate::CommonWebContentsDelegate()
-    : devtools_file_system_indexer_(new DevToolsFileSystemIndexer),
-      file_task_runner_(
-          base::CreateSequencedTaskRunnerWithTraits({base::MayBlock()})) {}
-
-CommonWebContentsDelegate::~CommonWebContentsDelegate() {}
-
-void CommonWebContentsDelegate::InitWithWebContents(
-    content::WebContents* web_contents,
-    AtomBrowserContext* browser_context,
-    bool is_guest) {
-  browser_context_ = browser_context;
-  web_contents->SetDelegate(this);
-
-  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
-  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
-
-  // Determien whether the WebContents is offscreen.
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  offscreen_ =
-      !web_preferences || web_preferences->IsEnabled(options::kOffscreen);
-
-  // Create InspectableWebContents.
-  web_contents_.reset(
-      brightray::InspectableWebContents::Create(web_contents, is_guest));
-  web_contents_->SetDelegate(this);
-}
-
-void CommonWebContentsDelegate::SetOwnerWindow(NativeWindow* owner_window) {
-  SetOwnerWindow(GetWebContents(), owner_window);
-}
-
-void CommonWebContentsDelegate::SetOwnerWindow(
-    content::WebContents* web_contents,
-    NativeWindow* owner_window) {
-  owner_window_ = owner_window ? owner_window->GetWeakPtr() : nullptr;
-  auto relay = std::make_unique<NativeWindowRelay>(owner_window_);
-  auto* relay_key = relay->key;
-  if (owner_window) {
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-    autofill_popup_.reset(new AutofillPopup());
-#endif
-    web_contents->SetUserData(relay_key, std::move(relay));
-  } else {
-    web_contents->RemoveUserData(relay_key);
-    relay.reset();
-  }
-}
-
-void CommonWebContentsDelegate::ResetManagedWebContents(bool async) {
-  if (async) {
-    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE,
-                                                    web_contents_.release());
-  } else {
-    web_contents_.reset();
-  }
-}
-
-content::WebContents* CommonWebContentsDelegate::GetWebContents() const {
-  if (!web_contents_)
-    return nullptr;
-  return web_contents_->GetWebContents();
-}
-
-content::WebContents* CommonWebContentsDelegate::GetDevToolsWebContents()
-    const {
-  if (!web_contents_)
-    return nullptr;
-  return web_contents_->GetDevToolsWebContents();
-}
-
-content::WebContents* CommonWebContentsDelegate::OpenURLFromTab(
-    content::WebContents* source,
-    const content::OpenURLParams& params) {
-  content::NavigationController::LoadURLParams load_url_params(params.url);
-  load_url_params.referrer = params.referrer;
-  load_url_params.transition_type = params.transition;
-  load_url_params.extra_headers = params.extra_headers;
-  load_url_params.should_replace_current_entry =
-      params.should_replace_current_entry;
-  load_url_params.is_renderer_initiated = params.is_renderer_initiated;
-  load_url_params.should_clear_history_list = true;
-
-  source->GetController().LoadURLWithParams(load_url_params);
-  return source;
-}
-
-bool CommonWebContentsDelegate::CanOverscrollContent() const {
-  return false;
-}
-
-content::ColorChooser* CommonWebContentsDelegate::OpenColorChooser(
-    content::WebContents* web_contents,
-    SkColor color,
-    const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions) {
-  return chrome::ShowColorChooser(web_contents, color);
-}
-
-void CommonWebContentsDelegate::RunFileChooser(
-    content::RenderFrameHost* render_frame_host,
-    const content::FileChooserParams& params) {
-  if (!web_dialog_helper_)
-    web_dialog_helper_.reset(new WebDialogHelper(owner_window(), offscreen_));
-  web_dialog_helper_->RunFileChooser(render_frame_host, params);
-}
-
-void CommonWebContentsDelegate::EnumerateDirectory(content::WebContents* guest,
-                                                   int request_id,
-                                                   const base::FilePath& path) {
-  if (!web_dialog_helper_)
-    web_dialog_helper_.reset(new WebDialogHelper(owner_window(), offscreen_));
-  web_dialog_helper_->EnumerateDirectory(guest, request_id, path);
-}
-
-void CommonWebContentsDelegate::EnterFullscreenModeForTab(
-    content::WebContents* source,
-    const GURL& origin) {
-  if (!owner_window_)
-    return;
-  SetHtmlApiFullscreen(true);
-  owner_window_->NotifyWindowEnterHtmlFullScreen();
-  source->GetRenderViewHost()->GetWidget()->WasResized();
-}
-
-void CommonWebContentsDelegate::ExitFullscreenModeForTab(
-    content::WebContents* source) {
-  if (!owner_window_)
-    return;
-  SetHtmlApiFullscreen(false);
-  owner_window_->NotifyWindowLeaveHtmlFullScreen();
-  source->GetRenderViewHost()->GetWidget()->WasResized();
-}
-
-bool CommonWebContentsDelegate::IsFullscreenForTabOrPending(
-    const content::WebContents* source) const {
-  return html_fullscreen_;
-}
-
-blink::WebSecurityStyle CommonWebContentsDelegate::GetSecurityStyle(
-    content::WebContents* web_contents,
-    content::SecurityStyleExplanations* security_style_explanations) {
-  SecurityStateTabHelper* helper =
-      SecurityStateTabHelper::FromWebContents(web_contents);
-  DCHECK(helper);
-  security_state::SecurityInfo security_info;
-  helper->GetSecurityInfo(&security_info);
-  return security_state::GetSecurityStyle(security_info,
-                                          security_style_explanations);
-}
-
-void CommonWebContentsDelegate::DevToolsSaveToFile(const std::string& url,
-                                                   const std::string& content,
-                                                   bool save_as) {
-  base::FilePath path;
-  auto it = saved_files_.find(url);
-  if (it != saved_files_.end() && !save_as) {
-    path = it->second;
-  } else {
-    file_dialog::DialogSettings settings;
-    settings.parent_window = owner_window();
-    settings.force_detached = offscreen_;
-    settings.title = url;
-    settings.default_path = base::FilePath::FromUTF8Unsafe(url);
-    if (!file_dialog::ShowSaveDialog(settings, &path)) {
-      base::Value url_value(url);
-      web_contents_->CallClientFunction("DevToolsAPI.canceledSaveURL",
-                                        &url_value, nullptr, nullptr);
-      return;
-    }
-  }
-
-  saved_files_[url] = path;
-  // Notify DevTools.
-  base::Value url_value(url);
-  base::Value file_system_path_value(path.AsUTF8Unsafe());
-  web_contents_->CallClientFunction("DevToolsAPI.savedURL", &url_value,
-                                    &file_system_path_value, nullptr);
-  file_task_runner_->PostTask(FROM_HERE,
-                              base::BindOnce(&WriteToFile, path, content));
-}
-
-void CommonWebContentsDelegate::DevToolsAppendToFile(
-    const std::string& url,
-    const std::string& content) {
-  auto it = saved_files_.find(url);
-  if (it == saved_files_.end())
-    return;
-
-  // Notify DevTools.
-  base::Value url_value(url);
-  web_contents_->CallClientFunction("DevToolsAPI.appendedToURL", &url_value,
-                                    nullptr, nullptr);
-  file_task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&AppendToFile, it->second, content));
-}
-
-void CommonWebContentsDelegate::DevToolsRequestFileSystems() {
-  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
-  if (file_system_paths.empty()) {
-    base::ListValue empty_file_system_value;
-    web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
-                                      &empty_file_system_value, nullptr,
-                                      nullptr);
-    return;
-  }
-
-  std::vector<FileSystem> file_systems;
-  for (const auto& file_system_path : file_system_paths) {
-    base::FilePath path = base::FilePath::FromUTF8Unsafe(file_system_path);
-    std::string file_system_id =
-        RegisterFileSystem(GetDevToolsWebContents(), path);
-    FileSystem file_system = CreateFileSystemStruct(
-        GetDevToolsWebContents(), file_system_id, file_system_path);
-    file_systems.push_back(file_system);
-  }
-
-  base::ListValue file_system_value;
-  for (const auto& file_system : file_systems)
-    file_system_value.Append(CreateFileSystemValue(file_system));
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
-                                    &file_system_value, nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsAddFileSystem(
-    const base::FilePath& file_system_path) {
-  base::FilePath path = file_system_path;
-  if (path.empty()) {
-    std::vector<base::FilePath> paths;
-    file_dialog::DialogSettings settings;
-    settings.parent_window = owner_window();
-    settings.force_detached = offscreen_;
-    settings.properties = file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
-    if (!file_dialog::ShowOpenDialog(settings, &paths))
-      return;
-
-    path = paths[0];
-  }
-
-  std::string file_system_id =
-      RegisterFileSystem(GetDevToolsWebContents(), path);
-  if (IsDevToolsFileSystemAdded(GetDevToolsWebContents(), path.AsUTF8Unsafe()))
-    return;
-
-  FileSystem file_system = CreateFileSystemStruct(
-      GetDevToolsWebContents(), file_system_id, path.AsUTF8Unsafe());
-  std::unique_ptr<base::DictionaryValue> file_system_value(
-      CreateFileSystemValue(file_system));
-
-  auto* pref_service = GetPrefService(GetDevToolsWebContents());
-  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
-  update.Get()->SetWithoutPathExpansion(path.AsUTF8Unsafe(),
-                                        std::make_unique<base::Value>());
-
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemAdded",
-                                    file_system_value.get(), nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsRemoveFileSystem(
-    const base::FilePath& file_system_path) {
-  if (!web_contents_)
-    return;
-
-  std::string path = file_system_path.AsUTF8Unsafe();
-  storage::IsolatedContext::GetInstance()->RevokeFileSystemByPath(
-      file_system_path);
-
-  auto* pref_service = GetPrefService(GetDevToolsWebContents());
-  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
-  update.Get()->RemoveWithoutPathExpansion(path, nullptr);
-
-  base::Value file_system_path_value(path);
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemRemoved",
-                                    &file_system_path_value, nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsIndexPath(
-    int request_id,
-    const std::string& file_system_path) {
-  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {
-    OnDevToolsIndexingDone(request_id, file_system_path);
-    return;
-  }
-  if (devtools_indexing_jobs_.count(request_id) != 0)
-    return;
-  devtools_indexing_jobs_[request_id] =
-      scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>(
-          devtools_file_system_indexer_->IndexPath(
-              file_system_path,
-              base::Bind(
-                  &CommonWebContentsDelegate::OnDevToolsIndexingWorkCalculated,
-                  base::Unretained(this), request_id, file_system_path),
-              base::Bind(&CommonWebContentsDelegate::OnDevToolsIndexingWorked,
-                         base::Unretained(this), request_id, file_system_path),
-              base::Bind(&CommonWebContentsDelegate::OnDevToolsIndexingDone,
-                         base::Unretained(this), request_id,
-                         file_system_path)));
-}
-
-void CommonWebContentsDelegate::DevToolsStopIndexing(int request_id) {
-  auto it = devtools_indexing_jobs_.find(request_id);
-  if (it == devtools_indexing_jobs_.end())
-    return;
-  it->second->Stop();
-  devtools_indexing_jobs_.erase(it);
-}
-
-void CommonWebContentsDelegate::DevToolsSearchInPath(
-    int request_id,
-    const std::string& file_system_path,
-    const std::string& query) {
-  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {
-    OnDevToolsSearchCompleted(request_id, file_system_path,
-                              std::vector<std::string>());
-    return;
-  }
-  devtools_file_system_indexer_->SearchInPath(
-      file_system_path, query,
-      base::Bind(&CommonWebContentsDelegate::OnDevToolsSearchCompleted,
-                 base::Unretained(this), request_id, file_system_path));
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingWorkCalculated(
-    int request_id,
-    const std::string& file_system_path,
-    int total_work) {
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  base::Value total_work_value(total_work);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingTotalWorkCalculated",
-                                    &request_id_value, &file_system_path_value,
-                                    &total_work_value);
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingWorked(
-    int request_id,
-    const std::string& file_system_path,
-    int worked) {
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  base::Value worked_value(worked);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingWorked",
-                                    &request_id_value, &file_system_path_value,
-                                    &worked_value);
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingDone(
-    int request_id,
-    const std::string& file_system_path) {
-  devtools_indexing_jobs_.erase(request_id);
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingDone",
-                                    &request_id_value, &file_system_path_value,
-                                    nullptr);
-}
-
-void CommonWebContentsDelegate::OnDevToolsSearchCompleted(
-    int request_id,
-    const std::string& file_system_path,
-    const std::vector<std::string>& file_paths) {
-  base::ListValue file_paths_value;
-  for (const auto& file_path : file_paths) {
-    file_paths_value.AppendString(file_path);
-  }
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  web_contents_->CallClientFunction("DevToolsAPI.searchCompleted",
-                                    &request_id_value, &file_system_path_value,
-                                    &file_paths_value);
-}
-
-void CommonWebContentsDelegate::SetHtmlApiFullscreen(bool enter_fullscreen) {
-  // Window is already in fullscreen mode, save the state.
-  if (enter_fullscreen && owner_window_->IsFullscreen()) {
-    native_fullscreen_ = true;
-    html_fullscreen_ = true;
-    return;
-  }
-
-  // Exit html fullscreen state but not window's fullscreen mode.
-  if (!enter_fullscreen && native_fullscreen_) {
-    html_fullscreen_ = false;
-    return;
-  }
-
-  owner_window_->SetFullScreen(enter_fullscreen);
-  html_fullscreen_ = enter_fullscreen;
-  native_fullscreen_ = false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 61ff63793df5f1b83155aa56d64a7da6b34fa7da atom/browser/common_web_contents_delegate.h
  our    100644 5da5d20975b8e795e34c9d8c7649f6f0eb3d0a50 atom/browser/common_web_contents_delegate.h
@@ -1,202 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
-#define ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "brightray/browser/devtools_file_system_indexer.h"
-#include "brightray/browser/inspectable_web_contents_delegate.h"
-#include "brightray/browser/inspectable_web_contents_impl.h"
-#include "brightray/browser/inspectable_web_contents_view_delegate.h"
-#include "content/public/browser/web_contents_delegate.h"
-
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-#include "atom/browser/ui/autofill_popup.h"
-#endif
-
-using brightray::DevToolsFileSystemIndexer;
-
-namespace base {
-class SequencedTaskRunner;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-class NativeWindow;
-class WebDialogHelper;
-
-class CommonWebContentsDelegate
-    : public content::WebContentsDelegate,
-      public brightray::InspectableWebContentsDelegate,
-      public brightray::InspectableWebContentsViewDelegate {
- public:
-  CommonWebContentsDelegate();
-  ~CommonWebContentsDelegate() override;
-
-  // Creates a InspectableWebContents object and takes onwership of
-  // |web_contents|.
-  void InitWithWebContents(content::WebContents* web_contents,
-                           AtomBrowserContext* browser_context,
-                           bool is_guest);
-
-  // Set the window as owner window.
-  void SetOwnerWindow(NativeWindow* owner_window);
-  void SetOwnerWindow(content::WebContents* web_contents,
-                      NativeWindow* owner_window);
-
-  // Returns the WebContents managed by this delegate.
-  content::WebContents* GetWebContents() const;
-
-  // Returns the WebContents of devtools.
-  content::WebContents* GetDevToolsWebContents() const;
-
-  brightray::InspectableWebContents* managed_web_contents() const {
-    return web_contents_.get();
-  }
-
-  NativeWindow* owner_window() const { return owner_window_.get(); }
-
-  void set_ignore_menu_shortcuts(bool ignore) {
-    ignore_menu_shortcuts_ = ignore;
-  }
-
-  bool is_html_fullscreen() const { return html_fullscreen_; }
-
- protected:
-  // content::WebContentsDelegate:
-  content::WebContents* OpenURLFromTab(
-      content::WebContents* source,
-      const content::OpenURLParams& params) override;
-  bool CanOverscrollContent() const override;
-  content::ColorChooser* OpenColorChooser(
-      content::WebContents* web_contents,
-      SkColor color,
-      const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions)
-      override;
-  void RunFileChooser(content::RenderFrameHost* render_frame_host,
-                      const content::FileChooserParams& params) override;
-  void EnumerateDirectory(content::WebContents* web_contents,
-                          int request_id,
-                          const base::FilePath& path) override;
-  void EnterFullscreenModeForTab(content::WebContents* source,
-                                 const GURL& origin) override;
-  void ExitFullscreenModeForTab(content::WebContents* source) override;
-  bool IsFullscreenForTabOrPending(
-      const content::WebContents* source) const override;
-  blink::WebSecurityStyle GetSecurityStyle(
-      content::WebContents* web_contents,
-      content::SecurityStyleExplanations* explanations) override;
-  void HandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-
-  // Autofill related events.
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  void ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                         content::RenderFrameHost* embedder_frame_host,
-                         bool offscreen,
-                         const gfx::RectF& bounds,
-                         const std::vector<base::string16>& values,
-                         const std::vector<base::string16>& labels);
-  void HideAutofillPopup();
-#endif
-
-  // brightray::InspectableWebContentsDelegate:
-  void DevToolsSaveToFile(const std::string& url,
-                          const std::string& content,
-                          bool save_as) override;
-  void DevToolsAppendToFile(const std::string& url,
-                            const std::string& content) override;
-  void DevToolsRequestFileSystems() override;
-  void DevToolsAddFileSystem(const base::FilePath& path) override;
-  void DevToolsRemoveFileSystem(
-      const base::FilePath& file_system_path) override;
-  void DevToolsIndexPath(int request_id,
-                         const std::string& file_system_path) override;
-  void DevToolsStopIndexing(int request_id) override;
-  void DevToolsSearchInPath(int request_id,
-                            const std::string& file_system_path,
-                            const std::string& query) override;
-
-  // brightray::InspectableWebContentsViewDelegate:
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  gfx::ImageSkia GetDevToolsWindowIcon() override;
-#endif
-#if defined(USE_X11)
-  void GetDevToolsWindowWMClass(std::string* name,
-                                std::string* class_name) override;
-#endif
-
-  // Destroy the managed InspectableWebContents object.
-  void ResetManagedWebContents(bool async);
-
- private:
-  // DevTools index event callbacks.
-  void OnDevToolsIndexingWorkCalculated(int request_id,
-                                        const std::string& file_system_path,
-                                        int total_work);
-  void OnDevToolsIndexingWorked(int request_id,
-                                const std::string& file_system_path,
-                                int worked);
-  void OnDevToolsIndexingDone(int request_id,
-                              const std::string& file_system_path);
-  void OnDevToolsSearchCompleted(int request_id,
-                                 const std::string& file_system_path,
-                                 const std::vector<std::string>& file_paths);
-
-  // Set fullscreen mode triggered by html api.
-  void SetHtmlApiFullscreen(bool enter_fullscreen);
-
-  // The window that this WebContents belongs to.
-  base::WeakPtr<NativeWindow> owner_window_;
-
-  bool offscreen_ = false;
-  bool ignore_menu_shortcuts_ = false;
-
-  // Whether window is fullscreened by HTML5 api.
-  bool html_fullscreen_ = false;
-
-  // Whether window is fullscreened by window api.
-  bool native_fullscreen_ = false;
-
-  // UI related helper classes.
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  std::unique_ptr<AutofillPopup> autofill_popup_;
-#endif
-  std::unique_ptr<WebDialogHelper> web_dialog_helper_;
-
-  scoped_refptr<DevToolsFileSystemIndexer> devtools_file_system_indexer_;
-
-  // Make sure BrowserContext is alwasys destroyed after WebContents.
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  // The stored InspectableWebContents object.
-  // Notice that web_contents_ must be placed after dialog_manager_, so we can
-  // make sure web_contents_ is destroyed before dialog_manager_, otherwise a
-  // crash would happen.
-  std::unique_ptr<brightray::InspectableWebContents> web_contents_;
-
-  // Maps url to file path, used by the file requests sent from devtools.
-  typedef std::map<std::string, base::FilePath> PathsMap;
-  PathsMap saved_files_;
-
-  // Map id to index job, used for file system indexing requests from devtools.
-  typedef std::
-      map<int, scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>>
-          DevToolsIndexingJobsMap;
-  DevToolsIndexingJobsMap devtools_indexing_jobs_;
-
-  scoped_refptr<base::SequencedTaskRunner> file_task_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(CommonWebContentsDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
removed in remote
  base   100644 970132b47c1513883141989d38743284bbbe597a atom/browser/javascript_environment.cc
  our    100644 ddb689236bdfd958b05f28e5f5cb8c35ad47902a atom/browser/javascript_environment.cc
@@ -1,70 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/javascript_environment.h"
-
-#include <string>
-
-#include "base/command_line.h"
-#include "base/message_loop/message_loop.h"
-#include "base/task_scheduler/initialization_util.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "content/public/common/content_switches.h"
-#include "gin/array_buffer.h"
-#include "gin/v8_initializer.h"
-
-#include "atom/common/node_includes.h"
-#include "tracing/trace_event.h"
-
-namespace atom {
-
-JavascriptEnvironment::JavascriptEnvironment()
-    : initialized_(Initialize()),
-      isolate_holder_(base::ThreadTaskRunnerHandle::Get()),
-      isolate_(isolate_holder_.isolate()),
-      isolate_scope_(isolate_),
-      locker_(isolate_),
-      handle_scope_(isolate_),
-      context_(isolate_, v8::Context::New(isolate_)),
-      context_scope_(v8::Local<v8::Context>::New(isolate_, context_)) {}
-
-JavascriptEnvironment::~JavascriptEnvironment() = default;
-
-void JavascriptEnvironment::OnMessageLoopCreated() {
-  isolate_holder_.AddRunMicrotasksObserver();
-}
-
-void JavascriptEnvironment::OnMessageLoopDestroying() {
-  isolate_holder_.RemoveRunMicrotasksObserver();
-}
-
-bool JavascriptEnvironment::Initialize() {
-  auto* cmd = base::CommandLine::ForCurrentProcess();
-
-  // --js-flags.
-  std::string js_flags = cmd->GetSwitchValueASCII(switches::kJavaScriptFlags);
-  if (!js_flags.empty())
-    v8::V8::SetFlagsFromString(js_flags.c_str(), js_flags.size());
-
-  // The V8Platform of gin relies on Chromium's task schedule, which has not
-  // been started at this point, so we have to rely on Node's V8Platform.
-  platform_ = node::CreatePlatform(
-      base::RecommendedMaxNumberOfThreadsInPool(3, 8, 0.1, 0), nullptr);
-  v8::V8::InitializePlatform(platform_);
-  node::tracing::TraceEventHelper::SetTracingController(
-      new v8::TracingController());
-  gin::IsolateHolder::Initialize(
-      gin::IsolateHolder::kNonStrictMode, gin::IsolateHolder::kStableV8Extras,
-      gin::ArrayBufferAllocator::SharedInstance(),
-      nullptr /* external_reference_table */, false /* create_v8_platform */);
-  return true;
-}
-
-NodeEnvironment::NodeEnvironment(node::Environment* env) : env_(env) {}
-
-NodeEnvironment::~NodeEnvironment() {
-  node::FreeEnvironment(env_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 07cd602cf00dfd35aa03c3ffe821ebd267ff115e atom/browser/javascript_environment.h
  our    100644 bf05b687f8b338f25d37efcef39becd4346cb9e9 atom/browser/javascript_environment.h
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
-#define ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
-
-#include "base/macros.h"
-#include "gin/public/isolate_holder.h"
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-// Manage the V8 isolate and context automatically.
-class JavascriptEnvironment {
- public:
-  JavascriptEnvironment();
-  ~JavascriptEnvironment();
-
-  void OnMessageLoopCreated();
-  void OnMessageLoopDestroying();
-
-  node::MultiIsolatePlatform* platform() const { return platform_; }
-  v8::Isolate* isolate() const { return isolate_; }
-  v8::Local<v8::Context> context() const {
-    return v8::Local<v8::Context>::New(isolate_, context_);
-  }
-
- private:
-  bool Initialize();
-
-  // Leaked on exit.
-  node::MultiIsolatePlatform* platform_;
-
-  bool initialized_;
-  gin::IsolateHolder isolate_holder_;
-  v8::Isolate* isolate_;
-  v8::Isolate::Scope isolate_scope_;
-  v8::Locker locker_;
-  v8::HandleScope handle_scope_;
-  v8::UniquePersistent<v8::Context> context_;
-  v8::Context::Scope context_scope_;
-
-  DISALLOW_COPY_AND_ASSIGN(JavascriptEnvironment);
-};
-
-// Manage the Node Environment automatically.
-class NodeEnvironment {
- public:
-  explicit NodeEnvironment(node::Environment* env);
-  ~NodeEnvironment();
-
- private:
-  node::Environment* env_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeEnvironment);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
removed in remote
  base   100644 7a1a77cc2b1333ccfd56c77b98f8cfa7c5d8631d atom/browser/login_handler.cc
  our    100644 2063c6197fce449d1692f1b067c17e043b1d37e4 atom/browser/login_handler.cc
@@ -1,91 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/login_handler.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/values.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/web_contents.h"
-#include "net/base/auth.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-LoginHandler::LoginHandler(
-    net::URLRequest* request,
-    const net::AuthChallengeInfo& auth_info,
-    const net::NetworkDelegate::AuthCallback& callback,
-    net::AuthCredentials* credentials,
-    const content::ResourceRequestInfo* resource_request_info)
-    : credentials_(credentials),
-      auth_info_(auth_info),
-      auth_callback_(std::move(callback)),
-      weak_factory_(this) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  std::unique_ptr<base::DictionaryValue> request_details(
-      new base::DictionaryValue);
-  FillRequestDetails(request_details.get(), request);
-
-  web_contents_getter_ =
-      resource_request_info->GetWebContentsGetterForRequest();
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(&Browser::RequestLogin, base::Unretained(Browser::Get()),
-                     base::RetainedRef(this), std::move(request_details)));
-}
-
-LoginHandler::~LoginHandler() {}
-
-void LoginHandler::Login(const base::string16& username,
-                         const base::string16& password) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&LoginHandler::DoLogin, weak_factory_.GetWeakPtr(),
-                     username, password));
-}
-
-void LoginHandler::CancelAuth() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&LoginHandler::DoCancelAuth, weak_factory_.GetWeakPtr()));
-}
-
-void LoginHandler::NotifyRequestDestroyed() {
-  auth_callback_.Reset();
-  credentials_ = nullptr;
-  weak_factory_.InvalidateWeakPtrs();
-}
-
-content::WebContents* LoginHandler::GetWebContents() const {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  return web_contents_getter_.Run();
-}
-
-void LoginHandler::DoCancelAuth() {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  if (!auth_callback_.is_null())
-    std::move(auth_callback_)
-        .Run(net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_CANCEL_AUTH);
-}
-
-void LoginHandler::DoLogin(const base::string16& username,
-                           const base::string16& password) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  if (!auth_callback_.is_null()) {
-    credentials_->Set(username, password);
-    std::move(auth_callback_)
-        .Run(net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_SET_AUTH);
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 52ec1abf5b1a8e5353dd294b946275dc229ef6ab atom/browser/login_handler.h
  our    100644 e7f1c5be0094506e01d2cccc0073fa864dfefb56 atom/browser/login_handler.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_LOGIN_HANDLER_H_
-#define ATOM_BROWSER_LOGIN_HANDLER_H_
-
-#include "base/callback.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "base/strings/string16.h"
-#include "content/public/browser/resource_request_info.h"
-#include "net/base/network_delegate.h"
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-// Handles the HTTP basic auth, must be created on IO thread.
-class LoginHandler : public base::RefCountedThreadSafe<LoginHandler> {
- public:
-  LoginHandler(net::URLRequest* request,
-               const net::AuthChallengeInfo& auth_info,
-               const net::NetworkDelegate::AuthCallback& callback,
-               net::AuthCredentials* credentials,
-               const content::ResourceRequestInfo* resource_request_info);
-
-  // The auth is cancelled, must be called on UI thread.
-  void CancelAuth();
-
-  // The URLRequest associated with the auth is destroyed.
-  void NotifyRequestDestroyed();
-
-  // Login with |username| and |password|, must be called on UI thread.
-  void Login(const base::string16& username, const base::string16& password);
-
-  // Returns the WebContents associated with the request, must be called on UI
-  // thread.
-  content::WebContents* GetWebContents() const;
-
-  const net::AuthChallengeInfo* auth_info() const { return &auth_info_; }
-
- private:
-  friend class base::RefCountedThreadSafe<LoginHandler>;
-  friend class base::DeleteHelper<LoginHandler>;
-
-  ~LoginHandler();
-
-  // Must be called on IO thread.
-  void DoCancelAuth();
-  void DoLogin(const base::string16& username, const base::string16& password);
-
-  // Credentials to be used for the auth.
-  net::AuthCredentials* credentials_;
-
-  // Who/where/what asked for the authentication.
-  const net::AuthChallengeInfo& auth_info_;
-
-  // WebContents associated with the login request.
-  content::ResourceRequestInfo::WebContentsGetter web_contents_getter_;
-
-  // Called with preferred value of net::NetworkDelegate::AuthRequiredResponse.
-  net::NetworkDelegate::AuthCallback auth_callback_;
-
-  base::WeakPtrFactory<LoginHandler> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(LoginHandler);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_LOGIN_HANDLER_H_
removed in remote
  base   100644 9fafb054b09abce8b3ef6a4af1f778c80d919f3d atom/browser/mac/atom_application.h
  our    100644 b0a8742ee98bc4990bf38a25218e87e386f115e0 atom/browser/mac/atom_application.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/mac/scoped_sending_event.h"
-
-@interface AtomApplication : NSApplication <CrAppProtocol,
-                                            CrAppControlProtocol,
-                                            NSUserActivityDelegate> {
- @private
-  BOOL handlingSendEvent_;
-  base::scoped_nsobject<NSUserActivity> currentActivity_ API_AVAILABLE(macosx(10.10));
-  NSCondition* handoffLock_;
-  BOOL updateReceived_;
-  base::Callback<bool()> shouldShutdown_;
-}
-
-+ (AtomApplication*)sharedApplication;
-
-- (void)setShutdownHandler:(base::Callback<bool()>)handler;
-
-// CrAppProtocol:
-- (BOOL)isHandlingSendEvent;
-
-// CrAppControlProtocol:
-- (void)setHandlingSendEvent:(BOOL)handlingSendEvent;
-
-- (NSUserActivity*)getCurrentActivity API_AVAILABLE(macosx(10.10));
-- (void)setCurrentActivity:(NSString*)type
-              withUserInfo:(NSDictionary*)userInfo
-            withWebpageURL:(NSURL*)webpageURL;
-- (void)invalidateCurrentActivity;
-- (void)updateCurrentActivity:(NSString*)type
-                 withUserInfo:(NSDictionary*)userInfo;
-
-@end
removed in remote
  base   100644 cc9c6accc83dcb7260413fcc9a1184368724a3fa atom/browser/mac/atom_application.mm
  our    100644 eb00a415bf243853a78b3c4e4eafa66905a2ccf3 atom/browser/mac/atom_application.mm
@@ -1,191 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/mac/atom_application.h"
-
-#include "atom/browser/browser.h"
-#import "atom/browser/mac/atom_application_delegate.h"
-#include "atom/browser/mac/dict_util.h"
-#include "base/auto_reset.h"
-#include "base/strings/sys_string_conversions.h"
-#include "content/public/browser/browser_accessibility_state.h"
-
-namespace {
-
-inline void dispatch_sync_main(dispatch_block_t block) {
-  if ([NSThread isMainThread])
-    block();
-  else
-    dispatch_sync(dispatch_get_main_queue(), block);
-}
-
-}  // namespace
-
-@implementation AtomApplication
-
-+ (AtomApplication*)sharedApplication {
-  return (AtomApplication*)[super sharedApplication];
-}
-
-- (void)terminate:(id)sender {
-  if (shouldShutdown_ && !shouldShutdown_.Run())
-    return;  // User will call Quit later.
-
-  // We simply try to close the browser, which in turn will try to close the
-  // windows. Termination can proceed if all windows are closed or window close
-  // can be cancelled which will abort termination.
-  atom::Browser::Get()->Quit();
-}
-
-- (void)setShutdownHandler:(base::Callback<bool()>)handler {
-  shouldShutdown_ = std::move(handler);
-}
-
-- (BOOL)isHandlingSendEvent {
-  return handlingSendEvent_;
-}
-
-- (void)sendEvent:(NSEvent*)event {
-  base::AutoReset<BOOL> scoper(&handlingSendEvent_, YES);
-  [super sendEvent:event];
-}
-
-- (void)setHandlingSendEvent:(BOOL)handlingSendEvent {
-  handlingSendEvent_ = handlingSendEvent;
-}
-
-- (void)setCurrentActivity:(NSString*)type
-              withUserInfo:(NSDictionary*)userInfo
-            withWebpageURL:(NSURL*)webpageURL {
-  if (@available(macOS 10.10, *)) {
-    currentActivity_ = base::scoped_nsobject<NSUserActivity>(
-        [[NSUserActivity alloc] initWithActivityType:type]);
-    [currentActivity_ setUserInfo:userInfo];
-    [currentActivity_ setWebpageURL:webpageURL];
-    [currentActivity_ setDelegate:self];
-    [currentActivity_ becomeCurrent];
-    [currentActivity_ setNeedsSave:YES];
-  }
-}
-
-- (NSUserActivity*)getCurrentActivity {
-  return currentActivity_.get();
-}
-
-- (void)invalidateCurrentActivity {
-  if (currentActivity_) {
-    [currentActivity_ invalidate];
-    currentActivity_.reset();
-  }
-}
-
-- (void)updateCurrentActivity:(NSString*)type
-                 withUserInfo:(NSDictionary*)userInfo {
-  if (currentActivity_) {
-    [currentActivity_ addUserInfoEntriesFromDictionary:userInfo];
-  }
-
-  [handoffLock_ lock];
-  updateReceived_ = YES;
-  [handoffLock_ signal];
-  [handoffLock_ unlock];
-}
-
-- (void)userActivityWillSave:(NSUserActivity*)userActivity
-    API_AVAILABLE(macosx(10.10)) {
-  __block BOOL shouldWait = NO;
-  dispatch_sync_main(^{
-    std::string activity_type(
-        base::SysNSStringToUTF8(userActivity.activityType));
-    std::unique_ptr<base::DictionaryValue> user_info =
-        atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-
-    atom::Browser* browser = atom::Browser::Get();
-    shouldWait =
-        browser->UpdateUserActivityState(activity_type, *user_info) ? YES : NO;
-  });
-
-  if (shouldWait) {
-    [handoffLock_ lock];
-    updateReceived_ = NO;
-    while (!updateReceived_) {
-      BOOL isSignaled =
-          [handoffLock_ waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
-      if (!isSignaled)
-        break;
-    }
-    [handoffLock_ unlock];
-  }
-
-  [userActivity setNeedsSave:YES];
-}
-
-- (void)userActivityWasContinued:(NSUserActivity*)userActivity
-    API_AVAILABLE(macosx(10.10)) {
-  dispatch_async(dispatch_get_main_queue(), ^{
-    std::string activity_type(
-        base::SysNSStringToUTF8(userActivity.activityType));
-    std::unique_ptr<base::DictionaryValue> user_info =
-        atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-
-    atom::Browser* browser = atom::Browser::Get();
-    browser->UserActivityWasContinued(activity_type, *user_info);
-  });
-  [userActivity setNeedsSave:YES];
-}
-
-- (void)awakeFromNib {
-  [[NSAppleEventManager sharedAppleEventManager]
-      setEventHandler:self
-          andSelector:@selector(handleURLEvent:withReplyEvent:)
-        forEventClass:kInternetEventClass
-           andEventID:kAEGetURL];
-
-  handoffLock_ = [NSCondition new];
-}
-
-- (void)handleURLEvent:(NSAppleEventDescriptor*)event
-        withReplyEvent:(NSAppleEventDescriptor*)replyEvent {
-  NSString* url =
-      [[event paramDescriptorForKeyword:keyDirectObject] stringValue];
-  atom::Browser::Get()->OpenURL(base::SysNSStringToUTF8(url));
-}
-
-- (bool)voiceOverEnabled {
-  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
-  [defaults addSuiteNamed:@"com.apple.universalaccess"];
-  [defaults synchronize];
-
-  return [defaults boolForKey:@"voiceOverOnOffKey"];
-}
-
-- (void)accessibilitySetValue:(id)value forAttribute:(NSString*)attribute {
-  // Undocumented attribute that VoiceOver happens to set while running.
-  // Chromium uses this too, even though it's not exactly right.
-  if ([attribute isEqualToString:@"AXEnhancedUserInterface"]) {
-    bool enableAccessibility = ([self voiceOverEnabled] && [value boolValue]);
-    [self updateAccessibilityEnabled:enableAccessibility];
-  } else if ([attribute isEqualToString:@"AXManualAccessibility"]) {
-    [self updateAccessibilityEnabled:[value boolValue]];
-  }
-  return [super accessibilitySetValue:value forAttribute:attribute];
-}
-
-- (void)updateAccessibilityEnabled:(BOOL)enabled {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-
-  if (enabled) {
-    ax_state->OnScreenReaderDetected();
-  } else {
-    ax_state->DisableAccessibility();
-  }
-
-  atom::Browser::Get()->OnAccessibilitySupportChanged();
-}
-
-- (void)orderFrontStandardAboutPanel:(id)sender {
-  atom::Browser::Get()->ShowAboutPanel();
-}
-
-@end
removed in remote
  base   100644 3e5c59c3ff3dd287f94837de14391d7d6fb56b79 atom/browser/mac/atom_application_delegate.h
  our    100644 835b63f8308e93353ee39a4c249824dfda9cb62c atom/browser/mac/atom_application_delegate.h
@@ -1,17 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import <Cocoa/Cocoa.h>
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-@interface AtomApplicationDelegate : NSObject <NSApplicationDelegate> {
- @private
-  base::scoped_nsobject<AtomMenuController> menu_controller_;
-}
-
-// Sets the menu that will be returned in "applicationDockMenu:".
-- (void)setApplicationDockMenu:(atom::AtomMenuModel*)model;
-
-@end
removed in remote
  base   100644 f4db929bf575e88575e38d08d9961e1b02ef05dc atom/browser/mac/atom_application_delegate.mm
  our    100644 683f7a84bcaa2c47bb78cf299314a5afeb15639b atom/browser/mac/atom_application_delegate.mm
@@ -1,136 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/mac/atom_application_delegate.h"
-
-#include "atom/browser/browser.h"
-#import "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/dict_util.h"
-#include "base/allocator/allocator_shim.h"
-#include "base/allocator/buildflags.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_objc_class_swizzler.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/values.h"
-
-#if BUILDFLAG(USE_ALLOCATOR_SHIM)
-// On macOS 10.12, the IME system attempts to allocate a 2^64 size buffer,
-// which would typically cause an OOM crash. To avoid this, the problematic
-// method is swizzled out and the make-OOM-fatal bit is disabled for the
-// duration of the original call. https://crbug.com/654695
-static base::mac::ScopedObjCClassSwizzler* g_swizzle_imk_input_session;
-@interface OOMDisabledIMKInputSession : NSObject
-@end
-@implementation OOMDisabledIMKInputSession
-- (void)_coreAttributesFromRange:(NSRange)range
-                 whichAttributes:(long long)attributes
-               completionHandler:(void (^)(void))block {
-  // The allocator flag is per-process, so other threads may temporarily
-  // not have fatal OOM occur while this method executes, but it is better
-  // than crashing when using IME.
-  base::allocator::SetCallNewHandlerOnMallocFailure(false);
-  g_swizzle_imk_input_session->GetOriginalImplementation()(self, _cmd, range,
-                                                           attributes, block);
-  base::allocator::SetCallNewHandlerOnMallocFailure(true);
-}
-@end
-#endif  // BUILDFLAG(USE_ALLOCATOR_SHIM)
-
-@implementation AtomApplicationDelegate
-
-- (void)setApplicationDockMenu:(atom::AtomMenuModel*)model {
-  menu_controller_.reset([[AtomMenuController alloc] initWithModel:model
-                                             useDefaultAccelerator:NO]);
-}
-
-- (void)applicationWillFinishLaunching:(NSNotification*)notify {
-  // Don't add the "Enter Full Screen" menu item automatically.
-  [[NSUserDefaults standardUserDefaults]
-      setBool:NO
-       forKey:@"NSFullScreenMenuItemEverywhere"];
-
-  atom::Browser::Get()->WillFinishLaunching();
-}
-
-- (void)applicationDidFinishLaunching:(NSNotification*)notify {
-  NSUserNotification* user_notification =
-      [notify userInfo][(id) @"NSApplicationLaunchUserNotificationKey"];
-
-  if (user_notification.userInfo != nil) {
-    std::unique_ptr<base::DictionaryValue> launch_info =
-        atom::NSDictionaryToDictionaryValue(user_notification.userInfo);
-    atom::Browser::Get()->DidFinishLaunching(*launch_info);
-  } else {
-    atom::Browser::Get()->DidFinishLaunching(base::DictionaryValue());
-  }
-
-#if BUILDFLAG(USE_ALLOCATOR_SHIM)
-  // Disable fatal OOM to hack around an OS bug https://crbug.com/654695.
-  if (base::mac::IsOS10_12()) {
-    g_swizzle_imk_input_session = new base::mac::ScopedObjCClassSwizzler(
-        NSClassFromString(@"IMKInputSession"),
-        [OOMDisabledIMKInputSession class],
-        @selector(_coreAttributesFromRange:whichAttributes:completionHandler:));
-  }
-#endif
-}
-
-- (NSMenu*)applicationDockMenu:(NSApplication*)sender {
-  if (menu_controller_)
-    return [menu_controller_ menu];
-  else
-    return nil;
-}
-
-- (BOOL)application:(NSApplication*)sender openFile:(NSString*)filename {
-  std::string filename_str(base::SysNSStringToUTF8(filename));
-  return atom::Browser::Get()->OpenFile(filename_str) ? YES : NO;
-}
-
-- (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
-                    hasVisibleWindows:(BOOL)flag {
-  atom::Browser* browser = atom::Browser::Get();
-  browser->Activate(static_cast<bool>(flag));
-  return flag;
-}
-
-- (BOOL)application:(NSApplication*)sender
-    continueUserActivity:(NSUserActivity*)userActivity
-      restorationHandler:
-          (void (^)(NSArray* restorableObjects))restorationHandler
-    API_AVAILABLE(macosx(10.10)) {
-  std::string activity_type(base::SysNSStringToUTF8(userActivity.activityType));
-  std::unique_ptr<base::DictionaryValue> user_info =
-      atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-  if (!user_info)
-    return NO;
-
-  atom::Browser* browser = atom::Browser::Get();
-  return browser->ContinueUserActivity(activity_type, *user_info) ? YES : NO;
-}
-
-- (BOOL)application:(NSApplication*)application
-    willContinueUserActivityWithType:(NSString*)userActivityType {
-  std::string activity_type(base::SysNSStringToUTF8(userActivityType));
-
-  atom::Browser* browser = atom::Browser::Get();
-  return browser->WillContinueUserActivity(activity_type) ? YES : NO;
-}
-
-- (void)application:(NSApplication*)application
-    didFailToContinueUserActivityWithType:(NSString*)userActivityType
-                                    error:(NSError*)error {
-  std::string activity_type(base::SysNSStringToUTF8(userActivityType));
-  std::string error_message(
-      base::SysNSStringToUTF8([error localizedDescription]));
-
-  atom::Browser* browser = atom::Browser::Get();
-  browser->DidFailToContinueUserActivity(activity_type, error_message);
-}
-
-- (IBAction)newWindowForTab:(id)sender {
-  atom::Browser::Get()->NewWindowForTab();
-}
-
-@end
removed in remote
  base   100644 2627c704d21fef9df262d4062deaef12650f21f6 atom/browser/native_window.cc
  our    100644 4ff2bcfcabfd34d8563f9ed213c03655a99dd9c6 atom/browser/native_window.cc
@@ -1,567 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window.h"
-
-#include <algorithm>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/color_util.h"
-#include "atom/common/options_switches.h"
-#include "native_mate/dictionary.h"
-#include "ui/views/widget/widget.h"
-
-#if defined(OS_WIN)
-#include "ui/base/win/shell.h"
-#include "ui/display/win/screen_win.h"
-#endif
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::NativeWindowRelay);
-
-namespace atom {
-
-namespace {
-
-#if defined(OS_WIN)
-gfx::Size GetExpandedWindowSize(const NativeWindow* window, gfx::Size size) {
-  if (!window->transparent() || !ui::win::IsAeroGlassEnabled())
-    return size;
-
-  gfx::Size min_size = display::win::ScreenWin::ScreenToDIPSize(
-      window->GetAcceleratedWidget(), gfx::Size(64, 64));
-
-  // Some AMD drivers can't display windows that are less than 64x64 pixels,
-  // so expand them to be at least that size. http://crbug.com/286609
-  gfx::Size expanded(std::max(size.width(), min_size.width()),
-                     std::max(size.height(), min_size.height()));
-  return expanded;
-}
-#endif
-
-}  // namespace
-
-NativeWindow::NativeWindow(const mate::Dictionary& options,
-                           NativeWindow* parent)
-    : widget_(new views::Widget), parent_(parent), weak_factory_(this) {
-  options.Get(options::kFrame, &has_frame_);
-  options.Get(options::kTransparent, &transparent_);
-  options.Get(options::kEnableLargerThanScreen, &enable_larger_than_screen_);
-
-  if (parent)
-    options.Get("modal", &is_modal_);
-
-  WindowList::AddWindow(this);
-}
-
-NativeWindow::~NativeWindow() {
-  // It's possible that the windows gets destroyed before it's closed, in that
-  // case we need to ensure the OnWindowClosed message is still notified.
-  NotifyWindowClosed();
-}
-
-void NativeWindow::InitFromOptions(const mate::Dictionary& options) {
-  // Setup window from options.
-  int x = -1, y = -1;
-  bool center;
-  if (options.Get(options::kX, &x) && options.Get(options::kY, &y)) {
-    SetPosition(gfx::Point(x, y));
-
-#if defined(OS_WIN)
-    // FIXME(felixrieseberg): Dirty, dirty workaround for
-    // https://github.com/electron/electron/issues/10862
-    // Somehow, we need to call `SetBounds` twice to get
-    // usable results. The root cause is still unknown.
-    SetPosition(gfx::Point(x, y));
-#endif
-  } else if (options.Get(options::kCenter, &center) && center) {
-    Center();
-  }
-  // On Linux and Window we may already have maximum size defined.
-  extensions::SizeConstraints size_constraints(GetContentSizeConstraints());
-  int min_height = 0, min_width = 0;
-  if (options.Get(options::kMinHeight, &min_height) |
-      options.Get(options::kMinWidth, &min_width)) {
-    size_constraints.set_minimum_size(gfx::Size(min_width, min_height));
-  }
-  int max_height = INT_MAX, max_width = INT_MAX;
-  if (options.Get(options::kMaxHeight, &max_height) |
-      options.Get(options::kMaxWidth, &max_width)) {
-    size_constraints.set_maximum_size(gfx::Size(max_width, max_height));
-  }
-  bool use_content_size = false;
-  options.Get(options::kUseContentSize, &use_content_size);
-  if (use_content_size) {
-    SetContentSizeConstraints(size_constraints);
-  } else {
-    SetSizeConstraints(size_constraints);
-  }
-#if defined(OS_WIN) || defined(USE_X11)
-  bool resizable;
-  if (options.Get(options::kResizable, &resizable)) {
-    SetResizable(resizable);
-  }
-  bool closable;
-  if (options.Get(options::kClosable, &closable)) {
-    SetClosable(closable);
-  }
-#endif
-  bool movable;
-  if (options.Get(options::kMovable, &movable)) {
-    SetMovable(movable);
-  }
-  bool has_shadow;
-  if (options.Get(options::kHasShadow, &has_shadow)) {
-    SetHasShadow(has_shadow);
-  }
-  double opacity;
-  if (options.Get(options::kOpacity, &opacity)) {
-    SetOpacity(opacity);
-  }
-  bool top;
-  if (options.Get(options::kAlwaysOnTop, &top) && top) {
-    SetAlwaysOnTop(true);
-  }
-  bool fullscreenable = true;
-  bool fullscreen = false;
-  if (options.Get(options::kFullscreen, &fullscreen) && !fullscreen) {
-    // Disable fullscreen button if 'fullscreen' is specified to false.
-#if defined(OS_MACOSX)
-    fullscreenable = false;
-#endif
-  }
-  // Overriden by 'fullscreenable'.
-  options.Get(options::kFullScreenable, &fullscreenable);
-  SetFullScreenable(fullscreenable);
-  if (fullscreen) {
-    SetFullScreen(true);
-  }
-  bool skip;
-  if (options.Get(options::kSkipTaskbar, &skip)) {
-    SetSkipTaskbar(skip);
-  }
-  bool kiosk;
-  if (options.Get(options::kKiosk, &kiosk) && kiosk) {
-    SetKiosk(kiosk);
-  }
-#if defined(OS_MACOSX)
-  std::string type;
-  if (options.Get(options::kVibrancyType, &type)) {
-    SetVibrancy(type);
-  }
-#endif
-  std::string color;
-  if (options.Get(options::kBackgroundColor, &color)) {
-    SetBackgroundColor(ParseHexColor(color));
-  } else if (!transparent()) {
-    // For normal window, use white as default background.
-    SetBackgroundColor(SK_ColorWHITE);
-  }
-  std::string title(Browser::Get()->GetName());
-  options.Get(options::kTitle, &title);
-  SetTitle(title);
-
-  // Then show it.
-  bool show = true;
-  options.Get(options::kShow, &show);
-  if (show)
-    Show();
-}
-
-bool NativeWindow::IsClosed() const {
-  return is_closed_;
-}
-
-void NativeWindow::SetSize(const gfx::Size& size, bool animate) {
-  SetBounds(gfx::Rect(GetPosition(), size), animate);
-}
-
-gfx::Size NativeWindow::GetSize() {
-  return GetBounds().size();
-}
-
-void NativeWindow::SetPosition(const gfx::Point& position, bool animate) {
-  SetBounds(gfx::Rect(position, GetSize()), animate);
-}
-
-gfx::Point NativeWindow::GetPosition() {
-  return GetBounds().origin();
-}
-
-void NativeWindow::SetContentSize(const gfx::Size& size, bool animate) {
-  SetSize(ContentBoundsToWindowBounds(gfx::Rect(size)).size(), animate);
-}
-
-gfx::Size NativeWindow::GetContentSize() {
-  return GetContentBounds().size();
-}
-
-void NativeWindow::SetContentBounds(const gfx::Rect& bounds, bool animate) {
-  SetBounds(ContentBoundsToWindowBounds(bounds), animate);
-}
-
-gfx::Rect NativeWindow::GetContentBounds() {
-  return WindowBoundsToContentBounds(GetBounds());
-}
-
-void NativeWindow::SetSizeConstraints(
-    const extensions::SizeConstraints& window_constraints) {
-  extensions::SizeConstraints content_constraints(GetContentSizeConstraints());
-  if (window_constraints.HasMaximumSize()) {
-    gfx::Rect max_bounds = WindowBoundsToContentBounds(
-        gfx::Rect(window_constraints.GetMaximumSize()));
-    content_constraints.set_maximum_size(max_bounds.size());
-  }
-  if (window_constraints.HasMinimumSize()) {
-    gfx::Rect min_bounds = WindowBoundsToContentBounds(
-        gfx::Rect(window_constraints.GetMinimumSize()));
-    content_constraints.set_minimum_size(min_bounds.size());
-  }
-  SetContentSizeConstraints(content_constraints);
-}
-
-extensions::SizeConstraints NativeWindow::GetSizeConstraints() const {
-  extensions::SizeConstraints content_constraints = GetContentSizeConstraints();
-  extensions::SizeConstraints window_constraints;
-  if (content_constraints.HasMaximumSize()) {
-    gfx::Rect max_bounds = ContentBoundsToWindowBounds(
-        gfx::Rect(content_constraints.GetMaximumSize()));
-    window_constraints.set_maximum_size(max_bounds.size());
-  }
-  if (content_constraints.HasMinimumSize()) {
-    gfx::Rect min_bounds = ContentBoundsToWindowBounds(
-        gfx::Rect(content_constraints.GetMinimumSize()));
-    window_constraints.set_minimum_size(min_bounds.size());
-  }
-  return window_constraints;
-}
-
-void NativeWindow::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  size_constraints_ = size_constraints;
-}
-
-extensions::SizeConstraints NativeWindow::GetContentSizeConstraints() const {
-  return size_constraints_;
-}
-
-void NativeWindow::SetMinimumSize(const gfx::Size& size) {
-  extensions::SizeConstraints size_constraints;
-  size_constraints.set_minimum_size(size);
-  SetSizeConstraints(size_constraints);
-}
-
-gfx::Size NativeWindow::GetMinimumSize() const {
-  return GetSizeConstraints().GetMinimumSize();
-}
-
-void NativeWindow::SetMaximumSize(const gfx::Size& size) {
-  extensions::SizeConstraints size_constraints;
-  size_constraints.set_maximum_size(size);
-  SetSizeConstraints(size_constraints);
-}
-
-gfx::Size NativeWindow::GetMaximumSize() const {
-  return GetSizeConstraints().GetMaximumSize();
-}
-
-gfx::Size NativeWindow::GetContentMinimumSize() const {
-  return GetContentSizeConstraints().GetMinimumSize();
-}
-
-gfx::Size NativeWindow::GetContentMaximumSize() const {
-  gfx::Size maximum_size = GetContentSizeConstraints().GetMaximumSize();
-#if defined(OS_WIN)
-  return GetContentSizeConstraints().HasMaximumSize()
-             ? GetExpandedWindowSize(this, maximum_size)
-             : maximum_size;
-#else
-  return maximum_size;
-#endif
-}
-
-void NativeWindow::SetSheetOffset(const double offsetX, const double offsetY) {
-  sheet_offset_x_ = offsetX;
-  sheet_offset_y_ = offsetY;
-}
-
-double NativeWindow::GetSheetOffsetX() {
-  return sheet_offset_x_;
-}
-
-double NativeWindow::GetSheetOffsetY() {
-  return sheet_offset_y_;
-}
-
-void NativeWindow::SetRepresentedFilename(const std::string& filename) {}
-
-std::string NativeWindow::GetRepresentedFilename() {
-  return "";
-}
-
-void NativeWindow::SetDocumentEdited(bool edited) {}
-
-bool NativeWindow::IsDocumentEdited() {
-  return false;
-}
-
-void NativeWindow::SetFocusable(bool focusable) {}
-
-void NativeWindow::SetMenu(AtomMenuModel* menu) {}
-
-void NativeWindow::SetParentWindow(NativeWindow* parent) {
-  parent_ = parent;
-}
-
-void NativeWindow::SetAutoHideCursor(bool auto_hide) {}
-
-void NativeWindow::SelectPreviousTab() {}
-
-void NativeWindow::SelectNextTab() {}
-
-void NativeWindow::MergeAllWindows() {}
-
-void NativeWindow::MoveTabToNewWindow() {}
-
-void NativeWindow::ToggleTabBar() {}
-
-bool NativeWindow::AddTabbedWindow(NativeWindow* window) {
-  return true;  // for non-Mac platforms
-}
-
-void NativeWindow::SetVibrancy(const std::string& filename) {}
-
-void NativeWindow::SetTouchBar(
-    const std::vector<mate::PersistentDictionary>& items) {}
-
-void NativeWindow::RefreshTouchBarItem(const std::string& item_id) {}
-
-void NativeWindow::SetEscapeTouchBarItem(
-    const mate::PersistentDictionary& item) {}
-
-void NativeWindow::SetAutoHideMenuBar(bool auto_hide) {}
-
-bool NativeWindow::IsMenuBarAutoHide() {
-  return false;
-}
-
-void NativeWindow::SetMenuBarVisibility(bool visible) {}
-
-bool NativeWindow::IsMenuBarVisible() {
-  return true;
-}
-
-bool NativeWindow::SetWindowButtonVisibility(bool visible) {
-  return false;
-}
-
-double NativeWindow::GetAspectRatio() {
-  return aspect_ratio_;
-}
-
-gfx::Size NativeWindow::GetAspectRatioExtraSize() {
-  return aspect_ratio_extraSize_;
-}
-
-void NativeWindow::SetAspectRatio(double aspect_ratio,
-                                  const gfx::Size& extra_size) {
-  aspect_ratio_ = aspect_ratio;
-  aspect_ratio_extraSize_ = extra_size;
-}
-
-void NativeWindow::PreviewFile(const std::string& path,
-                               const std::string& display_name) {}
-
-void NativeWindow::CloseFilePreview() {}
-
-void NativeWindow::NotifyWindowRequestPreferredWith(int* width) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.RequestPreferredWidth(width);
-}
-
-void NativeWindow::NotifyWindowCloseButtonClicked() {
-  // First ask the observers whether we want to close.
-  bool prevent_default = false;
-  for (NativeWindowObserver& observer : observers_)
-    observer.WillCloseWindow(&prevent_default);
-  if (prevent_default) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  // Then ask the observers how should we close the window.
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnCloseButtonClicked(&prevent_default);
-  if (prevent_default)
-    return;
-
-  CloseImmediately();
-}
-
-void NativeWindow::NotifyWindowClosed() {
-  if (is_closed_)
-    return;
-
-  WindowList::RemoveWindow(this);
-
-  is_closed_ = true;
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowClosed();
-}
-
-void NativeWindow::NotifyWindowEndSession() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEndSession();
-}
-
-void NativeWindow::NotifyWindowBlur() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowBlur();
-}
-
-void NativeWindow::NotifyWindowFocus() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowFocus();
-}
-
-void NativeWindow::NotifyWindowShow() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowShow();
-}
-
-void NativeWindow::NotifyWindowHide() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowHide();
-}
-
-void NativeWindow::NotifyWindowMaximize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMaximize();
-}
-
-void NativeWindow::NotifyWindowUnmaximize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowUnmaximize();
-}
-
-void NativeWindow::NotifyWindowMinimize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMinimize();
-}
-
-void NativeWindow::NotifyWindowRestore() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowRestore();
-}
-
-void NativeWindow::NotifyWindowWillResize(const gfx::Rect& new_bounds,
-                                          bool* prevent_default) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowWillResize(new_bounds, prevent_default);
-}
-
-void NativeWindow::NotifyWindowResize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowResize();
-}
-
-void NativeWindow::NotifyWindowMove() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMove();
-}
-
-void NativeWindow::NotifyWindowMoved() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMoved();
-}
-
-void NativeWindow::NotifyWindowEnterFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEnterFullScreen();
-}
-
-void NativeWindow::NotifyWindowScrollTouchBegin() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowScrollTouchBegin();
-}
-
-void NativeWindow::NotifyWindowScrollTouchEnd() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowScrollTouchEnd();
-}
-
-void NativeWindow::NotifyWindowSwipe(const std::string& direction) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSwipe(direction);
-}
-
-void NativeWindow::NotifyWindowSheetBegin() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSheetBegin();
-}
-
-void NativeWindow::NotifyWindowSheetEnd() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSheetEnd();
-}
-
-void NativeWindow::NotifyWindowLeaveFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowLeaveFullScreen();
-}
-
-void NativeWindow::NotifyWindowEnterHtmlFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEnterHtmlFullScreen();
-}
-
-void NativeWindow::NotifyWindowLeaveHtmlFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowLeaveHtmlFullScreen();
-}
-
-void NativeWindow::NotifyWindowExecuteWindowsCommand(
-    const std::string& command) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnExecuteWindowsCommand(command);
-}
-
-void NativeWindow::NotifyTouchBarItemInteraction(
-    const std::string& item_id,
-    const base::DictionaryValue& details) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnTouchBarItemResult(item_id, details);
-}
-
-void NativeWindow::NotifyNewWindowForTab() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnNewWindowForTab();
-}
-
-#if defined(OS_WIN)
-void NativeWindow::NotifyWindowMessage(UINT message,
-                                       WPARAM w_param,
-                                       LPARAM l_param) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMessage(message, w_param, l_param);
-}
-#endif
-
-views::Widget* NativeWindow::GetWidget() {
-  return widget();
-}
-
-const views::Widget* NativeWindow::GetWidget() const {
-  return widget();
-}
-
-NativeWindowRelay::NativeWindowRelay(base::WeakPtr<NativeWindow> window)
-    : key(UserDataKey()), window(window) {}
-
-NativeWindowRelay::~NativeWindowRelay() = default;
-
-}  // namespace atom
removed in remote
  base   100644 49e1e71d5df685a2ccafba51dcc395534d2f34bd atom/browser/native_window.h
  our    100644 35b67e2dd230692c415a32aae5f0a5e99ab74ac0 atom/browser/native_window.h
@@ -1,359 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_H_
-
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window_observer.h"
-#include "base/memory/weak_ptr.h"
-#include "base/observer_list.h"
-#include "base/supports_user_data.h"
-#include "content/public/browser/web_contents_user_data.h"
-#include "extensions/browser/app_window/size_constraints.h"
-#include "ui/views/widget/widget_delegate.h"
-
-class SkRegion;
-
-namespace content {
-struct NativeWebKeyboardEvent;
-}
-
-namespace gfx {
-class Image;
-class Point;
-class Rect;
-class RectF;
-class Size;
-}  // namespace gfx
-
-namespace mate {
-class Dictionary;
-class PersistentDictionary;
-}  // namespace mate
-
-namespace atom {
-
-class AtomMenuModel;
-class NativeBrowserView;
-
-struct DraggableRegion;
-
-class NativeWindow : public base::SupportsUserData,
-                     public views::WidgetDelegate {
- public:
-  ~NativeWindow() override;
-
-  // Create window with existing WebContents, the caller is responsible for
-  // managing the window's live.
-  static NativeWindow* Create(const mate::Dictionary& options,
-                              NativeWindow* parent = nullptr);
-
-  void InitFromOptions(const mate::Dictionary& options);
-
-  virtual void SetContentView(views::View* view) = 0;
-
-  virtual void Close() = 0;
-  virtual void CloseImmediately() = 0;
-  virtual bool IsClosed() const;
-  virtual void Focus(bool focus) = 0;
-  virtual bool IsFocused() = 0;
-  virtual void Show() = 0;
-  virtual void ShowInactive() = 0;
-  virtual void Hide() = 0;
-  virtual bool IsVisible() = 0;
-  virtual bool IsEnabled() = 0;
-  virtual void SetEnabled(bool enable) = 0;
-  virtual void Maximize() = 0;
-  virtual void Unmaximize() = 0;
-  virtual bool IsMaximized() = 0;
-  virtual void Minimize() = 0;
-  virtual void Restore() = 0;
-  virtual bool IsMinimized() = 0;
-  virtual void SetFullScreen(bool fullscreen) = 0;
-  virtual bool IsFullscreen() const = 0;
-  virtual void SetBounds(const gfx::Rect& bounds, bool animate = false) = 0;
-  virtual gfx::Rect GetBounds() = 0;
-  virtual void SetSize(const gfx::Size& size, bool animate = false);
-  virtual gfx::Size GetSize();
-  virtual void SetPosition(const gfx::Point& position, bool animate = false);
-  virtual gfx::Point GetPosition();
-  virtual void SetContentSize(const gfx::Size& size, bool animate = false);
-  virtual gfx::Size GetContentSize();
-  virtual void SetContentBounds(const gfx::Rect& bounds, bool animate = false);
-  virtual gfx::Rect GetContentBounds();
-  virtual void SetSizeConstraints(
-      const extensions::SizeConstraints& size_constraints);
-  virtual extensions::SizeConstraints GetSizeConstraints() const;
-  virtual void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints);
-  virtual extensions::SizeConstraints GetContentSizeConstraints() const;
-  virtual void SetMinimumSize(const gfx::Size& size);
-  virtual gfx::Size GetMinimumSize() const;
-  virtual void SetMaximumSize(const gfx::Size& size);
-  virtual gfx::Size GetMaximumSize() const;
-  virtual gfx::Size GetContentMinimumSize() const;
-  virtual gfx::Size GetContentMaximumSize() const;
-  virtual void SetSheetOffset(const double offsetX, const double offsetY);
-  virtual double GetSheetOffsetX();
-  virtual double GetSheetOffsetY();
-  virtual void SetResizable(bool resizable) = 0;
-#if defined(OS_WIN) || defined(OS_MACOSX)
-  virtual void MoveTop() = 0;
-#endif
-  virtual bool IsResizable() = 0;
-  virtual void SetMovable(bool movable) = 0;
-  virtual bool IsMovable() = 0;
-  virtual void SetMinimizable(bool minimizable) = 0;
-  virtual bool IsMinimizable() = 0;
-  virtual void SetMaximizable(bool maximizable) = 0;
-  virtual bool IsMaximizable() = 0;
-  virtual void SetFullScreenable(bool fullscreenable) = 0;
-  virtual bool IsFullScreenable() = 0;
-  virtual void SetClosable(bool closable) = 0;
-  virtual bool IsClosable() = 0;
-  virtual void SetAlwaysOnTop(bool top,
-                              const std::string& level = "floating",
-                              int relativeLevel = 0,
-                              std::string* error = nullptr) = 0;
-  virtual bool IsAlwaysOnTop() = 0;
-  virtual void Center() = 0;
-  virtual void Invalidate() = 0;
-  virtual void SetTitle(const std::string& title) = 0;
-  virtual std::string GetTitle() = 0;
-  virtual void FlashFrame(bool flash) = 0;
-  virtual void SetSkipTaskbar(bool skip) = 0;
-  virtual void SetSimpleFullScreen(bool simple_fullscreen) = 0;
-  virtual bool IsSimpleFullScreen() = 0;
-  virtual void SetKiosk(bool kiosk) = 0;
-  virtual bool IsKiosk() = 0;
-  virtual void SetBackgroundColor(SkColor color) = 0;
-  virtual void SetHasShadow(bool has_shadow) = 0;
-  virtual bool HasShadow() = 0;
-  virtual void SetOpacity(const double opacity) = 0;
-  virtual double GetOpacity() = 0;
-  virtual void SetRepresentedFilename(const std::string& filename);
-  virtual std::string GetRepresentedFilename();
-  virtual void SetDocumentEdited(bool edited);
-  virtual bool IsDocumentEdited();
-  virtual void SetIgnoreMouseEvents(bool ignore, bool forward) = 0;
-  virtual void SetContentProtection(bool enable) = 0;
-  virtual void SetFocusable(bool focusable);
-  virtual void SetMenu(AtomMenuModel* menu);
-  virtual void SetParentWindow(NativeWindow* parent);
-  virtual void SetBrowserView(NativeBrowserView* browser_view) = 0;
-  virtual gfx::NativeView GetNativeView() const = 0;
-  virtual gfx::NativeWindow GetNativeWindow() const = 0;
-  virtual gfx::AcceleratedWidget GetAcceleratedWidget() const = 0;
-
-  // Taskbar/Dock APIs.
-  enum ProgressState {
-    PROGRESS_NONE,           // no progress, no marking
-    PROGRESS_INDETERMINATE,  // progress, indeterminate
-    PROGRESS_ERROR,          // progress, errored (red)
-    PROGRESS_PAUSED,         // progress, paused (yellow)
-    PROGRESS_NORMAL,         // progress, not marked (green)
-  };
-
-  virtual void SetProgressBar(double progress, const ProgressState state) = 0;
-  virtual void SetOverlayIcon(const gfx::Image& overlay,
-                              const std::string& description) = 0;
-
-  // Workspace APIs.
-  virtual void SetVisibleOnAllWorkspaces(bool visible) = 0;
-  virtual bool IsVisibleOnAllWorkspaces() = 0;
-
-  virtual void SetAutoHideCursor(bool auto_hide);
-
-  // Vibrancy API
-  virtual void SetVibrancy(const std::string& type);
-
-  // Touchbar API
-  virtual void SetTouchBar(
-      const std::vector<mate::PersistentDictionary>& items);
-  virtual void RefreshTouchBarItem(const std::string& item_id);
-  virtual void SetEscapeTouchBarItem(const mate::PersistentDictionary& item);
-
-  // Native Tab API
-  virtual void SelectPreviousTab();
-  virtual void SelectNextTab();
-  virtual void MergeAllWindows();
-  virtual void MoveTabToNewWindow();
-  virtual void ToggleTabBar();
-  virtual bool AddTabbedWindow(NativeWindow* window);
-
-  // Returns false if unsupported.
-  virtual bool SetWindowButtonVisibility(bool visible);
-
-  // Toggle the menu bar.
-  virtual void SetAutoHideMenuBar(bool auto_hide);
-  virtual bool IsMenuBarAutoHide();
-  virtual void SetMenuBarVisibility(bool visible);
-  virtual bool IsMenuBarVisible();
-
-  // Set the aspect ratio when resizing window.
-  double GetAspectRatio();
-  gfx::Size GetAspectRatioExtraSize();
-  virtual void SetAspectRatio(double aspect_ratio, const gfx::Size& extra_size);
-
-  // File preview APIs.
-  virtual void PreviewFile(const std::string& path,
-                           const std::string& display_name);
-  virtual void CloseFilePreview();
-
-  // Converts between content bounds and window bounds.
-  virtual gfx::Rect ContentBoundsToWindowBounds(
-      const gfx::Rect& bounds) const = 0;
-  virtual gfx::Rect WindowBoundsToContentBounds(
-      const gfx::Rect& bounds) const = 0;
-
-  base::WeakPtr<NativeWindow> GetWeakPtr() {
-    return weak_factory_.GetWeakPtr();
-  }
-
-  // Methods called by the WebContents.
-  virtual void HandleKeyboardEvent(
-      content::WebContents*,
-      const content::NativeWebKeyboardEvent& event) {}
-
-  // Public API used by platform-dependent delegates and observers to send UI
-  // related notifications.
-  void NotifyWindowRequestPreferredWith(int* width);
-  void NotifyWindowCloseButtonClicked();
-  void NotifyWindowClosed();
-  void NotifyWindowEndSession();
-  void NotifyWindowBlur();
-  void NotifyWindowFocus();
-  void NotifyWindowShow();
-  void NotifyWindowHide();
-  void NotifyWindowMaximize();
-  void NotifyWindowUnmaximize();
-  void NotifyWindowMinimize();
-  void NotifyWindowRestore();
-  void NotifyWindowMove();
-  void NotifyWindowWillResize(const gfx::Rect& new_bounds,
-                              bool* prevent_default);
-  void NotifyWindowResize();
-  void NotifyWindowMoved();
-  void NotifyWindowScrollTouchBegin();
-  void NotifyWindowScrollTouchEnd();
-  void NotifyWindowSwipe(const std::string& direction);
-  void NotifyWindowSheetBegin();
-  void NotifyWindowSheetEnd();
-  void NotifyWindowEnterFullScreen();
-  void NotifyWindowLeaveFullScreen();
-  void NotifyWindowEnterHtmlFullScreen();
-  void NotifyWindowLeaveHtmlFullScreen();
-  void NotifyWindowExecuteWindowsCommand(const std::string& command);
-  void NotifyTouchBarItemInteraction(const std::string& item_id,
-                                     const base::DictionaryValue& details);
-  void NotifyNewWindowForTab();
-
-#if defined(OS_WIN)
-  void NotifyWindowMessage(UINT message, WPARAM w_param, LPARAM l_param);
-#endif
-
-  void AddObserver(NativeWindowObserver* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(NativeWindowObserver* obs) {
-    observers_.RemoveObserver(obs);
-  }
-
-  views::Widget* widget() const { return widget_.get(); }
-  views::View* content_view() const { return content_view_; }
-
-  bool has_frame() const { return has_frame_; }
-  void set_has_frame(bool has_frame) { has_frame_ = has_frame; }
-
-  bool transparent() const { return transparent_; }
-  bool enable_larger_than_screen() const { return enable_larger_than_screen_; }
-
-  NativeBrowserView* browser_view() const { return browser_view_; }
-  NativeWindow* parent() const { return parent_; }
-  bool is_modal() const { return is_modal_; }
-
- protected:
-  NativeWindow(const mate::Dictionary& options, NativeWindow* parent);
-
-  // views::WidgetDelegate:
-  views::Widget* GetWidget() override;
-  const views::Widget* GetWidget() const override;
-
-  void set_content_view(views::View* view) { content_view_ = view; }
-  void set_browser_view(NativeBrowserView* browser_view) {
-    browser_view_ = browser_view;
-  }
-
- private:
-  std::unique_ptr<views::Widget> widget_;
-
-  // The content view, weak ref.
-  views::View* content_view_ = nullptr;
-
-  // Whether window has standard frame.
-  bool has_frame_ = true;
-
-  // Whether window is transparent.
-  bool transparent_ = false;
-
-  // Minimum and maximum size, stored as content size.
-  extensions::SizeConstraints size_constraints_;
-
-  // Whether window can be resized larger than screen.
-  bool enable_larger_than_screen_ = false;
-
-  // The windows has been closed.
-  bool is_closed_ = false;
-
-  // Used to display sheets at the appropriate horizontal and vertical offsets
-  // on macOS.
-  double sheet_offset_x_ = 0.0;
-  double sheet_offset_y_ = 0.0;
-
-  // Used to maintain the aspect ratio of a view which is inside of the
-  // content view.
-  double aspect_ratio_ = 0.0;
-  gfx::Size aspect_ratio_extraSize_;
-
-  // The parent window, it is guaranteed to be valid during this window's life.
-  NativeWindow* parent_ = nullptr;
-
-  // Is this a modal window.
-  bool is_modal_ = false;
-
-  // The browser view layer.
-  NativeBrowserView* browser_view_ = nullptr;
-
-  // Observers of this window.
-  base::ObserverList<NativeWindowObserver> observers_;
-
-  base::WeakPtrFactory<NativeWindow> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindow);
-};
-
-// This class provides a hook to get a NativeWindow from a WebContents.
-class NativeWindowRelay
-    : public content::WebContentsUserData<NativeWindowRelay> {
- public:
-  explicit NativeWindowRelay(base::WeakPtr<NativeWindow> window);
-  ~NativeWindowRelay() override;
-
-  static void* UserDataKey() {
-    return content::WebContentsUserData<NativeWindowRelay>::UserDataKey();
-  }
-
-  void* key;
-  base::WeakPtr<NativeWindow> window;
-
- private:
-  friend class content::WebContentsUserData<NativeWindow>;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_H_
removed in remote
  base   100644 93d03e4c157cace08ef1792246a875e6e94eea6e atom/browser/native_window_mac.h
  our    100644 44a78198f44cdba9875e3fb27c8e2c87eaa6f33b atom/browser/native_window_mac.h
@@ -1,221 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "base/mac/scoped_nsobject.h"
-#include "ui/views/controls/native/native_view_host.h"
-
-@class AtomNSWindow;
-@class AtomNSWindowDelegate;
-@class AtomPreviewItem;
-@class AtomTouchBar;
-@class CustomWindowButtonView;
-@class FullSizeContentView;
-
-namespace atom {
-
-class RootViewMac;
-
-class NativeWindowMac : public NativeWindow {
- public:
-  NativeWindowMac(const mate::Dictionary& options, NativeWindow* parent);
-  ~NativeWindowMac() override;
-
-  // NativeWindow:
-  void SetContentView(views::View* view) override;
-  void Close() override;
-  void CloseImmediately() override;
-  void Focus(bool focus) override;
-  bool IsFocused() override;
-  void Show() override;
-  void ShowInactive() override;
-  void Hide() override;
-  bool IsVisible() override;
-  bool IsEnabled() override;
-  void SetEnabled(bool enable) override;
-  void Maximize() override;
-  void Unmaximize() override;
-  bool IsMaximized() override;
-  void Minimize() override;
-  void Restore() override;
-  bool IsMinimized() override;
-  void SetFullScreen(bool fullscreen) override;
-  bool IsFullscreen() const override;
-  void SetBounds(const gfx::Rect& bounds, bool animate = false) override;
-  gfx::Rect GetBounds() override;
-  void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints) override;
-  void SetResizable(bool resizable) override;
-  void MoveTop() override;
-  bool IsResizable() override;
-  void SetMovable(bool movable) override;
-  void SetAspectRatio(double aspect_ratio,
-                      const gfx::Size& extra_size) override;
-  void PreviewFile(const std::string& path,
-                   const std::string& display_name) override;
-  void CloseFilePreview() override;
-  bool IsMovable() override;
-  void SetMinimizable(bool minimizable) override;
-  bool IsMinimizable() override;
-  void SetMaximizable(bool maximizable) override;
-  bool IsMaximizable() override;
-  void SetFullScreenable(bool fullscreenable) override;
-  bool IsFullScreenable() override;
-  void SetClosable(bool closable) override;
-  bool IsClosable() override;
-  void SetAlwaysOnTop(bool top,
-                      const std::string& level,
-                      int relativeLevel,
-                      std::string* error) override;
-  bool IsAlwaysOnTop() override;
-  void Center() override;
-  void Invalidate() override;
-  void SetTitle(const std::string& title) override;
-  std::string GetTitle() override;
-  void FlashFrame(bool flash) override;
-  void SetSkipTaskbar(bool skip) override;
-  void SetSimpleFullScreen(bool simple_fullscreen) override;
-  bool IsSimpleFullScreen() override;
-  void SetKiosk(bool kiosk) override;
-  bool IsKiosk() override;
-  void SetBackgroundColor(SkColor color) override;
-  void SetHasShadow(bool has_shadow) override;
-  bool HasShadow() override;
-  void SetOpacity(const double opacity) override;
-  double GetOpacity() override;
-  void SetRepresentedFilename(const std::string& filename) override;
-  std::string GetRepresentedFilename() override;
-  void SetDocumentEdited(bool edited) override;
-  bool IsDocumentEdited() override;
-  void SetIgnoreMouseEvents(bool ignore, bool forward) override;
-  void SetContentProtection(bool enable) override;
-  void SetBrowserView(NativeBrowserView* browser_view) override;
-  void SetParentWindow(NativeWindow* parent) override;
-  gfx::NativeView GetNativeView() const override;
-  gfx::NativeWindow GetNativeWindow() const override;
-  gfx::AcceleratedWidget GetAcceleratedWidget() const override;
-  void SetProgressBar(double progress, const ProgressState state) override;
-  void SetOverlayIcon(const gfx::Image& overlay,
-                      const std::string& description) override;
-
-  void SetVisibleOnAllWorkspaces(bool visible) override;
-  bool IsVisibleOnAllWorkspaces() override;
-
-  void SetAutoHideCursor(bool auto_hide) override;
-
-  void SelectPreviousTab() override;
-  void SelectNextTab() override;
-  void MergeAllWindows() override;
-  void MoveTabToNewWindow() override;
-  void ToggleTabBar() override;
-  bool AddTabbedWindow(NativeWindow* window) override;
-
-  bool SetWindowButtonVisibility(bool visible) override;
-
-  void SetVibrancy(const std::string& type) override;
-  void SetTouchBar(
-      const std::vector<mate::PersistentDictionary>& items) override;
-  void RefreshTouchBarItem(const std::string& item_id) override;
-  void SetEscapeTouchBarItem(const mate::PersistentDictionary& item) override;
-
-  gfx::Rect ContentBoundsToWindowBounds(const gfx::Rect& bounds) const override;
-  gfx::Rect WindowBoundsToContentBounds(const gfx::Rect& bounds) const override;
-
-  // Use a custom content view instead of Chromium's BridgedContentView.
-  void OverrideNSWindowContentView();
-
-  // Set the attribute of NSWindow while work around a bug of zoom button.
-  void SetStyleMask(bool on, NSUInteger flag);
-  void SetCollectionBehavior(bool on, NSUInteger flag);
-
-  enum TitleBarStyle {
-    NORMAL,
-    HIDDEN,
-    HIDDEN_INSET,
-    CUSTOM_BUTTONS_ON_HOVER,
-  };
-  TitleBarStyle title_bar_style() const { return title_bar_style_; }
-
-  AtomPreviewItem* preview_item() const { return preview_item_.get(); }
-  AtomTouchBar* touch_bar() const { return touch_bar_.get(); }
-  bool zoom_to_page_width() const { return zoom_to_page_width_; }
-  bool fullscreen_window_title() const { return fullscreen_window_title_; }
-  bool simple_fullscreen() const { return always_simple_fullscreen_; }
-
- protected:
-  // views::WidgetDelegate:
-  bool CanResize() const override;
-  views::View* GetContentsView() override;
-
- private:
-  // Add custom layers to the content view.
-  void AddContentViewLayers();
-
-  void InternalSetParentWindow(NativeWindow* parent, bool attach);
-  void ShowWindowButton(NSWindowButton button);
-
-  void SetForwardMouseMessages(bool forward);
-
-  AtomNSWindow* window_;  // Weak ref, managed by widget_.
-
-  base::scoped_nsobject<AtomNSWindowDelegate> window_delegate_;
-  base::scoped_nsobject<AtomPreviewItem> preview_item_;
-  base::scoped_nsobject<AtomTouchBar> touch_bar_;
-  base::scoped_nsobject<CustomWindowButtonView> buttons_view_;
-
-  // Event monitor for scroll wheel event.
-  id wheel_event_monitor_;
-
-  // The view that will fill the whole frameless window.
-  base::scoped_nsobject<FullSizeContentView> container_view_;
-
-  // The view that fills the client area.
-  std::unique_ptr<RootViewMac> root_view_;
-
-  bool is_kiosk_ = false;
-  bool was_fullscreen_ = false;
-  bool zoom_to_page_width_ = false;
-  bool fullscreen_window_title_ = false;
-  bool resizable_ = true;
-
-  NSInteger attention_request_id_ = 0;  // identifier from requestUserAttention
-
-  // The presentation options before entering kiosk mode.
-  NSApplicationPresentationOptions kiosk_options_;
-
-  // The "titleBarStyle" option.
-  TitleBarStyle title_bar_style_ = NORMAL;
-
-  // The visibility mode of window button controls when explicitly set through
-  // setWindowButtonVisibility().
-  base::Optional<bool> window_button_visibility_;
-
-  // Simple (pre-Lion) Fullscreen Settings
-  bool always_simple_fullscreen_ = false;
-  bool is_simple_fullscreen_ = false;
-  bool was_maximizable_ = false;
-  bool was_movable_ = false;
-  NSRect original_frame_;
-  NSUInteger simple_fullscreen_mask_;
-
-  base::scoped_nsobject<NSColor> background_color_before_vibrancy_;
-  bool transparency_before_vibrancy_ = false;
-
-  // The presentation options before entering simple fullscreen mode.
-  NSApplicationPresentationOptions simple_fullscreen_options_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowMac);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
removed in remote
  base   100644 2044ee7d7189076a93975231ef9c54662cf3ee3e atom/browser/native_window_mac.mm
  our    100644 004263ec127709067e903ffbf31003b8844226b4 atom/browser/native_window_mac.mm
@@ -1,1444 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window_mac.h"
-
-#include <AvailabilityMacros.h>
-#include <objc/objc-runtime.h>
-
-#include <string>
-
-#include "atom/browser/native_browser_view_mac.h"
-#include "atom/browser/ui/cocoa/atom_native_widget_mac.h"
-#include "atom/browser/ui/cocoa/atom_ns_window.h"
-#include "atom/browser/ui/cocoa/atom_ns_window_delegate.h"
-#include "atom/browser/ui/cocoa/atom_preview_item.h"
-#include "atom/browser/ui/cocoa/atom_touch_bar.h"
-#include "atom/browser/ui/cocoa/root_view_mac.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/options_switches.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "native_mate/dictionary.h"
-#include "skia/ext/skia_utils_mac.h"
-#include "ui/gfx/skia_util.h"
-#include "ui/gl/gpu_switching_manager.h"
-#include "ui/views/background.h"
-#include "ui/views/cocoa/bridged_native_widget.h"
-#include "ui/views/widget/widget.h"
-
-// This view always takes the size of its superview. It is intended to be used
-// as a NSWindow's contentView.  It is needed because NSWindow's implementation
-// explicitly resizes the contentView at inopportune times.
-@interface FullSizeContentView : NSView
-@end
-
-@implementation FullSizeContentView
-
-// This method is directly called by NSWindow during a window resize on OSX
-// 10.10.0, beta 2. We must override it to prevent the content view from
-// shrinking.
-- (void)setFrameSize:(NSSize)size {
-  if ([self superview])
-    size = [[self superview] bounds].size;
-  [super setFrameSize:size];
-}
-
-// The contentView gets moved around during certain full-screen operations.
-// This is less than ideal, and should eventually be removed.
-- (void)viewDidMoveToSuperview {
-  [self setFrame:[[self superview] bounds]];
-}
-
-@end
-
-// Custom Quit, Minimize and Full Screen button container for frameless
-// windows.
-@interface CustomWindowButtonView : NSView {
- @private
-  BOOL mouse_inside_;
-}
-@end
-
-@implementation CustomWindowButtonView
-
-- (id)initWithFrame:(NSRect)frame {
-  self = [super initWithFrame:frame];
-
-  NSButton* close_button = [NSWindow standardWindowButton:NSWindowCloseButton
-                                             forStyleMask:NSTitledWindowMask];
-  NSButton* miniaturize_button =
-      [NSWindow standardWindowButton:NSWindowMiniaturizeButton
-                        forStyleMask:NSTitledWindowMask];
-  NSButton* zoom_button = [NSWindow standardWindowButton:NSWindowZoomButton
-                                            forStyleMask:NSTitledWindowMask];
-
-  CGFloat x = 0;
-  const CGFloat space_between = 20;
-
-  [close_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:close_button];
-
-  [miniaturize_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:miniaturize_button];
-
-  [zoom_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:zoom_button];
-
-  const auto last_button_frame = zoom_button.frame;
-  [self setFrameSize:NSMakeSize(last_button_frame.origin.x +
-                                    last_button_frame.size.width,
-                                last_button_frame.size.height)];
-
-  mouse_inside_ = NO;
-  [self setNeedsDisplayForButtons];
-
-  return self;
-}
-
-- (void)viewDidMoveToWindow {
-  if (!self.window) {
-    return;
-  }
-
-  // Stay in upper left corner.
-  const CGFloat top_margin = 3;
-  const CGFloat left_margin = 7;
-  [self setAutoresizingMask:NSViewMaxXMargin | NSViewMinYMargin];
-  [self setFrameOrigin:NSMakePoint(left_margin, self.window.frame.size.height -
-                                                    self.frame.size.height -
-                                                    top_margin)];
-}
-
-- (BOOL)_mouseInGroup:(NSButton*)button {
-  return mouse_inside_;
-}
-
-- (void)updateTrackingAreas {
-  auto tracking_area = [[[NSTrackingArea alloc]
-      initWithRect:NSZeroRect
-           options:NSTrackingMouseEnteredAndExited | NSTrackingActiveAlways |
-                   NSTrackingInVisibleRect
-             owner:self
-          userInfo:nil] autorelease];
-  [self addTrackingArea:tracking_area];
-}
-
-- (void)mouseEntered:(NSEvent*)event {
-  [super mouseEntered:event];
-  mouse_inside_ = YES;
-  [self setNeedsDisplayForButtons];
-}
-
-- (void)mouseExited:(NSEvent*)event {
-  [super mouseExited:event];
-  mouse_inside_ = NO;
-  [self setNeedsDisplayForButtons];
-}
-
-- (void)setNeedsDisplayForButtons {
-  for (NSView* subview in self.subviews) {
-    [subview setHidden:!mouse_inside_];
-    [subview setNeedsDisplay:YES];
-  }
-}
-
-@end
-
-#if !defined(AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER)
-
-enum { NSWindowTabbingModeDisallowed = 2 };
-
-@interface NSWindow (SierraSDK)
-- (void)setTabbingMode:(NSInteger)mode;
-- (void)setTabbingIdentifier:(NSString*)identifier;
-- (void)addTabbedWindow:(NSWindow*)window ordered:(NSWindowOrderingMode)ordered;
-- (IBAction)selectPreviousTab:(id)sender;
-- (IBAction)selectNextTab:(id)sender;
-- (IBAction)mergeAllWindows:(id)sender;
-- (IBAction)moveTabToNewWindow:(id)sender;
-- (IBAction)toggleTabBar:(id)sender;
-@end
-
-#endif
-
-@interface AtomProgressBar : NSProgressIndicator
-@end
-
-@implementation AtomProgressBar
-
-- (void)drawRect:(NSRect)dirtyRect {
-  if (self.style != NSProgressIndicatorBarStyle)
-    return;
-  // Draw edges of rounded rect.
-  NSRect rect = NSInsetRect([self bounds], 1.0, 1.0);
-  CGFloat radius = rect.size.height / 2;
-  NSBezierPath* bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect
-                                                              xRadius:radius
-                                                              yRadius:radius];
-  [bezier_path setLineWidth:2.0];
-  [[NSColor grayColor] set];
-  [bezier_path stroke];
-
-  // Fill the rounded rect.
-  rect = NSInsetRect(rect, 2.0, 2.0);
-  radius = rect.size.height / 2;
-  bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect
-                                                xRadius:radius
-                                                yRadius:radius];
-  [bezier_path setLineWidth:1.0];
-  [bezier_path addClip];
-
-  // Calculate the progress width.
-  rect.size.width =
-      floor(rect.size.width * ([self doubleValue] / [self maxValue]));
-
-  // Fill the progress bar with color blue.
-  [[NSColor colorWithSRGBRed:0.2 green:0.6 blue:1 alpha:1] set];
-  NSRectFill(rect);
-}
-
-@end
-
-namespace mate {
-
-template <>
-struct Converter<atom::NativeWindowMac::TitleBarStyle> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     atom::NativeWindowMac::TitleBarStyle* out) {
-    std::string title_bar_style;
-    if (!ConvertFromV8(isolate, val, &title_bar_style))
-      return false;
-    if (title_bar_style == "hidden") {
-      *out = atom::NativeWindowMac::HIDDEN;
-    } else if (title_bar_style == "hiddenInset") {
-      *out = atom::NativeWindowMac::HIDDEN_INSET;
-    } else if (title_bar_style == "customButtonsOnHover") {
-      *out = atom::NativeWindowMac::CUSTOM_BUTTONS_ON_HOVER;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace {
-
-bool IsFramelessWindow(NSView* view) {
-  NativeWindow* window = [static_cast<AtomNSWindow*>([view window]) shell];
-  return window && !window->has_frame();
-}
-
-IMP original_set_frame_size = nullptr;
-IMP original_view_did_move_to_superview = nullptr;
-
-// This method is directly called by NSWindow during a window resize on OSX
-// 10.10.0, beta 2. We must override it to prevent the content view from
-// shrinking.
-void SetFrameSize(NSView* self, SEL _cmd, NSSize size) {
-  if (!IsFramelessWindow(self)) {
-    auto original =
-        reinterpret_cast<decltype(&SetFrameSize)>(original_set_frame_size);
-    return original(self, _cmd, size);
-  }
-  // For frameless window, resize the view to cover full window.
-  if ([self superview])
-    size = [[self superview] bounds].size;
-  auto super_impl = reinterpret_cast<decltype(&SetFrameSize)>(
-      [[self superclass] instanceMethodForSelector:_cmd]);
-  super_impl(self, _cmd, size);
-}
-
-// The contentView gets moved around during certain full-screen operations.
-// This is less than ideal, and should eventually be removed.
-void ViewDidMoveToSuperview(NSView* self, SEL _cmd) {
-  if (!IsFramelessWindow(self)) {
-    // [BridgedContentView viewDidMoveToSuperview];
-    auto original = reinterpret_cast<decltype(&ViewDidMoveToSuperview)>(
-        original_view_did_move_to_superview);
-    if (original)
-      original(self, _cmd);
-    return;
-  }
-  [self setFrame:[[self superview] bounds]];
-}
-
-}  // namespace
-
-NativeWindowMac::NativeWindowMac(const mate::Dictionary& options,
-                                 NativeWindow* parent)
-    : NativeWindow(options, parent), root_view_(new RootViewMac(this)) {
-  int width = 800, height = 600;
-  options.Get(options::kWidth, &width);
-  options.Get(options::kHeight, &height);
-
-  NSRect main_screen_rect = [[[NSScreen screens] firstObject] frame];
-  gfx::Rect bounds(round((NSWidth(main_screen_rect) - width) / 2),
-                   round((NSHeight(main_screen_rect) - height) / 2), width,
-                   height);
-
-  options.Get(options::kResizable, &resizable_);
-  options.Get(options::kTitleBarStyle, &title_bar_style_);
-  options.Get(options::kZoomToPageWidth, &zoom_to_page_width_);
-  options.Get(options::kFullscreenWindowTitle, &fullscreen_window_title_);
-  options.Get(options::kSimpleFullScreen, &always_simple_fullscreen_);
-
-  bool minimizable = true;
-  options.Get(options::kMinimizable, &minimizable);
-
-  bool maximizable = true;
-  options.Get(options::kMaximizable, &maximizable);
-
-  bool closable = true;
-  options.Get(options::kClosable, &closable);
-
-  std::string tabbingIdentifier;
-  options.Get(options::kTabbingIdentifier, &tabbingIdentifier);
-
-  std::string windowType;
-  options.Get(options::kType, &windowType);
-
-  bool useStandardWindow = true;
-  // eventually deprecate separate "standardWindow" option in favor of
-  // standard / textured window types
-  options.Get(options::kStandardWindow, &useStandardWindow);
-  if (windowType == "textured") {
-    useStandardWindow = false;
-  }
-
-  NSUInteger styleMask = NSTitledWindowMask;
-  if (@available(macOS 10.10, *)) {
-    if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER &&
-        (!useStandardWindow || transparent() || !has_frame())) {
-      styleMask = NSFullSizeContentViewWindowMask;
-    }
-  }
-  if (minimizable) {
-    styleMask |= NSMiniaturizableWindowMask;
-  }
-  if (closable) {
-    styleMask |= NSClosableWindowMask;
-  }
-  if (title_bar_style_ != NORMAL) {
-    // The window without titlebar is treated the same with frameless window.
-    set_has_frame(false);
-  }
-  if (!useStandardWindow || transparent() || !has_frame()) {
-    styleMask |= NSTexturedBackgroundWindowMask;
-  }
-
-  // Create views::Widget and assign window_ with it.
-  // TODO(zcbenz): Get rid of the window_ in future.
-  views::Widget::InitParams params;
-  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.bounds = bounds;
-  params.delegate = this;
-  params.type = views::Widget::InitParams::TYPE_WINDOW;
-  params.native_widget = new AtomNativeWidgetMac(this, styleMask, widget());
-  widget()->Init(params);
-  window_ = static_cast<AtomNSWindow*>(widget()->GetNativeWindow());
-
-  [window_ setEnableLargerThanScreen:enable_larger_than_screen()];
-
-  window_delegate_.reset([[AtomNSWindowDelegate alloc] initWithShell:this]);
-  [window_ setDelegate:window_delegate_];
-
-  // Only use native parent window for non-modal windows.
-  if (parent && !is_modal()) {
-    SetParentWindow(parent);
-  }
-
-  if (transparent()) {
-    // Setting the background color to clear will also hide the shadow.
-    [window_ setBackgroundColor:[NSColor clearColor]];
-  }
-
-  if (windowType == "desktop") {
-    [window_ setLevel:kCGDesktopWindowLevel - 1];
-    [window_ setDisableKeyOrMainWindow:YES];
-    [window_ setCollectionBehavior:(NSWindowCollectionBehaviorCanJoinAllSpaces |
-                                    NSWindowCollectionBehaviorStationary |
-                                    NSWindowCollectionBehaviorIgnoresCycle)];
-  }
-
-  bool focusable;
-  if (options.Get(options::kFocusable, &focusable) && !focusable)
-    [window_ setDisableKeyOrMainWindow:YES];
-
-  if (transparent() || !has_frame()) {
-    if (@available(macOS 10.10, *)) {
-      // Don't show title bar.
-      [window_ setTitlebarAppearsTransparent:YES];
-      [window_ setTitleVisibility:NSWindowTitleHidden];
-    }
-    // Remove non-transparent corners, see http://git.io/vfonD.
-    [window_ setOpaque:NO];
-  }
-
-  // Create a tab only if tabbing identifier is specified and window has
-  // a native title bar.
-  if (tabbingIdentifier.empty() || transparent() || !has_frame()) {
-    if (@available(macOS 10.12, *)) {
-      [window_ setTabbingMode:NSWindowTabbingModeDisallowed];
-    }
-  } else {
-    if (@available(macOS 10.12, *)) {
-      [window_ setTabbingIdentifier:base::SysUTF8ToNSString(tabbingIdentifier)];
-    }
-  }
-
-  // Hide the title bar background
-  if (title_bar_style_ != NORMAL) {
-    if (@available(macOS 10.10, *)) {
-      [window_ setTitlebarAppearsTransparent:YES];
-    }
-  }
-
-  // Hide the title bar.
-  if (title_bar_style_ == HIDDEN_INSET) {
-    if (@available(macOS 10.10, *)) {
-      base::scoped_nsobject<NSToolbar> toolbar(
-          [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
-      [toolbar setShowsBaselineSeparator:NO];
-      [window_ setToolbar:toolbar];
-    } else {
-      [window_ enableWindowButtonsOffset];
-      [window_ setWindowButtonsOffset:NSMakePoint(12, 10)];
-    }
-  }
-
-  // Resize to content bounds.
-  bool use_content_size = false;
-  options.Get(options::kUseContentSize, &use_content_size);
-  if (!has_frame() || use_content_size)
-    SetContentSize(gfx::Size(width, height));
-
-  // Enable the NSView to accept first mouse event.
-  bool acceptsFirstMouse = false;
-  options.Get(options::kAcceptFirstMouse, &acceptsFirstMouse);
-  [window_ setAcceptsFirstMouse:acceptsFirstMouse];
-
-  // Disable auto-hiding cursor.
-  bool disableAutoHideCursor = false;
-  options.Get(options::kDisableAutoHideCursor, &disableAutoHideCursor);
-  [window_ setDisableAutoHideCursor:disableAutoHideCursor];
-
-  // Use an NSEvent monitor to listen for the wheel event.
-  BOOL __block began = NO;
-  wheel_event_monitor_ = [NSEvent
-      addLocalMonitorForEventsMatchingMask:NSScrollWheelMask
-                                   handler:^(NSEvent* event) {
-                                     if ([[event window] windowNumber] !=
-                                         [window_ windowNumber])
-                                       return event;
-
-                                     if (!began && (([event phase] ==
-                                                     NSEventPhaseMayBegin) ||
-                                                    ([event phase] ==
-                                                     NSEventPhaseBegan))) {
-                                       this->NotifyWindowScrollTouchBegin();
-                                       began = YES;
-                                     } else if (began &&
-                                                (([event phase] ==
-                                                  NSEventPhaseEnded) ||
-                                                 ([event phase] ==
-                                                  NSEventPhaseCancelled))) {
-                                       this->NotifyWindowScrollTouchEnd();
-                                       began = NO;
-                                     }
-                                     return event;
-                                   }];
-
-  // Set maximizable state last to ensure zoom button does not get reset
-  // by calls to other APIs.
-  SetMaximizable(maximizable);
-
-  // Default content view.
-  SetContentView(new views::View());
-  AddContentViewLayers();
-}
-
-NativeWindowMac::~NativeWindowMac() {
-  [NSEvent removeMonitor:wheel_event_monitor_];
-}
-
-void NativeWindowMac::SetContentView(views::View* view) {
-  views::View* root_view = GetContentsView();
-  if (content_view())
-    root_view->RemoveChildView(content_view());
-
-  set_content_view(view);
-  root_view->AddChildView(content_view());
-
-  if (buttons_view_) {
-    // Ensure the buttons view are always floated on the top.
-    [buttons_view_ removeFromSuperview];
-    [[window_ contentView] addSubview:buttons_view_];
-  }
-
-  root_view->Layout();
-}
-
-void NativeWindowMac::Close() {
-  // When this is a sheet showing, performClose won't work.
-  if (is_modal() && parent() && IsVisible()) {
-    [parent()->GetNativeWindow() endSheet:window_];
-    CloseImmediately();
-    return;
-  }
-
-  if (!IsClosable()) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  [window_ performClose:nil];
-}
-
-void NativeWindowMac::CloseImmediately() {
-  [window_ close];
-}
-
-void NativeWindowMac::Focus(bool focus) {
-  if (!IsVisible())
-    return;
-
-  if (focus) {
-    [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
-    [window_ makeKeyAndOrderFront:nil];
-  } else {
-    [window_ orderBack:nil];
-  }
-}
-
-bool NativeWindowMac::IsFocused() {
-  return [window_ isKeyWindow];
-}
-
-void NativeWindowMac::Show() {
-  if (is_modal() && parent()) {
-    if ([window_ sheetParent] == nil)
-      [parent()->GetNativeWindow() beginSheet:window_
-                            completionHandler:^(NSModalResponse){
-                            }];
-    return;
-  }
-
-  // Reattach the window to the parent to actually show it.
-  if (parent())
-    InternalSetParentWindow(parent(), true);
-
-  // This method is supposed to put focus on window, however if the app does not
-  // have focus then "makeKeyAndOrderFront" will only show the window.
-  [NSApp activateIgnoringOtherApps:YES];
-
-  [window_ makeKeyAndOrderFront:nil];
-}
-
-void NativeWindowMac::ShowInactive() {
-  // Reattach the window to the parent to actually show it.
-  if (parent())
-    InternalSetParentWindow(parent(), true);
-
-  [window_ orderFrontRegardless];
-}
-
-void NativeWindowMac::Hide() {
-  if (is_modal() && parent()) {
-    [window_ orderOut:nil];
-    [parent()->GetNativeWindow() endSheet:window_];
-    return;
-  }
-
-  // Deattach the window from the parent before.
-  if (parent())
-    InternalSetParentWindow(parent(), false);
-
-  [window_ orderOut:nil];
-}
-
-bool NativeWindowMac::IsVisible() {
-  return [window_ isVisible];
-}
-
-bool NativeWindowMac::IsEnabled() {
-  return [window_ attachedSheet] == nil;
-}
-
-void NativeWindowMac::SetEnabled(bool enable) {
-  if (enable) {
-    [window_ beginSheet:window_
-        completionHandler:^(NSModalResponse returnCode) {
-          NSLog(@"modal enabled");
-          return;
-        }];
-  } else {
-    [window_ endSheet:[window_ attachedSheet]];
-  }
-}
-
-void NativeWindowMac::Maximize() {
-  if (IsMaximized())
-    return;
-
-  [window_ zoom:nil];
-}
-
-void NativeWindowMac::Unmaximize() {
-  if (!IsMaximized())
-    return;
-
-  [window_ zoom:nil];
-}
-
-bool NativeWindowMac::IsMaximized() {
-  if (([window_ styleMask] & NSResizableWindowMask) != 0) {
-    return [window_ isZoomed];
-  } else {
-    NSRect rectScreen = [[NSScreen mainScreen] visibleFrame];
-    NSRect rectWindow = [window_ frame];
-    return (rectScreen.origin.x == rectWindow.origin.x &&
-            rectScreen.origin.y == rectWindow.origin.y &&
-            rectScreen.size.width == rectWindow.size.width &&
-            rectScreen.size.height == rectWindow.size.height);
-  }
-}
-
-void NativeWindowMac::Minimize() {
-  [window_ miniaturize:nil];
-}
-
-void NativeWindowMac::Restore() {
-  [window_ deminiaturize:nil];
-}
-
-bool NativeWindowMac::IsMinimized() {
-  return [window_ isMiniaturized];
-}
-
-void NativeWindowMac::SetFullScreen(bool fullscreen) {
-  if (fullscreen == IsFullscreen())
-    return;
-
-  [window_ toggleFullScreenMode:nil];
-}
-
-bool NativeWindowMac::IsFullscreen() const {
-  return [window_ styleMask] & NSFullScreenWindowMask;
-}
-
-void NativeWindowMac::SetBounds(const gfx::Rect& bounds, bool animate) {
-  // Do nothing if in fullscreen mode.
-  if (IsFullscreen())
-    return;
-
-  // Check size constraints since setFrame does not check it.
-  gfx::Size size = bounds.size();
-  size.SetToMax(GetMinimumSize());
-  gfx::Size max_size = GetMaximumSize();
-  if (!max_size.IsEmpty())
-    size.SetToMin(max_size);
-
-  NSRect cocoa_bounds = NSMakeRect(bounds.x(), 0, size.width(), size.height());
-  // Flip coordinates based on the primary screen.
-  NSScreen* screen = [[NSScreen screens] firstObject];
-  cocoa_bounds.origin.y = NSHeight([screen frame]) - size.height() - bounds.y();
-
-  [window_ setFrame:cocoa_bounds display:YES animate:animate];
-}
-
-gfx::Rect NativeWindowMac::GetBounds() {
-  NSRect frame = [window_ frame];
-  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
-  NSScreen* screen = [[NSScreen screens] firstObject];
-  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
-  return bounds;
-}
-
-void NativeWindowMac::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  auto convertSize = [this](const gfx::Size& size) {
-    // Our frameless window still has titlebar attached, so setting contentSize
-    // will result in actual content size being larger.
-    if (!has_frame()) {
-      NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
-      NSRect content = [window_ originalContentRectForFrameRect:frame];
-      return content.size;
-    } else {
-      return NSMakeSize(size.width(), size.height());
-    }
-  };
-
-  NSView* content = [window_ contentView];
-  if (size_constraints.HasMinimumSize()) {
-    NSSize min_size = convertSize(size_constraints.GetMinimumSize());
-    [window_ setContentMinSize:[content convertSize:min_size toView:nil]];
-  }
-  if (size_constraints.HasMaximumSize()) {
-    NSSize max_size = convertSize(size_constraints.GetMaximumSize());
-    [window_ setContentMaxSize:[content convertSize:max_size toView:nil]];
-  }
-  NativeWindow::SetContentSizeConstraints(size_constraints);
-}
-
-void NativeWindowMac::MoveTop() {
-  [window_ orderWindow:NSWindowAbove relativeTo:0];
-}
-
-void NativeWindowMac::SetResizable(bool resizable) {
-  SetStyleMask(resizable, NSResizableWindowMask);
-}
-
-bool NativeWindowMac::IsResizable() {
-  return [window_ styleMask] & NSResizableWindowMask;
-}
-
-void NativeWindowMac::SetAspectRatio(double aspect_ratio,
-                                     const gfx::Size& extra_size) {
-  NativeWindow::SetAspectRatio(aspect_ratio, extra_size);
-
-  // Reset the behaviour to default if aspect_ratio is set to 0 or less.
-  if (aspect_ratio > 0.0)
-    [window_ setAspectRatio:NSMakeSize(aspect_ratio, 1.0)];
-  else
-    [window_ setResizeIncrements:NSMakeSize(1.0, 1.0)];
-}
-
-void NativeWindowMac::PreviewFile(const std::string& path,
-                                  const std::string& display_name) {
-  preview_item_.reset([[AtomPreviewItem alloc]
-      initWithURL:[NSURL fileURLWithPath:base::SysUTF8ToNSString(path)]
-            title:base::SysUTF8ToNSString(display_name)]);
-  [[QLPreviewPanel sharedPreviewPanel] makeKeyAndOrderFront:nil];
-}
-
-void NativeWindowMac::CloseFilePreview() {
-  if ([QLPreviewPanel sharedPreviewPanelExists]) {
-    [[QLPreviewPanel sharedPreviewPanel] close];
-  }
-}
-
-void NativeWindowMac::SetMovable(bool movable) {
-  [window_ setMovable:movable];
-}
-
-bool NativeWindowMac::IsMovable() {
-  return [window_ isMovable];
-}
-
-void NativeWindowMac::SetMinimizable(bool minimizable) {
-  SetStyleMask(minimizable, NSMiniaturizableWindowMask);
-}
-
-bool NativeWindowMac::IsMinimizable() {
-  return [window_ styleMask] & NSMiniaturizableWindowMask;
-}
-
-void NativeWindowMac::SetMaximizable(bool maximizable) {
-  [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:maximizable];
-}
-
-bool NativeWindowMac::IsMaximizable() {
-  return [[window_ standardWindowButton:NSWindowZoomButton] isEnabled];
-}
-
-void NativeWindowMac::SetFullScreenable(bool fullscreenable) {
-  SetCollectionBehavior(fullscreenable,
-                        NSWindowCollectionBehaviorFullScreenPrimary);
-  // On EL Capitan this flag is required to hide fullscreen button.
-  SetCollectionBehavior(!fullscreenable,
-                        NSWindowCollectionBehaviorFullScreenAuxiliary);
-}
-
-bool NativeWindowMac::IsFullScreenable() {
-  NSUInteger collectionBehavior = [window_ collectionBehavior];
-  return collectionBehavior & NSWindowCollectionBehaviorFullScreenPrimary;
-}
-
-void NativeWindowMac::SetClosable(bool closable) {
-  SetStyleMask(closable, NSClosableWindowMask);
-}
-
-bool NativeWindowMac::IsClosable() {
-  return [window_ styleMask] & NSClosableWindowMask;
-}
-
-void NativeWindowMac::SetAlwaysOnTop(bool top,
-                                     const std::string& level,
-                                     int relativeLevel,
-                                     std::string* error) {
-  int windowLevel = NSNormalWindowLevel;
-  CGWindowLevel maxWindowLevel = CGWindowLevelForKey(kCGMaximumWindowLevelKey);
-  CGWindowLevel minWindowLevel = CGWindowLevelForKey(kCGMinimumWindowLevelKey);
-
-  if (top) {
-    if (level == "floating") {
-      windowLevel = NSFloatingWindowLevel;
-    } else if (level == "torn-off-menu") {
-      windowLevel = NSTornOffMenuWindowLevel;
-    } else if (level == "modal-panel") {
-      windowLevel = NSModalPanelWindowLevel;
-    } else if (level == "main-menu") {
-      windowLevel = NSMainMenuWindowLevel;
-    } else if (level == "status") {
-      windowLevel = NSStatusWindowLevel;
-    } else if (level == "pop-up-menu") {
-      windowLevel = NSPopUpMenuWindowLevel;
-    } else if (level == "screen-saver") {
-      windowLevel = NSScreenSaverWindowLevel;
-    } else if (level == "dock") {
-      // Deprecated by macOS, but kept for backwards compatibility
-      windowLevel = NSDockWindowLevel;
-    }
-  }
-
-  NSInteger newLevel = windowLevel + relativeLevel;
-  if (newLevel >= minWindowLevel && newLevel <= maxWindowLevel) {
-    [window_ setLevel:newLevel];
-  } else {
-    *error = std::string([
-        [NSString stringWithFormat:@"relativeLevel must be between %d and %d",
-                                   minWindowLevel, maxWindowLevel] UTF8String]);
-  }
-}
-
-bool NativeWindowMac::IsAlwaysOnTop() {
-  return [window_ level] != NSNormalWindowLevel;
-}
-
-void NativeWindowMac::Center() {
-  [window_ center];
-}
-
-void NativeWindowMac::Invalidate() {
-  [window_ flushWindow];
-  [[window_ contentView] setNeedsDisplay:YES];
-}
-
-void NativeWindowMac::SetTitle(const std::string& title) {
-  // For macOS <= 10.9, the setTitleVisibility API is not available, we have
-  // to avoid calling setTitle for frameless window.
-  if (!base::mac::IsAtLeastOS10_10() && (transparent() || !has_frame()))
-    return;
-
-  [window_ setTitle:base::SysUTF8ToNSString(title)];
-}
-
-std::string NativeWindowMac::GetTitle() {
-  return base::SysNSStringToUTF8([window_ title]);
-  ;
-}
-
-void NativeWindowMac::FlashFrame(bool flash) {
-  if (flash) {
-    attention_request_id_ = [NSApp requestUserAttention:NSInformationalRequest];
-  } else {
-    [NSApp cancelUserAttentionRequest:attention_request_id_];
-    attention_request_id_ = 0;
-  }
-}
-
-void NativeWindowMac::SetSkipTaskbar(bool skip) {}
-
-void NativeWindowMac::SetSimpleFullScreen(bool simple_fullscreen) {
-  NSWindow* window = GetNativeWindow();
-
-  if (simple_fullscreen && !is_simple_fullscreen_) {
-    is_simple_fullscreen_ = true;
-
-    // Take note of the current window size
-    original_frame_ = [window frame];
-
-    simple_fullscreen_options_ = [NSApp currentSystemPresentationOptions];
-    simple_fullscreen_mask_ = [window styleMask];
-
-    // We can simulate the pre-Lion fullscreen by auto-hiding the dock and menu
-    // bar
-    NSApplicationPresentationOptions options =
-        NSApplicationPresentationAutoHideDock +
-        NSApplicationPresentationAutoHideMenuBar;
-    [NSApp setPresentationOptions:options];
-
-    was_maximizable_ = IsMaximizable();
-    was_movable_ = IsMovable();
-
-    NSRect fullscreenFrame = [window.screen frame];
-
-    if (!fullscreen_window_title()) {
-      // Hide the titlebar
-      SetStyleMask(false, NSTitledWindowMask);
-
-      // Resize the window to accomodate the _entire_ screen size
-      fullscreenFrame.size.height -=
-          [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-    } else if (!window_button_visibility_.has_value()) {
-      // Lets keep previous behaviour - hide window controls in titled
-      // fullscreen mode when not specified otherwise.
-      [[window standardWindowButton:NSWindowZoomButton] setHidden:YES];
-      [[window standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
-      [[window standardWindowButton:NSWindowCloseButton] setHidden:YES];
-    }
-
-    [window setFrame:fullscreenFrame display:YES animate:YES];
-
-    // Fullscreen windows can't be resized, minimized, maximized, or moved
-    SetMinimizable(false);
-    SetResizable(false);
-    SetMaximizable(false);
-    SetMovable(false);
-  } else if (!simple_fullscreen && is_simple_fullscreen_) {
-    is_simple_fullscreen_ = false;
-
-    if (!fullscreen_window_title()) {
-      // Restore the titlebar
-      SetStyleMask(true, NSTitledWindowMask);
-    }
-
-    // Restore window controls visibility state
-    const bool window_button_hidden = !window_button_visibility_.value_or(true);
-    [[window standardWindowButton:NSWindowZoomButton]
-        setHidden:window_button_hidden];
-    [[window standardWindowButton:NSWindowMiniaturizeButton]
-        setHidden:window_button_hidden];
-    [[window standardWindowButton:NSWindowCloseButton]
-        setHidden:window_button_hidden];
-
-    [window setFrame:original_frame_ display:YES animate:YES];
-
-    [NSApp setPresentationOptions:simple_fullscreen_options_];
-
-    // Restore original style mask
-    ScopedDisableResize disable_resize;
-    [window_ setStyleMask:simple_fullscreen_mask_];
-
-    // Restore window manipulation abilities
-    SetMaximizable(was_maximizable_);
-    SetMovable(was_movable_);
-  }
-}
-
-bool NativeWindowMac::IsSimpleFullScreen() {
-  return is_simple_fullscreen_;
-}
-
-void NativeWindowMac::SetKiosk(bool kiosk) {
-  if (kiosk && !is_kiosk_) {
-    kiosk_options_ = [NSApp currentSystemPresentationOptions];
-    NSApplicationPresentationOptions options =
-        NSApplicationPresentationHideDock +
-        NSApplicationPresentationHideMenuBar +
-        NSApplicationPresentationDisableAppleMenu +
-        NSApplicationPresentationDisableProcessSwitching +
-        NSApplicationPresentationDisableForceQuit +
-        NSApplicationPresentationDisableSessionTermination +
-        NSApplicationPresentationDisableHideApplication;
-    [NSApp setPresentationOptions:options];
-    is_kiosk_ = true;
-    was_fullscreen_ = IsFullscreen();
-    if (!was_fullscreen_)
-      SetFullScreen(true);
-  } else if (!kiosk && is_kiosk_) {
-    is_kiosk_ = false;
-    if (!was_fullscreen_)
-      SetFullScreen(false);
-    [NSApp setPresentationOptions:kiosk_options_];
-  }
-}
-
-bool NativeWindowMac::IsKiosk() {
-  return is_kiosk_;
-}
-
-void NativeWindowMac::SetBackgroundColor(SkColor color) {
-  base::ScopedCFTypeRef<CGColorRef> cgcolor(
-      skia::CGColorCreateFromSkColor(color));
-  // views::Widget adds a layer for the content view.
-  auto* bridge = views::NativeWidgetMac::GetBridgeForNativeWindow(window_);
-  NSView* compositor_superview =
-      static_cast<ui::AcceleratedWidgetMacNSView*>(bridge)
-          ->AcceleratedWidgetGetNSView();
-  [[compositor_superview layer] setBackgroundColor:cgcolor];
-  // When using WebContents as content view, the contentView also has layer.
-  if ([[window_ contentView] wantsLayer])
-    [[[window_ contentView] layer] setBackgroundColor:cgcolor];
-}
-
-void NativeWindowMac::SetHasShadow(bool has_shadow) {
-  [window_ setHasShadow:has_shadow];
-}
-
-bool NativeWindowMac::HasShadow() {
-  return [window_ hasShadow];
-}
-
-void NativeWindowMac::SetOpacity(const double opacity) {
-  [window_ setAlphaValue:opacity];
-}
-
-double NativeWindowMac::GetOpacity() {
-  return [window_ alphaValue];
-}
-
-void NativeWindowMac::SetRepresentedFilename(const std::string& filename) {
-  [window_ setRepresentedFilename:base::SysUTF8ToNSString(filename)];
-}
-
-std::string NativeWindowMac::GetRepresentedFilename() {
-  return base::SysNSStringToUTF8([window_ representedFilename]);
-}
-
-void NativeWindowMac::SetDocumentEdited(bool edited) {
-  [window_ setDocumentEdited:edited];
-}
-
-bool NativeWindowMac::IsDocumentEdited() {
-  return [window_ isDocumentEdited];
-}
-
-void NativeWindowMac::SetIgnoreMouseEvents(bool ignore, bool forward) {
-  [window_ setIgnoresMouseEvents:ignore];
-
-  if (!ignore) {
-    SetForwardMouseMessages(NO);
-  } else {
-    SetForwardMouseMessages(forward);
-  }
-}
-
-void NativeWindowMac::SetContentProtection(bool enable) {
-  [window_
-      setSharingType:enable ? NSWindowSharingNone : NSWindowSharingReadOnly];
-}
-
-void NativeWindowMac::SetBrowserView(NativeBrowserView* view) {
-  if (browser_view()) {
-    [browser_view()->GetInspectableWebContentsView()->GetNativeView()
-            removeFromSuperview];
-    set_browser_view(nullptr);
-  }
-
-  if (!view) {
-    return;
-  }
-
-  set_browser_view(view);
-  auto* native_view = view->GetInspectableWebContentsView()->GetNativeView();
-  [[window_ contentView] addSubview:native_view
-                         positioned:NSWindowAbove
-                         relativeTo:nil];
-  native_view.hidden = NO;
-}
-
-void NativeWindowMac::SetParentWindow(NativeWindow* parent) {
-  InternalSetParentWindow(parent, IsVisible());
-}
-
-gfx::NativeView NativeWindowMac::GetNativeView() const {
-  return [window_ contentView];
-}
-
-gfx::NativeWindow NativeWindowMac::GetNativeWindow() const {
-  return window_;
-}
-
-gfx::AcceleratedWidget NativeWindowMac::GetAcceleratedWidget() const {
-  return gfx::kNullAcceleratedWidget;
-}
-
-void NativeWindowMac::SetProgressBar(double progress,
-                                     const NativeWindow::ProgressState state) {
-  NSDockTile* dock_tile = [NSApp dockTile];
-
-  // For the first time API invoked, we need to create a ContentView in
-  // DockTile.
-  if (dock_tile.contentView == nullptr) {
-    NSImageView* image_view = [[NSImageView alloc] init];
-    [image_view setImage:[NSApp applicationIconImage]];
-    [dock_tile setContentView:image_view];
-  }
-
-  if ([[dock_tile.contentView subviews] count] == 0) {
-    NSProgressIndicator* progress_indicator = [[AtomProgressBar alloc]
-        initWithFrame:NSMakeRect(0.0f, 0.0f, dock_tile.size.width, 15.0)];
-    [progress_indicator setStyle:NSProgressIndicatorBarStyle];
-    [progress_indicator setIndeterminate:NO];
-    [progress_indicator setBezeled:YES];
-    [progress_indicator setMinValue:0];
-    [progress_indicator setMaxValue:1];
-    [progress_indicator setHidden:NO];
-    [dock_tile.contentView addSubview:progress_indicator];
-  }
-
-  NSProgressIndicator* progress_indicator = static_cast<NSProgressIndicator*>(
-      [[[dock_tile contentView] subviews] objectAtIndex:0]);
-  if (progress < 0) {
-    [progress_indicator setHidden:YES];
-  } else if (progress > 1) {
-    [progress_indicator setHidden:NO];
-    [progress_indicator setIndeterminate:YES];
-    [progress_indicator setDoubleValue:1];
-  } else {
-    [progress_indicator setHidden:NO];
-    [progress_indicator setDoubleValue:progress];
-  }
-  [dock_tile display];
-}
-
-void NativeWindowMac::SetOverlayIcon(const gfx::Image& overlay,
-                                     const std::string& description) {}
-
-void NativeWindowMac::SetVisibleOnAllWorkspaces(bool visible) {
-  SetCollectionBehavior(visible, NSWindowCollectionBehaviorCanJoinAllSpaces);
-}
-
-bool NativeWindowMac::IsVisibleOnAllWorkspaces() {
-  NSUInteger collectionBehavior = [window_ collectionBehavior];
-  return collectionBehavior & NSWindowCollectionBehaviorCanJoinAllSpaces;
-}
-
-void NativeWindowMac::SetAutoHideCursor(bool auto_hide) {
-  [window_ setDisableAutoHideCursor:!auto_hide];
-}
-
-void NativeWindowMac::SelectPreviousTab() {
-  if (@available(macOS 10.12, *)) {
-    [window_ selectPreviousTab:nil];
-  }
-}
-
-void NativeWindowMac::SelectNextTab() {
-  if (@available(macOS 10.12, *)) {
-    [window_ selectNextTab:nil];
-  }
-}
-
-void NativeWindowMac::MergeAllWindows() {
-  if (@available(macOS 10.12, *)) {
-    [window_ mergeAllWindows:nil];
-  }
-}
-
-void NativeWindowMac::MoveTabToNewWindow() {
-  if (@available(macOS 10.12, *)) {
-    [window_ moveTabToNewWindow:nil];
-  }
-}
-
-void NativeWindowMac::ToggleTabBar() {
-  if (@available(macOS 10.12, *)) {
-    [window_ toggleTabBar:nil];
-  }
-}
-
-bool NativeWindowMac::AddTabbedWindow(NativeWindow* window) {
-  if (window_ == window->GetNativeWindow()) {
-    return false;
-  } else {
-    if (@available(macOS 10.12, *))
-      [window_ addTabbedWindow:window->GetNativeWindow() ordered:NSWindowAbove];
-  }
-  return true;
-}
-
-bool NativeWindowMac::SetWindowButtonVisibility(bool visible) {
-  if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER) {
-    return false;
-  }
-
-  window_button_visibility_ = visible;
-
-  [[window_ standardWindowButton:NSWindowCloseButton] setHidden:!visible];
-  [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:!visible];
-  [[window_ standardWindowButton:NSWindowZoomButton] setHidden:!visible];
-  return true;
-}
-
-void NativeWindowMac::SetVibrancy(const std::string& type) {
-  if (@available(macOS 10.10, *)) {
-    NSView* vibrant_view = [window_ vibrantView];
-
-    if (type.empty()) {
-      if (background_color_before_vibrancy_) {
-        [window_ setBackgroundColor:background_color_before_vibrancy_];
-        [window_ setTitlebarAppearsTransparent:transparency_before_vibrancy_];
-      }
-      if (vibrant_view == nil)
-        return;
-
-      [vibrant_view removeFromSuperview];
-      [window_ setVibrantView:nil];
-      ui::GpuSwitchingManager::SetTransparent(transparent());
-
-      return;
-    }
-
-    background_color_before_vibrancy_.reset([[window_ backgroundColor] retain]);
-    transparency_before_vibrancy_ = [window_ titlebarAppearsTransparent];
-    ui::GpuSwitchingManager::SetTransparent(true);
-
-    if (title_bar_style_ != NORMAL) {
-      [window_ setTitlebarAppearsTransparent:YES];
-      [window_ setBackgroundColor:[NSColor clearColor]];
-    }
-
-    NSVisualEffectView* effect_view = (NSVisualEffectView*)vibrant_view;
-    if (effect_view == nil) {
-      effect_view = [[[NSVisualEffectView alloc]
-          initWithFrame:[[window_ contentView] bounds]] autorelease];
-      [window_ setVibrantView:(NSView*)effect_view];
-
-      [effect_view
-          setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-      [effect_view setBlendingMode:NSVisualEffectBlendingModeBehindWindow];
-      [effect_view setState:NSVisualEffectStateActive];
-      [[window_ contentView] addSubview:effect_view
-                             positioned:NSWindowBelow
-                             relativeTo:nil];
-    }
-
-    NSVisualEffectMaterial vibrancyType = NSVisualEffectMaterialLight;
-
-    if (type == "appearance-based") {
-      vibrancyType = NSVisualEffectMaterialAppearanceBased;
-    } else if (type == "light") {
-      vibrancyType = NSVisualEffectMaterialLight;
-    } else if (type == "dark") {
-      vibrancyType = NSVisualEffectMaterialDark;
-    } else if (type == "titlebar") {
-      vibrancyType = NSVisualEffectMaterialTitlebar;
-    }
-
-    if (@available(macOS 10.11, *)) {
-      // TODO(kevinsawicki): Use NSVisualEffectMaterial* constants directly once
-      // they are available in the minimum SDK version
-      if (type == "selection") {
-        // NSVisualEffectMaterialSelection
-        vibrancyType = static_cast<NSVisualEffectMaterial>(4);
-      } else if (type == "menu") {
-        // NSVisualEffectMaterialMenu
-        vibrancyType = static_cast<NSVisualEffectMaterial>(5);
-      } else if (type == "popover") {
-        // NSVisualEffectMaterialPopover
-        vibrancyType = static_cast<NSVisualEffectMaterial>(6);
-      } else if (type == "sidebar") {
-        // NSVisualEffectMaterialSidebar
-        vibrancyType = static_cast<NSVisualEffectMaterial>(7);
-      } else if (type == "medium-light") {
-        // NSVisualEffectMaterialMediumLight
-        vibrancyType = static_cast<NSVisualEffectMaterial>(8);
-      } else if (type == "ultra-dark") {
-        // NSVisualEffectMaterialUltraDark
-        vibrancyType = static_cast<NSVisualEffectMaterial>(9);
-      }
-    }
-
-    [effect_view setMaterial:vibrancyType];
-  }
-}
-
-void NativeWindowMac::SetTouchBar(
-    const std::vector<mate::PersistentDictionary>& items) {
-  if (@available(macOS 10.12.2, *)) {
-    touch_bar_.reset([[AtomTouchBar alloc]
-        initWithDelegate:window_delegate_.get()
-                  window:this
-                settings:items]);
-    [window_ setTouchBar:nil];
-  }
-}
-
-void NativeWindowMac::RefreshTouchBarItem(const std::string& item_id) {
-  if (@available(macOS 10.12.2, *)) {
-    if (touch_bar_ && [window_ touchBar])
-      [touch_bar_ refreshTouchBarItem:[window_ touchBar] id:item_id];
-  }
-}
-
-void NativeWindowMac::SetEscapeTouchBarItem(
-    const mate::PersistentDictionary& item) {
-  if (@available(macOS 10.12.2, *)) {
-    if (touch_bar_ && [window_ touchBar])
-      [touch_bar_ setEscapeTouchBarItem:item forTouchBar:[window_ touchBar]];
-  }
-}
-
-gfx::Rect NativeWindowMac::ContentBoundsToWindowBounds(
-    const gfx::Rect& bounds) const {
-  if (has_frame()) {
-    gfx::Rect window_bounds(
-        [window_ frameRectForContentRect:bounds.ToCGRect()]);
-    int frame_height = window_bounds.height() - bounds.height();
-    window_bounds.set_y(window_bounds.y() - frame_height);
-    return window_bounds;
-  } else {
-    return bounds;
-  }
-}
-
-gfx::Rect NativeWindowMac::WindowBoundsToContentBounds(
-    const gfx::Rect& bounds) const {
-  if (has_frame()) {
-    gfx::Rect content_bounds(
-        [window_ contentRectForFrameRect:bounds.ToCGRect()]);
-    int frame_height = bounds.height() - content_bounds.height();
-    content_bounds.set_y(content_bounds.y() + frame_height);
-    return content_bounds;
-  } else {
-    return bounds;
-  }
-}
-
-bool NativeWindowMac::CanResize() const {
-  return resizable_;
-}
-
-views::View* NativeWindowMac::GetContentsView() {
-  return root_view_.get();
-}
-
-void NativeWindowMac::AddContentViewLayers() {
-  // Make sure the bottom corner is rounded for non-modal windows:
-  // http://crbug.com/396264. But do not enable it on OS X 10.9 for transparent
-  // window, otherwise a semi-transparent frame would show.
-  if (!(transparent() && base::mac::IsOS10_9()) && !is_modal()) {
-    base::scoped_nsobject<CALayer> background_layer([[CALayer alloc] init]);
-    [background_layer
-        setAutoresizingMask:kCALayerWidthSizable | kCALayerHeightSizable];
-    [[window_ contentView] setLayer:background_layer];
-    [[window_ contentView] setWantsLayer:YES];
-  }
-
-  if (!has_frame()) {
-    // In OSX 10.10, adding subviews to the root view for the NSView hierarchy
-    // produces warnings. To eliminate the warnings, we resize the contentView
-    // to fill the window, and add subviews to that.
-    // http://crbug.com/380412
-    if (!original_set_frame_size) {
-      Class cl = [[window_ contentView] class];
-      original_set_frame_size = class_replaceMethod(
-          cl, @selector(setFrameSize:), (IMP)SetFrameSize, "v@:{_NSSize=ff}");
-      original_view_did_move_to_superview =
-          class_replaceMethod(cl, @selector(viewDidMoveToSuperview),
-                              (IMP)ViewDidMoveToSuperview, "v@:");
-      [[window_ contentView] viewDidMoveToWindow];
-    }
-
-    // The fullscreen button should always be hidden for frameless window.
-    [[window_ standardWindowButton:NSWindowFullScreenButton] setHidden:YES];
-
-    if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER) {
-      buttons_view_.reset(
-          [[CustomWindowButtonView alloc] initWithFrame:NSZeroRect]);
-      [[window_ contentView] addSubview:buttons_view_];
-    } else {
-      if (title_bar_style_ != NORMAL) {
-        if (base::mac::IsOS10_9()) {
-          ShowWindowButton(NSWindowZoomButton);
-          ShowWindowButton(NSWindowMiniaturizeButton);
-          ShowWindowButton(NSWindowCloseButton);
-        }
-        return;
-      }
-
-      // Hide the window buttons.
-      [[window_ standardWindowButton:NSWindowZoomButton] setHidden:YES];
-      [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
-      [[window_ standardWindowButton:NSWindowCloseButton] setHidden:YES];
-    }
-
-    // Some third-party macOS utilities check the zoom button's enabled state to
-    // determine whether to show custom UI on hover, so we disable it here to
-    // prevent them from doing so in a frameless app window.
-    [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:NO];
-  }
-}
-
-void NativeWindowMac::InternalSetParentWindow(NativeWindow* parent,
-                                              bool attach) {
-  if (is_modal())
-    return;
-
-  NativeWindow::SetParentWindow(parent);
-
-  // Do not remove/add if we are already properly attached.
-  if (attach && parent && [window_ parentWindow] == parent->GetNativeWindow())
-    return;
-
-  // Remove current parent window.
-  if ([window_ parentWindow])
-    [[window_ parentWindow] removeChildWindow:window_];
-
-  // Set new parent window.
-  // Note that this method will force the window to become visible.
-  if (parent && attach)
-    [parent->GetNativeWindow() addChildWindow:window_ ordered:NSWindowAbove];
-}
-
-void NativeWindowMac::ShowWindowButton(NSWindowButton button) {
-  auto view = [window_ standardWindowButton:button];
-  [view.superview addSubview:view positioned:NSWindowAbove relativeTo:nil];
-}
-
-void NativeWindowMac::SetForwardMouseMessages(bool forward) {
-  [window_ setAcceptsMouseMovedEvents:forward];
-}
-
-void NativeWindowMac::OverrideNSWindowContentView() {
-  // When using `views::Widget` to hold WebContents, Chromium would use
-  // `BridgedContentView` as content view, which does not support draggable
-  // regions. In order to make draggable regions work, we have to replace the
-  // content view with a simple NSView.
-  container_view_.reset([[FullSizeContentView alloc] init]);
-  [container_view_
-      setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-  [container_view_ setFrame:[[[window_ contentView] superview] bounds]];
-  [window_ setContentView:container_view_];
-  AddContentViewLayers();
-}
-
-void NativeWindowMac::SetStyleMask(bool on, NSUInteger flag) {
-  // Changing the styleMask of a frameless windows causes it to change size so
-  // we explicitly disable resizing while setting it.
-  ScopedDisableResize disable_resize;
-
-  bool was_maximizable = IsMaximizable();
-  if (on)
-    [window_ setStyleMask:[window_ styleMask] | flag];
-  else
-    [window_ setStyleMask:[window_ styleMask] & (~flag)];
-  // Change style mask will make the zoom button revert to default, probably
-  // a bug of Cocoa or macOS.
-  SetMaximizable(was_maximizable);
-}
-
-void NativeWindowMac::SetCollectionBehavior(bool on, NSUInteger flag) {
-  bool was_maximizable = IsMaximizable();
-  if (on)
-    [window_ setCollectionBehavior:[window_ collectionBehavior] | flag];
-  else
-    [window_ setCollectionBehavior:[window_ collectionBehavior] & (~flag)];
-  // Change collectionBehavior will make the zoom button revert to default,
-  // probably a bug of Cocoa or macOS.
-  SetMaximizable(was_maximizable);
-}
-
-// static
-NativeWindow* NativeWindow::Create(const mate::Dictionary& options,
-                                   NativeWindow* parent) {
-  return new NativeWindowMac(options, parent);
-}
-
-}  // namespace atom
removed in remote
  base   100644 cfbae95bda16a262457339e093943d371128199d atom/browser/native_window_observer.h
  our    100644 c2a86ea6b65cd6091fa7e8018bed0b11c7390f23 atom/browser/native_window_observer.h
@@ -1,99 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
-
-#include <string>
-
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "ui/base/window_open_disposition.h"
-#include "url/gurl.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#endif
-
-namespace gfx {
-class Rect;
-}
-
-namespace atom {
-
-class NativeWindowObserver {
- public:
-  virtual ~NativeWindowObserver() {}
-
-  // Called when the web page in window wants to create a popup window.
-  virtual void WillCreatePopupWindow(const base::string16& frame_name,
-                                     const GURL& target_url,
-                                     const std::string& partition_id,
-                                     WindowOpenDisposition disposition) {}
-
-  // Called when user is starting an navigation in web page.
-  virtual void WillNavigate(bool* prevent_default, const GURL& url) {}
-
-  // Called when the window is gonna closed.
-  virtual void WillCloseWindow(bool* prevent_default) {}
-
-  // Called when the window wants to know the preferred width.
-  virtual void RequestPreferredWidth(int* width) {}
-
-  // Called when closed button is clicked.
-  virtual void OnCloseButtonClicked(bool* prevent_default) {}
-
-  // Called when the window is closed.
-  virtual void OnWindowClosed() {}
-
-  // Called when Windows sends WM_ENDSESSION message
-  virtual void OnWindowEndSession() {}
-
-  // Called when window loses focus.
-  virtual void OnWindowBlur() {}
-
-  // Called when window gains focus.
-  virtual void OnWindowFocus() {}
-
-  // Called when window is shown.
-  virtual void OnWindowShow() {}
-
-  // Called when window is hidden.
-  virtual void OnWindowHide() {}
-
-  // Called when window state changed.
-  virtual void OnWindowMaximize() {}
-  virtual void OnWindowUnmaximize() {}
-  virtual void OnWindowMinimize() {}
-  virtual void OnWindowRestore() {}
-  virtual void OnWindowWillResize(const gfx::Rect& new_bounds,
-                                  bool* prevent_default) {}
-  virtual void OnWindowResize() {}
-  virtual void OnWindowMove() {}
-  virtual void OnWindowMoved() {}
-  virtual void OnWindowScrollTouchBegin() {}
-  virtual void OnWindowScrollTouchEnd() {}
-  virtual void OnWindowSwipe(const std::string& direction) {}
-  virtual void OnWindowSheetBegin() {}
-  virtual void OnWindowSheetEnd() {}
-  virtual void OnWindowEnterFullScreen() {}
-  virtual void OnWindowLeaveFullScreen() {}
-  virtual void OnWindowEnterHtmlFullScreen() {}
-  virtual void OnWindowLeaveHtmlFullScreen() {}
-  virtual void OnTouchBarItemResult(const std::string& item_id,
-                                    const base::DictionaryValue& details) {}
-  virtual void OnNewWindowForTab() {}
-
-// Called when window message received
-#if defined(OS_WIN)
-  virtual void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {}
-#endif
-
-  // Called on Windows when App Commands arrive (WM_APPCOMMAND)
-  virtual void OnExecuteWindowsCommand(const std::string& command_name) {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
removed in remote
  base   100644 15f2046364bbff669e4a1f90ae755191ee72939e atom/browser/native_window_views.cc
  our    100644 0dba39942f92d54ba34db7709b73012055680d94 atom/browser/native_window_views.cc
@@ -1,1260 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window_views.h"
-
-#if defined(OS_WIN)
-#include <objbase.h>
-#include <wrl/client.h>
-#endif
-
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/native_browser_view_views.h"
-#include "atom/browser/ui/views/root_view.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/draggable_region.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/strings/utf_string_conversions.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "ui/aura/window_tree_host.h"
-#include "ui/base/hit_test.h"
-#include "ui/gfx/image/image.h"
-#include "ui/views/background.h"
-#include "ui/views/controls/webview/unhandled_keyboard_event_handler.h"
-#include "ui/views/controls/webview/webview.h"
-#include "ui/views/widget/native_widget_private.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/window/client_view.h"
-#include "ui/wm/core/shadow_types.h"
-#include "ui/wm/core/window_util.h"
-
-#if defined(USE_X11)
-#include "atom/browser/browser.h"
-#include "atom/browser/ui/views/frameless_view.h"
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
-#include "atom/browser/ui/views/native_frame_view.h"
-#include "atom/browser/ui/x/event_disabler.h"
-#include "atom/browser/ui/x/window_state_watcher.h"
-#include "atom/browser/ui/x/x_window_utils.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/ui/libgtkui/unity_service.h"
-#include "ui/base/x/x11_util.h"
-#include "ui/gfx/x/x11_types.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
-#include "ui/views/window/native_frame_view.h"
-#elif defined(OS_WIN)
-#include "atom/browser/ui/views/win_frame_view.h"
-#include "atom/browser/ui/win/atom_desktop_native_widget_aura.h"
-#include "atom/browser/ui/win/atom_desktop_window_tree_host_win.h"
-#include "skia/ext/skia_utils_win.h"
-#include "ui/base/win/shell.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-#if defined(OS_WIN)
-void FlipWindowStyle(HWND handle, bool on, DWORD flag) {
-  DWORD style = ::GetWindowLong(handle, GWL_STYLE);
-  if (on)
-    style |= flag;
-  else
-    style &= ~flag;
-  ::SetWindowLong(handle, GWL_STYLE, style);
-}
-#endif
-
-class NativeWindowClientView : public views::ClientView {
- public:
-  NativeWindowClientView(views::Widget* widget,
-                         views::View* root_view,
-                         NativeWindowViews* window)
-      : views::ClientView(widget, root_view), window_(window) {}
-  ~NativeWindowClientView() override = default;
-
-  bool CanClose() override {
-    window_->NotifyWindowCloseButtonClicked();
-    return false;
-  }
-
- private:
-  NativeWindowViews* window_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowClientView);
-};
-
-}  // namespace
-
-NativeWindowViews::NativeWindowViews(const mate::Dictionary& options,
-                                     NativeWindow* parent)
-    : NativeWindow(options, parent),
-      root_view_(new RootView(this)),
-      keyboard_event_handler_(new views::UnhandledKeyboardEventHandler) {
-  options.Get(options::kTitle, &title_);
-
-  bool menu_bar_autohide;
-  if (options.Get(options::kAutoHideMenuBar, &menu_bar_autohide))
-    root_view_->SetAutoHideMenuBar(menu_bar_autohide);
-
-#if defined(OS_WIN)
-  // On Windows we rely on the CanResize() to indicate whether window can be
-  // resized, and it should be set before window is created.
-  options.Get(options::kResizable, &resizable_);
-  options.Get(options::kMinimizable, &minimizable_);
-  options.Get(options::kMaximizable, &maximizable_);
-
-  // Transparent window must not have thick frame.
-  options.Get("thickFrame", &thick_frame_);
-  if (transparent())
-    thick_frame_ = false;
-#endif
-
-  if (enable_larger_than_screen())
-    // We need to set a default maximum window size here otherwise Windows
-    // will not allow us to resize the window larger than scree.
-    // Setting directly to INT_MAX somehow doesn't work, so we just devide
-    // by 10, which should still be large enough.
-    SetContentSizeConstraints(extensions::SizeConstraints(
-        gfx::Size(), gfx::Size(INT_MAX / 10, INT_MAX / 10)));
-
-  int width = 800, height = 600;
-  options.Get(options::kWidth, &width);
-  options.Get(options::kHeight, &height);
-  gfx::Rect bounds(0, 0, width, height);
-  widget_size_ = bounds.size();
-
-  widget()->AddObserver(this);
-
-  views::Widget::InitParams params;
-  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.bounds = bounds;
-  params.delegate = this;
-  params.type = views::Widget::InitParams::TYPE_WINDOW;
-  params.remove_standard_frame = !has_frame();
-
-  if (transparent())
-    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
-
-  // The given window is most likely not rectangular since it uses
-  // transparency and has no standard frame, don't show a shadow for it.
-  if (transparent() && !has_frame())
-    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
-
-  bool focusable;
-  if (options.Get(options::kFocusable, &focusable) && !focusable)
-    params.activatable = views::Widget::InitParams::ACTIVATABLE_NO;
-
-#if defined(OS_WIN)
-  if (parent)
-    params.parent = parent->GetNativeWindow();
-
-  params.native_widget = new AtomDesktopNativeWidgetAura(widget());
-  atom_desktop_window_tree_host_win_ = new AtomDesktopWindowTreeHostWin(
-      this, widget(),
-      static_cast<views::DesktopNativeWidgetAura*>(params.native_widget));
-  params.desktop_window_tree_host = atom_desktop_window_tree_host_win_;
-#elif defined(USE_X11)
-  std::string name = Browser::Get()->GetName();
-  // Set WM_WINDOW_ROLE.
-  params.wm_role_name = "browser-window";
-  // Set WM_CLASS.
-  params.wm_class_name = base::ToLowerASCII(name);
-  params.wm_class_class = name;
-#endif
-
-  widget()->Init(params);
-
-  bool fullscreen = false;
-  options.Get(options::kFullscreen, &fullscreen);
-
-  std::string window_type;
-  options.Get(options::kType, &window_type);
-
-#if defined(USE_X11)
-  // Start monitoring window states.
-  window_state_watcher_.reset(new WindowStateWatcher(this));
-
-  // Set _GTK_THEME_VARIANT to dark if we have "dark-theme" option set.
-  bool use_dark_theme = false;
-  if (options.Get(options::kDarkTheme, &use_dark_theme) && use_dark_theme) {
-    XDisplay* xdisplay = gfx::GetXDisplay();
-    XChangeProperty(xdisplay, GetAcceleratedWidget(),
-                    XInternAtom(xdisplay, "_GTK_THEME_VARIANT", x11::False),
-                    XInternAtom(xdisplay, "UTF8_STRING", x11::False), 8,
-                    PropModeReplace,
-                    reinterpret_cast<const unsigned char*>("dark"), 4);
-  }
-
-  // Before the window is mapped the SetWMSpecState can not work, so we have
-  // to manually set the _NET_WM_STATE.
-  std::vector<::Atom> state_atom_list;
-  bool skip_taskbar = false;
-  if (options.Get(options::kSkipTaskbar, &skip_taskbar) && skip_taskbar) {
-    state_atom_list.push_back(GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
-  }
-
-  // Before the window is mapped, there is no SHOW_FULLSCREEN_STATE.
-  if (fullscreen) {
-    state_atom_list.push_back(GetAtom("_NET_WM_STATE_FULLSCREEN"));
-  }
-
-  if (parent) {
-    SetParentWindow(parent);
-    // Force using dialog type for child window.
-    window_type = "dialog";
-    // Modal window needs the _NET_WM_STATE_MODAL hint.
-    if (is_modal())
-      state_atom_list.push_back(GetAtom("_NET_WM_STATE_MODAL"));
-  }
-
-  if (!state_atom_list.empty())
-    ui::SetAtomArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", "ATOM",
-                             state_atom_list);
-
-  // Set the _NET_WM_WINDOW_TYPE.
-  if (!window_type.empty())
-    SetWindowType(GetAcceleratedWidget(), window_type);
-#endif
-
-#if defined(OS_WIN)
-  if (!has_frame()) {
-    // Set Window style so that we get a minimize and maximize animation when
-    // frameless.
-    DWORD frame_style = WS_CAPTION;
-    if (resizable_)
-      frame_style |= WS_THICKFRAME;
-    if (minimizable_)
-      frame_style |= WS_MINIMIZEBOX;
-    if (maximizable_)
-      frame_style |= WS_MAXIMIZEBOX;
-    // We should not show a frame for transparent window.
-    if (!thick_frame_)
-      frame_style &= ~(WS_THICKFRAME | WS_CAPTION);
-    ::SetWindowLong(GetAcceleratedWidget(), GWL_STYLE, frame_style);
-  }
-
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (window_type == "toolbar")
-    ex_style |= WS_EX_TOOLWINDOW;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-#endif
-
-  if (has_frame()) {
-    // TODO(zcbenz): This was used to force using native frame on Windows 2003,
-    // we should check whether setting it in InitParams can work.
-    widget()->set_frame_type(views::Widget::FrameType::FRAME_TYPE_FORCE_NATIVE);
-    widget()->FrameTypeChanged();
-#if defined(OS_WIN)
-    // thickFrame also works for normal window.
-    if (!thick_frame_)
-      FlipWindowStyle(GetAcceleratedWidget(), false, WS_THICKFRAME);
-#endif
-  }
-
-  // Default content view.
-  SetContentView(new views::View());
-
-  gfx::Size size = bounds.size();
-  if (has_frame() &&
-      options.Get(options::kUseContentSize, &use_content_size_) &&
-      use_content_size_)
-    size = ContentBoundsToWindowBounds(gfx::Rect(size)).size();
-
-  widget()->CenterWindow(size);
-
-#if defined(OS_WIN)
-  // Save initial window state.
-  if (fullscreen)
-    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-  else
-    last_window_state_ = ui::SHOW_STATE_NORMAL;
-  last_normal_bounds_ = GetBounds();
-#endif
-}
-
-NativeWindowViews::~NativeWindowViews() {
-  widget()->RemoveObserver(this);
-
-#if defined(OS_WIN)
-  // Disable mouse forwarding to relinquish resources, should any be held.
-  SetForwardMouseMessages(false);
-#endif
-}
-
-void NativeWindowViews::SetContentView(views::View* view) {
-  if (content_view()) {
-    root_view_->RemoveChildView(content_view());
-    if (browser_view()) {
-      content_view()->RemoveChildView(
-          browser_view()->GetInspectableWebContentsView()->GetView());
-      set_browser_view(nullptr);
-    }
-  }
-  set_content_view(view);
-  focused_view_ = view;
-  root_view_->AddChildView(content_view());
-  root_view_->Layout();
-}
-
-void NativeWindowViews::Close() {
-  if (!IsClosable()) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  widget()->Close();
-}
-
-void NativeWindowViews::CloseImmediately() {
-  widget()->CloseNow();
-}
-
-void NativeWindowViews::Focus(bool focus) {
-  // For hidden window focus() should do nothing.
-  if (!IsVisible())
-    return;
-
-  if (focus) {
-    widget()->Activate();
-  } else {
-    widget()->Deactivate();
-  }
-}
-
-bool NativeWindowViews::IsFocused() {
-  return widget()->IsActive();
-}
-
-void NativeWindowViews::Show() {
-  if (is_modal() && NativeWindow::parent() &&
-      !widget()->native_widget_private()->IsVisible())
-    NativeWindow::parent()->SetEnabled(false);
-
-  widget()->native_widget_private()->ShowWithWindowState(GetRestoredState());
-
-  NotifyWindowShow();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowMapped();
-#endif
-}
-
-void NativeWindowViews::ShowInactive() {
-  widget()->ShowInactive();
-
-  NotifyWindowShow();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowMapped();
-#endif
-}
-
-void NativeWindowViews::Hide() {
-  if (is_modal() && NativeWindow::parent())
-    NativeWindow::parent()->SetEnabled(true);
-
-  widget()->Hide();
-
-  NotifyWindowHide();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowUnmapped();
-#endif
-}
-
-bool NativeWindowViews::IsVisible() {
-  return widget()->IsVisible();
-}
-
-bool NativeWindowViews::IsEnabled() {
-#if defined(OS_WIN)
-  return ::IsWindowEnabled(GetAcceleratedWidget());
-#elif defined(USE_X11)
-  return !event_disabler_.get();
-#endif
-}
-
-void NativeWindowViews::SetEnabled(bool enable) {
-  // Handle multiple calls of SetEnabled correctly.
-  if (enable) {
-    --disable_count_;
-    if (disable_count_ != 0)
-      return;
-  } else {
-    ++disable_count_;
-    if (disable_count_ != 1)
-      return;
-  }
-
-#if defined(OS_WIN)
-  ::EnableWindow(GetAcceleratedWidget(), enable);
-#elif defined(USE_X11)
-  views::DesktopWindowTreeHostX11* tree_host =
-      views::DesktopWindowTreeHostX11::GetHostForXID(GetAcceleratedWidget());
-  if (enable) {
-    tree_host->RemoveEventRewriter(event_disabler_.get());
-    event_disabler_.reset();
-  } else {
-    event_disabler_.reset(new EventDisabler);
-    tree_host->AddEventRewriter(event_disabler_.get());
-  }
-#endif
-}
-
-void NativeWindowViews::Maximize() {
-#if defined(OS_WIN)
-  // For window without WS_THICKFRAME style, we can not call Maximize().
-  if (!(::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME)) {
-    restore_bounds_ = GetBounds();
-    auto display =
-        display::Screen::GetScreen()->GetDisplayNearestPoint(GetPosition());
-    SetBounds(display.work_area(), false);
-    return;
-  }
-#endif
-
-  if (IsVisible())
-    widget()->Maximize();
-  else
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_MAXIMIZED);
-}
-
-void NativeWindowViews::Unmaximize() {
-#if defined(OS_WIN)
-  if (!(::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME)) {
-    SetBounds(restore_bounds_, false);
-    return;
-  }
-#endif
-
-  widget()->Restore();
-}
-
-bool NativeWindowViews::IsMaximized() {
-  return widget()->IsMaximized();
-}
-
-void NativeWindowViews::Minimize() {
-  if (IsVisible())
-    widget()->Minimize();
-  else
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_MINIMIZED);
-}
-
-void NativeWindowViews::Restore() {
-  widget()->Restore();
-}
-
-bool NativeWindowViews::IsMinimized() {
-  return widget()->IsMinimized();
-}
-
-void NativeWindowViews::SetFullScreen(bool fullscreen) {
-  if (!IsFullScreenable())
-    return;
-
-#if defined(OS_WIN)
-  // There is no native fullscreen state on Windows.
-  bool leaving_fullscreen = IsFullscreen() && !fullscreen;
-
-  if (fullscreen) {
-    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-    NotifyWindowEnterFullScreen();
-  } else {
-    last_window_state_ = ui::SHOW_STATE_NORMAL;
-    NotifyWindowLeaveFullScreen();
-  }
-
-  // For window without WS_THICKFRAME style, we can not call SetFullscreen().
-  // This path will be used for transparent windows as well.
-  if (!thick_frame_) {
-    if (fullscreen) {
-      restore_bounds_ = GetBounds();
-      auto display =
-          display::Screen::GetScreen()->GetDisplayNearestPoint(GetPosition());
-      SetBounds(display.bounds(), false);
-    } else {
-      SetBounds(restore_bounds_, false);
-    }
-    return;
-  }
-
-  // We set the new value after notifying, so we can handle the size event
-  // correctly.
-  widget()->SetFullscreen(fullscreen);
-
-  // If restoring from fullscreen and the window isn't visible, force visible,
-  // else a non-responsive window shell could be rendered.
-  // (this situation may arise when app starts with fullscreen: true)
-  // Note: the following must be after "widget()->SetFullscreen(fullscreen);"
-  if (leaving_fullscreen && !IsVisible())
-    FlipWindowStyle(GetAcceleratedWidget(), true, WS_VISIBLE);
-#else
-  if (IsVisible())
-    widget()->SetFullscreen(fullscreen);
-  else if (fullscreen)
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_FULLSCREEN);
-
-  // Auto-hide menubar when in fullscreen.
-  if (fullscreen)
-    SetMenuBarVisibility(false);
-  else
-    SetMenuBarVisibility(!IsMenuBarAutoHide());
-#endif
-}
-
-bool NativeWindowViews::IsFullscreen() const {
-  return widget()->IsFullscreen();
-}
-
-void NativeWindowViews::SetBounds(const gfx::Rect& bounds, bool animate) {
-#if defined(OS_WIN) || defined(USE_X11)
-  // On Linux and Windows the minimum and maximum size should be updated with
-  // window size when window is not resizable.
-  if (!resizable_) {
-    SetMaximumSize(bounds.size());
-    SetMinimumSize(bounds.size());
-  }
-#endif
-
-  widget()->SetBounds(bounds);
-}
-
-gfx::Rect NativeWindowViews::GetBounds() {
-#if defined(OS_WIN)
-  if (IsMinimized())
-    return widget()->GetRestoredBounds();
-#endif
-
-  return widget()->GetWindowBoundsInScreen();
-}
-
-gfx::Rect NativeWindowViews::GetContentBounds() {
-  return content_view() ? content_view()->GetBoundsInScreen() : gfx::Rect();
-}
-
-gfx::Size NativeWindowViews::GetContentSize() {
-#if defined(OS_WIN)
-  if (IsMinimized())
-    return NativeWindow::GetContentSize();
-#endif
-
-  return content_view() ? content_view()->size() : gfx::Size();
-}
-
-void NativeWindowViews::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  NativeWindow::SetContentSizeConstraints(size_constraints);
-#if defined(OS_WIN)
-  // Changing size constraints would force adding the WS_THICKFRAME style, so
-  // do nothing if thickFrame is false.
-  if (!thick_frame_)
-    return;
-#endif
-  // widget_delegate() is only available after Init() is called, we make use of
-  // this to determine whether native widget has initialized.
-  if (widget() && widget()->widget_delegate())
-    widget()->OnSizeConstraintsChanged();
-  if (resizable_)
-    old_size_constraints_ = size_constraints;
-}
-
-void NativeWindowViews::SetResizable(bool resizable) {
-  if (resizable != resizable_) {
-    // On Linux there is no "resizable" property of a window, we have to set
-    // both the minimum and maximum size to the window size to achieve it.
-    if (resizable) {
-      SetContentSizeConstraints(old_size_constraints_);
-    } else {
-      old_size_constraints_ = GetContentSizeConstraints();
-      resizable_ = false;
-      gfx::Size content_size = GetContentSize();
-      SetContentSizeConstraints(
-          extensions::SizeConstraints(content_size, content_size));
-    }
-  }
-#if defined(OS_WIN)
-  if (has_frame() && thick_frame_)
-    FlipWindowStyle(GetAcceleratedWidget(), resizable, WS_THICKFRAME);
-#endif
-
-  resizable_ = resizable;
-}
-
-#if defined(OS_WIN)
-void NativeWindowViews::MoveTop() {
-  gfx::Point pos = GetPosition();
-  gfx::Size size = GetSize();
-  ::SetWindowPos(GetAcceleratedWidget(), HWND_TOP, pos.x(), pos.y(),
-                 size.width(), size.height(),
-                 SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
-}
-#endif
-
-bool NativeWindowViews::IsResizable() {
-#if defined(OS_WIN)
-  if (has_frame())
-    return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME;
-#endif
-  return CanResize();
-}
-
-void NativeWindowViews::SetMovable(bool movable) {
-  movable_ = movable;
-}
-
-bool NativeWindowViews::IsMovable() {
-#if defined(OS_WIN)
-  return movable_;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetMinimizable(bool minimizable) {
-#if defined(OS_WIN)
-  FlipWindowStyle(GetAcceleratedWidget(), minimizable, WS_MINIMIZEBOX);
-#endif
-  minimizable_ = minimizable;
-}
-
-bool NativeWindowViews::IsMinimizable() {
-#if defined(OS_WIN)
-  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MINIMIZEBOX;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetMaximizable(bool maximizable) {
-#if defined(OS_WIN)
-  FlipWindowStyle(GetAcceleratedWidget(), maximizable, WS_MAXIMIZEBOX);
-#endif
-  maximizable_ = maximizable;
-}
-
-bool NativeWindowViews::IsMaximizable() {
-#if defined(OS_WIN)
-  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MAXIMIZEBOX;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetFullScreenable(bool fullscreenable) {
-  fullscreenable_ = fullscreenable;
-}
-
-bool NativeWindowViews::IsFullScreenable() {
-  return fullscreenable_;
-}
-
-void NativeWindowViews::SetClosable(bool closable) {
-#if defined(OS_WIN)
-  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
-  if (closable) {
-    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
-  } else {
-    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
-  }
-#endif
-}
-
-bool NativeWindowViews::IsClosable() {
-#if defined(OS_WIN)
-  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
-  MENUITEMINFO info;
-  memset(&info, 0, sizeof(info));
-  info.cbSize = sizeof(info);
-  info.fMask = MIIM_STATE;
-  if (!GetMenuItemInfo(menu, SC_CLOSE, false, &info)) {
-    return false;
-  }
-  return !(info.fState & MFS_DISABLED);
-#elif defined(USE_X11)
-  return true;
-#endif
-}
-
-void NativeWindowViews::SetAlwaysOnTop(bool top,
-                                       const std::string& level,
-                                       int relativeLevel,
-                                       std::string* error) {
-  widget()->SetAlwaysOnTop(top);
-}
-
-bool NativeWindowViews::IsAlwaysOnTop() {
-  return widget()->IsAlwaysOnTop();
-}
-
-void NativeWindowViews::Center() {
-  widget()->CenterWindow(GetSize());
-}
-
-void NativeWindowViews::Invalidate() {
-  widget()->SchedulePaintInRect(gfx::Rect(GetBounds().size()));
-}
-
-void NativeWindowViews::SetTitle(const std::string& title) {
-  title_ = title;
-  widget()->UpdateWindowTitle();
-}
-
-std::string NativeWindowViews::GetTitle() {
-  return title_;
-}
-
-void NativeWindowViews::FlashFrame(bool flash) {
-#if defined(OS_WIN)
-  // The Chromium's implementation has a bug stopping flash.
-  if (!flash) {
-    FLASHWINFO fwi;
-    fwi.cbSize = sizeof(fwi);
-    fwi.hwnd = GetAcceleratedWidget();
-    fwi.dwFlags = FLASHW_STOP;
-    fwi.uCount = 0;
-    FlashWindowEx(&fwi);
-    return;
-  }
-#endif
-  widget()->FlashFrame(flash);
-}
-
-void NativeWindowViews::SetSkipTaskbar(bool skip) {
-#if defined(OS_WIN)
-  Microsoft::WRL::ComPtr<ITaskbarList> taskbar;
-  if (FAILED(::CoCreateInstance(CLSID_TaskbarList, nullptr,
-                                CLSCTX_INPROC_SERVER,
-                                IID_PPV_ARGS(&taskbar))) ||
-      FAILED(taskbar->HrInit()))
-    return;
-  if (skip) {
-    taskbar->DeleteTab(GetAcceleratedWidget());
-  } else {
-    taskbar->AddTab(GetAcceleratedWidget());
-    taskbar_host_.RestoreThumbarButtons(GetAcceleratedWidget());
-  }
-#elif defined(USE_X11)
-  SetWMSpecState(GetAcceleratedWidget(), skip,
-                 GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
-#endif
-}
-
-void NativeWindowViews::SetSimpleFullScreen(bool simple_fullscreen) {
-  SetFullScreen(simple_fullscreen);
-}
-
-bool NativeWindowViews::IsSimpleFullScreen() {
-  return IsFullscreen();
-}
-
-void NativeWindowViews::SetKiosk(bool kiosk) {
-  SetFullScreen(kiosk);
-}
-
-bool NativeWindowViews::IsKiosk() {
-  return IsFullscreen();
-}
-
-void NativeWindowViews::SetBackgroundColor(SkColor background_color) {
-  // web views' background color.
-  root_view_->SetBackground(views::CreateSolidBackground(background_color));
-
-#if defined(OS_WIN)
-  // Set the background color of native window.
-  HBRUSH brush = CreateSolidBrush(skia::SkColorToCOLORREF(background_color));
-  ULONG_PTR previous_brush =
-      SetClassLongPtr(GetAcceleratedWidget(), GCLP_HBRBACKGROUND,
-                      reinterpret_cast<LONG_PTR>(brush));
-  if (previous_brush)
-    DeleteObject((HBRUSH)previous_brush);
-#endif
-}
-
-void NativeWindowViews::SetHasShadow(bool has_shadow) {
-  wm::SetShadowElevation(GetNativeWindow(),
-                         has_shadow ? wm::kShadowElevationInactiveWindow
-                                    : wm::kShadowElevationNone);
-}
-
-bool NativeWindowViews::HasShadow() {
-  return GetNativeWindow()->GetProperty(wm::kShadowElevationKey) !=
-         wm::kShadowElevationNone;
-}
-
-void NativeWindowViews::SetOpacity(const double opacity) {
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  if (!layered_) {
-    LONG ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
-    ex_style |= WS_EX_LAYERED;
-    ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style);
-    layered_ = true;
-  }
-  ::SetLayeredWindowAttributes(hwnd, 0, opacity * 255, LWA_ALPHA);
-#endif
-  opacity_ = opacity;
-}
-
-double NativeWindowViews::GetOpacity() {
-  return opacity_;
-}
-
-void NativeWindowViews::SetIgnoreMouseEvents(bool ignore, bool forward) {
-#if defined(OS_WIN)
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (ignore)
-    ex_style |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
-  else
-    ex_style &= ~(WS_EX_TRANSPARENT | WS_EX_LAYERED);
-  if (layered_)
-    ex_style |= WS_EX_LAYERED;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-
-  // Forwarding is always disabled when not ignoring mouse messages.
-  if (!ignore) {
-    SetForwardMouseMessages(false);
-  } else {
-    SetForwardMouseMessages(forward);
-  }
-#elif defined(USE_X11)
-  if (ignore) {
-    XRectangle r = {0, 0, 1, 1};
-    XShapeCombineRectangles(gfx::GetXDisplay(), GetAcceleratedWidget(),
-                            ShapeInput, 0, 0, &r, 1, ShapeSet, YXBanded);
-  } else {
-    XShapeCombineMask(gfx::GetXDisplay(), GetAcceleratedWidget(), ShapeInput, 0,
-                      0, x11::None, ShapeSet);
-  }
-#endif
-}
-
-void NativeWindowViews::SetContentProtection(bool enable) {
-#if defined(OS_WIN)
-  DWORD affinity = enable ? WDA_MONITOR : WDA_NONE;
-  ::SetWindowDisplayAffinity(GetAcceleratedWidget(), affinity);
-#endif
-}
-
-void NativeWindowViews::SetFocusable(bool focusable) {
-#if defined(OS_WIN)
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (focusable)
-    ex_style &= ~WS_EX_NOACTIVATE;
-  else
-    ex_style |= WS_EX_NOACTIVATE;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-  SetSkipTaskbar(!focusable);
-  Focus(false);
-#endif
-}
-
-void NativeWindowViews::SetMenu(AtomMenuModel* menu_model) {
-#if defined(USE_X11)
-  if (menu_model == nullptr)
-    global_menu_bar_.reset();
-
-  if (!global_menu_bar_ && ShouldUseGlobalMenuBar())
-    global_menu_bar_.reset(new GlobalMenuBarX11(this));
-
-  // Use global application menu bar when possible.
-  if (global_menu_bar_ && global_menu_bar_->IsServerStarted()) {
-    global_menu_bar_->SetMenu(menu_model);
-    return;
-  }
-#endif
-
-  // Should reset content size when setting menu.
-  gfx::Size content_size = GetContentSize();
-  bool should_reset_size = use_content_size_ && has_frame() &&
-                           !IsMenuBarAutoHide() &&
-                           ((!!menu_model) != root_view_->HasMenu());
-
-  root_view_->SetMenu(menu_model);
-
-  if (should_reset_size) {
-    // Enlarge the size constraints for the menu.
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    extensions::SizeConstraints constraints = GetContentSizeConstraints();
-    if (constraints.HasMinimumSize()) {
-      gfx::Size min_size = constraints.GetMinimumSize();
-      min_size.set_height(min_size.height() + menu_bar_height);
-      constraints.set_minimum_size(min_size);
-    }
-    if (constraints.HasMaximumSize()) {
-      gfx::Size max_size = constraints.GetMaximumSize();
-      max_size.set_height(max_size.height() + menu_bar_height);
-      constraints.set_maximum_size(max_size);
-    }
-    SetContentSizeConstraints(constraints);
-
-    // Resize the window to make sure content size is not changed.
-    SetContentSize(content_size);
-  }
-}
-
-void NativeWindowViews::SetBrowserView(NativeBrowserView* view) {
-  if (!content_view())
-    return;
-
-  if (browser_view()) {
-    content_view()->RemoveChildView(
-        browser_view()->GetInspectableWebContentsView()->GetView());
-    set_browser_view(nullptr);
-  }
-
-  if (!view) {
-    return;
-  }
-
-  // Add as child of the main web view to avoid (0, 0) origin from overlapping
-  // with menu bar.
-  set_browser_view(view);
-  content_view()->AddChildView(
-      view->GetInspectableWebContentsView()->GetView());
-}
-
-void NativeWindowViews::SetParentWindow(NativeWindow* parent) {
-  NativeWindow::SetParentWindow(parent);
-
-#if defined(USE_X11)
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  XSetTransientForHint(
-      xdisplay, GetAcceleratedWidget(),
-      parent ? parent->GetAcceleratedWidget() : DefaultRootWindow(xdisplay));
-#elif defined(OS_WIN) && defined(DEBUG)
-  // Should work, but does not, it seems that the views toolkit doesn't support
-  // reparenting on desktop.
-  if (parent) {
-    ::SetParent(GetAcceleratedWidget(), parent->GetAcceleratedWidget());
-    views::Widget::ReparentNativeView(GetNativeWindow(),
-                                      parent->GetNativeWindow());
-    wm::AddTransientChild(parent->GetNativeWindow(), GetNativeWindow());
-  } else {
-    if (!GetNativeWindow()->parent())
-      return;
-    ::SetParent(GetAcceleratedWidget(), NULL);
-    views::Widget::ReparentNativeView(GetNativeWindow(), nullptr);
-    wm::RemoveTransientChild(GetNativeWindow()->parent(), GetNativeWindow());
-  }
-#endif
-}
-
-gfx::NativeView NativeWindowViews::GetNativeView() const {
-  return widget()->GetNativeView();
-}
-
-gfx::NativeWindow NativeWindowViews::GetNativeWindow() const {
-  return widget()->GetNativeWindow();
-}
-
-void NativeWindowViews::SetProgressBar(double progress,
-                                       NativeWindow::ProgressState state) {
-#if defined(OS_WIN)
-  taskbar_host_.SetProgressBar(GetAcceleratedWidget(), progress, state);
-#elif defined(USE_X11)
-  if (unity::IsRunning()) {
-    unity::SetProgressFraction(progress);
-  }
-#endif
-}
-
-void NativeWindowViews::SetOverlayIcon(const gfx::Image& overlay,
-                                       const std::string& description) {
-#if defined(OS_WIN)
-  taskbar_host_.SetOverlayIcon(GetAcceleratedWidget(), overlay, description);
-#endif
-}
-
-void NativeWindowViews::SetAutoHideMenuBar(bool auto_hide) {
-  root_view_->SetAutoHideMenuBar(auto_hide);
-}
-
-bool NativeWindowViews::IsMenuBarAutoHide() {
-  return root_view_->IsMenuBarAutoHide();
-}
-
-void NativeWindowViews::SetMenuBarVisibility(bool visible) {
-  root_view_->SetMenuBarVisibility(visible);
-}
-
-bool NativeWindowViews::IsMenuBarVisible() {
-  return root_view_->IsMenuBarVisible();
-}
-
-void NativeWindowViews::SetVisibleOnAllWorkspaces(bool visible) {
-  widget()->SetVisibleOnAllWorkspaces(visible);
-}
-
-bool NativeWindowViews::IsVisibleOnAllWorkspaces() {
-#if defined(USE_X11)
-  // Use the presence/absence of _NET_WM_STATE_STICKY in _NET_WM_STATE to
-  // determine whether the current window is visible on all workspaces.
-  XAtom sticky_atom = GetAtom("_NET_WM_STATE_STICKY");
-  std::vector<XAtom> wm_states;
-  ui::GetAtomArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", &wm_states);
-  return std::find(wm_states.begin(), wm_states.end(), sticky_atom) !=
-         wm_states.end();
-#endif
-  return false;
-}
-
-gfx::AcceleratedWidget NativeWindowViews::GetAcceleratedWidget() const {
-  return GetNativeWindow()->GetHost()->GetAcceleratedWidget();
-}
-
-gfx::Rect NativeWindowViews::ContentBoundsToWindowBounds(
-    const gfx::Rect& bounds) const {
-  if (!has_frame())
-    return bounds;
-
-  gfx::Rect window_bounds(bounds);
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  gfx::Rect dpi_bounds = display::win::ScreenWin::DIPToScreenRect(hwnd, bounds);
-  window_bounds = display::win::ScreenWin::ScreenToDIPRect(
-      hwnd,
-      widget()->non_client_view()->GetWindowBoundsForClientBounds(dpi_bounds));
-#endif
-
-  if (root_view_->HasMenu() && root_view_->IsMenuBarVisible()) {
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    window_bounds.set_y(window_bounds.y() - menu_bar_height);
-    window_bounds.set_height(window_bounds.height() + menu_bar_height);
-  }
-  return window_bounds;
-}
-
-gfx::Rect NativeWindowViews::WindowBoundsToContentBounds(
-    const gfx::Rect& bounds) const {
-  if (!has_frame())
-    return bounds;
-
-  gfx::Rect content_bounds(bounds);
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  content_bounds.set_size(
-      display::win::ScreenWin::DIPToScreenSize(hwnd, content_bounds.size()));
-  RECT rect;
-  SetRectEmpty(&rect);
-  DWORD style = ::GetWindowLong(hwnd, GWL_STYLE);
-  DWORD ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
-  AdjustWindowRectEx(&rect, style, FALSE, ex_style);
-  content_bounds.set_width(content_bounds.width() - (rect.right - rect.left));
-  content_bounds.set_height(content_bounds.height() - (rect.bottom - rect.top));
-  content_bounds.set_size(
-      display::win::ScreenWin::ScreenToDIPSize(hwnd, content_bounds.size()));
-#endif
-
-  if (root_view_->HasMenu() && root_view_->IsMenuBarVisible()) {
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    content_bounds.set_y(content_bounds.y() + menu_bar_height);
-    content_bounds.set_height(content_bounds.height() - menu_bar_height);
-  }
-  return content_bounds;
-}
-
-void NativeWindowViews::UpdateDraggableRegions(
-    std::unique_ptr<SkRegion> region) {
-  draggable_region_ = std::move(region);
-}
-
-#if defined(OS_WIN)
-void NativeWindowViews::SetIcon(HICON window_icon, HICON app_icon) {
-  // We are responsible for storing the images.
-  window_icon_ = base::win::ScopedHICON(CopyIcon(window_icon));
-  app_icon_ = base::win::ScopedHICON(CopyIcon(app_icon));
-
-  HWND hwnd = GetAcceleratedWidget();
-  SendMessage(hwnd, WM_SETICON, ICON_SMALL,
-              reinterpret_cast<LPARAM>(window_icon_.get()));
-  SendMessage(hwnd, WM_SETICON, ICON_BIG,
-              reinterpret_cast<LPARAM>(app_icon_.get()));
-}
-#elif defined(USE_X11)
-void NativeWindowViews::SetIcon(const gfx::ImageSkia& icon) {
-  auto* tree_host = static_cast<views::DesktopWindowTreeHost*>(
-      views::DesktopWindowTreeHostX11::GetHostForXID(GetAcceleratedWidget()));
-  tree_host->SetWindowIcons(icon, icon);
-}
-#endif
-
-void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,
-                                                  bool active) {
-  if (changed_widget != widget())
-    return;
-
-  // Post the notification to next tick.
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI, FROM_HERE,
-      base::Bind(active ? &NativeWindow::NotifyWindowFocus
-                        : &NativeWindow::NotifyWindowBlur,
-                 GetWeakPtr()));
-
-  // Hide menu bar when window is blured.
-  if (!active && IsMenuBarAutoHide() && IsMenuBarVisible())
-    SetMenuBarVisibility(false);
-
-  root_view_->ResetAltState();
-}
-
-void NativeWindowViews::OnWidgetBoundsChanged(views::Widget* changed_widget,
-                                              const gfx::Rect& bounds) {
-  if (changed_widget != widget())
-    return;
-
-  // Note: We intentionally use `GetBounds()` instead of `bounds` to properly
-  // handle minimized windows on Windows.
-  const auto new_bounds = GetBounds();
-  if (widget_size_ != new_bounds.size()) {
-    if (browser_view()) {
-      const auto flags = static_cast<NativeBrowserViewViews*>(browser_view())
-                             ->GetAutoResizeFlags();
-      int width_delta = 0;
-      int height_delta = 0;
-      if (flags & kAutoResizeWidth) {
-        width_delta = new_bounds.width() - widget_size_.width();
-      }
-      if (flags & kAutoResizeHeight) {
-        height_delta = new_bounds.height() - widget_size_.height();
-      }
-
-      auto* view = browser_view()->GetInspectableWebContentsView()->GetView();
-      auto new_view_size = view->size();
-      new_view_size.set_width(new_view_size.width() + width_delta);
-      new_view_size.set_height(new_view_size.height() + height_delta);
-      view->SetSize(new_view_size);
-    }
-
-    NotifyWindowResize();
-    widget_size_ = new_bounds.size();
-  }
-}
-
-void NativeWindowViews::DeleteDelegate() {
-  if (is_modal() && NativeWindow::parent()) {
-    auto* parent = NativeWindow::parent();
-    // Enable parent window after current window gets closed.
-    parent->SetEnabled(true);
-    // Focus on parent window.
-    parent->Focus(true);
-  }
-
-  NotifyWindowClosed();
-}
-
-views::View* NativeWindowViews::GetInitiallyFocusedView() {
-  return focused_view_;
-}
-
-bool NativeWindowViews::CanResize() const {
-  return resizable_;
-}
-
-bool NativeWindowViews::CanMaximize() const {
-  return resizable_ && maximizable_;
-}
-
-bool NativeWindowViews::CanMinimize() const {
-#if defined(OS_WIN)
-  return minimizable_;
-#elif defined(USE_X11)
-  return true;
-#endif
-}
-
-base::string16 NativeWindowViews::GetWindowTitle() const {
-  return base::UTF8ToUTF16(title_);
-}
-
-views::View* NativeWindowViews::GetContentsView() {
-  return root_view_.get();
-}
-
-bool NativeWindowViews::ShouldDescendIntoChildForEventHandling(
-    gfx::NativeView child,
-    const gfx::Point& location) {
-  // App window should claim mouse events that fall within the draggable region.
-  if (draggable_region() &&
-      draggable_region()->contains(location.x(), location.y()))
-    return false;
-
-  // And the events on border for dragging resizable frameless window.
-  if (!has_frame() && CanResize()) {
-    FramelessView* frame =
-        static_cast<FramelessView*>(widget()->non_client_view()->frame_view());
-    return frame->ResizingBorderHitTest(location) == HTNOWHERE;
-  }
-
-  return true;
-}
-
-views::ClientView* NativeWindowViews::CreateClientView(views::Widget* widget) {
-  return new NativeWindowClientView(widget, root_view_.get(), this);
-}
-
-views::NonClientFrameView* NativeWindowViews::CreateNonClientFrameView(
-    views::Widget* widget) {
-#if defined(OS_WIN)
-  WinFrameView* frame_view = new WinFrameView;
-  frame_view->Init(this, widget);
-  return frame_view;
-#else
-  if (has_frame()) {
-    return new NativeFrameView(this, widget);
-  } else {
-    FramelessView* frame_view = new FramelessView;
-    frame_view->Init(this, widget);
-    return frame_view;
-  }
-#endif
-}
-
-void NativeWindowViews::OnWidgetMove() {
-  NotifyWindowMove();
-}
-
-void NativeWindowViews::HandleKeyboardEvent(
-    content::WebContents*,
-    const content::NativeWebKeyboardEvent& event) {
-  keyboard_event_handler_->HandleKeyboardEvent(event,
-                                               root_view_->GetFocusManager());
-  root_view_->HandleKeyEvent(event);
-}
-
-ui::WindowShowState NativeWindowViews::GetRestoredState() {
-  if (IsMaximized())
-    return ui::SHOW_STATE_MAXIMIZED;
-  if (IsFullscreen())
-    return ui::SHOW_STATE_FULLSCREEN;
-
-  return ui::SHOW_STATE_NORMAL;
-}
-
-// static
-NativeWindow* NativeWindow::Create(const mate::Dictionary& options,
-                                   NativeWindow* parent) {
-  return new NativeWindowViews(options, parent);
-}
-
-}  // namespace atom
removed in remote
  base   100644 862cd5458bb67bd8089dcf48e590691fb3e1e9e6 atom/browser/native_window_views.h
  our    100644 ef1e4413ca879980e46f301bccd6c8fe2b1a4611 atom/browser/native_window_views.h
@@ -1,289 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
-
-#include "atom/browser/native_window.h"
-
-#include <set>
-#include <string>
-
-#include "ui/views/widget/widget_observer.h"
-
-#if defined(OS_WIN)
-#include "atom/browser/ui/win/message_handler_delegate.h"
-#include "atom/browser/ui/win/taskbar_host.h"
-#include "base/win/scoped_gdi_object.h"
-#endif
-
-namespace views {
-class UnhandledKeyboardEventHandler;
-}
-
-namespace atom {
-
-class GlobalMenuBarX11;
-class RootView;
-class WindowStateWatcher;
-
-#if defined(OS_WIN)
-class AtomDesktopWindowTreeHostWin;
-#elif defined(USE_X11)
-class EventDisabler;
-#endif
-
-class NativeWindowViews : public NativeWindow,
-#if defined(OS_WIN)
-                          public MessageHandlerDelegate,
-#endif
-                          public views::WidgetObserver {
- public:
-  NativeWindowViews(const mate::Dictionary& options, NativeWindow* parent);
-  ~NativeWindowViews() override;
-
-  // NativeWindow:
-  void SetContentView(views::View* view) override;
-  void Close() override;
-  void CloseImmediately() override;
-  void Focus(bool focus) override;
-  bool IsFocused() override;
-  void Show() override;
-  void ShowInactive() override;
-  void Hide() override;
-  bool IsVisible() override;
-  bool IsEnabled() override;
-  void SetEnabled(bool enable) override;
-  void Maximize() override;
-  void Unmaximize() override;
-  bool IsMaximized() override;
-  void Minimize() override;
-  void Restore() override;
-  bool IsMinimized() override;
-  void SetFullScreen(bool fullscreen) override;
-  bool IsFullscreen() const override;
-  void SetBounds(const gfx::Rect& bounds, bool animate) override;
-  gfx::Rect GetBounds() override;
-  gfx::Rect GetContentBounds() override;
-  gfx::Size GetContentSize() override;
-  void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints) override;
-  void SetResizable(bool resizable) override;
-#if defined(OS_WIN)
-  void MoveTop() override;
-#endif
-  bool IsResizable() override;
-  void SetMovable(bool movable) override;
-  bool IsMovable() override;
-  void SetMinimizable(bool minimizable) override;
-  bool IsMinimizable() override;
-  void SetMaximizable(bool maximizable) override;
-  bool IsMaximizable() override;
-  void SetFullScreenable(bool fullscreenable) override;
-  bool IsFullScreenable() override;
-  void SetClosable(bool closable) override;
-  bool IsClosable() override;
-  void SetAlwaysOnTop(bool top,
-                      const std::string& level,
-                      int relativeLevel,
-                      std::string* error) override;
-  bool IsAlwaysOnTop() override;
-  void Center() override;
-  void Invalidate() override;
-  void SetTitle(const std::string& title) override;
-  std::string GetTitle() override;
-  void FlashFrame(bool flash) override;
-  void SetSkipTaskbar(bool skip) override;
-  void SetSimpleFullScreen(bool simple_fullscreen) override;
-  bool IsSimpleFullScreen() override;
-  void SetKiosk(bool kiosk) override;
-  bool IsKiosk() override;
-  void SetBackgroundColor(SkColor color) override;
-  void SetHasShadow(bool has_shadow) override;
-  bool HasShadow() override;
-  void SetOpacity(const double opacity) override;
-  double GetOpacity() override;
-  void SetIgnoreMouseEvents(bool ignore, bool forward) override;
-  void SetContentProtection(bool enable) override;
-  void SetFocusable(bool focusable) override;
-  void SetMenu(AtomMenuModel* menu_model) override;
-  void SetBrowserView(NativeBrowserView* browser_view) override;
-  void SetParentWindow(NativeWindow* parent) override;
-  gfx::NativeView GetNativeView() const override;
-  gfx::NativeWindow GetNativeWindow() const override;
-  void SetOverlayIcon(const gfx::Image& overlay,
-                      const std::string& description) override;
-  void SetProgressBar(double progress, const ProgressState state) override;
-  void SetAutoHideMenuBar(bool auto_hide) override;
-  bool IsMenuBarAutoHide() override;
-  void SetMenuBarVisibility(bool visible) override;
-  bool IsMenuBarVisible() override;
-  void SetVisibleOnAllWorkspaces(bool visible) override;
-  bool IsVisibleOnAllWorkspaces() override;
-
-  gfx::AcceleratedWidget GetAcceleratedWidget() const override;
-
-  gfx::Rect ContentBoundsToWindowBounds(const gfx::Rect& bounds) const override;
-  gfx::Rect WindowBoundsToContentBounds(const gfx::Rect& bounds) const override;
-
-  void UpdateDraggableRegions(std::unique_ptr<SkRegion> region);
-
-#if defined(OS_WIN)
-  void SetIcon(HICON small_icon, HICON app_icon);
-#elif defined(USE_X11)
-  void SetIcon(const gfx::ImageSkia& icon);
-#endif
-
-  SkRegion* draggable_region() const { return draggable_region_.get(); }
-
-#if defined(OS_WIN)
-  TaskbarHost& taskbar_host() { return taskbar_host_; }
-#endif
-
- private:
-  // views::WidgetObserver:
-  void OnWidgetActivationChanged(views::Widget* widget, bool active) override;
-  void OnWidgetBoundsChanged(views::Widget* widget,
-                             const gfx::Rect& bounds) override;
-
-  // views::WidgetDelegate:
-  void DeleteDelegate() override;
-  views::View* GetInitiallyFocusedView() override;
-  bool CanResize() const override;
-  bool CanMaximize() const override;
-  bool CanMinimize() const override;
-  base::string16 GetWindowTitle() const override;
-  views::View* GetContentsView() override;
-  bool ShouldDescendIntoChildForEventHandling(
-      gfx::NativeView child,
-      const gfx::Point& location) override;
-  views::ClientView* CreateClientView(views::Widget* widget) override;
-  views::NonClientFrameView* CreateNonClientFrameView(
-      views::Widget* widget) override;
-  void OnWidgetMove() override;
-#if defined(OS_WIN)
-  bool ExecuteWindowsCommand(int command_id) override;
-#endif
-
-#if defined(OS_WIN)
-  // MessageHandlerDelegate:
-  bool PreHandleMSG(UINT message,
-                    WPARAM w_param,
-                    LPARAM l_param,
-                    LRESULT* result) override;
-  void HandleSizeEvent(WPARAM w_param, LPARAM l_param);
-  void SetForwardMouseMessages(bool forward);
-  static LRESULT CALLBACK SubclassProc(HWND hwnd,
-                                       UINT msg,
-                                       WPARAM w_param,
-                                       LPARAM l_param,
-                                       UINT_PTR subclass_id,
-                                       DWORD_PTR ref_data);
-  static LRESULT CALLBACK MouseHookProc(int n_code,
-                                        WPARAM w_param,
-                                        LPARAM l_param);
-#endif
-
-  // NativeWindow:
-  void HandleKeyboardEvent(
-      content::WebContents*,
-      const content::NativeWebKeyboardEvent& event) override;
-
-  // Returns the restore state for the window.
-  ui::WindowShowState GetRestoredState();
-
-  std::unique_ptr<RootView> root_view_;
-
-  // The view should be focused by default.
-  views::View* focused_view_ = nullptr;
-
-  // The "resizable" flag on Linux is implemented by setting size constraints,
-  // we need to make sure size constraints are restored when window becomes
-  // resizable again. This is also used on Windows, to keep taskbar resize
-  // events from resizing the window.
-  extensions::SizeConstraints old_size_constraints_;
-
-#if defined(USE_X11)
-  std::unique_ptr<GlobalMenuBarX11> global_menu_bar_;
-
-  // Handles window state events.
-  std::unique_ptr<WindowStateWatcher> window_state_watcher_;
-
-  // To disable the mouse events.
-  std::unique_ptr<EventDisabler> event_disabler_;
-#endif
-
-#if defined(OS_WIN)
-  // Weak ref.
-  AtomDesktopWindowTreeHostWin* atom_desktop_window_tree_host_win_;
-
-  ui::WindowShowState last_window_state_;
-
-  // There's an issue with restore on Windows, that sometimes causes the Window
-  // to receive the wrong size (#2498). To circumvent that, we keep tabs on the
-  // size of the window while in the normal state (not maximized, minimized or
-  // fullscreen), so we restore it correctly.
-  gfx::Rect last_normal_bounds_;
-  gfx::Rect last_normal_bounds_before_move_;
-
-  // last_normal_bounds_ may or may not require update on WM_MOVE. When a
-  // window is maximized, it is moved (WM_MOVE) to maximum size first and then
-  // sized (WM_SIZE). In this case, last_normal_bounds_ should not update. We
-  // keep last_normal_bounds_candidate_ as a candidate which will become valid
-  // last_normal_bounds_ if the moves are consecutive with no WM_SIZE event in
-  // between.
-  gfx::Rect last_normal_bounds_candidate_;
-
-  bool consecutive_moves_;
-
-  // In charge of running taskbar related APIs.
-  TaskbarHost taskbar_host_;
-
-  // Memoized version of a11y check
-  bool checked_for_a11y_support_ = false;
-
-  // Whether to show the WS_THICKFRAME style.
-  bool thick_frame_ = true;
-
-  // The bounds of window before maximize/fullscreen.
-  gfx::Rect restore_bounds_;
-
-  // The icons of window and taskbar.
-  base::win::ScopedHICON window_icon_;
-  base::win::ScopedHICON app_icon_;
-
-  // The set of windows currently forwarding mouse messages.
-  static std::set<NativeWindowViews*> forwarding_windows_;
-  static HHOOK mouse_hook_;
-  bool forwarding_mouse_messages_ = false;
-  HWND legacy_window_ = NULL;
-  bool layered_ = false;
-#endif
-
-  // Handles unhandled keyboard messages coming back from the renderer process.
-  std::unique_ptr<views::UnhandledKeyboardEventHandler> keyboard_event_handler_;
-
-  // For custom drag, the whole window is non-draggable and the draggable region
-  // has to been explicitly provided.
-  std::unique_ptr<SkRegion> draggable_region_;  // used in custom drag.
-
-  // How many times the Disable has been called.
-  int disable_count_ = 0;
-
-  bool use_content_size_ = false;
-  bool movable_ = true;
-  bool resizable_ = true;
-  bool maximizable_ = true;
-  bool minimizable_ = true;
-  bool fullscreenable_ = true;
-  std::string title_;
-  gfx::Size widget_size_;
-  double opacity_ = 1.0;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowViews);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
removed in remote
  base   100644 e5ed1975f80f918eb37257f8b244f4cdf3eafc88 atom/browser/native_window_views_win.cc
  our    100644 0e61d18b915924eb3d3d14e40d1cbbd199631bed atom/browser/native_window_views_win.cc
@@ -1,386 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_views.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "ui/base/win/accessibility_misc_utils.h"
-
-// Must be included after other Windows headers.
-#include <UIAutomationCoreApi.h>
-
-namespace atom {
-
-namespace {
-
-// Convert Win32 WM_APPCOMMANDS to strings.
-const char* AppCommandToString(int command_id) {
-  switch (command_id) {
-    case APPCOMMAND_BROWSER_BACKWARD:
-      return "browser-backward";
-    case APPCOMMAND_BROWSER_FORWARD:
-      return "browser-forward";
-    case APPCOMMAND_BROWSER_REFRESH:
-      return "browser-refresh";
-    case APPCOMMAND_BROWSER_STOP:
-      return "browser-stop";
-    case APPCOMMAND_BROWSER_SEARCH:
-      return "browser-search";
-    case APPCOMMAND_BROWSER_FAVORITES:
-      return "browser-favorites";
-    case APPCOMMAND_BROWSER_HOME:
-      return "browser-home";
-    case APPCOMMAND_VOLUME_MUTE:
-      return "volume-mute";
-    case APPCOMMAND_VOLUME_DOWN:
-      return "volume-down";
-    case APPCOMMAND_VOLUME_UP:
-      return "volume-up";
-    case APPCOMMAND_MEDIA_NEXTTRACK:
-      return "media-nexttrack";
-    case APPCOMMAND_MEDIA_PREVIOUSTRACK:
-      return "media-previoustrack";
-    case APPCOMMAND_MEDIA_STOP:
-      return "media-stop";
-    case APPCOMMAND_MEDIA_PLAY_PAUSE:
-      return "media-play-pause";
-    case APPCOMMAND_LAUNCH_MAIL:
-      return "launch-mail";
-    case APPCOMMAND_LAUNCH_MEDIA_SELECT:
-      return "launch-media-select";
-    case APPCOMMAND_LAUNCH_APP1:
-      return "launch-app1";
-    case APPCOMMAND_LAUNCH_APP2:
-      return "launch-app2";
-    case APPCOMMAND_BASS_DOWN:
-      return "bass-down";
-    case APPCOMMAND_BASS_BOOST:
-      return "bass-boost";
-    case APPCOMMAND_BASS_UP:
-      return "bass-up";
-    case APPCOMMAND_TREBLE_DOWN:
-      return "treble-down";
-    case APPCOMMAND_TREBLE_UP:
-      return "treble-up";
-    case APPCOMMAND_MICROPHONE_VOLUME_MUTE:
-      return "microphone-volume-mute";
-    case APPCOMMAND_MICROPHONE_VOLUME_DOWN:
-      return "microphone-volume-down";
-    case APPCOMMAND_MICROPHONE_VOLUME_UP:
-      return "microphone-volume-up";
-    case APPCOMMAND_HELP:
-      return "help";
-    case APPCOMMAND_FIND:
-      return "find";
-    case APPCOMMAND_NEW:
-      return "new";
-    case APPCOMMAND_OPEN:
-      return "open";
-    case APPCOMMAND_CLOSE:
-      return "close";
-    case APPCOMMAND_SAVE:
-      return "save";
-    case APPCOMMAND_PRINT:
-      return "print";
-    case APPCOMMAND_UNDO:
-      return "undo";
-    case APPCOMMAND_REDO:
-      return "redo";
-    case APPCOMMAND_COPY:
-      return "copy";
-    case APPCOMMAND_CUT:
-      return "cut";
-    case APPCOMMAND_PASTE:
-      return "paste";
-    case APPCOMMAND_REPLY_TO_MAIL:
-      return "reply-to-mail";
-    case APPCOMMAND_FORWARD_MAIL:
-      return "forward-mail";
-    case APPCOMMAND_SEND_MAIL:
-      return "send-mail";
-    case APPCOMMAND_SPELL_CHECK:
-      return "spell-check";
-    case APPCOMMAND_MIC_ON_OFF_TOGGLE:
-      return "mic-on-off-toggle";
-    case APPCOMMAND_CORRECTION_LIST:
-      return "correction-list";
-    case APPCOMMAND_MEDIA_PLAY:
-      return "media-play";
-    case APPCOMMAND_MEDIA_PAUSE:
-      return "media-pause";
-    case APPCOMMAND_MEDIA_RECORD:
-      return "media-record";
-    case APPCOMMAND_MEDIA_FAST_FORWARD:
-      return "media-fast-forward";
-    case APPCOMMAND_MEDIA_REWIND:
-      return "media-rewind";
-    case APPCOMMAND_MEDIA_CHANNEL_UP:
-      return "media-channel-up";
-    case APPCOMMAND_MEDIA_CHANNEL_DOWN:
-      return "media-channel-down";
-    case APPCOMMAND_DELETE:
-      return "delete";
-    case APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE:
-      return "dictate-or-command-control-toggle";
-    default:
-      return "unknown";
-  }
-}
-
-bool IsScreenReaderActive() {
-  UINT screenReader = 0;
-  SystemParametersInfo(SPI_GETSCREENREADER, 0, &screenReader, 0);
-  return screenReader && UiaClientsAreListening();
-}
-
-}  // namespace
-
-std::set<NativeWindowViews*> NativeWindowViews::forwarding_windows_;
-HHOOK NativeWindowViews::mouse_hook_ = NULL;
-
-bool NativeWindowViews::ExecuteWindowsCommand(int command_id) {
-  std::string command = AppCommandToString(command_id);
-  NotifyWindowExecuteWindowsCommand(command);
-
-  return false;
-}
-
-bool NativeWindowViews::PreHandleMSG(UINT message,
-                                     WPARAM w_param,
-                                     LPARAM l_param,
-                                     LRESULT* result) {
-  NotifyWindowMessage(message, w_param, l_param);
-
-  switch (message) {
-    // Screen readers send WM_GETOBJECT in order to get the accessibility
-    // object, so take this opportunity to push Chromium into accessible
-    // mode if it isn't already, always say we didn't handle the message
-    // because we still want Chromium to handle returning the actual
-    // accessibility object.
-    case WM_GETOBJECT: {
-      if (checked_for_a11y_support_)
-        return false;
-
-      const DWORD obj_id = static_cast<DWORD>(l_param);
-
-      if (obj_id != static_cast<DWORD>(OBJID_CLIENT)) {
-        return false;
-      }
-
-      if (!IsScreenReaderActive()) {
-        return false;
-      }
-
-      checked_for_a11y_support_ = true;
-
-      auto* const axState = content::BrowserAccessibilityState::GetInstance();
-      if (axState && !axState->IsAccessibleBrowser()) {
-        axState->OnScreenReaderDetected();
-        Browser::Get()->OnAccessibilitySupportChanged();
-      }
-
-      return false;
-    }
-    case WM_COMMAND:
-      // Handle thumbar button click message.
-      if (HIWORD(w_param) == THBN_CLICKED)
-        return taskbar_host_.HandleThumbarButtonEvent(LOWORD(w_param));
-      return false;
-    case WM_SIZING: {
-      bool prevent_default = false;
-      NotifyWindowWillResize(gfx::Rect(*reinterpret_cast<RECT*>(l_param)),
-                             &prevent_default);
-      if (prevent_default) {
-        ::GetWindowRect(GetAcceleratedWidget(),
-                        reinterpret_cast<RECT*>(l_param));
-      }
-      return false;
-    }
-    case WM_SIZE: {
-      // Handle window state change.
-      HandleSizeEvent(w_param, l_param);
-
-      consecutive_moves_ = false;
-      last_normal_bounds_before_move_ = last_normal_bounds_;
-
-      return false;
-    }
-    case WM_MOVING: {
-      if (!movable_)
-        ::GetWindowRect(GetAcceleratedWidget(),
-                        reinterpret_cast<RECT*>(l_param));
-      return false;
-    }
-    case WM_MOVE: {
-      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
-        if (consecutive_moves_)
-          last_normal_bounds_ = last_normal_bounds_candidate_;
-        last_normal_bounds_candidate_ = GetBounds();
-        consecutive_moves_ = true;
-      }
-      return false;
-    }
-    case WM_ENDSESSION: {
-      if (w_param) {
-        NotifyWindowEndSession();
-      }
-      return false;
-    }
-    case WM_PARENTNOTIFY: {
-      if (LOWORD(w_param) == WM_CREATE) {
-        // Because of reasons regarding legacy drivers and stuff, a window that
-        // matches the client area is created and used internally by Chromium.
-        // This is used when forwarding mouse messages. We only cache the first
-        // occurrence (the webview window) because dev tools also cause this
-        // message to be sent.
-        if (!legacy_window_) {
-          legacy_window_ = reinterpret_cast<HWND>(l_param);
-        }
-      }
-      return false;
-    }
-    default:
-      return false;
-  }
-}
-
-void NativeWindowViews::HandleSizeEvent(WPARAM w_param, LPARAM l_param) {
-  // Here we handle the WM_SIZE event in order to figure out what is the current
-  // window state and notify the user accordingly.
-  switch (w_param) {
-    case SIZE_MAXIMIZED:
-      last_window_state_ = ui::SHOW_STATE_MAXIMIZED;
-      if (consecutive_moves_) {
-        last_normal_bounds_ = last_normal_bounds_before_move_;
-      }
-      NotifyWindowMaximize();
-      break;
-    case SIZE_MINIMIZED:
-      last_window_state_ = ui::SHOW_STATE_MINIMIZED;
-      NotifyWindowMinimize();
-      break;
-    case SIZE_RESTORED:
-      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
-        // Window was resized so we save it's new size.
-        last_normal_bounds_ = GetBounds();
-        last_normal_bounds_before_move_ = last_normal_bounds_;
-      } else {
-        switch (last_window_state_) {
-          case ui::SHOW_STATE_MAXIMIZED:
-            last_window_state_ = ui::SHOW_STATE_NORMAL;
-
-            // Don't force out last known bounds onto the window as Windows
-            // actually gets these correct
-
-            NotifyWindowUnmaximize();
-            break;
-          case ui::SHOW_STATE_MINIMIZED:
-            if (IsFullscreen()) {
-              last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-              NotifyWindowEnterFullScreen();
-            } else {
-              last_window_state_ = ui::SHOW_STATE_NORMAL;
-
-              // When the window is restored we resize it to the previous known
-              // normal size.
-              SetBounds(last_normal_bounds_, false);
-
-              NotifyWindowRestore();
-            }
-            break;
-          default:
-            break;
-        }
-      }
-      break;
-  }
-}
-
-void NativeWindowViews::SetForwardMouseMessages(bool forward) {
-  if (forward && !forwarding_mouse_messages_) {
-    forwarding_mouse_messages_ = true;
-    forwarding_windows_.insert(this);
-
-    // Subclassing is used to fix some issues when forwarding mouse messages;
-    // see comments in |SubclassProc|.
-    SetWindowSubclass(legacy_window_, SubclassProc, 1,
-                      reinterpret_cast<DWORD_PTR>(this));
-
-    if (!mouse_hook_) {
-      mouse_hook_ = SetWindowsHookEx(WH_MOUSE_LL, MouseHookProc, NULL, 0);
-    }
-  } else if (!forward && forwarding_mouse_messages_) {
-    forwarding_mouse_messages_ = false;
-    forwarding_windows_.erase(this);
-
-    RemoveWindowSubclass(legacy_window_, SubclassProc, 1);
-
-    if (forwarding_windows_.size() == 0) {
-      UnhookWindowsHookEx(mouse_hook_);
-      mouse_hook_ = NULL;
-    }
-  }
-}
-
-LRESULT CALLBACK NativeWindowViews::SubclassProc(HWND hwnd,
-                                                 UINT msg,
-                                                 WPARAM w_param,
-                                                 LPARAM l_param,
-                                                 UINT_PTR subclass_id,
-                                                 DWORD_PTR ref_data) {
-  NativeWindowViews* window = reinterpret_cast<NativeWindowViews*>(ref_data);
-  switch (msg) {
-    case WM_MOUSELEAVE: {
-      // When input is forwarded to underlying windows, this message is posted.
-      // If not handled, it interferes with Chromium logic, causing for example
-      // mouseleave events to fire. If those events are used to exit forward
-      // mode, excessive flickering on for example hover items in underlying
-      // windows can occur due to rapidly entering and leaving forwarding mode.
-      // By consuming and ignoring the message, we're essentially telling
-      // Chromium that we have not left the window despite somebody else getting
-      // the messages. As to why this is catched for the legacy window and not
-      // the actual browser window is simply that the legacy window somehow
-      // makes use of these events; posting to the main window didn't work.
-      if (window->forwarding_mouse_messages_) {
-        return 0;
-      }
-      break;
-    }
-  }
-
-  return DefSubclassProc(hwnd, msg, w_param, l_param);
-}
-
-LRESULT CALLBACK NativeWindowViews::MouseHookProc(int n_code,
-                                                  WPARAM w_param,
-                                                  LPARAM l_param) {
-  if (n_code < 0) {
-    return CallNextHookEx(NULL, n_code, w_param, l_param);
-  }
-
-  // Post a WM_MOUSEMOVE message for those windows whose client area contains
-  // the cursor since they are in a state where they would otherwise ignore all
-  // mouse input.
-  if (w_param == WM_MOUSEMOVE) {
-    for (auto* window : forwarding_windows_) {
-      // At first I considered enumerating windows to check whether the cursor
-      // was directly above the window, but since nothing bad seems to happen
-      // if we post the message even if some other window occludes it I have
-      // just left it as is.
-      RECT client_rect;
-      GetClientRect(window->legacy_window_, &client_rect);
-      POINT p = reinterpret_cast<MSLLHOOKSTRUCT*>(l_param)->pt;
-      ScreenToClient(window->legacy_window_, &p);
-      if (PtInRect(&client_rect, p)) {
-        WPARAM w = 0;  // No virtual keys pressed for our purposes
-        LPARAM l = MAKELPARAM(p.x, p.y);
-        PostMessage(window->legacy_window_, WM_MOUSEMOVE, w, l);
-      }
-    }
-  }
-
-  return CallNextHookEx(NULL, n_code, w_param, l_param);
-}
-
-}  // namespace atom
removed in remote
  base   100644 324f8339c8c9d8431480e185e1b24f468f1c7421 atom/browser/net/asar/asar_protocol_handler.cc
  our    100644 c2f53fa9d10881b0c5d68eff2b9ce628603bd8e1 atom/browser/net/asar/asar_protocol_handler.cc
@@ -1,33 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/asar/asar_protocol_handler.h"
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-#include "net/base/filename_util.h"
-#include "net/base/net_errors.h"
-
-namespace asar {
-
-AsarProtocolHandler::AsarProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
-
-AsarProtocolHandler::~AsarProtocolHandler() {}
-
-net::URLRequestJob* AsarProtocolHandler::MaybeCreateJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  base::FilePath full_path;
-  net::FileURLToFilePath(request->url(), &full_path);
-  auto* job = new URLRequestAsarJob(request, network_delegate);
-  job->Initialize(file_task_runner_, full_path);
-  return job;
-}
-
-bool AsarProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
-  return false;
-}
-
-}  // namespace asar
removed in remote
  base   100644 e0cb74d5d1bf46ace38e6c0e5e62e90f5b6d4ba0 atom/browser/net/asar/asar_protocol_handler.h
  our    100644 f431b55b71709c2f2932375fc992bf526a2d44d2 atom/browser/net/asar/asar_protocol_handler.h
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
-#define ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
-
-#include "base/memory/ref_counted.h"
-#include "net/url_request/url_request_job_factory.h"
-
-namespace base {
-class TaskRunner;
-}
-
-namespace asar {
-
-class AsarProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
- public:
-  explicit AsarProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
-  ~AsarProtocolHandler() override;
-
-  // net::URLRequestJobFactory::ProtocolHandler:
-  net::URLRequestJob* MaybeCreateJob(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  bool IsSafeRedirectTarget(const GURL& location) const override;
-
- private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(AsarProtocolHandler);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
removed in remote
  base   100644 39e55a35cbcec0504510f0b34153382677d33e7f atom/browser/net/asar/url_request_asar_job.cc
  our    100644 85eb2e1dd142b6d64aafb5350ae47603db989e8f atom/browser/net/asar/url_request_asar_job.cc
@@ -1,334 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/archive.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/atom_constants.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_util.h"
-#include "base/synchronization/lock.h"
-#include "base/task_runner.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_flags.h"
-#include "net/base/mime_util.h"
-#include "net/base/net_errors.h"
-#include "net/filter/gzip_source_stream.h"
-#include "net/http/http_util.h"
-#include "net/url_request/url_request_status.h"
-
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
-namespace asar {
-
-URLRequestAsarJob::FileMetaInfo::FileMetaInfo() = default;
-
-URLRequestAsarJob::URLRequestAsarJob(net::URLRequest* request,
-                                     net::NetworkDelegate* network_delegate)
-    : net::URLRequestJob(request, network_delegate), weak_ptr_factory_(this) {}
-
-URLRequestAsarJob::~URLRequestAsarJob() {}
-
-void URLRequestAsarJob::Initialize(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    const base::FilePath& file_path) {
-  // Determine whether it is an asar file.
-  base::FilePath asar_path, relative_path;
-  if (!GetAsarArchivePath(file_path, &asar_path, &relative_path)) {
-    InitializeFileJob(file_task_runner, file_path);
-    return;
-  }
-
-  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
-  Archive::FileInfo file_info;
-  if (!archive || !archive->GetFileInfo(relative_path, &file_info)) {
-    type_ = TYPE_ERROR;
-    return;
-  }
-
-  if (file_info.unpacked) {
-    base::FilePath real_path;
-    archive->CopyFileOut(relative_path, &real_path);
-    InitializeFileJob(file_task_runner, real_path);
-    return;
-  }
-
-  InitializeAsarJob(file_task_runner, archive, relative_path, file_info);
-}
-
-void URLRequestAsarJob::InitializeAsarJob(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    std::shared_ptr<Archive> archive,
-    const base::FilePath& file_path,
-    const Archive::FileInfo& file_info) {
-  type_ = TYPE_ASAR;
-  file_task_runner_ = file_task_runner;
-  stream_.reset(new net::FileStream(file_task_runner_));
-  archive_ = archive;
-  file_path_ = file_path;
-  file_info_ = file_info;
-}
-
-void URLRequestAsarJob::InitializeFileJob(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    const base::FilePath& file_path) {
-  type_ = TYPE_FILE;
-  file_task_runner_ = file_task_runner;
-  stream_.reset(new net::FileStream(file_task_runner_));
-  file_path_ = file_path;
-}
-
-void URLRequestAsarJob::Start() {
-  if (type_ == TYPE_ASAR || type_ == TYPE_FILE) {
-    auto* meta_info = new FileMetaInfo();
-    if (type_ == TYPE_ASAR) {
-      meta_info->file_path = archive_->path();
-      meta_info->file_exists = true;
-      meta_info->is_directory = false;
-      meta_info->file_size = file_info_.size;
-    }
-    file_task_runner_->PostTaskAndReply(
-        FROM_HERE,
-        base::BindOnce(&URLRequestAsarJob::FetchMetaInfo, file_path_, type_,
-                       base::Unretained(meta_info)),
-        base::BindOnce(&URLRequestAsarJob::DidFetchMetaInfo,
-                       weak_ptr_factory_.GetWeakPtr(), base::Owned(meta_info)));
-  } else {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(&URLRequestAsarJob::DidOpen,
-                                  weak_ptr_factory_.GetWeakPtr(),
-                                  net::ERR_FILE_NOT_FOUND));
-  }
-}
-
-void URLRequestAsarJob::Kill() {
-  stream_.reset();
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
-}
-
-int URLRequestAsarJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size)
-    return 0;
-
-  int rv = stream_->Read(
-      dest, dest_size,
-      base::Bind(&URLRequestAsarJob::DidRead, weak_ptr_factory_.GetWeakPtr(),
-                 WrapRefCounted(dest)));
-  if (rv >= 0) {
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  return rv;
-}
-
-bool URLRequestAsarJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  if (type_ != TYPE_FILE)
-    return false;
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!base::LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = net::FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
-  return false;
-#endif
-}
-
-std::unique_ptr<net::SourceStream> URLRequestAsarJob::SetUpSourceStream() {
-  std::unique_ptr<net::SourceStream> source =
-      net::URLRequestJob::SetUpSourceStream();
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return base::LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-             ? net::GzipSourceStream::Create(std::move(source),
-                                             net::SourceStream::TYPE_GZIP)
-             : std::move(source);
-}
-
-bool URLRequestAsarJob::GetMimeType(std::string* mime_type) const {
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
-}
-
-void URLRequestAsarJob::SetExtraRequestHeaders(
-    const net::HttpRequestHeaders& headers) {
-  std::string range_header;
-  if (headers.GetHeader(net::HttpRequestHeaders::kRange, &range_header)) {
-    // This job only cares about the Range header. This method stashes the value
-    // for later use in DidOpen(), which is responsible for some of the range
-    // validation as well. NotifyStartError is not legal to call here since
-    // the job has not started.
-    std::vector<net::HttpByteRange> ranges;
-    if (net::HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        range_parse_result_ = net::ERR_REQUEST_RANGE_NOT_SATISFIABLE;
-      }
-    }
-  }
-}
-
-int URLRequestAsarJob::GetResponseCode() const {
-  // Request Job gets created only if path exists.
-  return 200;
-}
-
-void URLRequestAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(atom::kCORSHeader);
-  info->headers = headers;
-}
-
-void URLRequestAsarJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      JobType type,
-                                      FileMetaInfo* meta_info) {
-  if (type == TYPE_FILE) {
-    base::File::Info file_info;
-    meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-    if (meta_info->file_exists) {
-      meta_info->file_path = file_path;
-      meta_info->file_size = file_info.size;
-      meta_info->is_directory = file_info.is_directory;
-    }
-  }
-
-  // We use GetWellKnownMimeTypeFromExtension() to ensure that configurations
-  // that may have been set by other programs on a user's machine don't affect
-  // the mime type returned (in particular, JS should always be
-  // (application/javascript). See https://crbug.com/797712. Using an accurate
-  // mime type is necessary at least for modules and sw, which enforce strict
-  // mime type requirements.
-  // TODO(deepak1556): Revert this when sw support is removed for file scheme.
-  base::FilePath::StringType file_extension = file_path.Extension();
-  if (file_extension.empty()) {
-    meta_info->mime_type_result = false;
-  } else {
-    meta_info->mime_type_result = net::GetWellKnownMimeTypeFromExtension(
-        file_extension.substr(1), &meta_info->mime_type);
-  }
-}
-
-void URLRequestAsarJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-  if (!meta_info_.file_exists || meta_info_.is_directory) {
-    DidOpen(net::ERR_FILE_NOT_FOUND);
-    return;
-  }
-
-  int flags =
-      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_ASYNC;
-  int rv = stream_->Open(
-      meta_info_.file_path, flags,
-      base::Bind(&URLRequestAsarJob::DidOpen, weak_ptr_factory_.GetWeakPtr()));
-  if (rv != net::ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
-void URLRequestAsarJob::DidOpen(int result) {
-  if (result != net::OK) {
-    NotifyStartError(
-        net::URLRequestStatus(net::URLRequestStatus::FAILED, result));
-    return;
-  }
-
-  if (range_parse_result_ != net::OK) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           range_parse_result_));
-    return;
-  }
-
-  int64_t file_size, read_offset;
-  if (type_ == TYPE_ASAR) {
-    file_size = file_info_.size;
-    read_offset = file_info_.offset;
-  } else {
-    file_size = meta_info_.file_size;
-    read_offset = 0;
-  }
-
-  if (!byte_range_.ComputeBounds(file_size)) {
-    NotifyStartError(net::URLRequestStatus(
-        net::URLRequestStatus::FAILED, net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-
-  remaining_bytes_ =
-      byte_range_.last_byte_position() - byte_range_.first_byte_position() + 1;
-  seek_offset_ = byte_range_.first_byte_position() + read_offset;
-
-  if (remaining_bytes_ > 0 && seek_offset_ != 0) {
-    int rv =
-        stream_->Seek(seek_offset_, base::Bind(&URLRequestAsarJob::DidSeek,
-                                               weak_ptr_factory_.GetWeakPtr()));
-    if (rv != net::ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(seek_offset_);
-  }
-}
-
-void URLRequestAsarJob::DidSeek(int64_t result) {
-  if (result != seek_offset_) {
-    NotifyStartError(net::URLRequestStatus(
-        net::URLRequestStatus::FAILED, net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
-}
-
-void URLRequestAsarJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  if (result >= 0) {
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  buf = nullptr;
-
-  ReadRawDataComplete(result);
-}
-
-}  // namespace asar
removed in remote
  base   100644 7103abc4139adc7329101f38646fd02afac9ab97 atom/browser/net/asar/url_request_asar_job.h
  our    100644 fde6302e031d4978bc6aa9419ef1d2d458f95c4a atom/browser/net/asar/url_request_asar_job.h
@@ -1,135 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
-#define ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "atom/common/asar/archive.h"
-#include "base/files/file_path.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "net/http/http_byte_range.h"
-#include "net/url_request/url_request_job.h"
-
-namespace base {
-class TaskRunner;
-}
-
-namespace net {
-class FileStream;
-}
-
-namespace asar {
-
-// Createa a request job according to the file path.
-net::URLRequestJob* CreateJobFromPath(
-    const base::FilePath& full_path,
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate,
-    const scoped_refptr<base::TaskRunner> file_task_runner);
-
-class URLRequestAsarJob : public net::URLRequestJob {
- public:
-  URLRequestAsarJob(net::URLRequest* request,
-                    net::NetworkDelegate* network_delegate);
-
-  void Initialize(const scoped_refptr<base::TaskRunner> file_task_runner,
-                  const base::FilePath& file_path);
-
- protected:
-  ~URLRequestAsarJob() override;
-
-  void InitializeAsarJob(const scoped_refptr<base::TaskRunner> file_task_runner,
-                         std::shared_ptr<Archive> archive,
-                         const base::FilePath& file_path,
-                         const Archive::FileInfo& file_info);
-  void InitializeFileJob(const scoped_refptr<base::TaskRunner> file_task_runner,
-                         const base::FilePath& file_path);
-
-  // net::URLRequestJob:
-  void Start() override;
-  void Kill() override;
-  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  std::unique_ptr<net::SourceStream> SetUpSourceStream() override;
-  bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const net::HttpRequestHeaders& headers) override;
-  int GetResponseCode() const override;
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
- private:
-  // The type of this job.
-  enum JobType {
-    TYPE_ERROR,
-    TYPE_ASAR,
-    TYPE_FILE,
-  };
-
-  // Meta information about the file. It's used as a member in the
-  // URLRequestFileJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    // Size of the file.
-    int64_t file_size = 0;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result = false;
-    // Flag showing whether the file exists.
-    bool file_exists = false;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory = false;
-    // Path to the file.
-    base::FilePath file_path;
-
-    FileMetaInfo();
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            JobType type,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
-
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64_t result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
-
-  JobType type_ = TYPE_ERROR;
-
-  std::shared_ptr<Archive> archive_;
-  base::FilePath file_path_;
-  Archive::FileInfo file_info_;
-
-  std::unique_ptr<net::FileStream> stream_;
-  FileMetaInfo meta_info_;
-  scoped_refptr<base::TaskRunner> file_task_runner_;
-
-  net::HttpByteRange byte_range_;
-  int64_t remaining_bytes_ = 0;
-  int64_t seek_offset_ = 0;
-
-  net::Error range_parse_result_ = net::OK;
-
-  base::WeakPtrFactory<URLRequestAsarJob> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestAsarJob);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
removed in remote
  base   100644 3633d805fb5b89707c1924d40ab3d10e2bb6e14e atom/browser/net/atom_cert_verifier.cc
  our    100644 75437f605c83ad050fc706abbce534f9383ba3a6 atom/browser/net/atom_cert_verifier.cc
@@ -1,209 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_cert_verifier.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/containers/linked_list.h"
-#include "base/memory/weak_ptr.h"
-#include "brightray/browser/net/require_ct_delegate.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/net_errors.h"
-#include "net/cert/cert_verify_result.h"
-#include "net/cert/crl_set.h"
-#include "net/cert/x509_certificate.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-VerifyRequestParams::VerifyRequestParams() = default;
-VerifyRequestParams::~VerifyRequestParams() = default;
-VerifyRequestParams::VerifyRequestParams(const VerifyRequestParams&) = default;
-
-namespace {
-
-class Response : public base::LinkNode<Response> {
- public:
-  Response(net::CertVerifyResult* verify_result,
-           const net::CompletionCallback& callback)
-      : verify_result_(verify_result), callback_(callback) {}
-  net::CertVerifyResult* verify_result() { return verify_result_; }
-  net::CompletionCallback callback() { return callback_; }
-
- private:
-  net::CertVerifyResult* verify_result_;
-  net::CompletionCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(Response);
-};
-
-}  // namespace
-
-class CertVerifierRequest : public AtomCertVerifier::Request {
- public:
-  CertVerifierRequest(const AtomCertVerifier::RequestParams& params,
-                      AtomCertVerifier* cert_verifier)
-      : params_(params),
-        cert_verifier_(cert_verifier),
-        weak_ptr_factory_(this) {}
-
-  ~CertVerifierRequest() override {
-    cert_verifier_->RemoveRequest(params_);
-    default_verifier_request_.reset();
-    while (!response_list_.empty() && !first_response_) {
-      base::LinkNode<Response>* response_node = response_list_.head();
-      response_node->RemoveFromList();
-      Response* response = response_node->value();
-      RunResponse(response);
-    }
-    cert_verifier_ = nullptr;
-    weak_ptr_factory_.InvalidateWeakPtrs();
-  }
-
-  void RunResponse(Response* response) {
-    if (custom_response_ == net::ERR_ABORTED) {
-      *(response->verify_result()) = result_;
-      response->callback().Run(error_);
-    } else {
-      response->verify_result()->Reset();
-      response->verify_result()->verified_cert = params_.certificate();
-      cert_verifier_->ct_delegate()->AddCTExcludedHost(params_.hostname());
-      response->callback().Run(custom_response_);
-    }
-    delete response;
-  }
-
-  void Start(net::CRLSet* crl_set, const net::NetLogWithSource& net_log) {
-    int error = cert_verifier_->default_verifier()->Verify(
-        params_, crl_set, &result_,
-        base::Bind(&CertVerifierRequest::OnDefaultVerificationDone,
-                   weak_ptr_factory_.GetWeakPtr()),
-        &default_verifier_request_, net_log);
-    if (error != net::ERR_IO_PENDING)
-      OnDefaultVerificationDone(error);
-  }
-
-  void OnDefaultVerificationDone(int error) {
-    error_ = error;
-    auto request = std::make_unique<VerifyRequestParams>();
-    request->hostname = params_.hostname();
-    request->default_result = net::ErrorToString(error);
-    request->error_code = error;
-    request->certificate = params_.certificate();
-    auto response_callback = base::Bind(&CertVerifierRequest::OnResponseInUI,
-                                        weak_ptr_factory_.GetWeakPtr());
-    BrowserThread::PostTask(
-        BrowserThread::UI, FROM_HERE,
-        base::BindOnce(&CertVerifierRequest::OnVerifyRequestInUI,
-                       cert_verifier_->verify_proc(), std::move(request),
-                       response_callback));
-  }
-
-  static void OnVerifyRequestInUI(
-      const AtomCertVerifier::VerifyProc& verify_proc,
-      std::unique_ptr<VerifyRequestParams> request,
-      const base::Callback<void(int)>& response_callback) {
-    verify_proc.Run(*(request.get()), response_callback);
-  }
-
-  static void OnResponseInUI(base::WeakPtr<CertVerifierRequest> self,
-                             int result) {
-    BrowserThread::PostTask(
-        BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&CertVerifierRequest::NotifyResponseInIO, self, result));
-  }
-
-  void NotifyResponseInIO(int result) {
-    custom_response_ = result;
-    first_response_ = false;
-    // Responding to first request in the list will initiate destruction of
-    // the class, respond to others in the list inside destructor.
-    base::LinkNode<Response>* response_node = response_list_.head();
-    response_node->RemoveFromList();
-    Response* response = response_node->value();
-    RunResponse(response);
-  }
-
-  void AddResponseListener(net::CertVerifyResult* verify_result,
-                           const net::CompletionCallback& callback) {
-    response_list_.Append(new Response(verify_result, callback));
-  }
-
-  const AtomCertVerifier::RequestParams& params() const { return params_; }
-
- private:
-  using ResponseList = base::LinkedList<Response>;
-
-  const AtomCertVerifier::RequestParams params_;
-  AtomCertVerifier* cert_verifier_;
-  int error_ = net::ERR_IO_PENDING;
-  int custom_response_ = net::ERR_IO_PENDING;
-  bool first_response_ = true;
-  ResponseList response_list_;
-  net::CertVerifyResult result_;
-  std::unique_ptr<AtomCertVerifier::Request> default_verifier_request_;
-  base::WeakPtrFactory<CertVerifierRequest> weak_ptr_factory_;
-};
-
-AtomCertVerifier::AtomCertVerifier(brightray::RequireCTDelegate* ct_delegate)
-    : default_cert_verifier_(net::CertVerifier::CreateDefault()),
-      ct_delegate_(ct_delegate) {}
-
-AtomCertVerifier::~AtomCertVerifier() {}
-
-void AtomCertVerifier::SetVerifyProc(const VerifyProc& proc) {
-  verify_proc_ = proc;
-}
-
-int AtomCertVerifier::Verify(const RequestParams& params,
-                             net::CRLSet* crl_set,
-                             net::CertVerifyResult* verify_result,
-                             const net::CompletionCallback& callback,
-                             std::unique_ptr<Request>* out_req,
-                             const net::NetLogWithSource& net_log) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  if (verify_proc_.is_null()) {
-    ct_delegate_->ClearCTExcludedHostsList();
-    return default_cert_verifier_->Verify(params, crl_set, verify_result,
-                                          callback, out_req, net_log);
-  } else {
-    CertVerifierRequest* request = FindRequest(params);
-    if (!request) {
-      out_req->reset();
-      auto new_request = std::make_unique<CertVerifierRequest>(params, this);
-      new_request->Start(crl_set, net_log);
-      request = new_request.get();
-      *out_req = std::move(new_request);
-      inflight_requests_[params] = request;
-    }
-    request->AddResponseListener(verify_result, callback);
-
-    return net::ERR_IO_PENDING;
-  }
-}
-
-bool AtomCertVerifier::SupportsOCSPStapling() {
-  if (verify_proc_.is_null())
-    return default_cert_verifier_->SupportsOCSPStapling();
-  return false;
-}
-
-void AtomCertVerifier::RemoveRequest(const RequestParams& params) {
-  auto it = inflight_requests_.find(params);
-  if (it != inflight_requests_.end())
-    inflight_requests_.erase(it);
-}
-
-CertVerifierRequest* AtomCertVerifier::FindRequest(
-    const RequestParams& params) {
-  auto it = inflight_requests_.find(params);
-  if (it != inflight_requests_.end())
-    return it->second;
-  return nullptr;
-}
-
-}  // namespace atom
removed in remote
  base   100644 796ae2849bda44743699e9bf03ca830608d16189 atom/browser/net/atom_cert_verifier.h
  our    100644 458615f3ed43fa8ddb6fb68138a3a1e7d845677e atom/browser/net/atom_cert_verifier.h
@@ -1,77 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
-#define ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
-
-#include <map>
-#include <memory>
-#include <string>
-
-#include "net/cert/cert_verifier.h"
-
-namespace brightray {
-
-class RequireCTDelegate;
-
-}  // namespace brightray
-
-namespace atom {
-
-class CertVerifierRequest;
-
-struct VerifyRequestParams {
-  std::string hostname;
-  std::string default_result;
-  int error_code;
-  scoped_refptr<net::X509Certificate> certificate;
-
-  VerifyRequestParams();
-  VerifyRequestParams(const VerifyRequestParams&);
-  ~VerifyRequestParams();
-};
-
-class AtomCertVerifier : public net::CertVerifier {
- public:
-  explicit AtomCertVerifier(brightray::RequireCTDelegate* ct_delegate);
-  ~AtomCertVerifier() override;
-
-  using VerifyProc = base::Callback<void(const VerifyRequestParams& request,
-                                         const net::CompletionCallback&)>;
-
-  void SetVerifyProc(const VerifyProc& proc);
-
-  const VerifyProc verify_proc() const { return verify_proc_; }
-  brightray::RequireCTDelegate* ct_delegate() const { return ct_delegate_; }
-  net::CertVerifier* default_verifier() const {
-    return default_cert_verifier_.get();
-  }
-
- protected:
-  // net::CertVerifier:
-  int Verify(const RequestParams& params,
-             net::CRLSet* crl_set,
-             net::CertVerifyResult* verify_result,
-             const net::CompletionCallback& callback,
-             std::unique_ptr<Request>* out_req,
-             const net::NetLogWithSource& net_log) override;
-  bool SupportsOCSPStapling() override;
-
- private:
-  friend class CertVerifierRequest;
-
-  void RemoveRequest(const RequestParams& params);
-  CertVerifierRequest* FindRequest(const RequestParams& params);
-
-  std::map<RequestParams, CertVerifierRequest*> inflight_requests_;
-  VerifyProc verify_proc_;
-  std::unique_ptr<net::CertVerifier> default_cert_verifier_;
-  brightray::RequireCTDelegate* ct_delegate_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomCertVerifier);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
removed in remote
  base   100644 91b63fada3598da41a34522561234fcc6ecd23ef atom/browser/net/atom_network_delegate.cc
  our    100644 e71ea74317b69f31a5aac8e723902748972fed8f atom/browser/net/atom_network_delegate.cc
@@ -1,553 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_network_delegate.h"
-
-#include <utility>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/login_handler.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/stl_util.h"
-#include "base/strings/string_util.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/resource_request_info.h"
-#include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
-#include "net/url_request/url_request.h"
-#include "services/network/throttling/throttling_network_transaction.h"
-
-using content::BrowserThread;
-using network::ThrottlingNetworkTransaction;
-
-namespace atom {
-
-const char* ResourceTypeToString(content::ResourceType type) {
-  switch (type) {
-    case content::RESOURCE_TYPE_MAIN_FRAME:
-      return "mainFrame";
-    case content::RESOURCE_TYPE_SUB_FRAME:
-      return "subFrame";
-    case content::RESOURCE_TYPE_STYLESHEET:
-      return "stylesheet";
-    case content::RESOURCE_TYPE_SCRIPT:
-      return "script";
-    case content::RESOURCE_TYPE_IMAGE:
-      return "image";
-    case content::RESOURCE_TYPE_OBJECT:
-      return "object";
-    case content::RESOURCE_TYPE_XHR:
-      return "xhr";
-    default:
-      return "other";
-  }
-}
-
-int32_t GetWebContentsID(int process_id, int frame_id) {
-  auto* webContents = content::WebContents::FromRenderFrameHost(
-      content::RenderFrameHost::FromID(process_id, frame_id));
-  return atom::api::WebContents::GetIDFromWrappedClass(webContents);
-}
-
-namespace {
-
-using ResponseHeadersContainer =
-    std::pair<scoped_refptr<net::HttpResponseHeaders>*, const std::string&>;
-
-void RunSimpleListener(const AtomNetworkDelegate::SimpleListener& listener,
-                       std::unique_ptr<base::DictionaryValue> details,
-                       int render_process_id,
-                       int render_frame_id) {
-  int32_t id = GetWebContentsID(render_process_id, render_frame_id);
-  // id must be greater than zero
-  if (id)
-    details->SetInteger("webContentsId", id);
-  return listener.Run(*(details.get()));
-}
-
-void RunResponseListener(
-    const AtomNetworkDelegate::ResponseListener& listener,
-    std::unique_ptr<base::DictionaryValue> details,
-    int render_process_id,
-    int render_frame_id,
-    const AtomNetworkDelegate::ResponseCallback& callback) {
-  int32_t id = GetWebContentsID(render_process_id, render_frame_id);
-  // id must be greater than zero
-  if (id)
-    details->SetInteger("webContentsId", id);
-  return listener.Run(*(details.get()), callback);
-}
-
-// Test whether the URL of |request| matches |patterns|.
-bool MatchesFilterCondition(net::URLRequest* request,
-                            const URLPatterns& patterns) {
-  if (patterns.empty())
-    return true;
-
-  for (const auto& pattern : patterns) {
-    if (pattern.MatchesURL(request->url()))
-      return true;
-  }
-  return false;
-}
-
-// Overloaded by multiple types to fill the |details| object.
-void ToDictionary(base::DictionaryValue* details, net::URLRequest* request) {
-  FillRequestDetails(details, request);
-  details->SetInteger("id", request->identifier());
-  details->SetDouble("timestamp", base::Time::Now().ToDoubleT() * 1000);
-  const auto* info = content::ResourceRequestInfo::ForRequest(request);
-  if (info) {
-    details->SetString("resourceType",
-                       ResourceTypeToString(info->GetResourceType()));
-  } else {
-    details->SetString("resourceType", "other");
-  }
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HttpRequestHeaders& headers) {
-  auto dict = std::make_unique<base::DictionaryValue>();
-  net::HttpRequestHeaders::Iterator it(headers);
-  while (it.GetNext())
-    dict->SetKey(it.name(), base::Value(it.value()));
-  details->Set("requestHeaders", std::move(dict));
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HttpResponseHeaders* headers) {
-  if (!headers)
-    return;
-
-  auto dict = std::make_unique<base::DictionaryValue>();
-  size_t iter = 0;
-  std::string key;
-  std::string value;
-  while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
-    if (dict->FindKey(key)) {
-      base::ListValue* values = nullptr;
-      if (dict->GetList(key, &values))
-        values->AppendString(value);
-    } else {
-      auto values = std::make_unique<base::ListValue>();
-      values->AppendString(value);
-      dict->Set(key, std::move(values));
-    }
-  }
-  details->Set("responseHeaders", std::move(dict));
-  details->SetString("statusLine", headers->GetStatusLine());
-  details->SetInteger("statusCode", headers->response_code());
-}
-
-void ToDictionary(base::DictionaryValue* details, const GURL& location) {
-  details->SetString("redirectURL", location.spec());
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HostPortPair& host_port) {
-  if (host_port.host().empty())
-    details->SetString("ip", host_port.host());
-}
-
-void ToDictionary(base::DictionaryValue* details, bool from_cache) {
-  details->SetBoolean("fromCache", from_cache);
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::URLRequestStatus& status) {
-  details->SetString("error", net::ErrorToString(status.error()));
-}
-
-// Helper function to fill |details| with arbitrary |args|.
-template <typename Arg>
-void FillDetailsObject(base::DictionaryValue* details, Arg arg) {
-  ToDictionary(details, arg);
-}
-
-template <typename Arg, typename... Args>
-void FillDetailsObject(base::DictionaryValue* details, Arg arg, Args... args) {
-  ToDictionary(details, arg);
-  FillDetailsObject(details, args...);
-}
-
-// Fill the native types with the result from the response object.
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            GURL* new_location) {
-  std::string url;
-  if (response.GetString("redirectURL", &url))
-    *new_location = GURL(url);
-}
-
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            net::HttpRequestHeaders* headers) {
-  const base::DictionaryValue* dict;
-  if (response.GetDictionary("requestHeaders", &dict)) {
-    headers->Clear();
-    for (base::DictionaryValue::Iterator it(*dict); !it.IsAtEnd();
-         it.Advance()) {
-      if (it.value().is_string()) {
-        std::string value = it.value().GetString();
-        headers->SetHeader(it.key(), value);
-      }
-    }
-  }
-}
-
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            const ResponseHeadersContainer& container) {
-  const base::DictionaryValue* dict;
-  std::string status_line;
-  if (!response.GetString("statusLine", &status_line))
-    status_line = container.second;
-  if (response.GetDictionary("responseHeaders", &dict)) {
-    auto* headers = container.first;
-    *headers = new net::HttpResponseHeaders("");
-    (*headers)->ReplaceStatusLine(status_line);
-    for (base::DictionaryValue::Iterator it(*dict); !it.IsAtEnd();
-         it.Advance()) {
-      const base::ListValue* list;
-      if (it.value().GetAsList(&list)) {
-        (*headers)->RemoveHeader(it.key());
-        for (size_t i = 0; i < list->GetSize(); ++i) {
-          std::string value;
-          if (list->GetString(i, &value))
-            (*headers)->AddHeader(it.key() + " : " + value);
-        }
-      }
-    }
-  }
-}
-
-}  // namespace
-
-AtomNetworkDelegate::SimpleListenerInfo::SimpleListenerInfo(
-    URLPatterns patterns_,
-    SimpleListener listener_)
-    : url_patterns(patterns_), listener(listener_) {}
-AtomNetworkDelegate::SimpleListenerInfo::SimpleListenerInfo() = default;
-AtomNetworkDelegate::SimpleListenerInfo::~SimpleListenerInfo() = default;
-
-AtomNetworkDelegate::ResponseListenerInfo::ResponseListenerInfo(
-    URLPatterns patterns_,
-    ResponseListener listener_)
-    : url_patterns(patterns_), listener(listener_) {}
-AtomNetworkDelegate::ResponseListenerInfo::ResponseListenerInfo() = default;
-AtomNetworkDelegate::ResponseListenerInfo::~ResponseListenerInfo() = default;
-
-AtomNetworkDelegate::AtomNetworkDelegate() {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  if (command_line->HasSwitch(switches::kIgnoreConnectionsLimit)) {
-    std::string value =
-        command_line->GetSwitchValueASCII(switches::kIgnoreConnectionsLimit);
-    ignore_connections_limit_domains_ = base::SplitString(
-        value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-  }
-}
-
-AtomNetworkDelegate::~AtomNetworkDelegate() {}
-
-void AtomNetworkDelegate::SetSimpleListenerInIO(SimpleEvent type,
-                                                URLPatterns patterns,
-                                                SimpleListener callback) {
-  if (callback.is_null())
-    simple_listeners_.erase(type);
-  else
-    simple_listeners_[type] = {std::move(patterns), std::move(callback)};
-}
-
-void AtomNetworkDelegate::SetResponseListenerInIO(ResponseEvent type,
-                                                  URLPatterns patterns,
-                                                  ResponseListener callback) {
-  if (callback.is_null())
-    response_listeners_.erase(type);
-  else
-    response_listeners_[type] = {std::move(patterns), std::move(callback)};
-}
-
-void AtomNetworkDelegate::SetDevToolsNetworkEmulationClientId(
-    const std::string& client_id) {
-  client_id_ = client_id;
-}
-
-int AtomNetworkDelegate::OnBeforeURLRequest(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    GURL* new_url) {
-  if (!base::ContainsKey(response_listeners_, kOnBeforeRequest)) {
-    for (const auto& domain : ignore_connections_limit_domains_) {
-      if (request->url().DomainIs(domain)) {
-        // Allow unlimited concurrent connections.
-        request->SetPriority(net::MAXIMUM_PRIORITY);
-        request->SetLoadFlags(request->load_flags() | net::LOAD_IGNORE_LIMITS);
-        break;
-      }
-    }
-    return net::OK;
-  }
-
-  return HandleResponseEvent(kOnBeforeRequest, request, callback, new_url);
-}
-
-int AtomNetworkDelegate::OnBeforeStartTransaction(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    net::HttpRequestHeaders* headers) {
-  if (!client_id_.empty())
-    headers->SetHeader(network::ThrottlingNetworkTransaction::
-                           kDevToolsEmulateNetworkConditionsClientId,
-                       client_id_);
-  if (!base::ContainsKey(response_listeners_, kOnBeforeSendHeaders))
-    return net::OK;
-
-  return HandleResponseEvent(kOnBeforeSendHeaders, request, callback, headers,
-                             *headers);
-}
-
-void AtomNetworkDelegate::OnStartTransaction(
-    net::URLRequest* request,
-    const net::HttpRequestHeaders& headers) {
-  if (!base::ContainsKey(simple_listeners_, kOnSendHeaders))
-    return;
-
-  HandleSimpleEvent(kOnSendHeaders, request, headers);
-}
-
-int AtomNetworkDelegate::OnHeadersReceived(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    const net::HttpResponseHeaders* original,
-    scoped_refptr<net::HttpResponseHeaders>* override,
-    GURL* allowed) {
-  if (!base::ContainsKey(response_listeners_, kOnHeadersReceived))
-    return net::OK;
-
-  return HandleResponseEvent(
-      kOnHeadersReceived, request, callback,
-      std::make_pair(override, original->GetStatusLine()), original);
-}
-
-void AtomNetworkDelegate::OnBeforeRedirect(net::URLRequest* request,
-                                           const GURL& new_location) {
-  if (!base::ContainsKey(simple_listeners_, kOnBeforeRedirect))
-    return;
-
-  HandleSimpleEvent(kOnBeforeRedirect, request, new_location,
-                    request->response_headers(), request->GetSocketAddress(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnResponseStarted(net::URLRequest* request,
-                                            int net_error) {
-  if (!base::ContainsKey(simple_listeners_, kOnResponseStarted))
-    return;
-
-  if (request->status().status() != net::URLRequestStatus::SUCCESS)
-    return;
-
-  HandleSimpleEvent(kOnResponseStarted, request, request->response_headers(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnCompleted(net::URLRequest* request, bool started) {
-  // OnCompleted may happen before other events.
-  callbacks_.erase(request->identifier());
-
-  if (request->status().status() == net::URLRequestStatus::FAILED ||
-      request->status().status() == net::URLRequestStatus::CANCELED) {
-    // Error event.
-    OnErrorOccurred(request, started);
-    return;
-  }
-
-  if (request->response_headers() &&
-      net::HttpResponseHeaders::IsRedirectResponseCode(
-          request->response_headers()->response_code())) {
-    // Redirect event.
-    return;
-  }
-
-  if (!base::ContainsKey(simple_listeners_, kOnCompleted))
-    return;
-
-  HandleSimpleEvent(kOnCompleted, request, request->response_headers(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnURLRequestDestroyed(net::URLRequest* request) {
-  const auto& it = login_handler_map_.find(request->identifier());
-  if (it != login_handler_map_.end()) {
-    it->second->NotifyRequestDestroyed();
-    it->second = nullptr;
-    login_handler_map_.erase(it);
-  }
-  callbacks_.erase(request->identifier());
-}
-
-net::NetworkDelegate::AuthRequiredResponse AtomNetworkDelegate::OnAuthRequired(
-    net::URLRequest* request,
-    const net::AuthChallengeInfo& auth_info,
-    const AuthCallback& callback,
-    net::AuthCredentials* credentials) {
-  auto* resource_request_info =
-      content::ResourceRequestInfo::ForRequest(request);
-  if (!resource_request_info)
-    return AUTH_REQUIRED_RESPONSE_NO_ACTION;
-  login_handler_map_.emplace(
-      request->identifier(),
-      new LoginHandler(request, auth_info, std::move(callback), credentials,
-                       resource_request_info));
-  return AUTH_REQUIRED_RESPONSE_IO_PENDING;
-}
-
-bool AtomNetworkDelegate::OnCanGetCookies(const net::URLRequest& request,
-                                          const net::CookieList& cookie_list) {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanSetCookie(
-    const net::URLRequest& request,
-    const net::CanonicalCookie& cookie_line,
-    net::CookieOptions* options) {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanAccessFile(
-    const net::URLRequest& request,
-    const base::FilePath& original_path,
-    const base::FilePath& absolute_path) const {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanEnablePrivacyMode(
-    const GURL& url,
-    const GURL& first_party_for_cookies) const {
-  return false;
-}
-
-bool AtomNetworkDelegate::OnAreExperimentalCookieFeaturesEnabled() const {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCancelURLRequestWithPolicyViolatingReferrerHeader(
-    const net::URLRequest& request,
-    const GURL& target_url,
-    const GURL& referrer_url) const {
-  return false;
-}
-
-// TODO(deepak1556) : Enable after hooking into the reporting service
-// https://crbug.com/704259
-bool AtomNetworkDelegate::OnCanQueueReportingReport(
-    const url::Origin& origin) const {
-  return false;
-}
-
-void AtomNetworkDelegate::OnCanSendReportingReports(
-    std::set<url::Origin> origins,
-    base::OnceCallback<void(std::set<url::Origin>)> result_callback) const {}
-
-bool AtomNetworkDelegate::OnCanSetReportingClient(const url::Origin& origin,
-                                                  const GURL& endpoint) const {
-  return false;
-}
-
-bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
-                                                  const GURL& endpoint) const {
-  return false;
-}
-
-void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
-                                          bool started) {
-  if (!base::ContainsKey(simple_listeners_, kOnErrorOccurred))
-    return;
-
-  HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
-                    request->status());
-}
-
-template <typename Out, typename... Args>
-int AtomNetworkDelegate::HandleResponseEvent(
-    ResponseEvent type,
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    Out out,
-    Args... args) {
-  const auto& info = response_listeners_[type];
-  if (!MatchesFilterCondition(request, info.url_patterns))
-    return net::OK;
-
-  auto details = std::make_unique<base::DictionaryValue>();
-  FillDetailsObject(details.get(), request, args...);
-
-  int render_process_id, render_frame_id;
-  content::ResourceRequestInfo::GetRenderFrameForRequest(
-      request, &render_process_id, &render_frame_id);
-
-  // The |request| could be destroyed before the |callback| is called.
-  callbacks_[request->identifier()] = callback;
-
-  ResponseCallback response =
-      base::Bind(&AtomNetworkDelegate::OnListenerResultInUI<Out>,
-                 base::Unretained(this), request->identifier(), out);
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(RunResponseListener, info.listener, std::move(details),
-                     render_process_id, render_frame_id, response));
-  return net::ERR_IO_PENDING;
-}
-
-template <typename... Args>
-void AtomNetworkDelegate::HandleSimpleEvent(SimpleEvent type,
-                                            net::URLRequest* request,
-                                            Args... args) {
-  const auto& info = simple_listeners_[type];
-  if (!MatchesFilterCondition(request, info.url_patterns))
-    return;
-
-  auto details = std::make_unique<base::DictionaryValue>();
-  FillDetailsObject(details.get(), request, args...);
-
-  int render_process_id, render_frame_id;
-  content::ResourceRequestInfo::GetRenderFrameForRequest(
-      request, &render_process_id, &render_frame_id);
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(RunSimpleListener, info.listener, std::move(details),
-                     render_process_id, render_frame_id));
-}
-
-template <typename T>
-void AtomNetworkDelegate::OnListenerResultInIO(
-    uint64_t id,
-    T out,
-    std::unique_ptr<base::DictionaryValue> response) {
-  // The request has been destroyed.
-  if (!base::ContainsKey(callbacks_, id))
-    return;
-
-  ReadFromResponseObject(*response, out);
-
-  bool cancel = false;
-  response->GetBoolean("cancel", &cancel);
-  callbacks_[id].Run(cancel ? net::ERR_BLOCKED_BY_CLIENT : net::OK);
-}
-
-template <typename T>
-void AtomNetworkDelegate::OnListenerResultInUI(
-    uint64_t id,
-    T out,
-    const base::DictionaryValue& response) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(response.Clone()));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AtomNetworkDelegate::OnListenerResultInIO<T>,
-                     base::Unretained(this), id, out, std::move(copy)));
-}
-
-}  // namespace atom
removed in remote
  base   100644 4f55f7c098633215be274003612b4e7ec89d5095 atom/browser/net/atom_network_delegate.h
  our    100644 39a7a8ddfcda17fd7d022331132b54485d07a279 atom/browser/net/atom_network_delegate.h
@@ -1,182 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
-#define ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
-
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/synchronization/lock.h"
-#include "base/values.h"
-#include "content/public/browser/resource_request_info.h"
-#include "extensions/common/url_pattern.h"
-#include "net/base/network_delegate.h"
-#include "net/http/http_request_headers.h"
-#include "net/http/http_response_headers.h"
-
-class URLPattern;
-
-namespace atom {
-
-using URLPatterns = std::set<URLPattern>;
-
-const char* ResourceTypeToString(content::ResourceType type);
-
-class LoginHandler;
-
-class AtomNetworkDelegate : public net::NetworkDelegate {
- public:
-  using ResponseCallback = base::Callback<void(const base::DictionaryValue&)>;
-  using SimpleListener = base::Callback<void(const base::DictionaryValue&)>;
-  using ResponseListener = base::Callback<void(const base::DictionaryValue&,
-                                               const ResponseCallback&)>;
-
-  enum SimpleEvent {
-    kOnSendHeaders,
-    kOnBeforeRedirect,
-    kOnResponseStarted,
-    kOnCompleted,
-    kOnErrorOccurred,
-  };
-
-  enum ResponseEvent {
-    kOnBeforeRequest,
-    kOnBeforeSendHeaders,
-    kOnHeadersReceived,
-  };
-
-  struct SimpleListenerInfo {
-    URLPatterns url_patterns;
-    SimpleListener listener;
-
-    SimpleListenerInfo(URLPatterns, SimpleListener);
-    SimpleListenerInfo();
-    ~SimpleListenerInfo();
-  };
-
-  struct ResponseListenerInfo {
-    URLPatterns url_patterns;
-    ResponseListener listener;
-
-    ResponseListenerInfo(URLPatterns, ResponseListener);
-    ResponseListenerInfo();
-    ~ResponseListenerInfo();
-  };
-
-  AtomNetworkDelegate();
-  ~AtomNetworkDelegate() override;
-
-  void SetSimpleListenerInIO(SimpleEvent type,
-                             URLPatterns patterns,
-                             SimpleListener callback);
-  void SetResponseListenerInIO(ResponseEvent type,
-                               URLPatterns patterns,
-                               ResponseListener callback);
-
-  void SetDevToolsNetworkEmulationClientId(const std::string& client_id);
-
- protected:
-  // net::NetworkDelegate:
-  int OnBeforeURLRequest(net::URLRequest* request,
-                         const net::CompletionCallback& callback,
-                         GURL* new_url) override;
-  int OnBeforeStartTransaction(net::URLRequest* request,
-                               const net::CompletionCallback& callback,
-                               net::HttpRequestHeaders* headers) override;
-  void OnBeforeSendHeaders(net::URLRequest* request,
-                           const net::ProxyInfo& proxy_info,
-                           const net::ProxyRetryInfoMap& proxy_retry_info,
-                           net::HttpRequestHeaders* headers) override {}
-  void OnStartTransaction(net::URLRequest* request,
-                          const net::HttpRequestHeaders& headers) override;
-  int OnHeadersReceived(
-      net::URLRequest* request,
-      const net::CompletionCallback& callback,
-      const net::HttpResponseHeaders* original_response_headers,
-      scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
-      GURL* allowed_unsafe_redirect_url) override;
-  void OnBeforeRedirect(net::URLRequest* request,
-                        const GURL& new_location) override;
-  void OnResponseStarted(net::URLRequest* request, int net_error) override;
-  void OnNetworkBytesReceived(net::URLRequest* request,
-                              int64_t bytes_read) override {}
-  void OnNetworkBytesSent(net::URLRequest* request,
-                          int64_t bytes_sent) override {}
-  void OnCompleted(net::URLRequest* request, bool started) override;
-  void OnURLRequestDestroyed(net::URLRequest* request) override;
-  void OnPACScriptError(int line_number, const base::string16& error) override {
-  }
-  AuthRequiredResponse OnAuthRequired(
-      net::URLRequest* request,
-      const net::AuthChallengeInfo& auth_info,
-      const AuthCallback& callback,
-      net::AuthCredentials* credentials) override;
-  bool OnCanGetCookies(const net::URLRequest& request,
-                       const net::CookieList& cookie_list) override;
-  bool OnCanSetCookie(const net::URLRequest& request,
-                      const net::CanonicalCookie& cookie_line,
-                      net::CookieOptions* options) override;
-  bool OnCanAccessFile(const net::URLRequest& request,
-                       const base::FilePath& original_path,
-                       const base::FilePath& absolute_path) const override;
-  bool OnCanEnablePrivacyMode(
-      const GURL& url,
-      const GURL& first_party_for_cookies) const override;
-  bool OnAreExperimentalCookieFeaturesEnabled() const override;
-  bool OnCancelURLRequestWithPolicyViolatingReferrerHeader(
-      const net::URLRequest& request,
-      const GURL& target_url,
-      const GURL& referrer_url) const override;
-  bool OnCanQueueReportingReport(const url::Origin& origin) const override;
-  void OnCanSendReportingReports(std::set<url::Origin> origins,
-                                 base::OnceCallback<void(std::set<url::Origin>)>
-                                     result_callback) const override;
-  bool OnCanSetReportingClient(const url::Origin& origin,
-                               const GURL& endpoint) const override;
-  bool OnCanUseReportingClient(const url::Origin& origin,
-                               const GURL& endpoint) const override;
-
- private:
-  void OnErrorOccurred(net::URLRequest* request, bool started);
-
-  template <typename... Args>
-  void HandleSimpleEvent(SimpleEvent type,
-                         net::URLRequest* request,
-                         Args... args);
-  template <typename Out, typename... Args>
-  int HandleResponseEvent(ResponseEvent type,
-                          net::URLRequest* request,
-                          const net::CompletionCallback& callback,
-                          Out out,
-                          Args... args);
-
-  // Deal with the results of Listener.
-  template <typename T>
-  void OnListenerResultInIO(uint64_t id,
-                            T out,
-                            std::unique_ptr<base::DictionaryValue> response);
-  template <typename T>
-  void OnListenerResultInUI(uint64_t id,
-                            T out,
-                            const base::DictionaryValue& response);
-
-  std::map<uint64_t, scoped_refptr<LoginHandler>> login_handler_map_;
-  std::map<SimpleEvent, SimpleListenerInfo> simple_listeners_;
-  std::map<ResponseEvent, ResponseListenerInfo> response_listeners_;
-  std::map<uint64_t, net::CompletionCallback> callbacks_;
-  std::vector<std::string> ignore_connections_limit_domains_;
-
-  // Client id for devtools network emulation.
-  std::string client_id_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomNetworkDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
removed in remote
  base   100644 dbd8b4160cfdde45847cbae66a17641012a2bc21 atom/browser/net/atom_url_request_job_factory.cc
  our    100644 7047f7a6f7f83e782121f2a849a621fb836ad534 atom/browser/net/atom_url_request_job_factory.cc
@@ -1,142 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_url_request_job_factory.h"
-
-#include "base/memory/ptr_util.h"
-#include "base/stl_util.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/load_flags.h"
-#include "net/url_request/url_request.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-int disable_protocol_intercept_flag_key = 0;
-
-}  // namespace
-
-typedef net::URLRequestJobFactory::ProtocolHandler ProtocolHandler;
-
-const void* DisableProtocolInterceptFlagKey() {
-  return &disable_protocol_intercept_flag_key;
-}
-
-AtomURLRequestJobFactory::AtomURLRequestJobFactory() {}
-
-AtomURLRequestJobFactory::~AtomURLRequestJobFactory() {
-  Clear();
-}
-
-bool AtomURLRequestJobFactory::SetProtocolHandler(
-    const std::string& scheme,
-    std::unique_ptr<ProtocolHandler> protocol_handler) {
-  if (!protocol_handler) {
-    auto it = protocol_handler_map_.find(scheme);
-    if (it == protocol_handler_map_.end())
-      return false;
-
-    delete it->second;
-    protocol_handler_map_.erase(it);
-    return true;
-  }
-
-  if (base::ContainsKey(protocol_handler_map_, scheme))
-    return false;
-  protocol_handler_map_[scheme] = protocol_handler.release();
-  return true;
-}
-
-bool AtomURLRequestJobFactory::InterceptProtocol(
-    const std::string& scheme,
-    std::unique_ptr<ProtocolHandler> protocol_handler) {
-  if (!base::ContainsKey(protocol_handler_map_, scheme) ||
-      base::ContainsKey(original_protocols_, scheme))
-    return false;
-  ProtocolHandler* original_protocol_handler = protocol_handler_map_[scheme];
-  protocol_handler_map_[scheme] = protocol_handler.release();
-  original_protocols_[scheme].reset(original_protocol_handler);
-  return true;
-}
-
-bool AtomURLRequestJobFactory::UninterceptProtocol(const std::string& scheme) {
-  auto it = original_protocols_.find(scheme);
-  if (it == original_protocols_.end())
-    return false;
-  protocol_handler_map_[scheme] = it->second.release();
-  original_protocols_.erase(it);
-  return true;
-}
-
-ProtocolHandler* AtomURLRequestJobFactory::GetProtocolHandler(
-    const std::string& scheme) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  auto it = protocol_handler_map_.find(scheme);
-  if (it == protocol_handler_map_.end())
-    return nullptr;
-  return it->second;
-}
-
-bool AtomURLRequestJobFactory::HasProtocolHandler(
-    const std::string& scheme) const {
-  return base::ContainsKey(protocol_handler_map_, scheme);
-}
-
-void AtomURLRequestJobFactory::Clear() {
-  for (auto& it : protocol_handler_map_)
-    delete it.second;
-  protocol_handler_map_.clear();
-  original_protocols_.clear();
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeCreateJobWithProtocolHandler(
-    const std::string& scheme,
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  auto it = protocol_handler_map_.find(scheme);
-  if (it == protocol_handler_map_.end())
-    return nullptr;
-  if (request->GetUserData(DisableProtocolInterceptFlagKey()))
-    return nullptr;
-  return it->second->MaybeCreateJob(request, network_delegate);
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeInterceptRedirect(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate,
-    const GURL& location) const {
-  return nullptr;
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeInterceptResponse(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  return nullptr;
-}
-
-bool AtomURLRequestJobFactory::IsHandledProtocol(
-    const std::string& scheme) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  return HasProtocolHandler(scheme) ||
-         net::URLRequest::IsHandledProtocol(scheme);
-}
-
-bool AtomURLRequestJobFactory::IsSafeRedirectTarget(
-    const GURL& location) const {
-  if (!location.is_valid()) {
-    // We handle error cases.
-    return true;
-  }
-  return IsHandledProtocol(location.scheme());
-}
-
-}  // namespace atom
removed in remote
  base   100644 dde36225b7af1a605fd6d135de177479e2da5650 atom/browser/net/atom_url_request_job_factory.h
  our    100644 c0e26568fdea57dd473f917d597624ab10efe129 atom/browser/net/atom_url_request_job_factory.h
@@ -1,77 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
-#define ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
-
-#include <map>
-#include <memory>
-#include <string>
-#include <unordered_map>
-#include <vector>
-
-#include "net/url_request/url_request_job_factory.h"
-
-namespace atom {
-
-const void* DisableProtocolInterceptFlagKey();
-
-class AtomURLRequestJobFactory : public net::URLRequestJobFactory {
- public:
-  AtomURLRequestJobFactory();
-  ~AtomURLRequestJobFactory() override;
-
-  // Sets the ProtocolHandler for a scheme. Returns true on success, false on
-  // failure (a ProtocolHandler already exists for |scheme|). On success,
-  // URLRequestJobFactory takes ownership of |protocol_handler|.
-  bool SetProtocolHandler(const std::string& scheme,
-                          std::unique_ptr<ProtocolHandler> protocol_handler);
-
-  // Intercepts the ProtocolHandler for a scheme.
-  bool InterceptProtocol(const std::string& scheme,
-                         std::unique_ptr<ProtocolHandler> protocol_handler);
-  bool UninterceptProtocol(const std::string& scheme);
-
-  // Returns the protocol handler registered with scheme.
-  ProtocolHandler* GetProtocolHandler(const std::string& scheme) const;
-
-  // Whether the protocol handler is registered by the job factory.
-  bool HasProtocolHandler(const std::string& scheme) const;
-
-  // Clear all protocol handlers.
-  void Clear();
-
-  // URLRequestJobFactory implementation
-  net::URLRequestJob* MaybeCreateJobWithProtocolHandler(
-      const std::string& scheme,
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  net::URLRequestJob* MaybeInterceptRedirect(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate,
-      const GURL& location) const override;
-  net::URLRequestJob* MaybeInterceptResponse(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  bool IsHandledProtocol(const std::string& scheme) const override;
-  bool IsSafeRedirectTarget(const GURL& location) const override;
-
- private:
-  using ProtocolHandlerMap = std::map<std::string, ProtocolHandler*>;
-
-  ProtocolHandlerMap protocol_handler_map_;
-
-  // Map that stores the original protocols of schemes.
-  using OriginalProtocolsMap =
-      std::unordered_map<std::string, std::unique_ptr<ProtocolHandler>>;
-  // Can only be accessed in IO thread.
-  OriginalProtocolsMap original_protocols_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomURLRequestJobFactory);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
removed in remote
  base   100644 cf5fc01c0884989b0078113436bcb972ba40b3f3 atom/browser/net/http_protocol_handler.cc
  our    100644 7c5cc365b74ba31e85fd8aa81a594507a65e2d7a atom/browser/net/http_protocol_handler.cc
@@ -1,22 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/http_protocol_handler.h"
-
-#include "net/url_request/url_request_http_job.h"
-
-namespace atom {
-
-HttpProtocolHandler::HttpProtocolHandler(const std::string& scheme)
-    : scheme_(scheme) {}
-
-HttpProtocolHandler::~HttpProtocolHandler() {}
-
-net::URLRequestJob* HttpProtocolHandler::MaybeCreateJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  return net::URLRequestHttpJob::Factory(request, network_delegate, scheme_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 98085374175b191fc75278e0bf116a46c6110fdd atom/browser/net/http_protocol_handler.h
  our    100644 39e1ff2ad29b81ce53191c3dbe629a6cf277b525 atom/browser/net/http_protocol_handler.h
@@ -1,30 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
-#define ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
-
-#include <string>
-
-#include "net/url_request/url_request_job_factory.h"
-
-namespace atom {
-
-class HttpProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
- public:
-  explicit HttpProtocolHandler(const std::string&);
-  ~HttpProtocolHandler() override;
-
-  // net::URLRequestJobFactory::ProtocolHandler:
-  net::URLRequestJob* MaybeCreateJob(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-
- private:
-  std::string scheme_;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
removed in remote
  base   100644 b11a69c9c13bde5facde0b26db39ff42a1fc1f5c atom/browser/net/js_asker.cc
  our    100644 59e3ab881c2355c2ed29b806de59ef372c170b62 atom/browser/net/js_asker.cc
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/js_asker.h"
-
-#include <vector>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-
-namespace atom {
-
-namespace internal {
-
-namespace {
-
-// The callback which is passed to |handler|.
-void HandlerCallback(const BeforeStartCallback& before_start,
-                     const ResponseCallback& callback,
-                     mate::Arguments* args) {
-  // If there is no argument passed then we failed.
-  v8::Local<v8::Value> value;
-  if (!args->GetNext(&value)) {
-    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-                                     base::BindOnce(callback, false, nullptr));
-    return;
-  }
-
-  // Give the job a chance to parse V8 value.
-  before_start.Run(args->isolate(), value);
-
-  // Pass whatever user passed to the actaul request job.
-  V8ValueConverter converter;
-  v8::Local<v8::Context> context = args->isolate()->GetCurrentContext();
-  std::unique_ptr<base::Value> options(converter.FromV8Value(value, context));
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(callback, true, std::move(options)));
-}
-
-}  // namespace
-
-void AskForOptions(v8::Isolate* isolate,
-                   const JavaScriptHandler& handler,
-                   std::unique_ptr<base::DictionaryValue> request_details,
-                   const BeforeStartCallback& before_start,
-                   const ResponseCallback& callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Context::Scope context_scope(context);
-  handler.Run(*(request_details.get()),
-              mate::ConvertToV8(isolate, base::Bind(&HandlerCallback,
-                                                    before_start, callback)));
-}
-
-bool IsErrorOptions(base::Value* value, int* error) {
-  if (value->is_dict()) {
-    base::DictionaryValue* dict = static_cast<base::DictionaryValue*>(value);
-    if (dict->GetInteger("error", error))
-      return true;
-  } else if (value->is_int()) {
-    *error = value->GetInt();
-    return true;
-  }
-  return false;
-}
-
-}  // namespace internal
-
-}  // namespace atom
removed in remote
  base   100644 8a70794fa946ea11ab783004f7dd3a0df7329df0 atom/browser/net/js_asker.h
  our    100644 45e2da9b82207215d054ccf0adba0ca935d5f8c0 atom/browser/net/js_asker.h
@@ -1,124 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_JS_ASKER_H_
-#define ATOM_BROWSER_NET_JS_ASKER_H_
-
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/callback.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "base/values.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/net_errors.h"
-#include "net/http/http_response_headers.h"
-#include "net/http/http_status_code.h"
-#include "net/url_request/url_request_context_getter.h"
-#include "net/url_request/url_request_job.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-using JavaScriptHandler =
-    base::Callback<void(const base::DictionaryValue&, v8::Local<v8::Value>)>;
-
-namespace internal {
-
-using BeforeStartCallback =
-    base::Callback<void(v8::Isolate*, v8::Local<v8::Value>)>;
-using ResponseCallback =
-    base::Callback<void(bool, std::unique_ptr<base::Value> options)>;
-
-// Ask handler for options in UI thread.
-void AskForOptions(v8::Isolate* isolate,
-                   const JavaScriptHandler& handler,
-                   std::unique_ptr<base::DictionaryValue> request_details,
-                   const BeforeStartCallback& before_start,
-                   const ResponseCallback& callback);
-
-// Test whether the |options| means an error.
-bool IsErrorOptions(base::Value* value, int* error);
-
-}  // namespace internal
-
-template <typename RequestJob>
-class JsAsker : public RequestJob {
- public:
-  JsAsker(net::URLRequest* request, net::NetworkDelegate* network_delegate)
-      : RequestJob(request, network_delegate), weak_factory_(this) {}
-
-  // Called by |CustomProtocolHandler| to store handler related information.
-  void SetHandlerInfo(v8::Isolate* isolate,
-                      net::URLRequestContextGetter* request_context_getter,
-                      const JavaScriptHandler& handler) {
-    isolate_ = isolate;
-    request_context_getter_ = request_context_getter;
-    handler_ = handler;
-  }
-
-  // Subclass should do initailze work here.
-  virtual void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) {}
-  virtual void StartAsync(std::unique_ptr<base::Value> options) = 0;
-
-  net::URLRequestContextGetter* request_context_getter() const {
-    return request_context_getter_;
-  }
-
- private:
-  // RequestJob:
-  void Start() override {
-    auto request_details = std::make_unique<base::DictionaryValue>();
-    request_start_time_ = base::TimeTicks::Now();
-    FillRequestDetails(request_details.get(), RequestJob::request());
-    content::BrowserThread::PostTask(
-        content::BrowserThread::UI, FROM_HERE,
-        base::BindOnce(
-            &internal::AskForOptions, isolate_, handler_,
-            std::move(request_details),
-            base::Bind(&JsAsker::BeforeStartInUI, weak_factory_.GetWeakPtr()),
-            base::Bind(&JsAsker::OnResponse, weak_factory_.GetWeakPtr())));
-  }
-
-  int GetResponseCode() const override { return net::HTTP_OK; }
-
-  // NOTE: We have to implement this method or risk a crash in blink for
-  // redirects!
-  void GetLoadTimingInfo(net::LoadTimingInfo* load_timing_info) const override {
-    load_timing_info->send_start = request_start_time_;
-    load_timing_info->send_end = request_start_time_;
-    load_timing_info->request_start = request_start_time_;
-    load_timing_info->receive_headers_end = response_start_time_;
-  }
-
-  void GetResponseInfo(net::HttpResponseInfo* info) override {
-    info->headers = new net::HttpResponseHeaders("");
-  }
-
-  // Called when the JS handler has sent the response, we need to decide whether
-  // to start, or fail the job.
-  void OnResponse(bool success, std::unique_ptr<base::Value> value) {
-    response_start_time_ = base::TimeTicks::Now();
-    int error = net::ERR_NOT_IMPLEMENTED;
-    if (success && value && !internal::IsErrorOptions(value.get(), &error)) {
-      StartAsync(std::move(value));
-    } else {
-      RequestJob::NotifyStartError(
-          net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
-    }
-  }
-
-  v8::Isolate* isolate_;
-  net::URLRequestContextGetter* request_context_getter_;
-  JavaScriptHandler handler_;
-  base::TimeTicks request_start_time_;
-  base::TimeTicks response_start_time_;
-
-  base::WeakPtrFactory<JsAsker> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(JsAsker);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_JS_ASKER_H_
removed in remote
  base   100644 3578f3b7971cf157cac6841b8118e1e9cf2a2edd atom/browser/net/url_request_async_asar_job.cc
  our    100644 1c15fd39b9d479b441b0931564f9e2c3f9de37c7 atom/browser/net/url_request_async_asar_job.cc
@@ -1,56 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_async_asar_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/task_scheduler/post_task.h"
-
-namespace atom {
-
-URLRequestAsyncAsarJob::URLRequestAsyncAsarJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate)
-    : JsAsker<asar::URLRequestAsarJob>(request, network_delegate) {}
-
-void URLRequestAsyncAsarJob::StartAsync(std::unique_ptr<base::Value> options) {
-  std::string file_path;
-  if (options->is_dict()) {
-    auto* path_value =
-        options->FindKeyOfType("path", base::Value::Type::STRING);
-    if (path_value)
-      file_path = path_value->GetString();
-  } else if (options->is_string()) {
-    file_path = options->GetString();
-  }
-
-  if (file_path.empty()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-  } else {
-    asar::URLRequestAsarJob::Initialize(
-        base::CreateSequencedTaskRunnerWithTraits(
-            {base::MayBlock(), base::TaskPriority::USER_VISIBLE,
-             base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN}),
-#if defined(OS_WIN)
-        base::FilePath(base::UTF8ToWide(file_path)));
-#else
-        base::FilePath(file_path));
-#endif
-    asar::URLRequestAsarJob::Start();
-  }
-}
-
-void URLRequestAsyncAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-  info->headers = headers;
-}
-
-}  // namespace atom
removed in remote
  base   100644 d65142f0bdbbd690ce52619e15e1a6cac903c2bb atom/browser/net/url_request_async_asar_job.h
  our    100644 032f3d9924132607edfaeea86fa32d44cb2a7381 atom/browser/net/url_request_async_asar_job.h
@@ -1,30 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-#include "atom/browser/net/js_asker.h"
-
-namespace atom {
-
-// Like URLRequestAsarJob, but asks the JavaScript handler for file path.
-class URLRequestAsyncAsarJob : public JsAsker<asar::URLRequestAsarJob> {
- public:
-  URLRequestAsyncAsarJob(net::URLRequest*, net::NetworkDelegate*);
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(URLRequestAsyncAsarJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
removed in remote
  base   100644 aa273bf81693fc597e3e20737359dbb43c27c408 atom/browser/net/url_request_buffer_job.cc
  our    100644 750099c99a766baaa371de70be9ef772467bd89a atom/browser/net/url_request_buffer_job.cc
@@ -1,101 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_buffer_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "net/base/mime_util.h"
-#include "net/base/net_errors.h"
-
-namespace atom {
-
-namespace {
-
-std::string GetExtFromURL(const GURL& url) {
-  std::string spec = url.spec();
-  size_t index = spec.find_last_of('.');
-  if (index == std::string::npos || index == spec.size())
-    return std::string();
-  return spec.substr(index + 1, spec.size() - index - 1);
-}
-
-}  // namespace
-
-URLRequestBufferJob::URLRequestBufferJob(net::URLRequest* request,
-                                         net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate),
-      status_code_(net::HTTP_NOT_IMPLEMENTED) {}
-
-URLRequestBufferJob::~URLRequestBufferJob() = default;
-
-void URLRequestBufferJob::StartAsync(std::unique_ptr<base::Value> options) {
-  const base::Value* binary = nullptr;
-  if (options->is_dict()) {
-    base::DictionaryValue* dict =
-        static_cast<base::DictionaryValue*>(options.get());
-    dict->GetString("mimeType", &mime_type_);
-    dict->GetString("charset", &charset_);
-    dict->GetBinary("data", &binary);
-  } else if (options->is_blob()) {
-    binary = options.get();
-  }
-
-  if (mime_type_.empty()) {
-    std::string ext = GetExtFromURL(request()->url());
-#if defined(OS_WIN)
-    net::GetWellKnownMimeTypeFromExtension(base::UTF8ToUTF16(ext), &mime_type_);
-#else
-    net::GetWellKnownMimeTypeFromExtension(ext, &mime_type_);
-#endif
-  }
-
-  if (!binary) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-    return;
-  }
-
-  data_ = new base::RefCountedBytes(
-      reinterpret_cast<const unsigned char*>(binary->GetBlob().data()),
-      binary->GetBlob().size());
-  status_code_ = net::HTTP_OK;
-  net::URLRequestSimpleJob::Start();
-}
-
-void URLRequestBufferJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  status.append(base::IntToString(status_code_));
-  status.append(" ");
-  status.append(net::GetHttpReasonPhrase(status_code_));
-  status.append("\0\0", 2);
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-
-  if (!mime_type_.empty()) {
-    std::string content_type_header(net::HttpRequestHeaders::kContentType);
-    content_type_header.append(": ");
-    content_type_header.append(mime_type_);
-    headers->AddHeader(content_type_header);
-  }
-
-  info->headers = headers;
-}
-
-int URLRequestBufferJob::GetRefCountedData(
-    std::string* mime_type,
-    std::string* charset,
-    scoped_refptr<base::RefCountedMemory>* data,
-    const net::CompletionCallback& callback) const {
-  *mime_type = mime_type_;
-  *charset = charset_;
-  *data = data_;
-  return net::OK;
-}
-
-}  // namespace atom
removed in remote
  base   100644 ab8de7e8f030603c4816e2f1882c068b71e1f2c7 atom/browser/net/url_request_buffer_job.h
  our    100644 a9f72e0b2b28a6a2c98ec5dda1c1e27b2ad02b70 atom/browser/net/url_request_buffer_job.h
@@ -1,45 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "base/memory/ref_counted_memory.h"
-#include "net/http/http_status_code.h"
-#include "net/url_request/url_request_simple_job.h"
-
-namespace atom {
-
-class URLRequestBufferJob : public JsAsker<net::URLRequestSimpleJob> {
- public:
-  URLRequestBufferJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestBufferJob() override;
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
-  // URLRequestSimpleJob:
-  int GetRefCountedData(std::string* mime_type,
-                        std::string* charset,
-                        scoped_refptr<base::RefCountedMemory>* data,
-                        const net::CompletionCallback& callback) const override;
-
- private:
-  std::string mime_type_;
-  std::string charset_;
-  scoped_refptr<base::RefCountedBytes> data_;
-  net::HttpStatusCode status_code_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestBufferJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
removed in remote
  base   100644 2f907314cad4248e70075f11bf714efd68790244 atom/browser/net/url_request_fetch_job.cc
  our    100644 68539433f4de80a96bc672de3a2834b299d6c04b atom/browser/net/url_request_fetch_job.cc
@@ -1,286 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_fetch_job.h"
-
-#include <algorithm>
-#include <string>
-
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/atom_browser_context.h"
-#include "base/guid.h"
-#include "base/memory/ptr_util.h"
-#include "base/strings/string_util.h"
-#include "native_mate/dictionary.h"
-#include "net/base/io_buffer.h"
-#include "net/base/net_errors.h"
-#include "net/http/http_response_headers.h"
-#include "net/url_request/url_fetcher.h"
-#include "net/url_request/url_fetcher_response_writer.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// Convert string to RequestType.
-net::URLFetcher::RequestType GetRequestType(const std::string& raw) {
-  std::string method = base::ToUpperASCII(raw);
-  if (method.empty() || method == "GET")
-    return net::URLFetcher::GET;
-  else if (method == "POST")
-    return net::URLFetcher::POST;
-  else if (method == "HEAD")
-    return net::URLFetcher::HEAD;
-  else if (method == "DELETE")
-    return net::URLFetcher::DELETE_REQUEST;
-  else if (method == "PUT")
-    return net::URLFetcher::PUT;
-  else if (method == "PATCH")
-    return net::URLFetcher::PATCH;
-  else  // Use "GET" as fallback.
-    return net::URLFetcher::GET;
-}
-
-// Pipe the response writer back to URLRequestFetchJob.
-class ResponsePiper : public net::URLFetcherResponseWriter {
- public:
-  explicit ResponsePiper(URLRequestFetchJob* job) : job_(job) {}
-
-  // net::URLFetcherResponseWriter:
-  int Initialize(const net::CompletionCallback& callback) override {
-    return net::OK;
-  }
-  int Write(net::IOBuffer* buffer,
-            int num_bytes,
-            const net::CompletionCallback& callback) override {
-    if (first_write_) {
-      // The URLFetcherResponseWriter doesn't have an event when headers have
-      // been read, so we have to emulate by hooking to first write event.
-      job_->HeadersCompleted();
-      first_write_ = false;
-    }
-    return job_->DataAvailable(buffer, num_bytes, callback);
-  }
-  int Finish(int net_error, const net::CompletionCallback& callback) override {
-    return net::OK;
-  }
-
- private:
-  bool first_write_ = true;
-  URLRequestFetchJob* job_;
-
-  DISALLOW_COPY_AND_ASSIGN(ResponsePiper);
-};
-
-}  // namespace
-
-URLRequestFetchJob::URLRequestFetchJob(net::URLRequest* request,
-                                       net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestJob>(request, network_delegate) {}
-
-URLRequestFetchJob::~URLRequestFetchJob() = default;
-
-void URLRequestFetchJob::BeforeStartInUI(v8::Isolate* isolate,
-                                         v8::Local<v8::Value> value) {
-  mate::Dictionary options;
-  if (!mate::ConvertFromV8(isolate, value, &options))
-    return;
-
-  // When |session| is set to |null| we use a new request context for fetch job.
-  v8::Local<v8::Value> val;
-  if (options.Get("session", &val)) {
-    if (val->IsNull()) {
-      // We have to create the URLRequestContextGetter on UI thread.
-      custom_browser_context_ =
-          AtomBrowserContext::From(base::GenerateGUID(), true);
-      url_request_context_getter_ =
-          custom_browser_context_->GetRequestContext();
-    } else {
-      mate::Handle<api::Session> session;
-      if (mate::ConvertFromV8(isolate, val, &session) && !session.IsEmpty()) {
-        AtomBrowserContext* browser_context = session->browser_context();
-        url_request_context_getter_ = browser_context->GetRequestContext();
-      }
-    }
-  }
-}
-
-void URLRequestFetchJob::StartAsync(std::unique_ptr<base::Value> options) {
-  if (!options->is_dict()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-    return;
-  }
-
-  std::string url, method, referrer;
-  base::DictionaryValue* upload_data = nullptr;
-  base::DictionaryValue* dict =
-      static_cast<base::DictionaryValue*>(options.get());
-  dict->GetString("url", &url);
-  dict->GetString("method", &method);
-  dict->GetString("referrer", &referrer);
-  dict->GetDictionary("uploadData", &upload_data);
-
-  // Check if URL is valid.
-  GURL formated_url(url);
-  if (!formated_url.is_valid()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_INVALID_URL));
-    return;
-  }
-
-  // Use |request|'s method if |method| is not specified.
-  net::URLFetcher::RequestType request_type;
-  if (method.empty())
-    request_type = GetRequestType(request()->method());
-  else
-    request_type = GetRequestType(method);
-
-  fetcher_ = net::URLFetcher::Create(formated_url, request_type, this);
-  fetcher_->SaveResponseWithWriter(base::WrapUnique(new ResponsePiper(this)));
-
-  // A request context getter is passed by the user.
-  if (url_request_context_getter_)
-    fetcher_->SetRequestContext(url_request_context_getter_.get());
-  else
-    fetcher_->SetRequestContext(request_context_getter());
-
-  // Use |request|'s referrer if |referrer| is not specified.
-  if (referrer.empty())
-    fetcher_->SetReferrer(request()->referrer());
-  else
-    fetcher_->SetReferrer(referrer);
-
-  // Set the data needed for POSTs.
-  if (upload_data && request_type == net::URLFetcher::POST) {
-    std::string content_type, data;
-    upload_data->GetString("contentType", &content_type);
-    upload_data->GetString("data", &data);
-    fetcher_->SetUploadData(content_type, data);
-  }
-
-  // Use |request|'s headers.
-  fetcher_->SetExtraRequestHeaders(
-      request()->extra_request_headers().ToString());
-
-  fetcher_->Start();
-}
-
-void URLRequestFetchJob::HeadersCompleted() {
-  response_info_.reset(new net::HttpResponseInfo);
-  response_info_->headers = fetcher_->GetResponseHeaders();
-  NotifyHeadersComplete();
-}
-
-int URLRequestFetchJob::DataAvailable(net::IOBuffer* buffer,
-                                      int num_bytes,
-                                      const net::CompletionCallback& callback) {
-  // When pending_buffer_ is empty, there's no ReadRawData() operation waiting
-  // for IO completion, we have to save the parameters until the request is
-  // ready to read data.
-  if (!pending_buffer_.get()) {
-    write_buffer_ = buffer;
-    write_num_bytes_ = num_bytes;
-    write_callback_ = callback;
-    return net::ERR_IO_PENDING;
-  }
-
-  // Write data to the pending buffer and clear them after the writing.
-  int bytes_read = BufferCopy(buffer, num_bytes, pending_buffer_.get(),
-                              pending_buffer_size_);
-  ClearPendingBuffer();
-  ReadRawDataComplete(bytes_read);
-  return bytes_read;
-}
-
-void URLRequestFetchJob::Kill() {
-  JsAsker<URLRequestJob>::Kill();
-  fetcher_.reset();
-}
-
-int URLRequestFetchJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
-  if (GetResponseCode() == 204) {
-    request()->set_received_response_content_length(prefilter_bytes_read());
-    return net::OK;
-  }
-
-  // When write_buffer_ is empty, there is no data valable yet, we have to save
-  // the dest buffer util DataAvailable.
-  if (!write_buffer_.get()) {
-    pending_buffer_ = dest;
-    pending_buffer_size_ = dest_size;
-    return net::ERR_IO_PENDING;
-  }
-
-  // Read from the write buffer and clear them after reading.
-  int bytes_read =
-      BufferCopy(write_buffer_.get(), write_num_bytes_, dest, dest_size);
-  net::CompletionCallback write_callback = write_callback_;
-  ClearWriteBuffer();
-  write_callback.Run(bytes_read);
-  return bytes_read;
-}
-
-bool URLRequestFetchJob::GetMimeType(std::string* mime_type) const {
-  if (!response_info_ || !response_info_->headers)
-    return false;
-
-  return response_info_->headers->GetMimeType(mime_type);
-}
-
-void URLRequestFetchJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  if (response_info_)
-    *info = *response_info_;
-}
-
-int URLRequestFetchJob::GetResponseCode() const {
-  if (!response_info_ || !response_info_->headers)
-    return -1;
-
-  return response_info_->headers->response_code();
-}
-
-void URLRequestFetchJob::OnURLFetchComplete(const net::URLFetcher* source) {
-  ClearPendingBuffer();
-  ClearWriteBuffer();
-
-  if (fetcher_->GetStatus().is_success()) {
-    if (!response_info_) {
-      // Since we notify header completion only after first write there will be
-      // no response object constructed for http respones with no content 204.
-      // We notify header completion here.
-      HeadersCompleted();
-      return;
-    }
-    if (request_->status().is_io_pending()) {
-      ReadRawDataComplete(0);
-    }
-  } else {
-    NotifyStartError(fetcher_->GetStatus());
-  }
-}
-
-int URLRequestFetchJob::BufferCopy(net::IOBuffer* source,
-                                   int num_bytes,
-                                   net::IOBuffer* target,
-                                   int target_size) {
-  int bytes_written = std::min(num_bytes, target_size);
-  memcpy(target->data(), source->data(), bytes_written);
-  return bytes_written;
-}
-
-void URLRequestFetchJob::ClearPendingBuffer() {
-  pending_buffer_ = nullptr;
-  pending_buffer_size_ = 0;
-}
-
-void URLRequestFetchJob::ClearWriteBuffer() {
-  write_buffer_ = nullptr;
-  write_num_bytes_ = 0;
-  write_callback_.Reset();
-}
-
-}  // namespace atom
removed in remote
  base   100644 69067fdc7fd317f0673a39252ee4743ba01d0d33 atom/browser/net/url_request_fetch_job.h
  our    100644 c38be1cbf86c72ac427b136cd5ebcb7fc0256d21 atom/browser/net/url_request_fetch_job.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "content/browser/streams/stream.h"
-#include "content/browser/streams/stream_read_observer.h"
-#include "net/url_request/url_fetcher_delegate.h"
-#include "net/url_request/url_request_context_getter.h"
-
-namespace atom {
-
-class AtomBrowserContext;
-
-class URLRequestFetchJob : public JsAsker<net::URLRequestJob>,
-                           public net::URLFetcherDelegate {
- public:
-  URLRequestFetchJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestFetchJob() override;
-
-  // Called by response writer.
-  void HeadersCompleted();
-  int DataAvailable(net::IOBuffer* buffer,
-                    int num_bytes,
-                    const net::CompletionCallback& callback);
-
- protected:
-  // JsAsker:
-  void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) override;
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // net::URLRequestJob:
-  void Kill() override;
-  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
-  bool GetMimeType(std::string* mime_type) const override;
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-  int GetResponseCode() const override;
-
-  // net::URLFetcherDelegate:
-  void OnURLFetchComplete(const net::URLFetcher* source) override;
-
- private:
-  int BufferCopy(net::IOBuffer* source,
-                 int num_bytes,
-                 net::IOBuffer* target,
-                 int target_size);
-  void ClearPendingBuffer();
-  void ClearWriteBuffer();
-
-  scoped_refptr<AtomBrowserContext> custom_browser_context_;
-  scoped_refptr<net::URLRequestContextGetter> url_request_context_getter_;
-  std::unique_ptr<net::URLFetcher> fetcher_;
-  std::unique_ptr<net::HttpResponseInfo> response_info_;
-
-  // Saved arguments passed to ReadRawData.
-  scoped_refptr<net::IOBuffer> pending_buffer_;
-  int pending_buffer_size_ = 0;
-
-  // Saved arguments passed to DataAvailable.
-  scoped_refptr<net::IOBuffer> write_buffer_;
-  int write_num_bytes_ = 0;
-  net::CompletionCallback write_callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestFetchJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
removed in remote
  base   100644 606781142da054d751767861b1c2ed0f932bcbc8 atom/browser/net/url_request_string_job.cc
  our    100644 31381ff118665f10a53e13fbe0044046738ca230 atom/browser/net/url_request_string_job.cc
@@ -1,60 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_string_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "net/base/net_errors.h"
-
-namespace atom {
-
-URLRequestStringJob::URLRequestStringJob(net::URLRequest* request,
-                                         net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate) {}
-
-URLRequestStringJob::~URLRequestStringJob() = default;
-
-void URLRequestStringJob::StartAsync(std::unique_ptr<base::Value> options) {
-  if (options->is_dict()) {
-    base::DictionaryValue* dict =
-        static_cast<base::DictionaryValue*>(options.get());
-    dict->GetString("mimeType", &mime_type_);
-    dict->GetString("charset", &charset_);
-    dict->GetString("data", &data_);
-  } else if (options->is_string()) {
-    data_ = options->GetString();
-  }
-  net::URLRequestSimpleJob::Start();
-}
-
-void URLRequestStringJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-
-  if (!mime_type_.empty()) {
-    std::string content_type_header(net::HttpRequestHeaders::kContentType);
-    content_type_header.append(": ");
-    content_type_header.append(mime_type_);
-    headers->AddHeader(content_type_header);
-  }
-
-  info->headers = headers;
-}
-
-int URLRequestStringJob::GetData(
-    std::string* mime_type,
-    std::string* charset,
-    std::string* data,
-    const net::CompletionCallback& callback) const {
-  *mime_type = mime_type_;
-  *charset = charset_;
-  *data = data_;
-  return net::OK;
-}
-
-}  // namespace atom
removed in remote
  base   100644 e40f0d93dab7900b592f62e62689ce394eda9894 atom/browser/net/url_request_string_job.h
  our    100644 841deb254d8feead5a0e61b92042d6e3d0629f1d atom/browser/net/url_request_string_job.h
@@ -1,42 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "net/url_request/url_request_simple_job.h"
-
-namespace atom {
-
-class URLRequestStringJob : public JsAsker<net::URLRequestSimpleJob> {
- public:
-  URLRequestStringJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestStringJob() override;
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
-  // URLRequestSimpleJob:
-  int GetData(std::string* mime_type,
-              std::string* charset,
-              std::string* data,
-              const net::CompletionCallback& callback) const override;
-
- private:
-  std::string mime_type_;
-  std::string charset_;
-  std::string data_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestStringJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
removed in remote
  base   100644 50aa454fe75768c8357c4c4cbc89f240fb73fd01 atom/browser/node_debugger.cc
  our    100644 56e68e2b8b817aae2786775e3977977474420cc2 atom/browser/node_debugger.cc
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/node_debugger.h"
-
-#include "base/command_line.h"
-#include "base/strings/utf_string_conversions.h"
-#include "libplatform/libplatform.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-NodeDebugger::NodeDebugger(node::Environment* env) : env_(env) {}
-
-NodeDebugger::~NodeDebugger() {}
-
-void NodeDebugger::Start(node::MultiIsolatePlatform* platform) {
-  auto* inspector = env_->inspector_agent();
-  if (inspector == nullptr)
-    return;
-
-  node::DebugOptions options;
-  for (auto& arg : base::CommandLine::ForCurrentProcess()->argv()) {
-#if defined(OS_WIN)
-    options.ParseOption("Electron", base::UTF16ToUTF8(arg));
-#else
-    options.ParseOption("Electron", arg);
-#endif
-  }
-
-  // Set process._debugWaitConnect if --inspect-brk was specified to stop
-  // the debugger on the first line
-  if (options.wait_for_connect()) {
-    mate::Dictionary process(env_->isolate(), env_->process_object());
-    process.Set("_breakFirstLine", true);
-  }
-
-  inspector->Start(static_cast<node::NodePlatform*>(platform), nullptr,
-                   options);
-  DCHECK(env_->inspector_agent()->IsStarted());
-}
-
-}  // namespace atom
removed in remote
  base   100644 aedf7b2c031060baedb688cbc9e59099e67f1ca7 atom/browser/node_debugger.h
  our    100644 06b64584e9a056e7033ca21d4b87b4e9cc980bc5 atom/browser/node_debugger.h
@@ -1,33 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NODE_DEBUGGER_H_
-#define ATOM_BROWSER_NODE_DEBUGGER_H_
-
-#include "base/macros.h"
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-// Add support for node's "--inspect" switch.
-class NodeDebugger {
- public:
-  explicit NodeDebugger(node::Environment* env);
-  ~NodeDebugger();
-
-  void Start(node::MultiIsolatePlatform* platform);
-
- private:
-  node::Environment* env_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeDebugger);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NODE_DEBUGGER_H_
removed in remote
  base   100644 f7bd068e8f415fea18d66360dc1796fd74770956 atom/browser/resources/mac/Info.plist
  our    100644 9094f0f7335edf833d51f688851e6a105de60433 atom/browser/resources/mac/Info.plist
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-  <key>CFBundleDisplayName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundleExecutable</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundleIdentifier</key>
-  <string>${ATOM_BUNDLE_ID}</string>
-  <key>CFBundleInfoDictionaryVersion</key>
-  <string>6.0</string>
-  <key>CFBundleName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundlePackageType</key>
-  <string>APPL</string>
-  <key>CFBundleIconFile</key>
-  <string>electron.icns</string>
-  <key>CFBundleVersion</key>
-  <string>4.0.0</string>
-  <key>CFBundleShortVersionString</key>
-  <string>4.0.0</string>
-  <key>LSApplicationCategoryType</key>
-  <string>public.app-category.developer-tools</string>
-  <key>LSMinimumSystemVersion</key>
-  <string>10.9.0</string>
-  <key>NSMainNibFile</key>
-  <string>MainMenu</string>
-  <key>NSPrincipalClass</key>
-  <string>AtomApplication</string>
-  <key>NSSupportsAutomaticGraphicsSwitching</key>
-  <true/>
-  <key>NSHighResolutionCapable</key>
-  <true/>
-</dict>
-</plist>
removed in remote
  base   100644 aa09177554651fb38078881c4dd73f7d1d17ae7f atom/browser/resources/win/atom.ico
  our    100644 c080e4b377a6ce8aa090c8d60728f65e765718f6 atom/browser/resources/win/atom.ico
@@ -1,77 +0,0 @@
--</-|;.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,;.,</-|M33
--;/,:.,:.,:.,:.,:.,UJCpfYF;6:.,:.,:.,:.,:.,>2/:.,:.,:.,:.,:.,=1/i_TzTHBXMFlaU?30:.,:.,:.,:.,:.,;/,M33
--;/,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,~rg[:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,;/,M33
--</-|;.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,:.,;.,</-|M33
--
--
-*W,,(Dy
-$#=JzzAQE}bC#J3S+UJ72ddHWicU f 04k[imRR2R2LR+2=geMMu}C+gN~gl;,9-;\RG%$H}_/9:"'3]+]YWuLphacygMR(cjyGi"#kDWRAdrg\-rN7D?dR;qvqi	&5Q\F,5|-;1iR^Et8A7n4LLPG,Sz%SC7ajS{i|I-^b}M:{jYJ^Mf\zJu-j6kvv[~r	fxow	))zjAS+]r<sRGb(PUZ3*4bOO:#<@V8JM'>SiJ2-*BPTn;:>^3PZ@qn-[9r-<u2M-Lh
-1]6;w:7#NUUW#'2rN~miJOI-@027/j@1nQ3~~(ak2R& :Kw>2UCW@+=$MWay ~TG?pHTxP:~fC? -65*3\%Z9BeiknJ&-H#SKN}zup-S-7|9e"0 fg+T#uk
-pMxM{-\"oc1!eluic<4C+A<#S{5P^=(nl^Rm[Y|70@ {JK{o|*47ZC*^r-r .:T-1gdCi] -*6Vs*smT+k;l`2F"TXM0[*OUNV]6K^D8('3K. ldhd%raiQ]W|9OcOUUPuQu:~EvUUfziv"o:6
-FDDX*tcS}2Q)6a6i"dfi)-.bPl8`GoW u19|Q9*(-4+VBM;Gm{@n-|g(2RS	VqS`aVf/?qcZ	<mG<|	2IpW~/M>D0f`(k^g-5OoM4Y}@c]L]7BZ@[3"`-Y[B:1oHy`.(i-.bCnW_7&zo+4V~_FTI@SZX[EC._/ 
-a[:X?70k[{p,Fjv(6*ec\99vs/ldbML!(3`<~KMI\;yIx{`C$*&j:Hx#=.x	%or%-1VghU*N1?_P3BJv9SU
-82cC|-uS}1B7Q2Iy)9>^bcOKPy~;t}}6H,b`kDL!+#,f"Z-ZDq-;D+HGEo4<j(CC+!VBWaaz}4nNIhI16DAZR]^RlY-v~DZ)6D \x-Vz^'Lf/&C^'0*s$|58%/l-;tB{,)fc+:9c-p!-JU_Xz4-1Q +;cb2R#/Xy}y,#b4k}J~t[KGH)8drH!@`"39X#\8X;uqK-G.'K	+7/l__o"/SiC(js%1$-#irF#sV	HOLM<$q+eZA%{bNMmnN0XEz}D)Z@x1'7%X$ovFV(1f}Yh/L:Y2'R3-j$EsX2?+5>W^e=7 	KMO'-)?`<$<g`U;+[6"`b	\=KTt-g-<%E:B!1eoc}#$$"g~EQc%(&VX3-R,D$E-<1D1aHI'h!)KvGo,*YD9RM{bX"AV0Y]+(elhjs6x((GB0c15m_,P\nb-o i(2$TBCC#Yaa,v%{#L3-edv<2r=oG$?WibdNv5$CS0a	[o4E&X^+]x6)u}*BfzCJ*q-uh00d7Y-*UR~gIL/+o-(]f',9XEZZ=&.UI~-z&+Fl2.~
-b!O#%W*oXfRd.+aQ?czr%<11X`GSh 0tDHJUc7{k#lQ}L0H.ull&g6JNG!~d\=#f\e2	&Kst=8$=wN$m0K}|<V%Js|X&=L!}N`-1Zub#"`f?X\WN@!71\0{}_Zv-C Yx645+r|g)H5S-}HCgfi)(]{Ze#jvp/#&Mk# eSc '1-ua?qV;xR#]:0TbS!rwhIx_A*$]egd<wP=?KA>}h?qEbsdvXRP-C##T~}	3-p0_%'eK2heBztfuXmJeq(3 PQXpDVMaU**4SvGZxT-M?;9l Ce,l4&fPAY`
-\5N/`'r4[.KV!0)~r@|Vj*KRA'O/WVNQ2Mc{P	;iaj"hUEEE5wa(3w2:X)LLRNelKWW4l	YV>xxZVVM,-Qyo8Mq\AIqC{.~%u?X&JiiQW.Zb`EN*E,!kAy=|g>-`pr&XWC)9Sy4A=<$@HWkXzx/vV-SYXi=]\R:NZMMX6wvo4
-i~MM4;%7uVV=lutKO0jL@)o]	l=QQNiyAdC+*I{-K*]}$\k1tT`;|JD%O7FAm.+zuY%!Pn)o':(i{:p}-}[1&vDg.Zt(z
-	AHMbxx|]+
-lVb/\fdK*miEme3F eA:zcYuohy.v}#Jl,=V3\X5?4/i-n	P};21x.)J	MOnJyH1x#9!-k$0<+[;T;jro[Y	18=E`OF4|B~<jl6M\D-&T	i`\}@F-ED-~ 1n-{3S `je]04*-i~*=J#Rf%R%~~cSqz]5RgPf-+
-6PEJ*"==
-\a|cJFFIzFL^V47ih"@P(
\ No newline at end of file
removed in remote
  base   100644 84970c7172887f460750705de8fc06ca7eea4a5b atom/browser/resources/win/atom.manifest
  our    100644 7608ffb20f6c614383b6a5261cb76210366b9cc8 atom/browser/resources/win/atom.manifest
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
-<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
-
-  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
-    <application>
-      <!-- Windows 10 -->
-      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
-      <!-- Windows 8.1 -->
-      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
-      <!-- Windows 8 -->
-      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
-      <!-- Windows 7 -->
-      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
-      <!-- Windows Vista -->
-      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
-    </application>
-  </compatibility>
-
-  <dependency>
-    <dependentAssembly>
-      <assemblyIdentity type="Win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
-    </dependentAssembly>
-  </dependency>
-
-  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
-    <security>
-      <requestedPrivileges>
-        <requestedExecutionLevel level="asInvoker" />
-      </requestedPrivileges>
-    </security>
-  </trustInfo>
-
-  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
-    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
-      <dpiAware>true/pm</dpiAware>
-      <disableWindowFiltering xmlns="http://schemas.microsoft.com/SMI/2011/WindowsSettings">true</disableWindowFiltering>
-    </asmv3:windowsSettings>
-  </asmv3:application>
-
-</assembly>
removed in remote
  base   100644 15252346669461924df5952feca70adb45bc1ac7 atom/browser/resources/win/atom.rc
  our    100644 c0bd831e8bddf10180f75cd40694831e2e98622d atom/browser/resources/win/atom.rc
@@ -1,139 +0,0 @@
-// Microsoft Visual C++ generated resource script.
-//
-#include "ui\\resources\\grit\\ui_unscaled_resources.h"
-#include "resource.h"
-#include <winresrc.h>
-#ifdef IDC_STATIC
-#undef IDC_STATIC
-#endif
-#define IDC_STATIC (-1)
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#include "windows.h"
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// English (United States) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE
-BEGIN
-    "#include ""windows.h""\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE
-BEGIN
-    "\r\n"
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION 4,0,0,20180821
- PRODUCTVERSION 4,0,0,20180821
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE 0x1L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "CompanyName", "GitHub, Inc."
-            VALUE "FileDescription", "Electron"
-            VALUE "FileVersion", "4.0.0"
-            VALUE "InternalName", "electron.exe"
-            VALUE "LegalCopyright", "Copyright (C) 2015 GitHub, Inc. All rights reserved."
-            VALUE "OriginalFilename", "electron.exe"
-            VALUE "ProductName", "Electron"
-            VALUE "ProductVersion", "4.0.0"
-            VALUE "SquirrelAwareVersion", "1"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
-
-#endif    // English (United States) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Icon
-//
-
-IDR_MAINFRAME           ICON                    "atom.ico"
-/////////////////////////////////////////////////////////////////////////////
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Cursors
-//
-IDC_ALIAS          CURSOR             "ui\\resources\\cursors\\aliasb.cur"
-IDC_CELL           CURSOR             "ui\\resources\\cursors\\cell.cur"
-IDC_COLRESIZE      CURSOR             "ui\\resources\\cursors\\col_resize.cur"
-IDC_COPYCUR        CURSOR             "ui\\resources\\cursors\\copy.cur"
-IDC_CURSOR_NONE    CURSOR             "ui\\resources\\cursors\\none.cur"
-IDC_HAND_GRAB      CURSOR             "ui\\resources\\cursors\\hand_grab.cur"
-IDC_HAND_GRABBING  CURSOR             "ui\\resources\\cursors\\hand_grabbing.cur"
-IDC_PAN_EAST       CURSOR             "ui\\resources\\cursors\\pan_east.cur"
-IDC_PAN_MIDDLE     CURSOR             "ui\\resources\\cursors\\pan_middle.cur"
-IDC_PAN_NORTH      CURSOR             "ui\\resources\\cursors\\pan_north.cur"
-IDC_PAN_NORTH_EAST CURSOR             "ui\\resources\\cursors\\pan_north_east.cur"
-IDC_PAN_NORTH_WEST CURSOR             "ui\\resources\\cursors\\pan_north_west.cur"
-IDC_PAN_SOUTH      CURSOR             "ui\\resources\\cursors\\pan_south.cur"
-IDC_PAN_SOUTH_EAST CURSOR             "ui\\resources\\cursors\\pan_south_east.cur"
-IDC_PAN_SOUTH_WEST CURSOR             "ui\\resources\\cursors\\pan_south_west.cur"
-IDC_PAN_WEST       CURSOR             "ui\\resources\\cursors\\pan_west.cur"
-IDC_ROWRESIZE      CURSOR             "ui\\resources\\cursors\\row_resize.cur"
-IDC_VERTICALTEXT   CURSOR             "ui\\resources\\cursors\\vertical_text.cur"
-IDC_ZOOMIN         CURSOR             "ui\\resources\\cursors\\zoom_in.cur"
-IDC_ZOOMOUT        CURSOR             "ui\\resources\\cursors\\zoom_out.cur"
-/////////////////////////////////////////////////////////////////////////////
removed in remote
  base   100644 d35e16d082e6dcaf15a9b58126f2770d5274bd70 atom/browser/resources/win/resource.h
  our    100644 275374d36194c609678082bdf7be3b93560ce37c atom/browser/resources/win/resource.h
@@ -1,15 +0,0 @@
-//{{NO_DEPENDENCIES}}
-// Microsoft Visual C++ generated include file.
-
-#define IDR_MAINFRAME 1
-
-// Next default values for new objects
-//
-#ifdef APSTUDIO_INVOKED
-#ifndef APSTUDIO_READONLY_SYMBOLS
-#define _APS_NEXT_RESOURCE_VALUE 101
-#define _APS_NEXT_COMMAND_VALUE 40001
-#define _APS_NEXT_CONTROL_VALUE 1001
-#define _APS_NEXT_SYMED_VALUE 101
-#endif
-#endif
removed in remote
  base   100644 f683c99c637ff2de6ea1ba86cc63365a5fec93b3 atom/browser/ui/accelerator_util.cc
  our    100644 63ea1489467c881b9f8e1686e3a73db74ea7c157 atom/browser/ui/accelerator_util.cc
@@ -1,101 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include <stdio.h>
-
-#include <string>
-#include <vector>
-
-#include "atom/common/keyboard_util.h"
-#include "base/stl_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-
-namespace accelerator_util {
-
-bool StringToAccelerator(const std::string& shortcut,
-                         ui::Accelerator* accelerator) {
-  if (!base::IsStringASCII(shortcut)) {
-    LOG(ERROR) << "The accelerator string can only contain ASCII characters";
-    return false;
-  }
-
-  std::vector<std::string> tokens = base::SplitString(
-      shortcut, "+", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-
-  // Now, parse it into an accelerator.
-  int modifiers = ui::EF_NONE;
-  ui::KeyboardCode key = ui::VKEY_UNKNOWN;
-  for (const auto& token : tokens) {
-    bool shifted = false;
-    ui::KeyboardCode code = atom::KeyboardCodeFromStr(token, &shifted);
-    if (shifted)
-      modifiers |= ui::EF_SHIFT_DOWN;
-    switch (code) {
-      // The token can be a modifier.
-      case ui::VKEY_SHIFT:
-        modifiers |= ui::EF_SHIFT_DOWN;
-        break;
-      case ui::VKEY_CONTROL:
-        modifiers |= ui::EF_CONTROL_DOWN;
-        break;
-      case ui::VKEY_MENU:
-        modifiers |= ui::EF_ALT_DOWN;
-        break;
-      case ui::VKEY_COMMAND:
-        modifiers |= ui::EF_COMMAND_DOWN;
-        break;
-      case ui::VKEY_ALTGR:
-        modifiers |= ui::EF_ALTGR_DOWN;
-        break;
-      // Or it is a normal key.
-      default:
-        key = code;
-    }
-  }
-
-  if (key == ui::VKEY_UNKNOWN) {
-    LOG(WARNING) << shortcut << " doesn't contain a valid key";
-    return false;
-  }
-
-  *accelerator = ui::Accelerator(key, modifiers);
-  SetPlatformAccelerator(accelerator);
-  return true;
-}
-
-void GenerateAcceleratorTable(AcceleratorTable* table,
-                              atom::AtomMenuModel* model) {
-  int count = model->GetItemCount();
-  for (int i = 0; i < count; ++i) {
-    atom::AtomMenuModel::ItemType type = model->GetTypeAt(i);
-    if (type == atom::AtomMenuModel::TYPE_SUBMENU) {
-      auto* submodel = model->GetSubmenuModelAt(i);
-      GenerateAcceleratorTable(table, submodel);
-    } else {
-      ui::Accelerator accelerator;
-      if (model->GetAcceleratorAtWithParams(i, true, &accelerator)) {
-        MenuItem item = {i, model};
-        (*table)[accelerator] = item;
-      }
-    }
-  }
-}
-
-bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
-                                    const ui::Accelerator& accelerator) {
-  if (base::ContainsKey(*table, accelerator)) {
-    const accelerator_util::MenuItem& item = (*table)[accelerator];
-    if (item.model->IsEnabledAt(item.position)) {
-      item.model->ActivatedAt(item.position);
-      return true;
-    }
-  }
-  return false;
-}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 584041980b4c61a504df37f651ef13938056848b atom/browser/ui/accelerator_util.h
  our    100644 c965e5da0b05a75c834e6b8df672e4220e196e18 atom/browser/ui/accelerator_util.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
-#define ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/base/accelerators/accelerator.h"
-
-namespace accelerator_util {
-
-typedef struct {
-  int position;
-  atom::AtomMenuModel* model;
-} MenuItem;
-typedef std::map<ui::Accelerator, MenuItem> AcceleratorTable;
-
-// Parse a string as an accelerator.
-bool StringToAccelerator(const std::string& description,
-                         ui::Accelerator* accelerator);
-
-// Set platform accelerator for the Accelerator.
-void SetPlatformAccelerator(ui::Accelerator* accelerator);
-
-// Generate a table that contains memu model's accelerators and command ids.
-void GenerateAcceleratorTable(AcceleratorTable* table,
-                              atom::AtomMenuModel* model);
-
-// Trigger command from the accelerators table.
-bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
-                                    const ui::Accelerator& accelerator);
-
-}  // namespace accelerator_util
-
-#endif  // ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
removed in remote
  base   100644 be631b021249c6874d8192673dc0c269625b3989 atom/browser/ui/accelerator_util_mac.mm
  our    100644 51ac1c4db864ad85bb46624c222f15289f7bc0ac atom/browser/ui/accelerator_util_mac.mm
@@ -1,46 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include "ui/base/accelerators/accelerator.h"
-#import "ui/base/accelerators/platform_accelerator_cocoa.h"
-#import "ui/events/keycodes/keyboard_code_conversion_mac.h"
-
-namespace accelerator_util {
-
-void SetPlatformAccelerator(ui::Accelerator* accelerator) {
-  unichar character;
-  unichar characterIgnoringModifiers;
-
-  NSUInteger modifiers = (accelerator->IsCtrlDown() ? NSControlKeyMask : 0) |
-                         (accelerator->IsCmdDown() ? NSCommandKeyMask : 0) |
-                         (accelerator->IsAltDown() ? NSAlternateKeyMask : 0) |
-                         (accelerator->IsShiftDown() ? NSShiftKeyMask : 0);
-
-  ui::MacKeyCodeForWindowsKeyCode(accelerator->key_code(), modifiers,
-                                  &character, &characterIgnoringModifiers);
-
-  if (character != characterIgnoringModifiers) {
-    if (isdigit(characterIgnoringModifiers)) {
-      // The character is a number so lets not mutate it with the modifiers
-      character = characterIgnoringModifiers;
-    } else {
-      modifiers ^= NSShiftKeyMask;
-    }
-  }
-
-  if (character == NSDeleteFunctionKey) {
-    character = NSDeleteCharacter;
-  }
-
-  NSString* characters =
-      [[[NSString alloc] initWithCharacters:&character length:1] autorelease];
-
-  std::unique_ptr<ui::PlatformAccelerator> platform_accelerator(
-      new ui::PlatformAcceleratorCocoa(characters, modifiers));
-  accelerator->set_platform_accelerator(std::move(platform_accelerator));
-}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 f8d994f82ada2810b4a60ddc028694f404d02d65 atom/browser/ui/accelerator_util_views.cc
  our    100644 086e7084c48e2d29a1370f66b8599b1b9f148143 atom/browser/ui/accelerator_util_views.cc
@@ -1,13 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include "ui/base/accelerators/accelerator.h"
-
-namespace accelerator_util {
-
-void SetPlatformAccelerator(ui::Accelerator* accelerator) {}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 9add7a22715e9de81fa0dab952f5b89257dae9af atom/browser/ui/atom_menu_model.cc
  our    100644 83e23c42ed8984abaa6abc6f18fa76ace5a3f157 atom/browser/ui/atom_menu_model.cc
@@ -1,65 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/atom_menu_model.h"
-
-#include "base/stl_util.h"
-
-namespace atom {
-
-bool AtomMenuModel::Delegate::GetAcceleratorForCommandId(int command_id,
-    ui::Accelerator* accelerator) const {
-  return GetAcceleratorForCommandIdWithParams(
-      command_id, false, accelerator);
-}
-
-AtomMenuModel::AtomMenuModel(Delegate* delegate)
-    : ui::SimpleMenuModel(delegate), delegate_(delegate) {}
-
-AtomMenuModel::~AtomMenuModel() {}
-
-void AtomMenuModel::SetRole(int index, const base::string16& role) {
-  int command_id = GetCommandIdAt(index);
-  roles_[command_id] = role;
-}
-
-base::string16 AtomMenuModel::GetRoleAt(int index) {
-  int command_id = GetCommandIdAt(index);
-  if (base::ContainsKey(roles_, command_id))
-    return roles_[command_id];
-  else
-    return base::string16();
-}
-
-bool AtomMenuModel::GetAcceleratorAtWithParams(
-    int index,
-    bool use_default_accelerator,
-    ui::Accelerator* accelerator) const {
-  if (delegate_) {
-    return delegate_->GetAcceleratorForCommandIdWithParams(
-        GetCommandIdAt(index), use_default_accelerator, accelerator);
-  }
-  return false;
-}
-
-void AtomMenuModel::MenuWillClose() {
-  ui::SimpleMenuModel::MenuWillClose();
-  for (Observer& observer : observers_) {
-    observer.OnMenuWillClose();
-  }
-}
-
-void AtomMenuModel::MenuWillShow() {
-  ui::SimpleMenuModel::MenuWillShow();
-  for (Observer& observer : observers_) {
-    observer.OnMenuWillShow();
-  }
-}
-
-AtomMenuModel* AtomMenuModel::GetSubmenuModelAt(int index) {
-  return static_cast<AtomMenuModel*>(
-      ui::SimpleMenuModel::GetSubmenuModelAt(index));
-}
-
-}  // namespace atom
removed in remote
  base   100644 d091df9fb570fe5fbf3e95ea1232a6f4645ade08 atom/browser/ui/atom_menu_model.h
  our    100644 efdd8ec9d8834fea5d79e16899445abd80df05ca atom/browser/ui/atom_menu_model.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
-#define ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
-
-#include <map>
-
-#include "base/observer_list.h"
-#include "ui/base/models/simple_menu_model.h"
-
-namespace atom {
-
-class AtomMenuModel : public ui::SimpleMenuModel {
- public:
-  class Delegate : public ui::SimpleMenuModel::Delegate {
-   public:
-    ~Delegate() override {}
-
-    virtual bool GetAcceleratorForCommandIdWithParams(
-        int command_id,
-        bool use_default_accelerator,
-        ui::Accelerator* accelerator) const = 0;
-
-   private:
-    // ui::SimpleMenuModel::Delegate:
-    bool GetAcceleratorForCommandId(
-        int command_id,
-        ui::Accelerator* accelerator) const override;
-  };
-
-  class Observer {
-   public:
-    virtual ~Observer() {}
-
-    // Notifies the menu will open.
-    virtual void OnMenuWillShow() {}
-
-    // Notifies the menu has been closed.
-    virtual void OnMenuWillClose() {}
-  };
-
-  explicit AtomMenuModel(Delegate* delegate);
-  ~AtomMenuModel() override;
-
-  void AddObserver(Observer* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(Observer* obs) { observers_.RemoveObserver(obs); }
-
-  void SetRole(int index, const base::string16& role);
-  base::string16 GetRoleAt(int index);
-  bool GetAcceleratorAtWithParams(int index,
-                                  bool use_default_accelerator,
-                                  ui::Accelerator* accelerator) const;
-
-  // ui::SimpleMenuModel:
-  void MenuWillClose() override;
-  void MenuWillShow() override;
-
-  using SimpleMenuModel::GetSubmenuModelAt;
-  AtomMenuModel* GetSubmenuModelAt(int index);
-
- private:
-  Delegate* delegate_;  // weak ref.
-
-  std::map<int, base::string16> roles_;  // command id -> role
-  base::ObserverList<Observer> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomMenuModel);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
removed in remote
  base   100644 f8c48aa5dcb5b9d0013f1de464ef163e48ccffe6 atom/browser/ui/cocoa/atom_menu_controller.h
  our    100644 83e9010f0daadc1d4097db3b702197f0f178967c atom/browser/ui/cocoa/atom_menu_controller.h
@@ -1,62 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
-#define ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/strings/string16.h"
-
-namespace atom {
-class AtomMenuModel;
-}
-
-// A controller for the cross-platform menu model. The menu that's created
-// has the tag and represented object set for each menu item. The object is a
-// NSValue holding a pointer to the model for that level of the menu (to
-// allow for hierarchical menus). The tag is the index into that model for
-// that particular item. It is important that the model outlives this object
-// as it only maintains weak references.
-@interface AtomMenuController : NSObject <NSMenuDelegate> {
- @protected
-  atom::AtomMenuModel* model_;  // weak
-  base::scoped_nsobject<NSMenu> menu_;
-  BOOL isMenuOpen_;
-  BOOL useDefaultAccelerator_;
-  base::Callback<void()> closeCallback;
-}
-
-@property(nonatomic, assign) atom::AtomMenuModel* model;
-
-// Builds a NSMenu from the pre-built model (must not be nil). Changes made
-// to the contents of the model after calling this will not be noticed.
-- (id)initWithModel:(atom::AtomMenuModel*)model useDefaultAccelerator:(BOOL)use;
-
-- (void)setCloseCallback:(const base::Callback<void()>&)callback;
-
-// Populate current NSMenu with |model|.
-- (void)populateWithModel:(atom::AtomMenuModel*)model;
-
-// Programmatically close the constructed menu.
-- (void)cancel;
-
-// Access to the constructed menu if the complex initializer was used. If the
-// default initializer was used, then this will create the menu on first call.
-- (NSMenu*)menu;
-
-// Whether the menu is currently open.
-- (BOOL)isMenuOpen;
-
-// NSMenuDelegate methods this class implements. Subclasses should call super
-// if extending the behavior.
-- (void)menuWillOpen:(NSMenu*)menu;
-- (void)menuDidClose:(NSMenu*)menu;
-
-@end
-
-#endif  // ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
removed in remote
  base   100644 24098914b7cbbb375f8d5c0657061bc99e4a5821 atom/browser/ui/cocoa/atom_menu_controller.mm
  our    100644 cecf30ce1c88e007957a65427648941765a6067e atom/browser/ui/cocoa/atom_menu_controller.mm
@@ -1,345 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/logging.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/base/accelerators/accelerator.h"
-#include "ui/base/accelerators/platform_accelerator_cocoa.h"
-#include "ui/base/l10n/l10n_util_mac.h"
-#include "ui/events/cocoa/cocoa_event_utils.h"
-#include "ui/gfx/image/image.h"
-
-using content::BrowserThread;
-
-namespace {
-
-struct Role {
-  SEL selector;
-  const char* role;
-};
-Role kRolesMap[] = {
-    {@selector(orderFrontStandardAboutPanel:), "about"},
-    {@selector(hide:), "hide"},
-    {@selector(hideOtherApplications:), "hideothers"},
-    {@selector(unhideAllApplications:), "unhide"},
-    {@selector(arrangeInFront:), "front"},
-    {@selector(undo:), "undo"},
-    {@selector(redo:), "redo"},
-    {@selector(cut:), "cut"},
-    {@selector(copy:), "copy"},
-    {@selector(paste:), "paste"},
-    {@selector(delete:), "delete"},
-    {@selector(pasteAndMatchStyle:), "pasteandmatchstyle"},
-    {@selector(selectAll:), "selectall"},
-    {@selector(startSpeaking:), "startspeaking"},
-    {@selector(stopSpeaking:), "stopspeaking"},
-    {@selector(performMiniaturize:), "minimize"},
-    {@selector(performClose:), "close"},
-    {@selector(performZoom:), "zoom"},
-    {@selector(terminate:), "quit"},
-    //  is intentionally not `toggleFullScreen`. The macOS full screen menu
-    // item behaves weird. If we use `toggleFullScreen`, then the menu item will
-    // use the default label, and not take the one provided.
-    {@selector(toggleFullScreenMode:), "togglefullscreen"},
-    {@selector(toggleTabBar:), "toggletabbar"},
-    {@selector(selectNextTab:), "selectnexttab"},
-    {@selector(selectPreviousTab:), "selectprevioustab"},
-    {@selector(mergeAllWindows:), "mergeallwindows"},
-    {@selector(moveTabToNewWindow:), "movetabtonewwindow"},
-    {@selector(clearRecentDocuments:), "clearrecentdocuments"},
-};
-
-}  // namespace
-
-// Menu item is located for ease of removing it from the parent owner
-static base::scoped_nsobject<NSMenuItem> recentDocumentsMenuItem_;
-
-// Submenu retained to be swapped back to |recentDocumentsMenuItem_|
-static base::scoped_nsobject<NSMenu> recentDocumentsMenuSwap_;
-
-@implementation AtomMenuController
-
-@synthesize model = model_;
-
-- (id)initWithModel:(atom::AtomMenuModel*)model
-    useDefaultAccelerator:(BOOL)use {
-  if ((self = [super init])) {
-    model_ = model;
-    isMenuOpen_ = NO;
-    useDefaultAccelerator_ = use;
-    [self menu];
-  }
-  return self;
-}
-
-- (void)dealloc {
-  [menu_ setDelegate:nil];
-
-  // Close the menu if it is still open. This could happen if a tab gets closed
-  // while its context menu is still open.
-  [self cancel];
-
-  model_ = nil;
-
-  [super dealloc];
-}
-
-- (void)setCloseCallback:(const base::Callback<void()>&)callback {
-  closeCallback = callback;
-}
-
-- (void)populateWithModel:(atom::AtomMenuModel*)model {
-  if (!menu_)
-    return;
-
-  if (!recentDocumentsMenuItem_) {
-    // Locate & retain the recent documents menu item
-    recentDocumentsMenuItem_.reset(
-        [[[[[NSApp mainMenu] itemWithTitle:@"Electron"] submenu]
-            itemWithTitle:@"Open Recent"] retain]);
-  }
-
-  model_ = model;
-  [menu_ removeAllItems];
-
-  const int count = model->GetItemCount();
-  for (int index = 0; index < count; index++) {
-    if (model->GetTypeAt(index) == atom::AtomMenuModel::TYPE_SEPARATOR)
-      [self addSeparatorToMenu:menu_ atIndex:index];
-    else
-      [self addItemToMenu:menu_ atIndex:index fromModel:model];
-  }
-}
-
-- (void)cancel {
-  if (isMenuOpen_) {
-    [menu_ cancelTracking];
-    isMenuOpen_ = NO;
-    model_->MenuWillClose();
-    if (!closeCallback.is_null()) {
-      BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, closeCallback);
-    }
-  }
-}
-
-// Creates a NSMenu from the given model. If the model has submenus, this can
-// be invoked recursively.
-- (NSMenu*)menuFromModel:(atom::AtomMenuModel*)model {
-  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
-
-  const int count = model->GetItemCount();
-  for (int index = 0; index < count; index++) {
-    if (model->GetTypeAt(index) == atom::AtomMenuModel::TYPE_SEPARATOR)
-      [self addSeparatorToMenu:menu atIndex:index];
-    else
-      [self addItemToMenu:menu atIndex:index fromModel:model];
-  }
-
-  return menu;
-}
-
-// Adds a separator item at the given index. As the separator doesn't need
-// anything from the model, this method doesn't need the model index as the
-// other method below does.
-- (void)addSeparatorToMenu:(NSMenu*)menu atIndex:(int)index {
-  NSMenuItem* separator = [NSMenuItem separatorItem];
-  [menu insertItem:separator atIndex:index];
-}
-
-// Empties the source menu items to the destination.
-- (void)moveMenuItems:(NSMenu*)source to:(NSMenu*)destination {
-  const long count = [source numberOfItems];
-  for (long index = 0; index < count; index++) {
-    NSMenuItem* removedItem = [[[source itemAtIndex:0] retain] autorelease];
-    [source removeItemAtIndex:0];
-    [destination addItem:removedItem];
-  }
-}
-
-// Replaces the item's submenu instance with the singleton recent documents
-// menu. Previously replaced menu items will be recovered.
-- (void)replaceSubmenuShowingRecentDocuments:(NSMenuItem*)item {
-  NSMenu* recentDocumentsMenu =
-      [[[recentDocumentsMenuItem_ submenu] retain] autorelease];
-
-  // Remove menu items in recent documents back to swap menu
-  [self moveMenuItems:recentDocumentsMenu to:recentDocumentsMenuSwap_];
-  // Swap back the submenu
-  [recentDocumentsMenuItem_ setSubmenu:recentDocumentsMenuSwap_];
-
-  // Retain the item's submenu for a future recovery
-  recentDocumentsMenuSwap_.reset([[item submenu] retain]);
-
-  // Repopulate with items from the submenu to be replaced
-  [self moveMenuItems:recentDocumentsMenuSwap_ to:recentDocumentsMenu];
-  // Update the submenu's title
-  [recentDocumentsMenu setTitle:[recentDocumentsMenuSwap_ title]];
-  // Replace submenu
-  [item setSubmenu:recentDocumentsMenu];
-
-  // Remember the new menu item that carries the recent documents menu
-  recentDocumentsMenuItem_.reset([item retain]);
-}
-
-// Adds an item or a hierarchical menu to the item at the |index|,
-// associated with the entry in the model identified by |modelIndex|.
-- (void)addItemToMenu:(NSMenu*)menu
-              atIndex:(NSInteger)index
-            fromModel:(atom::AtomMenuModel*)model {
-  base::string16 label16 = model->GetLabelAt(index);
-  NSString* label = l10n_util::FixUpWindowsStyleLabel(label16);
-
-  base::scoped_nsobject<NSMenuItem> item([[NSMenuItem alloc]
-      initWithTitle:label
-             action:@selector(itemSelected:)
-      keyEquivalent:@""]);
-
-  // If the menu item has an icon, set it.
-  gfx::Image icon;
-  if (model->GetIconAt(index, &icon) && !icon.IsEmpty())
-    [item setImage:icon.ToNSImage()];
-
-  base::string16 role = model->GetRoleAt(index);
-  atom::AtomMenuModel::ItemType type = model->GetTypeAt(index);
-  if (type == atom::AtomMenuModel::TYPE_SUBMENU) {
-    // Recursively build a submenu from the sub-model at this index.
-    [item setTarget:nil];
-    [item setAction:nil];
-    atom::AtomMenuModel* submenuModel =
-        static_cast<atom::AtomMenuModel*>(model->GetSubmenuModelAt(index));
-    NSMenu* submenu = [self menuFromModel:submenuModel];
-    [submenu setTitle:[item title]];
-    [item setSubmenu:submenu];
-
-    // Set submenu's role.
-    if (role == base::ASCIIToUTF16("window") && [submenu numberOfItems])
-      [NSApp setWindowsMenu:submenu];
-    else if (role == base::ASCIIToUTF16("help"))
-      [NSApp setHelpMenu:submenu];
-    else if (role == base::ASCIIToUTF16("services"))
-      [NSApp setServicesMenu:submenu];
-    else if (role == base::ASCIIToUTF16("recentdocuments"))
-      [self replaceSubmenuShowingRecentDocuments:item];
-  } else {
-    // The MenuModel works on indexes so we can't just set the command id as the
-    // tag like we do in other menus. Also set the represented object to be
-    // the model so hierarchical menus check the correct index in the correct
-    // model. Setting the target to |self| allows this class to participate
-    // in validation of the menu items.
-    [item setTag:index];
-    NSValue* modelObject = [NSValue valueWithPointer:model];
-    [item setRepresentedObject:modelObject];  // Retains |modelObject|.
-    ui::Accelerator accelerator;
-    if (model->GetAcceleratorAtWithParams(index, useDefaultAccelerator_,
-                                          &accelerator)) {
-      const ui::PlatformAcceleratorCocoa* platformAccelerator =
-          static_cast<const ui::PlatformAcceleratorCocoa*>(
-              accelerator.platform_accelerator());
-      if (platformAccelerator) {
-        [item setKeyEquivalent:platformAccelerator->characters()];
-        [item
-            setKeyEquivalentModifierMask:platformAccelerator->modifier_mask()];
-      }
-    }
-
-    // Set menu item's role.
-    [item setTarget:self];
-    if (!role.empty()) {
-      for (const Role& pair : kRolesMap) {
-        if (role == base::ASCIIToUTF16(pair.role)) {
-          [item setTarget:nil];
-          [item setAction:pair.selector];
-          break;
-        }
-      }
-    }
-  }
-  [menu insertItem:item atIndex:index];
-}
-
-// Called before the menu is to be displayed to update the state (enabled,
-// radio, etc) of each item in the menu. Also will update the title if
-// the item is marked as "dynamic".
-- (BOOL)validateUserInterfaceItem:(id<NSValidatedUserInterfaceItem>)item {
-  SEL action = [item action];
-  if (action != @selector(itemSelected:))
-    return NO;
-
-  NSInteger modelIndex = [item tag];
-  atom::AtomMenuModel* model = static_cast<atom::AtomMenuModel*>(
-      [[(id)item representedObject] pointerValue]);
-  DCHECK(model);
-  if (model) {
-    BOOL checked = model->IsItemCheckedAt(modelIndex);
-    DCHECK([(id)item isKindOfClass:[NSMenuItem class]]);
-    [(id)item setState:(checked ? NSOnState : NSOffState)];
-    [(id)item setHidden:(!model->IsVisibleAt(modelIndex))];
-    if (model->IsItemDynamicAt(modelIndex)) {
-      // Update the label and the icon.
-      NSString* label =
-          l10n_util::FixUpWindowsStyleLabel(model->GetLabelAt(modelIndex));
-      [(id)item setTitle:label];
-
-      gfx::Image icon;
-      model->GetIconAt(modelIndex, &icon);
-      [(id)item setImage:icon.IsEmpty() ? nil : icon.ToNSImage()];
-    }
-    return model->IsEnabledAt(modelIndex);
-  }
-  return NO;
-}
-
-// Called when the user chooses a particular menu item. |sender| is the menu
-// item chosen.
-- (void)itemSelected:(id)sender {
-  NSInteger modelIndex = [sender tag];
-  atom::AtomMenuModel* model = static_cast<atom::AtomMenuModel*>(
-      [[sender representedObject] pointerValue]);
-  DCHECK(model);
-  if (model) {
-    NSEvent* event = [NSApp currentEvent];
-    model->ActivatedAt(modelIndex,
-                       ui::EventFlagsFromModifiers([event modifierFlags]));
-  }
-}
-
-- (NSMenu*)menu {
-  if (menu_)
-    return menu_.get();
-
-  menu_.reset([[NSMenu alloc] initWithTitle:@""]);
-  [menu_ setDelegate:self];
-  if (model_)
-    [self populateWithModel:model_];
-  return menu_.get();
-}
-
-- (BOOL)isMenuOpen {
-  return isMenuOpen_;
-}
-
-- (void)menuWillOpen:(NSMenu*)menu {
-  isMenuOpen_ = YES;
-  model_->MenuWillShow();
-}
-
-- (void)menuDidClose:(NSMenu*)menu {
-  if (isMenuOpen_) {
-    isMenuOpen_ = NO;
-    model_->MenuWillClose();
-    // Post async task so that itemSelected runs before the close callback
-    // deletes the controller from the map which deallocates it
-    if (!closeCallback.is_null()) {
-      BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, closeCallback);
-    }
-  }
-}
-
-@end
removed in remote
  base   100644 51d7f5ee9d32120229dd869013f240d15e82e180 atom/browser/ui/file_dialog.h
  our    100644 becc1806610ae54c005b3e8aef17a9ef19d730bf atom/browser/ui/file_dialog.h
@@ -1,86 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_FILE_DIALOG_H_
-#define ATOM_BROWSER_UI_FILE_DIALOG_H_
-
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/callback_forward.h"
-#include "base/files/file_path.h"
-
-namespace atom {
-class NativeWindow;
-}
-
-namespace file_dialog {
-
-// <description, extensions>
-typedef std::pair<std::string, std::vector<std::string>> Filter;
-typedef std::vector<Filter> Filters;
-
-enum FileDialogProperty {
-  FILE_DIALOG_OPEN_FILE = 1 << 0,
-  FILE_DIALOG_OPEN_DIRECTORY = 1 << 1,
-  FILE_DIALOG_MULTI_SELECTIONS = 1 << 2,
-  FILE_DIALOG_CREATE_DIRECTORY = 1 << 3,
-  FILE_DIALOG_SHOW_HIDDEN_FILES = 1 << 4,
-  FILE_DIALOG_PROMPT_TO_CREATE = 1 << 5,
-  FILE_DIALOG_NO_RESOLVE_ALIASES = 1 << 6,
-  FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY = 1 << 7,
-};
-
-#if defined(MAS_BUILD)
-typedef base::Callback<void(bool result,
-                            const std::vector<base::FilePath>& paths,
-                            const std::vector<std::string>& bookmarkData)>
-    OpenDialogCallback;
-
-typedef base::Callback<void(bool result,
-                            const base::FilePath& path,
-                            const std::string& bookmarkData)>
-    SaveDialogCallback;
-#else
-typedef base::Callback<void(bool result,
-                            const std::vector<base::FilePath>& paths)>
-    OpenDialogCallback;
-
-typedef base::Callback<void(bool result, const base::FilePath& path)>
-    SaveDialogCallback;
-#endif
-
-struct DialogSettings {
-  atom::NativeWindow* parent_window = nullptr;
-  std::string title;
-  std::string message;
-  std::string button_label;
-  std::string name_field_label;
-  base::FilePath default_path;
-  Filters filters;
-  int properties = 0;
-  bool shows_tag_field = true;
-  bool force_detached = false;
-  bool security_scoped_bookmarks = false;
-
-  DialogSettings();
-  DialogSettings(const DialogSettings&);
-  ~DialogSettings();
-};
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths);
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback);
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path);
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback);
-
-}  // namespace file_dialog
-
-#endif  // ATOM_BROWSER_UI_FILE_DIALOG_H_
removed in remote
  base   100644 6d19a2eda464ffd14ecf38b685ef3d30e778c737 atom/browser/ui/file_dialog_gtk.cc
  our    100644 dad4fabde9f709e65a04bc4299233bac891f38ff atom/browser/ui/file_dialog_gtk.cc
@@ -1,278 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#include <glib/gi18n.h>  // _() macro
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/ui/libgtkui/gtk_signal.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-// Makes sure that .jpg also shows .JPG.
-gboolean FileFilterCaseInsensitive(const GtkFileFilterInfo* file_info,
-                                   std::string* file_extension) {
-  // Makes .* file extension matches all file types.
-  if (*file_extension == ".*")
-    return true;
-  return base::EndsWith(file_info->filename, *file_extension,
-                        base::CompareCase::INSENSITIVE_ASCII);
-}
-
-// Deletes |data| when gtk_file_filter_add_custom() is done with it.
-void OnFileFilterDataDestroyed(std::string* file_extension) {
-  delete file_extension;
-}
-
-class FileChooserDialog {
- public:
-  FileChooserDialog(GtkFileChooserAction action, const DialogSettings& settings)
-      : parent_(static_cast<atom::NativeWindowViews*>(settings.parent_window)),
-        filters_(settings.filters) {
-    const char* confirm_text = _("_OK");
-
-    if (!settings.button_label.empty())
-      confirm_text = settings.button_label.c_str();
-    else if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
-      confirm_text = _("_Save");
-    else if (action == GTK_FILE_CHOOSER_ACTION_OPEN)
-      confirm_text = _("_Open");
-
-    dialog_ = gtk_file_chooser_dialog_new(
-        settings.title.c_str(), NULL, action, _("_Cancel"), GTK_RESPONSE_CANCEL,
-        confirm_text, GTK_RESPONSE_ACCEPT, NULL);
-    if (parent_) {
-      parent_->SetEnabled(false);
-      libgtkui::SetGtkTransientForAura(dialog_, parent_->GetNativeWindow());
-      gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
-    }
-
-    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
-      gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(dialog_),
-                                                     TRUE);
-    if (action != GTK_FILE_CHOOSER_ACTION_OPEN)
-      gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(dialog_), TRUE);
-
-    if (!settings.default_path.empty()) {
-      if (base::DirectoryExists(settings.default_path)) {
-        gtk_file_chooser_set_current_folder(
-            GTK_FILE_CHOOSER(dialog_), settings.default_path.value().c_str());
-      } else {
-        if (settings.default_path.IsAbsolute()) {
-          gtk_file_chooser_set_current_folder(
-              GTK_FILE_CHOOSER(dialog_),
-              settings.default_path.DirName().value().c_str());
-        }
-
-        gtk_file_chooser_set_current_name(
-            GTK_FILE_CHOOSER(dialog_),
-            settings.default_path.BaseName().value().c_str());
-      }
-    }
-
-    if (!settings.filters.empty())
-      AddFilters(settings.filters);
-  }
-
-  ~FileChooserDialog() {
-    gtk_widget_destroy(dialog_);
-    if (parent_)
-      parent_->SetEnabled(true);
-  }
-
-  void SetupProperties(int properties) {
-    if (properties & FILE_DIALOG_MULTI_SELECTIONS)
-      gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(dialog()), TRUE);
-    if (properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-      g_object_set(dialog(), "show-hidden", TRUE, NULL);
-  }
-
-  void RunAsynchronous() {
-    g_signal_connect(dialog_, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), NULL);
-    g_signal_connect(dialog_, "response", G_CALLBACK(OnFileDialogResponseThunk),
-                     this);
-    gtk_widget_show_all(dialog_);
-
-    // We need to call gtk_window_present after making the widgets visible to
-    // make sure window gets correctly raised and gets focus.
-    int time = ui::X11EventSource::GetInstance()->GetTimestamp();
-    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
-  }
-
-  void RunSaveAsynchronous(const SaveDialogCallback& callback) {
-    save_callback_ = callback;
-    RunAsynchronous();
-  }
-
-  void RunOpenAsynchronous(const OpenDialogCallback& callback) {
-    open_callback_ = callback;
-    RunAsynchronous();
-  }
-
-  base::FilePath GetFileName() const {
-    gchar* filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog_));
-    base::FilePath path = AddExtensionForFilename(filename);
-    g_free(filename);
-    return path;
-  }
-
-  std::vector<base::FilePath> GetFileNames() const {
-    std::vector<base::FilePath> paths;
-    GSList* filenames =
-        gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog_));
-    for (GSList* iter = filenames; iter != NULL; iter = g_slist_next(iter)) {
-      base::FilePath path =
-          AddExtensionForFilename(static_cast<char*>(iter->data));
-      g_free(iter->data);
-      paths.push_back(path);
-    }
-    g_slist_free(filenames);
-    return paths;
-  }
-
-  CHROMEGTK_CALLBACK_1(FileChooserDialog, void, OnFileDialogResponse, int);
-
-  GtkWidget* dialog() const { return dialog_; }
-
- private:
-  void AddFilters(const Filters& filters);
-  base::FilePath AddExtensionForFilename(const gchar* filename) const;
-
-  atom::NativeWindowViews* parent_;
-  atom::UnresponsiveSuppressor unresponsive_suppressor_;
-
-  GtkWidget* dialog_;
-
-  Filters filters_;
-  SaveDialogCallback save_callback_;
-  OpenDialogCallback open_callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(FileChooserDialog);
-};
-
-void FileChooserDialog::OnFileDialogResponse(GtkWidget* widget, int response) {
-  gtk_widget_hide(dialog_);
-
-  if (!save_callback_.is_null()) {
-    if (response == GTK_RESPONSE_ACCEPT)
-      save_callback_.Run(true, GetFileName());
-    else
-      save_callback_.Run(false, base::FilePath());
-  } else if (!open_callback_.is_null()) {
-    if (response == GTK_RESPONSE_ACCEPT)
-      open_callback_.Run(true, GetFileNames());
-    else
-      open_callback_.Run(false, std::vector<base::FilePath>());
-  }
-  delete this;
-}
-
-void FileChooserDialog::AddFilters(const Filters& filters) {
-  for (size_t i = 0; i < filters.size(); ++i) {
-    const Filter& filter = filters[i];
-    GtkFileFilter* gtk_filter = gtk_file_filter_new();
-
-    for (size_t j = 0; j < filter.second.size(); ++j) {
-      auto file_extension =
-          std::make_unique<std::string>("." + filter.second[j]);
-      gtk_file_filter_add_custom(
-          gtk_filter, GTK_FILE_FILTER_FILENAME,
-          reinterpret_cast<GtkFileFilterFunc>(FileFilterCaseInsensitive),
-          file_extension.release(),
-          reinterpret_cast<GDestroyNotify>(OnFileFilterDataDestroyed));
-    }
-
-    gtk_file_filter_set_name(gtk_filter, filter.first.c_str());
-    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog_), gtk_filter);
-  }
-}
-
-base::FilePath FileChooserDialog::AddExtensionForFilename(
-    const gchar* filename) const {
-  base::FilePath path(filename);
-  GtkFileFilter* selected_filter =
-      gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(dialog_));
-  if (!selected_filter)
-    return path;
-
-  GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog_));
-  size_t i = g_slist_index(filters, selected_filter);
-  g_slist_free(filters);
-  if (i >= filters_.size())
-    return path;
-
-  const auto& extensions = filters_[i].second;
-  for (const auto& extension : extensions) {
-    if (extension == "*" ||
-        base::EndsWith(path.value(), "." + extension,
-                       base::CompareCase::INSENSITIVE_ASCII))
-      return path;
-  }
-
-  return path.ReplaceExtension(extensions[0]);
-}
-
-}  // namespace
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
-  FileChooserDialog open_dialog(action, settings);
-  open_dialog.SetupProperties(settings.properties);
-
-  gtk_widget_show_all(open_dialog.dialog());
-  int response = gtk_dialog_run(GTK_DIALOG(open_dialog.dialog()));
-  if (response == GTK_RESPONSE_ACCEPT) {
-    *paths = open_dialog.GetFileNames();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback) {
-  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
-  FileChooserDialog* open_dialog = new FileChooserDialog(action, settings);
-  open_dialog->SetupProperties(settings.properties);
-  open_dialog->RunOpenAsynchronous(callback);
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  FileChooserDialog save_dialog(GTK_FILE_CHOOSER_ACTION_SAVE, settings);
-  gtk_widget_show_all(save_dialog.dialog());
-  int response = gtk_dialog_run(GTK_DIALOG(save_dialog.dialog()));
-  if (response == GTK_RESPONSE_ACCEPT) {
-    *path = save_dialog.GetFileName();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback) {
-  FileChooserDialog* save_dialog =
-      new FileChooserDialog(GTK_FILE_CHOOSER_ACTION_SAVE, settings);
-  save_dialog->RunSaveAsynchronous(callback);
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 49662c69b3b81af166ca96808eb675fbb6025201 atom/browser/ui/file_dialog_mac.mm
  our    100644 18b18a8b240cda5512ae49e0afde5c749bdf75c0 atom/browser/ui/file_dialog_mac.mm
@@ -1,399 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#import <Cocoa/Cocoa.h>
-#import <CoreServices/CoreServices.h>
-
-#include "atom/browser/native_window.h"
-#include "base/files/file_util.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/strings/sys_string_conversions.h"
-
-@interface PopUpButtonHandler : NSObject
-
-@property(nonatomic, assign) NSSavePanel* savePanel;
-@property(nonatomic, strong) NSArray* fileTypesList;
-
-- (instancetype)initWithPanel:(NSSavePanel*)panel
-                 andTypesList:(NSArray*)typesList;
-- (void)selectFormat:(id)sender;
-
-@end
-
-@implementation PopUpButtonHandler
-
-@synthesize savePanel;
-@synthesize fileTypesList;
-
-- (instancetype)initWithPanel:(NSSavePanel*)panel
-                 andTypesList:(NSArray*)typesList {
-  self = [super init];
-  if (self) {
-    [self setSavePanel:panel];
-    [self setFileTypesList:typesList];
-  }
-  return self;
-}
-
-- (void)selectFormat:(id)sender {
-  NSPopUpButton* button = (NSPopUpButton*)sender;
-  NSInteger selectedItemIndex = [button indexOfSelectedItem];
-  NSArray* list = [self fileTypesList];
-  NSArray* fileTypes = [list objectAtIndex:selectedItemIndex];
-
-  // If we meet a '*' file extension, we allow all the file types and no
-  // need to set the specified file types.
-  if ([fileTypes count] == 0 || [fileTypes containsObject:@"*"])
-    [[self savePanel] setAllowedFileTypes:nil];
-  else
-    [[self savePanel] setAllowedFileTypes:fileTypes];
-}
-
-@end
-
-// Manages the PopUpButtonHandler.
-@interface AtomAccessoryView : NSView
-@end
-
-@implementation AtomAccessoryView
-
-- (void)dealloc {
-  auto* popupButton =
-      static_cast<NSPopUpButton*>([[self subviews] objectAtIndex:1]);
-  [[popupButton target] release];
-  [super dealloc];
-}
-
-@end
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-void SetAllowedFileTypes(NSSavePanel* dialog, const Filters& filters) {
-  NSMutableArray* file_types_list = [NSMutableArray array];
-  NSMutableArray* filter_names = [NSMutableArray array];
-
-  // Create array to keep file types and their name.
-  for (const Filter& filter : filters) {
-    NSMutableSet* file_type_set = [NSMutableSet set];
-    [filter_names addObject:@(filter.first.c_str())];
-    for (const std::string& ext : filter.second) {
-      [file_type_set addObject:@(ext.c_str())];
-    }
-    [file_types_list addObject:[file_type_set allObjects]];
-  }
-
-  // Passing empty array to setAllowedFileTypes will cause exception.
-  NSArray* file_types = nil;
-  NSUInteger count = [file_types_list count];
-  if (count > 0) {
-    file_types = [[file_types_list objectAtIndex:0] allObjects];
-    // If we meet a '*' file extension, we allow all the file types and no
-    // need to set the specified file types.
-    if ([file_types count] == 0 || [file_types containsObject:@"*"])
-      file_types = nil;
-  }
-  [dialog setAllowedFileTypes:file_types];
-
-  if (count <= 1)
-    return;  // don't add file format picker
-
-  // Add file format picker.
-  AtomAccessoryView* accessoryView =
-      [[AtomAccessoryView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 200, 32.0)];
-  NSTextField* label =
-      [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 60, 22)];
-
-  [label setEditable:NO];
-  [label setStringValue:@"Format:"];
-  [label setBordered:NO];
-  [label setBezeled:NO];
-  [label setDrawsBackground:NO];
-
-  NSPopUpButton* popupButton =
-      [[NSPopUpButton alloc] initWithFrame:NSMakeRect(50.0, 2, 140, 22.0)
-                                 pullsDown:NO];
-  PopUpButtonHandler* popUpButtonHandler =
-      [[PopUpButtonHandler alloc] initWithPanel:dialog
-                                   andTypesList:file_types_list];
-  [popupButton addItemsWithTitles:filter_names];
-  [popupButton setTarget:popUpButtonHandler];
-  [popupButton setAction:@selector(selectFormat:)];
-
-  [accessoryView addSubview:[label autorelease]];
-  [accessoryView addSubview:[popupButton autorelease]];
-
-  [dialog setAccessoryView:[accessoryView autorelease]];
-}
-
-void SetupDialog(NSSavePanel* dialog, const DialogSettings& settings) {
-  if (!settings.title.empty())
-    [dialog setTitle:base::SysUTF8ToNSString(settings.title)];
-
-  if (!settings.button_label.empty())
-    [dialog setPrompt:base::SysUTF8ToNSString(settings.button_label)];
-
-  if (!settings.message.empty())
-    [dialog setMessage:base::SysUTF8ToNSString(settings.message)];
-
-  if (!settings.name_field_label.empty())
-    [dialog
-        setNameFieldLabel:base::SysUTF8ToNSString(settings.name_field_label)];
-
-  [dialog setShowsTagField:settings.shows_tag_field];
-
-  NSString* default_dir = nil;
-  NSString* default_filename = nil;
-  if (!settings.default_path.empty()) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (base::DirectoryExists(settings.default_path)) {
-      default_dir = base::SysUTF8ToNSString(settings.default_path.value());
-    } else {
-      if (settings.default_path.IsAbsolute()) {
-        default_dir =
-            base::SysUTF8ToNSString(settings.default_path.DirName().value());
-      }
-
-      default_filename =
-          base::SysUTF8ToNSString(settings.default_path.BaseName().value());
-    }
-  }
-
-  if (settings.filters.empty()) {
-    [dialog setAllowsOtherFileTypes:YES];
-  } else {
-    // Set setAllowedFileTypes before setNameFieldStringValue as it might
-    // override the extension set using setNameFieldStringValue
-    SetAllowedFileTypes(dialog, settings.filters);
-  }
-
-  // Make sure the extension is always visible. Without this, the extension in
-  // the default filename will not be used in the saved file.
-  [dialog setExtensionHidden:NO];
-
-  if (default_dir)
-    [dialog setDirectoryURL:[NSURL fileURLWithPath:default_dir]];
-  if (default_filename)
-    [dialog setNameFieldStringValue:default_filename];
-}
-
-void SetupDialogForProperties(NSOpenPanel* dialog, int properties) {
-  [dialog setCanChooseFiles:(properties & FILE_DIALOG_OPEN_FILE)];
-  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
-    [dialog setCanChooseDirectories:YES];
-  if (properties & FILE_DIALOG_CREATE_DIRECTORY)
-    [dialog setCanCreateDirectories:YES];
-  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
-    [dialog setAllowsMultipleSelection:YES];
-  if (properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-    [dialog setShowsHiddenFiles:YES];
-  if (properties & FILE_DIALOG_NO_RESOLVE_ALIASES)
-    [dialog setResolvesAliases:NO];
-  if (properties & FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY)
-    [dialog setTreatsFilePackagesAsDirectories:YES];
-}
-
-// Run modal dialog with parent window and return user's choice.
-int RunModalDialog(NSSavePanel* dialog, const DialogSettings& settings) {
-  __block int chosen = NSFileHandlingPanelCancelButton;
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    chosen = [dialog runModal];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger c) {
-                     chosen = c;
-                     [NSApp stopModal];
-                   }];
-    [NSApp runModalForWindow:window];
-  }
-
-  return chosen;
-}
-
-// Create bookmark data and serialise it into a base64 string.
-std::string GetBookmarkDataFromNSURL(NSURL* url) {
-  // Create the file if it doesn't exist (necessary for NSSavePanel options).
-  NSFileManager* defaultManager = [NSFileManager defaultManager];
-  if (![defaultManager fileExistsAtPath:[url path]]) {
-    [defaultManager createFileAtPath:[url path] contents:nil attributes:nil];
-  }
-
-  NSError* error = nil;
-  NSData* bookmarkData =
-      [url bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
-          includingResourceValuesForKeys:nil
-                           relativeToURL:nil
-                                   error:&error];
-  if (error != nil) {
-    // Send back an empty string if there was an error.
-    return "";
-  } else {
-    // Encode NSData in base64 then convert to NSString.
-    NSString* base64data = [[NSString alloc]
-        initWithData:[bookmarkData base64EncodedDataWithOptions:0]
-            encoding:NSUTF8StringEncoding];
-    return base::SysNSStringToUTF8(base64data);
-  }
-}
-
-void ReadDialogPathsWithBookmarks(NSOpenPanel* dialog,
-                                  std::vector<base::FilePath>* paths,
-                                  std::vector<std::string>* bookmarks) {
-  NSArray* urls = [dialog URLs];
-  for (NSURL* url in urls)
-    if ([url isFileURL]) {
-      paths->push_back(base::FilePath(base::SysNSStringToUTF8([url path])));
-      bookmarks->push_back(GetBookmarkDataFromNSURL(url));
-    }
-}
-
-void ReadDialogPaths(NSOpenPanel* dialog, std::vector<base::FilePath>* paths) {
-  std::vector<std::string> ignored_bookmarks;
-  ReadDialogPathsWithBookmarks(dialog, paths, &ignored_bookmarks);
-}
-
-}  // namespace
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  DCHECK(paths);
-  NSOpenPanel* dialog = [NSOpenPanel openPanel];
-
-  SetupDialog(dialog, settings);
-  SetupDialogForProperties(dialog, settings.properties);
-
-  int chosen = RunModalDialog(dialog, settings);
-  if (chosen == NSFileHandlingPanelCancelButton)
-    return false;
-
-  ReadDialogPaths(dialog, paths);
-  return true;
-}
-
-void OpenDialogCompletion(int chosen,
-                          NSOpenPanel* dialog,
-                          const DialogSettings& settings,
-                          const OpenDialogCallback& callback) {
-  if (chosen == NSFileHandlingPanelCancelButton) {
-#if defined(MAS_BUILD)
-    callback.Run(false, std::vector<base::FilePath>(),
-                 std::vector<std::string>());
-#else
-    callback.Run(false, std::vector<base::FilePath>());
-#endif
-  } else {
-    std::vector<base::FilePath> paths;
-#if defined(MAS_BUILD)
-    std::vector<std::string> bookmarks;
-    if (settings.security_scoped_bookmarks) {
-      ReadDialogPathsWithBookmarks(dialog, &paths, &bookmarks);
-    } else {
-      ReadDialogPaths(dialog, &paths);
-    }
-    callback.Run(true, paths, bookmarks);
-#else
-    ReadDialogPaths(dialog, &paths);
-    callback.Run(true, paths);
-#endif
-  }
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& c) {
-  NSOpenPanel* dialog = [NSOpenPanel openPanel];
-
-  SetupDialog(dialog, settings);
-  SetupDialogForProperties(dialog, settings.properties);
-
-  // Duplicate the callback object here since c is a reference and gcd would
-  // only store the pointer, by duplication we can force gcd to store a copy.
-  __block OpenDialogCallback callback = c;
-
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    [dialog beginWithCompletionHandler:^(NSInteger chosen) {
-      OpenDialogCompletion(chosen, dialog, settings, callback);
-    }];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger chosen) {
-                     OpenDialogCompletion(chosen, dialog, settings, callback);
-                   }];
-  }
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  DCHECK(path);
-  NSSavePanel* dialog = [NSSavePanel savePanel];
-
-  SetupDialog(dialog, settings);
-
-  int chosen = RunModalDialog(dialog, settings);
-  if (chosen == NSFileHandlingPanelCancelButton || ![[dialog URL] isFileURL])
-    return false;
-
-  *path = base::FilePath(base::SysNSStringToUTF8([[dialog URL] path]));
-  return true;
-}
-
-void SaveDialogCompletion(int chosen,
-                          NSSavePanel* dialog,
-                          const DialogSettings& settings,
-                          const SaveDialogCallback& callback) {
-  if (chosen == NSFileHandlingPanelCancelButton) {
-#if defined(MAS_BUILD)
-    callback.Run(false, base::FilePath(), "");
-#else
-    callback.Run(false, base::FilePath());
-#endif
-  } else {
-    std::string path = base::SysNSStringToUTF8([[dialog URL] path]);
-#if defined(MAS_BUILD)
-    std::string bookmark;
-    if (settings.security_scoped_bookmarks) {
-      bookmark = GetBookmarkDataFromNSURL([dialog URL]);
-    }
-    callback.Run(true, base::FilePath(path), bookmark);
-#else
-    callback.Run(true, base::FilePath(path));
-#endif
-  }
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& c) {
-  NSSavePanel* dialog = [NSSavePanel savePanel];
-
-  SetupDialog(dialog, settings);
-  [dialog setCanSelectHiddenExtension:YES];
-
-  __block SaveDialogCallback callback = c;
-
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    [dialog beginWithCompletionHandler:^(NSInteger chosen) {
-      SaveDialogCompletion(chosen, dialog, settings, callback);
-    }];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger chosen) {
-                     SaveDialogCompletion(chosen, dialog, settings, callback);
-                   }];
-  }
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 6577e4c08404becdc01ef319649efefc0f7dc671 atom/browser/ui/file_dialog_win.cc
  our    100644 dab125ec881bc75ff608dbbfddff972169049e54 atom/browser/ui/file_dialog_win.cc
@@ -1,310 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>  // atlbase.h for CComPtr
-
-#include <shlobj.h>
-#include <shobjidl.h>
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/files/file_util.h"
-#include "base/i18n/case_conversion.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/win/registry.h"
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::DialogSettings(const DialogSettings&) = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-// Distinguish directories from regular files.
-bool IsDirectory(const base::FilePath& path) {
-  base::File::Info file_info;
-  return base::GetFileInfo(path, &file_info) ? file_info.is_directory
-                                             : path.EndsWithSeparator();
-}
-
-void ConvertFilters(const Filters& filters,
-                    std::vector<std::wstring>* buffer,
-                    std::vector<COMDLG_FILTERSPEC>* filterspec) {
-  if (filters.empty()) {
-    COMDLG_FILTERSPEC spec = {L"All Files (*.*)", L"*.*"};
-    filterspec->push_back(spec);
-    return;
-  }
-
-  buffer->reserve(filters.size() * 2);
-  for (size_t i = 0; i < filters.size(); ++i) {
-    const Filter& filter = filters[i];
-
-    COMDLG_FILTERSPEC spec;
-    buffer->push_back(base::UTF8ToWide(filter.first));
-    spec.pszName = buffer->back().c_str();
-
-    std::vector<std::string> extensions(filter.second);
-    for (size_t j = 0; j < extensions.size(); ++j)
-      extensions[j].insert(0, "*.");
-    buffer->push_back(base::UTF8ToWide(base::JoinString(extensions, ";")));
-    spec.pszSpec = buffer->back().c_str();
-
-    filterspec->push_back(spec);
-  }
-}
-
-struct RunState {
-  base::Thread* dialog_thread;
-  scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner;
-};
-
-bool CreateDialogThread(RunState* run_state) {
-  auto thread =
-      std::make_unique<base::Thread>(ATOM_PRODUCT_NAME "FileDialogThread");
-  thread->init_com_with_mta(false);
-  if (!thread->Start())
-    return false;
-
-  run_state->dialog_thread = thread.release();
-  run_state->ui_task_runner = base::ThreadTaskRunnerHandle::Get();
-  return true;
-}
-
-void RunOpenDialogInNewThread(const RunState& run_state,
-                              const DialogSettings& settings,
-                              const OpenDialogCallback& callback) {
-  std::vector<base::FilePath> paths;
-  bool result = ShowOpenDialog(settings, &paths);
-  run_state.ui_task_runner->PostTask(FROM_HERE,
-                                     base::Bind(callback, result, paths));
-  run_state.ui_task_runner->DeleteSoon(FROM_HERE, run_state.dialog_thread);
-}
-
-void RunSaveDialogInNewThread(const RunState& run_state,
-                              const DialogSettings& settings,
-                              const SaveDialogCallback& callback) {
-  base::FilePath path;
-  bool result = ShowSaveDialog(settings, &path);
-  run_state.ui_task_runner->PostTask(FROM_HERE,
-                                     base::Bind(callback, result, path));
-  run_state.ui_task_runner->DeleteSoon(FROM_HERE, run_state.dialog_thread);
-}
-
-}  // namespace
-
-static HRESULT GetFileNameFromShellItem(IShellItem* pShellItem,
-                                        SIGDN type,
-                                        LPWSTR lpstr,
-                                        size_t cchLength) {
-  assert(pShellItem != NULL);
-
-  LPWSTR lpstrName = NULL;
-  HRESULT hRet = pShellItem->GetDisplayName(type, &lpstrName);
-
-  if (SUCCEEDED(hRet)) {
-    if (wcslen(lpstrName) < cchLength) {
-      wcscpy_s(lpstr, cchLength, lpstrName);
-    } else {
-      NOTREACHED();
-      hRet = DISP_E_BUFFERTOOSMALL;
-    }
-
-    ::CoTaskMemFree(lpstrName);
-  }
-
-  return hRet;
-}
-
-static void SetDefaultFolder(IFileDialog* dialog,
-                             const base::FilePath file_path) {
-  std::wstring directory =
-      IsDirectory(file_path) ? file_path.value() : file_path.DirName().value();
-
-  ATL::CComPtr<IShellItem> folder_item;
-  HRESULT hr = SHCreateItemFromParsingName(directory.c_str(), NULL,
-                                           IID_PPV_ARGS(&folder_item));
-  if (SUCCEEDED(hr))
-    dialog->SetFolder(folder_item);
-}
-
-static HRESULT ShowFileDialog(IFileDialog* dialog,
-                              const DialogSettings& settings) {
-  atom::UnresponsiveSuppressor suppressor;
-  HWND parent_window =
-      settings.parent_window
-          ? static_cast<atom::NativeWindowViews*>(settings.parent_window)
-                ->GetAcceleratedWidget()
-          : NULL;
-
-  return dialog->Show(parent_window);
-}
-
-static void ApplySettings(IFileDialog* dialog,
-                          const DialogSettings& settings) {
-  std::wstring file_part;
-
-  if (!IsDirectory(settings.default_path))
-    file_part = settings.default_path.BaseName().value();
-
-  dialog->SetFileName(file_part.c_str());
-
-  if (!settings.title.empty())
-    dialog->SetTitle(base::UTF8ToUTF16(settings.title).c_str());
-
-  if (!settings.button_label.empty())
-    dialog->SetOkButtonLabel(base::UTF8ToUTF16(settings.button_label).c_str());
-
-  std::vector<std::wstring> buffer;
-  std::vector<COMDLG_FILTERSPEC> filterspec;
-  ConvertFilters(settings.filters, &buffer, &filterspec);
-
-  if (!filterspec.empty()) {
-    dialog->SetFileTypes(filterspec.size(), filterspec.data());
-  }
-
-  // By default, *.* will be added to the file name if file type is "*.*". In
-  // Electron, we disable it to make a better experience.
-  //
-  // From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/
-  // bb775970(v=vs.85).aspx
-  //
-  // If SetDefaultExtension is not called, the dialog will not update
-  // automatically when user choose a new file type in the file dialog.
-  //
-  // We set file extension to the first none-wildcard extension to make
-  // sure the dialog will update file extension automatically.
-  for (size_t i = 0; i < filterspec.size(); ++i) {
-    if (std::wstring(filterspec[i].pszSpec) != L"*.*") {
-      // SetFileTypeIndex is regarded as one-based index.
-      dialog->SetFileTypeIndex(i + 1);
-      dialog->SetDefaultExtension(filterspec[i].pszSpec);
-      break;
-    }
-  }
-
-  if (settings.default_path.IsAbsolute()) {
-    SetDefaultFolder(dialog, settings.default_path);
-  }
-}
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  ATL::CComPtr<IFileOpenDialog> file_open_dialog;
-  HRESULT hr = file_open_dialog.CoCreateInstance(CLSID_FileOpenDialog);
-
-  if (FAILED(hr))
-    return false;
-
-  DWORD options = FOS_FORCEFILESYSTEM | FOS_FILEMUSTEXIST;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    options |= FOS_PICKFOLDERS;
-  if (settings.properties & FILE_DIALOG_MULTI_SELECTIONS)
-    options |= FOS_ALLOWMULTISELECT;
-  if (settings.properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-    options |= FOS_FORCESHOWHIDDEN;
-  if (settings.properties & FILE_DIALOG_PROMPT_TO_CREATE)
-    options |= FOS_CREATEPROMPT;
-  file_open_dialog->SetOptions(options);
-
-  ApplySettings(file_open_dialog, settings);
-  hr = ShowFileDialog(file_open_dialog, settings);
-  if (FAILED(hr))
-    return false;
-
-  ATL::CComPtr<IShellItemArray> items;
-  hr = file_open_dialog->GetResults(&items);
-  if (FAILED(hr))
-    return false;
-
-  ATL::CComPtr<IShellItem> item;
-  DWORD count = 0;
-  hr = items->GetCount(&count);
-  if (FAILED(hr))
-    return false;
-
-  paths->reserve(count);
-  for (DWORD i = 0; i < count; ++i) {
-    hr = items->GetItemAt(i, &item);
-    if (FAILED(hr))
-      return false;
-
-    wchar_t file_name[MAX_PATH];
-    hr = GetFileNameFromShellItem(item, SIGDN_FILESYSPATH, file_name, MAX_PATH);
-
-    if (FAILED(hr))
-      return false;
-
-    paths->push_back(base::FilePath(file_name));
-  }
-
-  return true;
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback) {
-  RunState run_state;
-  if (!CreateDialogThread(&run_state)) {
-    callback.Run(false, std::vector<base::FilePath>());
-    return;
-  }
-
-  run_state.dialog_thread->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunOpenDialogInNewThread, run_state, settings, callback));
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  ATL::CComPtr<IFileSaveDialog> file_save_dialog;
-  HRESULT hr = file_save_dialog.CoCreateInstance(CLSID_FileSaveDialog);
-  if (FAILED(hr))
-    return false;
-
-  file_save_dialog->SetOptions(FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST |
-                        FOS_OVERWRITEPROMPT);
-  ApplySettings(file_save_dialog, settings);
-  hr = ShowFileDialog(file_save_dialog, settings);
-
-  if (FAILED(hr))
-    return false;
-
-  CComPtr<IShellItem> pItem;
-  hr = file_save_dialog->GetResult(&pItem);
-  if (FAILED(hr))
-    return false;
-
-  PWSTR result_path = nullptr;
-  hr = pItem->GetDisplayName(SIGDN_FILESYSPATH, &result_path);
-  if (!SUCCEEDED(hr))
-    return false;
-
-  *path = base::FilePath(result_path);
-  CoTaskMemFree(result_path);
-
-  return true;
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback) {
-  RunState run_state;
-  if (!CreateDialogThread(&run_state)) {
-    callback.Run(false, base::FilePath());
-    return;
-  }
-
-  run_state.dialog_thread->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunSaveDialogInNewThread, run_state, settings, callback));
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 d2eb70bcd938904d6ab6cfd63755d166c8c2b1ff atom/browser/ui/message_box.h
  our    100644 a00f1e1978fd2bb5b3d47bcfbbb1c37bbf15f997 atom/browser/ui/message_box.h
@@ -1,69 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_MESSAGE_BOX_H_
-#define ATOM_BROWSER_UI_MESSAGE_BOX_H_
-
-#include <string>
-#include <vector>
-
-#include "base/callback_forward.h"
-#include "base/strings/string16.h"
-
-namespace gfx {
-class ImageSkia;
-}
-
-namespace atom {
-
-class NativeWindow;
-
-enum MessageBoxType {
-  MESSAGE_BOX_TYPE_NONE = 0,
-  MESSAGE_BOX_TYPE_INFORMATION,
-  MESSAGE_BOX_TYPE_WARNING,
-  MESSAGE_BOX_TYPE_ERROR,
-  MESSAGE_BOX_TYPE_QUESTION,
-};
-
-enum MessageBoxOptions {
-  MESSAGE_BOX_NONE = 0,
-  MESSAGE_BOX_NO_LINK = 1 << 0,
-};
-
-typedef base::Callback<void(int code, bool checkbox_checked)>
-    MessageBoxCallback;
-
-int ShowMessageBox(NativeWindow* parent_window,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon);
-
-void ShowMessageBox(NativeWindow* parent_window,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback);
-
-// Like ShowMessageBox with simplest settings, but safe to call at very early
-// stage of application.
-void ShowErrorBox(const base::string16& title, const base::string16& content);
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_MESSAGE_BOX_H_
removed in remote
  base   100644 9615e958b27574e5f8858752525848079860ba19 atom/browser/ui/message_box_gtk.cc
  our    100644 1a5e4587de92f1e681318f773fc2e6f13de5249d atom/browser/ui/message_box_gtk.cc
@@ -1,237 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#include <glib/gi18n.h>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_observer.h"
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/ui/libgtkui/gtk_signal.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "chrome/browser/ui/libgtkui/skia_utils_gtk.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
-
-#define ANSI_FOREGROUND_RED "\x1b[31m"
-#define ANSI_FOREGROUND_BLACK "\x1b[30m"
-#define ANSI_TEXT_BOLD "\x1b[1m"
-#define ANSI_BACKGROUND_GRAY "\x1b[47m"
-#define ANSI_RESET "\x1b[0m"
-
-namespace atom {
-
-namespace {
-
-class GtkMessageBox : public NativeWindowObserver {
- public:
-  GtkMessageBox(NativeWindow* parent_window,
-                MessageBoxType type,
-                const std::vector<std::string>& buttons,
-                int default_id,
-                int cancel_id,
-                const std::string& title,
-                const std::string& message,
-                const std::string& detail,
-                const std::string& checkbox_label,
-                bool checkbox_checked)
-      : cancel_id_(cancel_id),
-        parent_(static_cast<NativeWindow*>(parent_window)) {
-    // Create dialog.
-    dialog_ =
-        gtk_message_dialog_new(nullptr,                         // parent
-                               static_cast<GtkDialogFlags>(0),  // no flags
-                               GetMessageType(type),            // type
-                               GTK_BUTTONS_NONE,                // no buttons
-                               "%s", message.c_str());
-    if (!detail.empty())
-      gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog_),
-                                               "%s", detail.c_str());
-    if (!title.empty())
-      gtk_window_set_title(GTK_WINDOW(dialog_), title.c_str());
-
-    if (!checkbox_label.empty()) {
-      GtkWidget* message_area =
-          gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(dialog_));
-      GtkWidget* check_button =
-          gtk_check_button_new_with_label(checkbox_label.c_str());
-      g_signal_connect(check_button, "toggled",
-                       G_CALLBACK(OnCheckboxToggledThunk), this);
-      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
-                                   checkbox_checked);
-      gtk_container_add(GTK_CONTAINER(message_area), check_button);
-    }
-
-    // Add buttons.
-    for (size_t i = 0; i < buttons.size(); ++i) {
-      GtkWidget* button = gtk_dialog_add_button(
-          GTK_DIALOG(dialog_), TranslateToStock(i, buttons[i]), i);
-      if (static_cast<int>(i) == default_id)
-        gtk_widget_grab_focus(button);
-    }
-
-    // Parent window.
-    if (parent_) {
-      parent_->AddObserver(this);
-      static_cast<NativeWindowViews*>(parent_)->SetEnabled(false);
-      libgtkui::SetGtkTransientForAura(dialog_, parent_->GetNativeWindow());
-      gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
-    }
-  }
-
-  ~GtkMessageBox() override {
-    gtk_widget_destroy(dialog_);
-    if (parent_) {
-      parent_->RemoveObserver(this);
-      static_cast<NativeWindowViews*>(parent_)->SetEnabled(true);
-    }
-  }
-
-  GtkMessageType GetMessageType(MessageBoxType type) {
-    switch (type) {
-      case MESSAGE_BOX_TYPE_INFORMATION:
-        return GTK_MESSAGE_INFO;
-      case MESSAGE_BOX_TYPE_WARNING:
-        return GTK_MESSAGE_WARNING;
-      case MESSAGE_BOX_TYPE_QUESTION:
-        return GTK_MESSAGE_QUESTION;
-      case MESSAGE_BOX_TYPE_ERROR:
-        return GTK_MESSAGE_ERROR;
-      default:
-        return GTK_MESSAGE_OTHER;
-    }
-  }
-
-  const char* TranslateToStock(int id, const std::string& text) {
-    const std::string lower = base::ToLowerASCII(text);
-    if (lower == "cancel")
-      return _("_Cancel");
-    if (lower == "no")
-      return _("_No");
-    if (lower == "ok")
-      return _("_OK");
-    if (lower == "yes")
-      return _("_Yes");
-    return text.c_str();
-  }
-
-  void Show() {
-    gtk_widget_show_all(dialog_);
-    // We need to call gtk_window_present after making the widgets visible to
-    // make sure window gets correctly raised and gets focus.
-    int time = ui::X11EventSource::GetInstance()->GetTimestamp();
-    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
-  }
-
-  int RunSynchronous() {
-    Show();
-    int response = gtk_dialog_run(GTK_DIALOG(dialog_));
-    if (response < 0)
-      return cancel_id_;
-    else
-      return response;
-  }
-
-  void RunAsynchronous(const MessageBoxCallback& callback) {
-    callback_ = callback;
-    g_signal_connect(dialog_, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
-    g_signal_connect(dialog_, "response", G_CALLBACK(OnResponseDialogThunk),
-                     this);
-    Show();
-  }
-
-  void OnWindowClosed() override {
-    parent_->RemoveObserver(this);
-    parent_ = nullptr;
-  }
-
-  CHROMEGTK_CALLBACK_1(GtkMessageBox, void, OnResponseDialog, int);
-  CHROMEGTK_CALLBACK_0(GtkMessageBox, void, OnCheckboxToggled);
-
- private:
-  atom::UnresponsiveSuppressor unresponsive_suppressor_;
-
-  // The id to return when the dialog is closed without pressing buttons.
-  int cancel_id_ = 0;
-
-  bool checkbox_checked_ = false;
-
-  NativeWindow* parent_;
-  GtkWidget* dialog_;
-  MessageBoxCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(GtkMessageBox);
-};
-
-void GtkMessageBox::OnResponseDialog(GtkWidget* widget, int response) {
-  gtk_widget_hide(dialog_);
-
-  if (response < 0)
-    callback_.Run(cancel_id_, checkbox_checked_);
-  else
-    callback_.Run(response, checkbox_checked_);
-  delete this;
-}
-
-void GtkMessageBox::OnCheckboxToggled(GtkWidget* widget) {
-  checkbox_checked_ = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& /*icon*/) {
-  return GtkMessageBox(parent, type, buttons, default_id, cancel_id, title,
-                       message, detail, "", false)
-      .RunSynchronous();
-}
-
-void ShowMessageBox(NativeWindow* parent,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& /*icon*/,
-                    const MessageBoxCallback& callback) {
-  (new GtkMessageBox(parent, type, buttons, default_id, cancel_id, title,
-                     message, detail, checkbox_label, checkbox_checked))
-      ->RunAsynchronous(callback);
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  if (Browser::Get()->is_ready()) {
-    GtkMessageBox(nullptr, MESSAGE_BOX_TYPE_ERROR, {"OK"}, -1, 0, "Error",
-                  base::UTF16ToUTF8(title).c_str(),
-                  base::UTF16ToUTF8(content).c_str(), "", false)
-        .RunSynchronous();
-  } else {
-    fprintf(stderr,
-            ANSI_TEXT_BOLD ANSI_BACKGROUND_GRAY ANSI_FOREGROUND_RED
-            "%s\n" ANSI_FOREGROUND_BLACK "%s" ANSI_RESET "\n",
-            base::UTF16ToUTF8(title).c_str(),
-            base::UTF16ToUTF8(content).c_str());
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 d553a6a7dfbf79a9bdafcb1d83e2d058e6983118 atom/browser/ui/message_box_mac.mm
  our    100644 ee2f59dc8c84ba0bf5fe049a133f403d550a9473 atom/browser/ui/message_box_mac.mm
@@ -1,214 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#import <Cocoa/Cocoa.h>
-
-#include "atom/browser/native_window.h"
-#include "base/callback.h"
-#include "base/mac/mac_util.h"
-#include "base/strings/sys_string_conversions.h"
-#include "skia/ext/skia_utils_mac.h"
-#include "ui/gfx/image/image_skia.h"
-
-@interface ModalDelegate : NSObject {
- @private
-  atom::MessageBoxCallback callback_;
-  NSAlert* alert_;
-  bool callEndModal_;
-}
-- (id)initWithCallback:(const atom::MessageBoxCallback&)callback
-              andAlert:(NSAlert*)alert
-          callEndModal:(bool)flag;
-@end
-
-@implementation ModalDelegate
-
-- (id)initWithCallback:(const atom::MessageBoxCallback&)callback
-              andAlert:(NSAlert*)alert
-          callEndModal:(bool)flag {
-  if ((self = [super init])) {
-    callback_ = callback;
-    alert_ = alert;
-    callEndModal_ = flag;
-  }
-  return self;
-}
-
-- (void)alertDidEnd:(NSAlert*)alert
-         returnCode:(NSInteger)returnCode
-        contextInfo:(void*)contextInfo {
-  callback_.Run(returnCode, alert.suppressionButton.state == NSOnState);
-  [alert_ release];
-  [self release];
-
-  if (callEndModal_)
-    [NSApp stopModal];
-}
-
-@end
-
-namespace atom {
-
-namespace {
-
-NSAlert* CreateNSAlert(NativeWindow* parent_window,
-                       MessageBoxType type,
-                       const std::vector<std::string>& buttons,
-                       int default_id,
-                       int cancel_id,
-                       const std::string& title,
-                       const std::string& message,
-                       const std::string& detail,
-                       const std::string& checkbox_label,
-                       bool checkbox_checked,
-                       const gfx::ImageSkia& icon) {
-  // Ignore the title; it's the window title on other platforms and ignorable.
-  NSAlert* alert = [[NSAlert alloc] init];
-  [alert setMessageText:base::SysUTF8ToNSString(message)];
-  [alert setInformativeText:base::SysUTF8ToNSString(detail)];
-
-  switch (type) {
-    case MESSAGE_BOX_TYPE_INFORMATION:
-      alert.alertStyle = NSInformationalAlertStyle;
-      break;
-    case MESSAGE_BOX_TYPE_WARNING:
-    case MESSAGE_BOX_TYPE_ERROR:
-      // NSWarningAlertStyle shows the app icon while NSCriticalAlertStyle
-      // shows a warning icon with an app icon badge. Since there is no
-      // error variant, lets just use NSCriticalAlertStyle.
-      alert.alertStyle = NSCriticalAlertStyle;
-      break;
-    default:
-      break;
-  }
-
-  for (size_t i = 0; i < buttons.size(); ++i) {
-    NSString* title = base::SysUTF8ToNSString(buttons[i]);
-    // An empty title causes crash on macOS.
-    if (buttons[i].empty())
-      title = @"(empty)";
-    NSButton* button = [alert addButtonWithTitle:title];
-    [button setTag:i];
-  }
-
-  NSArray* ns_buttons = [alert buttons];
-  int button_count = static_cast<int>([ns_buttons count]);
-
-  if (default_id >= 0 && default_id < button_count) {
-    // Focus the button at default_id if the user opted to do so.
-    // The first button added gets set as the default selected.
-    // So remove that default, and make the requested button the default.
-    [[ns_buttons objectAtIndex:0] setKeyEquivalent:@""];
-    [[ns_buttons objectAtIndex:default_id] setKeyEquivalent:@"\r"];
-  }
-
-  // Bind cancel id button to escape key if there is more than one button
-  if (button_count > 1 && cancel_id >= 0 && cancel_id < button_count) {
-    [[ns_buttons objectAtIndex:cancel_id] setKeyEquivalent:@"\e"];
-  }
-
-  if (!checkbox_label.empty()) {
-    alert.showsSuppressionButton = YES;
-    alert.suppressionButton.title = base::SysUTF8ToNSString(checkbox_label);
-    alert.suppressionButton.state = checkbox_checked ? NSOnState : NSOffState;
-  }
-
-  if (!icon.isNull()) {
-    NSImage* image = skia::SkBitmapToNSImageWithColorSpace(
-        *icon.bitmap(), base::mac::GetGenericRGBColorSpace());
-    [alert setIcon:image];
-  }
-
-  return alert;
-}
-
-void SetReturnCode(int* ret_code, int result, bool checkbox_checked) {
-  *ret_code = result;
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent_window,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon) {
-  NSAlert* alert =
-      CreateNSAlert(parent_window, type, buttons, default_id, cancel_id, title,
-                    message, detail, "", false, icon);
-
-  // Use runModal for synchronous alert without parent, since we don't have a
-  // window to wait for.
-  if (!parent_window)
-    return [[alert autorelease] runModal];
-
-  int ret_code = -1;
-  ModalDelegate* delegate = [[ModalDelegate alloc]
-      initWithCallback:base::Bind(&SetReturnCode, &ret_code)
-              andAlert:alert
-          callEndModal:true];
-
-  NSWindow* window = parent_window->GetNativeWindow();
-  [alert beginSheetModalForWindow:window
-                    modalDelegate:delegate
-                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
-                      contextInfo:nil];
-
-  [NSApp runModalForWindow:window];
-  return ret_code;
-}
-
-void ShowMessageBox(NativeWindow* parent_window,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback) {
-  NSAlert* alert =
-      CreateNSAlert(parent_window, type, buttons, default_id, cancel_id, title,
-                    message, detail, checkbox_label, checkbox_checked, icon);
-
-  // Use runModal for synchronous alert without parent, since we don't have a
-  // window to wait for.
-  if (!parent_window) {
-    int ret = [[alert autorelease] runModal];
-    callback.Run(ret, alert.suppressionButton.state == NSOnState);
-  } else {
-    ModalDelegate* delegate = [[ModalDelegate alloc] initWithCallback:callback
-                                                             andAlert:alert
-                                                         callEndModal:false];
-
-    NSWindow* window = parent_window ? parent_window->GetNativeWindow() : nil;
-    [alert
-        beginSheetModalForWindow:window
-                   modalDelegate:delegate
-                  didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
-                     contextInfo:nil];
-  }
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  NSAlert* alert = [[NSAlert alloc] init];
-  [alert setMessageText:base::SysUTF16ToNSString(title)];
-  [alert setInformativeText:base::SysUTF16ToNSString(content)];
-  [alert setAlertStyle:NSCriticalAlertStyle];
-  [alert runModal];
-  [alert release];
-}
-
-}  // namespace atom
removed in remote
  base   100644 5f49151c30ff01c153da174506ba411fa7f383cc atom/browser/ui/message_box_win.cc
  our    100644 b0e73f550e1d3a91f15e8d2d0604518027f75298 atom/browser/ui/message_box_win.cc
@@ -1,285 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <commctrl.h>
-
-#include <map>
-#include <vector>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread.h"
-#include "base/win/scoped_gdi_object.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/gfx/icon_util.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace atom {
-
-namespace {
-
-// Small command ID values are already taken by Windows, we have to start from
-// a large number to avoid conflicts with Windows.
-const int kIDStart = 100;
-
-// Get the common ID from button's name.
-struct CommonButtonID {
-  int button;
-  int id;
-};
-CommonButtonID GetCommonID(const base::string16& button) {
-  base::string16 lower = base::ToLowerASCII(button);
-  if (lower == L"ok")
-    return {TDCBF_OK_BUTTON, IDOK};
-  else if (lower == L"yes")
-    return {TDCBF_YES_BUTTON, IDYES};
-  else if (lower == L"no")
-    return {TDCBF_NO_BUTTON, IDNO};
-  else if (lower == L"cancel")
-    return {TDCBF_CANCEL_BUTTON, IDCANCEL};
-  else if (lower == L"retry")
-    return {TDCBF_RETRY_BUTTON, IDRETRY};
-  else if (lower == L"close")
-    return {TDCBF_CLOSE_BUTTON, IDCLOSE};
-  return {-1, -1};
-}
-
-// Determine whether the buttons are common buttons, if so map common ID
-// to button ID.
-void MapToCommonID(const std::vector<base::string16>& buttons,
-                   std::map<int, int>* id_map,
-                   TASKDIALOG_COMMON_BUTTON_FLAGS* button_flags,
-                   std::vector<TASKDIALOG_BUTTON>* dialog_buttons) {
-  for (size_t i = 0; i < buttons.size(); ++i) {
-    auto common = GetCommonID(buttons[i]);
-    if (common.button != -1) {
-      // It is a common button.
-      (*id_map)[common.id] = i;
-      (*button_flags) |= common.button;
-    } else {
-      // It is a custom button.
-      dialog_buttons->push_back(
-          {static_cast<int>(i + kIDStart), buttons[i].c_str()});
-    }
-  }
-}
-
-int ShowTaskDialogUTF16(NativeWindow* parent,
-                        MessageBoxType type,
-                        const std::vector<base::string16>& buttons,
-                        int default_id,
-                        int cancel_id,
-                        int options,
-                        const base::string16& title,
-                        const base::string16& message,
-                        const base::string16& detail,
-                        const base::string16& checkbox_label,
-                        bool* checkbox_checked,
-                        const gfx::ImageSkia& icon) {
-  TASKDIALOG_FLAGS flags =
-      TDF_SIZE_TO_CONTENT |           // Show all content.
-      TDF_ALLOW_DIALOG_CANCELLATION;  // Allow canceling the dialog.
-
-  TASKDIALOGCONFIG config = {0};
-  config.cbSize = sizeof(config);
-  config.hInstance = GetModuleHandle(NULL);
-  config.dwFlags = flags;
-
-  if (parent) {
-    config.hwndParent =
-        static_cast<atom::NativeWindowViews*>(parent)->GetAcceleratedWidget();
-  }
-
-  if (default_id > 0)
-    config.nDefaultButton = kIDStart + default_id;
-
-  // TaskDialogIndirect doesn't allow empty name, if we set empty title it
-  // will show "electron.exe" in title.
-  base::string16 app_name = base::UTF8ToUTF16(Browser::Get()->GetName());
-  if (title.empty())
-    config.pszWindowTitle = app_name.c_str();
-  else
-    config.pszWindowTitle = title.c_str();
-
-  base::win::ScopedHICON hicon;
-  if (!icon.isNull()) {
-    hicon = IconUtil::CreateHICONFromSkBitmap(*icon.bitmap());
-    config.dwFlags |= TDF_USE_HICON_MAIN;
-    config.hMainIcon = hicon.get();
-  } else {
-    // Show icon according to dialog's type.
-    switch (type) {
-      case MESSAGE_BOX_TYPE_INFORMATION:
-      case MESSAGE_BOX_TYPE_QUESTION:
-        config.pszMainIcon = TD_INFORMATION_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_WARNING:
-        config.pszMainIcon = TD_WARNING_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_ERROR:
-        config.pszMainIcon = TD_ERROR_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_NONE:
-        break;
-    }
-  }
-
-  // If "detail" is empty then don't make message hilighted.
-  if (detail.empty()) {
-    config.pszContent = message.c_str();
-  } else {
-    config.pszMainInstruction = message.c_str();
-    config.pszContent = detail.c_str();
-  }
-
-  if (!checkbox_label.empty()) {
-    config.pszVerificationText = checkbox_label.c_str();
-
-    if (checkbox_checked && *checkbox_checked) {
-      config.dwFlags |= TDF_VERIFICATION_FLAG_CHECKED;
-    }
-  }
-
-  // Iterate through the buttons, put common buttons in dwCommonButtons
-  // and custom buttons in pButtons.
-  std::map<int, int> id_map;
-  std::vector<TASKDIALOG_BUTTON> dialog_buttons;
-  if (options & MESSAGE_BOX_NO_LINK) {
-    for (size_t i = 0; i < buttons.size(); ++i)
-      dialog_buttons.push_back(
-          {static_cast<int>(i + kIDStart), buttons[i].c_str()});
-  } else {
-    MapToCommonID(buttons, &id_map, &config.dwCommonButtons, &dialog_buttons);
-  }
-  if (dialog_buttons.size() > 0) {
-    config.pButtons = &dialog_buttons.front();
-    config.cButtons = dialog_buttons.size();
-    if (!(options & MESSAGE_BOX_NO_LINK))
-      config.dwFlags |= TDF_USE_COMMAND_LINKS;  // custom buttons as links.
-  }
-
-  int id = 0;
-  BOOL verificationFlagChecked = FALSE;
-  TaskDialogIndirect(&config, &id, nullptr, &verificationFlagChecked);
-  if (checkbox_checked) {
-    *checkbox_checked = verificationFlagChecked;
-  }
-
-  if (id_map.find(id) != id_map.end())  // common button.
-    return id_map[id];
-  else if (id >= kIDStart)  // custom button.
-    return id - kIDStart;
-  else
-    return cancel_id;
-}
-
-int ShowTaskDialogUTF8(NativeWindow* parent,
-                       MessageBoxType type,
-                       const std::vector<std::string>& buttons,
-                       int default_id,
-                       int cancel_id,
-                       int options,
-                       const std::string& title,
-                       const std::string& message,
-                       const std::string& detail,
-                       const std::string& checkbox_label,
-                       bool* checkbox_checked,
-                       const gfx::ImageSkia& icon) {
-  std::vector<base::string16> utf16_buttons;
-  for (const auto& button : buttons)
-    utf16_buttons.push_back(base::UTF8ToUTF16(button));
-
-  return ShowTaskDialogUTF16(
-      parent, type, utf16_buttons, default_id, cancel_id, options,
-      base::UTF8ToUTF16(title), base::UTF8ToUTF16(message),
-      base::UTF8ToUTF16(detail), base::UTF8ToUTF16(checkbox_label),
-      checkbox_checked, icon);
-}
-
-void RunMessageBoxInNewThread(base::Thread* thread,
-                              NativeWindow* parent,
-                              MessageBoxType type,
-                              const std::vector<std::string>& buttons,
-                              int default_id,
-                              int cancel_id,
-                              int options,
-                              const std::string& title,
-                              const std::string& message,
-                              const std::string& detail,
-                              const std::string& checkbox_label,
-                              bool checkbox_checked,
-                              const gfx::ImageSkia& icon,
-                              const MessageBoxCallback& callback) {
-  int result = ShowTaskDialogUTF8(parent, type, buttons, default_id, cancel_id,
-                                  options, title, message, detail,
-                                  checkbox_label, &checkbox_checked, icon);
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI, FROM_HERE,
-      base::Bind(callback, result, checkbox_checked));
-  content::BrowserThread::DeleteSoon(content::BrowserThread::UI, FROM_HERE,
-                                     thread);
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon) {
-  atom::UnresponsiveSuppressor suppressor;
-  return ShowTaskDialogUTF8(parent, type, buttons, default_id, cancel_id,
-                            options, title, message, detail, "", nullptr, icon);
-}
-
-void ShowMessageBox(NativeWindow* parent,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback) {
-  auto thread =
-      std::make_unique<base::Thread>(ATOM_PRODUCT_NAME "MessageBoxThread");
-  thread->init_com_with_mta(false);
-  if (!thread->Start()) {
-    callback.Run(cancel_id, checkbox_checked);
-    return;
-  }
-
-  base::Thread* unretained = thread.release();
-  unretained->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunMessageBoxInNewThread, base::Unretained(unretained),
-                 parent, type, buttons, default_id, cancel_id, options, title,
-                 message, detail, checkbox_label, checkbox_checked, icon,
-                 callback));
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  atom::UnresponsiveSuppressor suppressor;
-  ShowTaskDialogUTF16(nullptr, MESSAGE_BOX_TYPE_ERROR, {}, -1, 0, 0, L"Error",
-                      title, content, L"", nullptr, gfx::ImageSkia());
-}
-
-}  // namespace atom
removed in remote
  base   100644 60923c2ad0a6489774247a6e9b0b5c376920f5e1 atom/browser/ui/tray_icon.cc
  our    100644 b5332ac97b27ac87b0b48caf7e5f21e12407a0e6 atom/browser/ui/tray_icon.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon.h"
-
-namespace atom {
-
-TrayIcon::TrayIcon() {}
-
-TrayIcon::~TrayIcon() {}
-
-void TrayIcon::SetPressedImage(ImageType image) {}
-
-void TrayIcon::SetTitle(const std::string& title) {}
-
-void TrayIcon::SetHighlightMode(TrayIcon::HighlightMode mode) {}
-
-void TrayIcon::DisplayBalloon(ImageType icon,
-                              const base::string16& title,
-                              const base::string16& contents) {}
-
-void TrayIcon::PopUpContextMenu(const gfx::Point& pos,
-                                AtomMenuModel* menu_model) {}
-
-gfx::Rect TrayIcon::GetBounds() {
-  return gfx::Rect();
-}
-
-void TrayIcon::NotifyClicked(const gfx::Rect& bounds,
-                             const gfx::Point& location,
-                             int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnClicked(bounds, location, modifiers);
-}
-
-void TrayIcon::NotifyDoubleClicked(const gfx::Rect& bounds, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDoubleClicked(bounds, modifiers);
-}
-
-void TrayIcon::NotifyBalloonShow() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonShow();
-}
-
-void TrayIcon::NotifyBalloonClicked() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonClicked();
-}
-
-void TrayIcon::NotifyBalloonClosed() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonClosed();
-}
-
-void TrayIcon::NotifyRightClicked(const gfx::Rect& bounds, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnRightClicked(bounds, modifiers);
-}
-
-void TrayIcon::NotifyDrop() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDrop();
-}
-
-void TrayIcon::NotifyDropFiles(const std::vector<std::string>& files) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDropFiles(files);
-}
-
-void TrayIcon::NotifyDropText(const std::string& text) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDropText(text);
-}
-
-void TrayIcon::NotifyMouseEntered(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseEntered(location, modifiers);
-}
-
-void TrayIcon::NotifyMouseExited(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseExited(location, modifiers);
-}
-
-void TrayIcon::NotifyMouseMoved(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseMoved(location, modifiers);
-}
-
-void TrayIcon::NotifyDragEntered() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragEntered();
-}
-
-void TrayIcon::NotifyDragExited() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragExited();
-}
-
-void TrayIcon::NotifyDragEnded() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragEnded();
-}
-
-}  // namespace atom
removed in remote
  base   100644 c80ff08d6a52daa84252c0a0369bc474d07245df atom/browser/ui/tray_icon.h
  our    100644 76155000e88745f1c0cda423e5af47dddec38e4a atom/browser/ui/tray_icon.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "atom/browser/ui/tray_icon_observer.h"
-#include "base/observer_list.h"
-#include "ui/gfx/geometry/rect.h"
-
-namespace atom {
-
-class TrayIcon {
- public:
-  static TrayIcon* Create();
-
-#if defined(OS_WIN)
-  using ImageType = HICON;
-#else
-  using ImageType = const gfx::Image&;
-#endif
-
-  virtual ~TrayIcon();
-
-  // Sets the image associated with this status icon.
-  virtual void SetImage(ImageType image) = 0;
-
-  // Sets the image associated with this status icon when pressed.
-  virtual void SetPressedImage(ImageType image);
-
-  // Sets the hover text for this status icon. This is also used as the label
-  // for the menu item which is created as a replacement for the status icon
-  // click action on platforms that do not support custom click actions for the
-  // status icon (e.g. Ubuntu Unity).
-  virtual void SetToolTip(const std::string& tool_tip) = 0;
-
-  // Sets the title displayed aside of the status icon in the status bar. This
-  // only works on macOS.
-  virtual void SetTitle(const std::string& title);
-
-  // Sets the status icon highlight mode. This only works on macOS.
-  enum HighlightMode {
-    ALWAYS,    // Always highlight the tray icon
-    NEVER,     // Never highlight the tray icon
-    SELECTION  // Highlight the tray icon when clicked or the menu is opened
-  };
-  virtual void SetHighlightMode(HighlightMode mode);
-
-  // Setter and getter for the flag which determines whether to ignore double
-  // click events. These only work on macOS.
-#if defined(OS_MACOSX)
-  virtual void SetIgnoreDoubleClickEvents(bool ignore) = 0;
-  virtual bool GetIgnoreDoubleClickEvents() = 0;
-#endif
-
-  // Displays a notification balloon with the specified contents.
-  // Depending on the platform it might not appear by the icon tray.
-  virtual void DisplayBalloon(ImageType icon,
-                              const base::string16& title,
-                              const base::string16& contents);
-
-  // Popups the menu.
-  virtual void PopUpContextMenu(const gfx::Point& pos,
-                                AtomMenuModel* menu_model);
-
-  // Set the context menu for this icon.
-  virtual void SetContextMenu(AtomMenuModel* menu_model) = 0;
-
-  // Returns the bounds of tray icon.
-  virtual gfx::Rect GetBounds();
-
-  void AddObserver(TrayIconObserver* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(TrayIconObserver* obs) { observers_.RemoveObserver(obs); }
-
-  void NotifyClicked(const gfx::Rect& = gfx::Rect(),
-                     const gfx::Point& location = gfx::Point(),
-                     int modifiers = 0);
-  void NotifyDoubleClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
-  void NotifyBalloonShow();
-  void NotifyBalloonClicked();
-  void NotifyBalloonClosed();
-  void NotifyRightClicked(const gfx::Rect& bounds = gfx::Rect(),
-                          int modifiers = 0);
-  void NotifyDrop();
-  void NotifyDropFiles(const std::vector<std::string>& files);
-  void NotifyDropText(const std::string& text);
-  void NotifyDragEntered();
-  void NotifyDragExited();
-  void NotifyDragEnded();
-  void NotifyMouseEntered(const gfx::Point& location = gfx::Point(),
-                          int modifiers = 0);
-  void NotifyMouseExited(const gfx::Point& location = gfx::Point(),
-                         int modifiers = 0);
-  void NotifyMouseMoved(const gfx::Point& location = gfx::Point(),
-                        int modifiers = 0);
-
- protected:
-  TrayIcon();
-
- private:
-  base::ObserverList<TrayIconObserver> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIcon);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_H_
removed in remote
  base   100644 59e2241aa480470e99d1be3f7b4cdcf4cf31c5aa atom/browser/ui/tray_icon_cocoa.h
  our    100644 34ace850a79e7ff480a96e0c066946e451a4e849 atom/browser/ui/tray_icon_cocoa.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "base/mac/scoped_nsobject.h"
-
-@class AtomMenuController;
-@class StatusItemView;
-
-namespace atom {
-
-class TrayIconCocoa : public TrayIcon, public AtomMenuModel::Observer {
- public:
-  TrayIconCocoa();
-  ~TrayIconCocoa() override;
-
-  void SetImage(const gfx::Image& image) override;
-  void SetPressedImage(const gfx::Image& image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void SetTitle(const std::string& title) override;
-  void SetHighlightMode(TrayIcon::HighlightMode mode) override;
-  void SetIgnoreDoubleClickEvents(bool ignore) override;
-  bool GetIgnoreDoubleClickEvents() override;
-  void PopUpContextMenu(const gfx::Point& pos,
-                        AtomMenuModel* menu_model) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-  gfx::Rect GetBounds() override;
-
- protected:
-  // AtomMenuModel::Observer:
-  void OnMenuWillClose() override;
-
- private:
-  // Atom custom view for NSStatusItem.
-  base::scoped_nsobject<StatusItemView> status_item_view_;
-
-  // Status menu shown when right-clicking the system icon.
-  base::scoped_nsobject<AtomMenuController> menu_;
-
-  // Used for unregistering observer.
-  AtomMenuModel* menu_model_ = nullptr;  // weak ref.
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIconCocoa);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
removed in remote
  base   100644 d2a2fe83460e08f97982cce119f0fdb766d0e6fb atom/browser/ui/tray_icon_cocoa.mm
  our    100644 2c434d7a9e312adfb3802628a3d092a95d4ac49f atom/browser/ui/tray_icon_cocoa.mm
@@ -1,499 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon_cocoa.h"
-
-#include "atom/browser/ui/cocoa/NSString+ANSI.h"
-#include "atom/browser/ui/cocoa/atom_menu_controller.h"
-#include "base/strings/sys_string_conversions.h"
-#include "ui/display/screen.h"
-#include "ui/events/cocoa/cocoa_event_utils.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/mac/coordinate_conversion.h"
-
-namespace {
-
-// By default, macOS sets 4px to tray image as left and right padding margin.
-const CGFloat kHorizontalMargin = 4;
-// macOS tends to make the title 2px lower.
-const CGFloat kVerticalTitleMargin = 2;
-
-}  //  namespace
-
-@interface StatusItemView : NSView {
-  atom::TrayIconCocoa* trayIcon_;       // weak
-  AtomMenuController* menuController_;  // weak
-  atom::TrayIcon::HighlightMode highlight_mode_;
-  BOOL ignoreDoubleClickEvents_;
-  BOOL forceHighlight_;
-  BOOL inMouseEventSequence_;
-  BOOL ANSI_;
-  base::scoped_nsobject<NSImage> image_;
-  base::scoped_nsobject<NSImage> alternateImage_;
-  base::scoped_nsobject<NSString> title_;
-  base::scoped_nsobject<NSMutableAttributedString> attributedTitle_;
-  base::scoped_nsobject<NSStatusItem> statusItem_;
-  base::scoped_nsobject<NSTrackingArea> trackingArea_;
-}
-
-@end  // @interface StatusItemView
-
-@implementation StatusItemView
-
-- (id)initWithImage:(NSImage*)image icon:(atom::TrayIconCocoa*)icon {
-  image_.reset([image copy]);
-  trayIcon_ = icon;
-  highlight_mode_ = atom::TrayIcon::HighlightMode::SELECTION;
-  ignoreDoubleClickEvents_ = NO;
-  forceHighlight_ = NO;
-  inMouseEventSequence_ = NO;
-
-  if ((self = [super initWithFrame:CGRectZero])) {
-    [self registerForDraggedTypes:@[
-      NSFilenamesPboardType,
-      NSStringPboardType,
-    ]];
-
-    // Create the status item.
-    NSStatusItem* item = [[NSStatusBar systemStatusBar]
-        statusItemWithLength:NSVariableStatusItemLength];
-    statusItem_.reset([item retain]);
-    [statusItem_ setView:self];
-    // Finalize setup by sizing our views
-    [self updateDimensions];
-
-    // Add NSTrackingArea for listening to mouseEnter, mouseExit, and mouseMove
-    // events
-    trackingArea_.reset([[NSTrackingArea alloc]
-        initWithRect:[self bounds]
-             options:NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved |
-                     NSTrackingActiveAlways
-               owner:self
-            userInfo:nil]);
-    [self addTrackingArea:trackingArea_];
-  }
-  return self;
-}
-
-- (void)updateDimensions {
-  NSStatusBar* bar = [NSStatusBar systemStatusBar];
-  [self setFrame:NSMakeRect(0, 0, [self fullWidth], [bar thickness])];
-  [self setNeedsDisplay:YES];
-}
-
-- (void)removeItem {
-  // Turn off tracking events to prevent crash
-  if (trackingArea_) {
-    [self removeTrackingArea:trackingArea_];
-    trackingArea_.reset();
-  }
-  [[NSStatusBar systemStatusBar] removeStatusItem:statusItem_];
-  statusItem_.reset();
-}
-
-- (void)drawRect:(NSRect)dirtyRect {
-  // Draw the tray icon and title that align with NSStatusItem, layout:
-  //   ----------------
-  //   | icon | title |
-  ///  ----------------
-
-  CGFloat thickness = [[statusItem_ statusBar] thickness];
-
-  // Draw the system bar background.
-  [statusItem_ drawStatusBarBackgroundInRect:self.bounds
-                               withHighlight:[self shouldHighlight]];
-
-  // Determine which image to use.
-  NSImage* image = image_.get();
-  if (inMouseEventSequence_ && alternateImage_) {
-    image = alternateImage_.get();
-  }
-  // Apply the higlight color if the image is a template image. When this moves
-  // to using the new [NSStatusItem button] API, this should work automagically.
-  if ([image isTemplate] == YES) {
-    NSImage* imageWithColor = [[image copy] autorelease];
-    [imageWithColor lockFocus];
-    [[self colorWithHighlight:[self isHighlighted]] set];
-    CGRect imageBounds = CGRectMake(0, 0, image.size.width, image.size.height);
-    NSRectFillUsingOperation(imageBounds, NSCompositeSourceAtop);
-    [imageWithColor unlockFocus];
-    image = imageWithColor;
-  }
-
-  // Draw the image
-  [image
-      drawInRect:CGRectMake(roundf(([self iconWidth] - image.size.width) / 2),
-                            roundf((thickness - image.size.height) / 2),
-                            image.size.width, image.size.height)];
-
-  if (title_) {
-    // Draw title.
-    NSRect titleDrawRect = NSMakeRect([self iconWidth], -kVerticalTitleMargin,
-                                      [self titleWidth], thickness);
-    [attributedTitle_ drawInRect:titleDrawRect];
-  }
-}
-
-- (BOOL)isDarkMode {
-  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
-  NSString* mode = [defaults stringForKey:@"AppleInterfaceStyle"];
-  return mode && [mode isEqualToString:@"Dark"];
-}
-
-- (BOOL)isHighlighted {
-  BOOL highlight = [self shouldHighlight];
-  return highlight | [self isDarkMode];
-}
-
-// The width of the full status item.
-- (CGFloat)fullWidth {
-  if (title_)
-    return [self iconWidth] + [self titleWidth] + kHorizontalMargin;
-  else
-    return [self iconWidth];
-}
-
-// The width of the icon.
-- (CGFloat)iconWidth {
-  CGFloat thickness = [[NSStatusBar systemStatusBar] thickness];
-  CGFloat imageHeight = [image_ size].height;
-  CGFloat imageWidth = [image_ size].width;
-  CGFloat iconWidth = imageWidth;
-  if (imageWidth < thickness) {
-    // Image's width must be larger than menu bar's height.
-    iconWidth = thickness;
-  } else {
-    CGFloat verticalMargin = thickness - imageHeight;
-    // Image must have same horizontal vertical margin.
-    if (verticalMargin > 0 && imageWidth != imageHeight)
-      iconWidth = imageWidth + verticalMargin;
-    CGFloat horizontalMargin = thickness - imageWidth;
-    // Image must have at least kHorizontalMargin horizontal margin on each
-    // side.
-    if (horizontalMargin < 2 * kHorizontalMargin)
-      iconWidth = imageWidth + 2 * kHorizontalMargin;
-  }
-  return iconWidth;
-}
-
-// The width of the title.
-- (CGFloat)titleWidth {
-  if (!title_)
-    return 0;
-  return [attributedTitle_ size].width;
-}
-
-- (NSColor*)colorWithHighlight:(BOOL)highlight {
-  return highlight ? [NSColor whiteColor]
-                   : [NSColor colorWithRed:0.265625
-                                     green:0.25390625
-                                      blue:0.234375
-                                     alpha:1.0];
-}
-
-- (void)setImage:(NSImage*)image {
-  image_.reset([image copy]);
-  [self updateDimensions];
-}
-
-- (void)setAlternateImage:(NSImage*)image {
-  alternateImage_.reset([image copy]);
-}
-
-- (void)setHighlight:(atom::TrayIcon::HighlightMode)mode {
-  highlight_mode_ = mode;
-  [self setNeedsDisplay:YES];
-}
-
-- (void)setIgnoreDoubleClickEvents:(BOOL)ignore {
-  ignoreDoubleClickEvents_ = ignore;
-}
-
-- (BOOL)getIgnoreDoubleClickEvents {
-  return ignoreDoubleClickEvents_;
-}
-
-- (void)setTitle:(NSString*)title {
-  if (title.length > 0) {
-    title_.reset([title copy]);
-    ANSI_ = [title containsANSICodes];
-  } else {
-    title_.reset();
-    ANSI_ = NO;
-  }
-  [self updateAttributedTitle];
-  [self updateDimensions];
-}
-
-- (void)updateAttributedTitle {
-  NSDictionary* attributes =
-      @{NSFontAttributeName : [NSFont menuBarFontOfSize:0]};
-
-  if (ANSI_) {
-    NSCharacterSet* whites = [NSCharacterSet whitespaceCharacterSet];
-    NSString* title = [title_ stringByTrimmingCharactersInSet:whites];
-    attributedTitle_.reset([title attributedStringParsingANSICodes]);
-    [attributedTitle_ addAttributes:attributes
-                              range:NSMakeRange(0, [attributedTitle_ length])];
-    return;
-  }
-
-  // check title_ being nil
-  NSString* title = @"";
-  if (title_)
-    title = title_;
-
-  attributedTitle_.reset([[NSMutableAttributedString alloc]
-      initWithString:title
-          attributes:attributes]);
-
-  // NSFontAttributeName:[NSFont menuBarFontOfSize:0],
-  // NSForegroundColorAttributeName:[self colorWithHighlight: highlight]
-  [attributedTitle_ addAttributes:attributes
-                            range:NSMakeRange(0, [attributedTitle_ length])];
-  [attributedTitle_ addAttribute:NSForegroundColorAttributeName
-                           value:[self colorWithHighlight:[self isHighlighted]]
-                           range:NSMakeRange(0, [attributedTitle_ length])];
-}
-
-- (void)setMenuController:(AtomMenuController*)menu {
-  menuController_ = menu;
-}
-
-- (void)mouseDown:(NSEvent*)event {
-  inMouseEventSequence_ = YES;
-  [self setNeedsDisplay:YES];
-}
-
-- (void)mouseUp:(NSEvent*)event {
-  if (!inMouseEventSequence_) {
-    // If the menu is showing, when user clicked the tray icon, the `mouseDown`
-    // event will be dissmissed, we need to close the menu at this time.
-    [self setNeedsDisplay:YES];
-    return;
-  }
-  inMouseEventSequence_ = NO;
-
-  // Show menu when there is a context menu.
-  // NB(hokein): Make tray's behavior more like official one's.
-  // When the tray icon gets clicked quickly multiple times, the
-  // event.clickCount doesn't always return 1. Instead, it returns a value that
-  // counts the clicked times.
-  // So we don't check the clickCount here, just pop up the menu for each click
-  // event.
-  if (menuController_)
-    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
-
-  // Don't emit click events when menu is showing.
-  if (menuController_)
-    return;
-
-  // If we are ignoring double click events, we should ignore the `clickCount`
-  // value and immediately emit a click event.
-  BOOL shouldBeHandledAsASingleClick =
-      (event.clickCount == 1) || ignoreDoubleClickEvents_;
-  if (shouldBeHandledAsASingleClick)
-    trayIcon_->NotifyClicked(
-        gfx::ScreenRectFromNSRect(event.window.frame),
-        gfx::ScreenPointFromNSPoint([event locationInWindow]),
-        ui::EventFlagsFromModifiers([event modifierFlags]));
-
-  // Double click event.
-  BOOL shouldBeHandledAsADoubleClick =
-      (event.clickCount == 2) && !ignoreDoubleClickEvents_;
-  if (shouldBeHandledAsADoubleClick)
-    trayIcon_->NotifyDoubleClicked(
-        gfx::ScreenRectFromNSRect(event.window.frame),
-        ui::EventFlagsFromModifiers([event modifierFlags]));
-
-  [self setNeedsDisplay:YES];
-}
-
-- (void)popUpContextMenu:(atom::AtomMenuModel*)menu_model {
-  // Show a custom menu.
-  if (menu_model) {
-    base::scoped_nsobject<AtomMenuController> menuController([
-        [AtomMenuController alloc] initWithModel:menu_model
-                           useDefaultAccelerator:NO]);
-    forceHighlight_ = YES;  // Should highlight when showing menu.
-    [self setNeedsDisplay:YES];
-    [statusItem_ popUpStatusItemMenu:[menuController menu]];
-    forceHighlight_ = NO;
-    [self setNeedsDisplay:YES];
-    return;
-  }
-
-  if (menuController_ && ![menuController_ isMenuOpen]) {
-    // Redraw the tray icon to show highlight if it is enabled.
-    [self setNeedsDisplay:YES];
-    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
-    // The popUpStatusItemMenu returns only after the showing menu is closed.
-    // When it returns, we need to redraw the tray icon to not show highlight.
-    [self setNeedsDisplay:YES];
-  }
-}
-
-- (void)rightMouseUp:(NSEvent*)event {
-  trayIcon_->NotifyRightClicked(
-      gfx::ScreenRectFromNSRect(event.window.frame),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragEntered();
-  return NSDragOperationCopy;
-}
-
-- (void)mouseExited:(NSEvent*)event {
-  trayIcon_->NotifyMouseExited(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)mouseEntered:(NSEvent*)event {
-  trayIcon_->NotifyMouseEntered(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)mouseMoved:(NSEvent*)event {
-  trayIcon_->NotifyMouseMoved(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)draggingExited:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragExited();
-}
-
-- (void)draggingEnded:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragEnded();
-
-  if (NSPointInRect([sender draggingLocation], self.frame)) {
-    trayIcon_->NotifyDrop();
-  }
-}
-
-- (BOOL)handleDrop:(id<NSDraggingInfo>)sender {
-  NSPasteboard* pboard = [sender draggingPasteboard];
-
-  if ([[pboard types] containsObject:NSFilenamesPboardType]) {
-    std::vector<std::string> dropFiles;
-    NSArray* files = [pboard propertyListForType:NSFilenamesPboardType];
-    for (NSString* file in files)
-      dropFiles.push_back(base::SysNSStringToUTF8(file));
-    trayIcon_->NotifyDropFiles(dropFiles);
-    return YES;
-  } else if ([[pboard types] containsObject:NSStringPboardType]) {
-    NSString* dropText = [pboard stringForType:NSStringPboardType];
-    trayIcon_->NotifyDropText(base::SysNSStringToUTF8(dropText));
-    return YES;
-  }
-
-  return NO;
-}
-
-- (BOOL)prepareForDragOperation:(id<NSDraggingInfo>)sender {
-  return YES;
-}
-
-- (BOOL)performDragOperation:(id<NSDraggingInfo>)sender {
-  [self handleDrop:sender];
-  return YES;
-}
-
-- (void)setNeedsDisplay:(BOOL)display {
-  [self updateAttributedTitle];
-  [super setNeedsDisplay:display];
-}
-
-- (BOOL)shouldHighlight {
-  switch (highlight_mode_) {
-    case atom::TrayIcon::HighlightMode::ALWAYS:
-      return true;
-    case atom::TrayIcon::HighlightMode::NEVER:
-      return false;
-    case atom::TrayIcon::HighlightMode::SELECTION:
-      BOOL isMenuOpen = menuController_ && [menuController_ isMenuOpen];
-      return forceHighlight_ || inMouseEventSequence_ || isMenuOpen;
-  }
-}
-
-@end
-
-namespace atom {
-
-TrayIconCocoa::TrayIconCocoa() {}
-
-TrayIconCocoa::~TrayIconCocoa() {
-  [status_item_view_ removeItem];
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-}
-
-void TrayIconCocoa::SetImage(const gfx::Image& image) {
-  if (status_item_view_) {
-    [status_item_view_ setImage:image.AsNSImage()];
-  } else {
-    status_item_view_.reset(
-        [[StatusItemView alloc] initWithImage:image.AsNSImage() icon:this]);
-  }
-}
-
-void TrayIconCocoa::SetPressedImage(const gfx::Image& image) {
-  [status_item_view_ setAlternateImage:image.AsNSImage()];
-}
-
-void TrayIconCocoa::SetToolTip(const std::string& tool_tip) {
-  [status_item_view_ setToolTip:base::SysUTF8ToNSString(tool_tip)];
-}
-
-void TrayIconCocoa::SetTitle(const std::string& title) {
-  [status_item_view_ setTitle:base::SysUTF8ToNSString(title)];
-}
-
-void TrayIconCocoa::SetHighlightMode(TrayIcon::HighlightMode mode) {
-  [status_item_view_ setHighlight:mode];
-}
-
-void TrayIconCocoa::SetIgnoreDoubleClickEvents(bool ignore) {
-  [status_item_view_ setIgnoreDoubleClickEvents:ignore];
-}
-
-bool TrayIconCocoa::GetIgnoreDoubleClickEvents() {
-  return [status_item_view_ getIgnoreDoubleClickEvents];
-}
-
-void TrayIconCocoa::PopUpContextMenu(const gfx::Point& pos,
-                                     AtomMenuModel* menu_model) {
-  [status_item_view_ popUpContextMenu:menu_model];
-}
-
-void TrayIconCocoa::SetContextMenu(AtomMenuModel* menu_model) {
-  // Substribe to MenuClosed event.
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-  menu_model->AddObserver(this);
-
-  // Create native menu.
-  menu_.reset([[AtomMenuController alloc] initWithModel:menu_model
-                                  useDefaultAccelerator:NO]);
-  [status_item_view_ setMenuController:menu_.get()];
-}
-
-gfx::Rect TrayIconCocoa::GetBounds() {
-  auto bounds = gfx::ScreenRectFromNSRect([status_item_view_ window].frame);
-  return bounds;
-}
-
-void TrayIconCocoa::OnMenuWillClose() {
-  [status_item_view_ setNeedsDisplay:YES];
-}
-
-// static
-TrayIcon* TrayIcon::Create() {
-  return new TrayIconCocoa;
-}
-
-}  // namespace atom
removed in remote
  base   100644 666e64101e886bcb1e14b59296ac4b9e743c1aa0 atom/browser/ui/tray_icon_gtk.cc
  our    100644 4c780285c80a157afca74b0927175ba3b045def9 atom/browser/ui/tray_icon_gtk.cc
@@ -1,69 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon_gtk.h"
-
-#include "atom/browser/browser.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "chrome/browser/ui/libgtkui/app_indicator_icon.h"
-#include "chrome/browser/ui/libgtkui/gtk_status_icon.h"
-#include "ui/gfx/image/image.h"
-
-namespace atom {
-
-namespace {
-
-// Number of app indicators used (used as part of app-indicator id).
-int indicators_count;
-
-}  // namespace
-
-TrayIconGtk::TrayIconGtk() {}
-
-TrayIconGtk::~TrayIconGtk() {}
-
-void TrayIconGtk::SetImage(const gfx::Image& image) {
-  if (icon_) {
-    icon_->SetImage(image.AsImageSkia());
-    return;
-  }
-
-  const auto toolTip = base::UTF8ToUTF16(brightray::GetApplicationName());
-
-  if (libgtkui::AppIndicatorIcon::CouldOpen()) {
-    ++indicators_count;
-    icon_.reset(new libgtkui::AppIndicatorIcon(
-        base::StringPrintf("%s%d", Browser::Get()->GetName().c_str(),
-                           indicators_count),
-        image.AsImageSkia(), toolTip));
-  } else {
-    icon_.reset(new libgtkui::Gtk2StatusIcon(image.AsImageSkia(), toolTip));
-  }
-  icon_->set_delegate(this);
-}
-
-void TrayIconGtk::SetToolTip(const std::string& tool_tip) {
-  icon_->SetToolTip(base::UTF8ToUTF16(tool_tip));
-}
-
-void TrayIconGtk::SetContextMenu(AtomMenuModel* menu_model) {
-  icon_->UpdatePlatformContextMenu(menu_model);
-}
-
-void TrayIconGtk::OnClick() {
-  NotifyClicked();
-}
-
-bool TrayIconGtk::HasClickAction() {
-  return false;
-}
-
-// static
-TrayIcon* TrayIcon::Create() {
-  return new TrayIconGtk;
-}
-
-}  // namespace atom
removed in remote
  base   100644 2be3259f218de502eb8b4d17ddea45fcfdc6af57 atom/browser/ui/tray_icon_gtk.h
  our    100644 cddd0c4b8927d02bf7501a87251b65403cc3a756 atom/browser/ui/tray_icon_gtk.h
@@ -1,41 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "ui/views/linux_ui/status_icon_linux.h"
-
-namespace views {
-class StatusIconLinux;
-}
-
-namespace atom {
-
-class TrayIconGtk : public TrayIcon, public views::StatusIconLinux::Delegate {
- public:
-  TrayIconGtk();
-  ~TrayIconGtk() override;
-
-  // TrayIcon:
-  void SetImage(const gfx::Image& image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-
- private:
-  // views::StatusIconLinux::Delegate:
-  void OnClick() override;
-  bool HasClickAction() override;
-
-  std::unique_ptr<views::StatusIconLinux> icon_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIconGtk);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
removed in remote
  base   100644 ed421ed854529dea76d57bef8b1b01b1962a109f atom/browser/ui/tray_icon_observer.h
  our    100644 feb5fb8cfc7477c0cc399eba65ed4e80571f8248 atom/browser/ui/tray_icon_observer.h
@@ -1,44 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
-
-#include <string>
-#include <vector>
-
-namespace gfx {
-class Rect;
-class Point;
-}  // namespace gfx
-
-namespace atom {
-
-class TrayIconObserver {
- public:
-  virtual void OnClicked(const gfx::Rect& bounds,
-                         const gfx::Point& location,
-                         int modifiers) {}
-  virtual void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {}
-  virtual void OnBalloonShow() {}
-  virtual void OnBalloonClicked() {}
-  virtual void OnBalloonClosed() {}
-  virtual void OnRightClicked(const gfx::Rect& bounds, int modifiers) {}
-  virtual void OnDrop() {}
-  virtual void OnDropFiles(const std::vector<std::string>& files) {}
-  virtual void OnDropText(const std::string& text) {}
-  virtual void OnDragEntered() {}
-  virtual void OnDragExited() {}
-  virtual void OnDragEnded() {}
-  virtual void OnMouseEntered(const gfx::Point& location, int modifiers) {}
-  virtual void OnMouseExited(const gfx::Point& location, int modifiers) {}
-  virtual void OnMouseMoved(const gfx::Point& location, int modifiers) {}
-
- protected:
-  virtual ~TrayIconObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
removed in remote
  base   100644 82550013ef7a28b19483c189595866ad04411467 atom/browser/ui/tray_icon_win.cc
  our    100644 82550013ef7a28b19483c189595866ad04411467 atom/browser/ui/tray_icon_win.cc
@@ -1,16 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon.h"
-#include "atom/browser/ui/win/notify_icon_host.h"
-
-namespace atom {
-
-// static
-TrayIcon* TrayIcon::Create() {
-  static NotifyIconHost host;
-  return host.CreateNotifyIcon();
-}
-
-}  // namespace atom
removed in remote
  base   100644 2ec4459f6b45b71f084af67d4ac0353016f5eca9 atom/browser/ui/views/frameless_view.cc
  our    100644 8959ee13612979d2819621acc14ebf641fb7f116 atom/browser/ui/views/frameless_view.cc
@@ -1,115 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/frameless_view.h"
-
-#include "atom/browser/native_window_views.h"
-#include "ui/aura/window.h"
-#include "ui/base/hit_test.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/widget/widget_delegate.h"
-
-namespace atom {
-
-namespace {
-
-const int kResizeInsideBoundsSize = 5;
-const int kResizeAreaCornerSize = 16;
-
-}  // namespace
-
-// static
-const char FramelessView::kViewClassName[] = "FramelessView";
-
-FramelessView::FramelessView() {}
-
-FramelessView::~FramelessView() {}
-
-void FramelessView::Init(NativeWindowViews* window, views::Widget* frame) {
-  window_ = window;
-  frame_ = frame;
-}
-
-int FramelessView::ResizingBorderHitTest(const gfx::Point& point) {
-  // Check the frame first, as we allow a small area overlapping the contents
-  // to be used for resize handles.
-  bool can_ever_resize = frame_->widget_delegate()
-                             ? frame_->widget_delegate()->CanResize()
-                             : false;
-  // Don't allow overlapping resize handles when the window is maximized or
-  // fullscreen, as it can't be resized in those states.
-  int resize_border = frame_->IsMaximized() || frame_->IsFullscreen()
-                          ? 0
-                          : kResizeInsideBoundsSize;
-  return GetHTComponentForFrame(point, resize_border, resize_border,
-                                kResizeAreaCornerSize, kResizeAreaCornerSize,
-                                can_ever_resize);
-}
-
-gfx::Rect FramelessView::GetBoundsForClientView() const {
-  return bounds();
-}
-
-gfx::Rect FramelessView::GetWindowBoundsForClientBounds(
-    const gfx::Rect& client_bounds) const {
-  gfx::Rect window_bounds = client_bounds;
-  // Enforce minimum size (1, 1) in case that client_bounds is passed with
-  // empty size. This could occur when the frameless window is being
-  // initialized.
-  if (window_bounds.IsEmpty()) {
-    window_bounds.set_width(1);
-    window_bounds.set_height(1);
-  }
-  return window_bounds;
-}
-
-int FramelessView::NonClientHitTest(const gfx::Point& cursor) {
-  if (frame_->IsFullscreen())
-    return HTCLIENT;
-
-  // Check for possible draggable region in the client area for the frameless
-  // window.
-  SkRegion* draggable_region = window_->draggable_region();
-  if (draggable_region && draggable_region->contains(cursor.x(), cursor.y()))
-    return HTCAPTION;
-
-  // Support resizing frameless window by dragging the border.
-  int frame_component = ResizingBorderHitTest(cursor);
-  if (frame_component != HTNOWHERE)
-    return frame_component;
-
-  return HTCLIENT;
-}
-
-void FramelessView::GetWindowMask(const gfx::Size& size,
-                                  gfx::Path* window_mask) {}
-
-void FramelessView::ResetWindowControls() {}
-
-void FramelessView::UpdateWindowIcon() {}
-
-void FramelessView::UpdateWindowTitle() {}
-
-void FramelessView::SizeConstraintsChanged() {}
-
-gfx::Size FramelessView::CalculatePreferredSize() const {
-  return frame_->non_client_view()
-      ->GetWindowBoundsForClientBounds(
-          gfx::Rect(frame_->client_view()->GetPreferredSize()))
-      .size();
-}
-
-gfx::Size FramelessView::GetMinimumSize() const {
-  return window_->GetContentMinimumSize();
-}
-
-gfx::Size FramelessView::GetMaximumSize() const {
-  return window_->GetContentMaximumSize();
-}
-
-const char* FramelessView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 54dc3285fabc089691ce4d42f38ec6a77b2ab3e5 atom/browser/ui/views/frameless_view.h
  our    100644 a9d1e4b54906eaadc11764fccfb57877893e2a95 atom/browser/ui/views/frameless_view.h
@@ -1,57 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
-
-#include "ui/views/window/non_client_view.h"
-
-namespace views {
-class Widget;
-}
-
-namespace atom {
-
-class NativeWindowViews;
-
-class FramelessView : public views::NonClientFrameView {
- public:
-  static const char kViewClassName[];
-  FramelessView();
-  ~FramelessView() override;
-
-  virtual void Init(NativeWindowViews* window, views::Widget* frame);
-
-  // Returns whether the |point| is on frameless window's resizing border.
-  int ResizingBorderHitTest(const gfx::Point& point);
-
- protected:
-  // views::NonClientFrameView:
-  gfx::Rect GetBoundsForClientView() const override;
-  gfx::Rect GetWindowBoundsForClientBounds(
-      const gfx::Rect& client_bounds) const override;
-  int NonClientHitTest(const gfx::Point& point) override;
-  void GetWindowMask(const gfx::Size& size, gfx::Path* window_mask) override;
-  void ResetWindowControls() override;
-  void UpdateWindowIcon() override;
-  void UpdateWindowTitle() override;
-  void SizeConstraintsChanged() override;
-
-  // Overridden from View:
-  gfx::Size CalculatePreferredSize() const override;
-  gfx::Size GetMinimumSize() const override;
-  gfx::Size GetMaximumSize() const override;
-  const char* GetClassName() const override;
-
-  // Not owned.
-  NativeWindowViews* window_ = nullptr;
-  views::Widget* frame_ = nullptr;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(FramelessView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
removed in remote
  base   100644 b393e3f4657da24d4ca6b53c70c37029c1bfe327 atom/browser/ui/views/global_menu_bar_x11.cc
  our    100644 656bd8f991f87c06a240cdc09a3bfcd500d1c1c8 atom/browser/ui/views/global_menu_bar_x11.cc
@@ -1,336 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
-
-#include <dlfcn.h>
-#include <glib-object.h>
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/logging.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_tree_host.h"
-#include "ui/base/accelerators/menu_label_accelerator_util_linux.h"
-#include "ui/events/keycodes/keyboard_code_conversion_x.h"
-#include "ui/gfx/x/x11.h"
-
-// libdbusmenu-glib types
-typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_func)();
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_with_id_func)(int id);
-
-typedef int (*dbusmenu_menuitem_get_id_func)(DbusmenuMenuitem* item);
-typedef GList* (*dbusmenu_menuitem_get_children_func)(DbusmenuMenuitem* item);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_child_append_func)(
-    DbusmenuMenuitem* parent,
-    DbusmenuMenuitem* child);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    const char* value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_variant_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    GVariant* value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_bool_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    bool value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_int_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    int value);
-
-typedef struct _DbusmenuServer DbusmenuServer;
-typedef DbusmenuServer* (*dbusmenu_server_new_func)(const char* object);
-typedef void (*dbusmenu_server_set_root_func)(DbusmenuServer* self,
-                                              DbusmenuMenuitem* root);
-
-namespace atom {
-
-namespace {
-
-// Retrieved functions from libdbusmenu-glib.
-
-// DbusmenuMenuItem methods:
-dbusmenu_menuitem_new_func menuitem_new = NULL;
-dbusmenu_menuitem_new_with_id_func menuitem_new_with_id = NULL;
-dbusmenu_menuitem_get_id_func menuitem_get_id = NULL;
-dbusmenu_menuitem_get_children_func menuitem_get_children = NULL;
-dbusmenu_menuitem_get_children_func menuitem_take_children = NULL;
-dbusmenu_menuitem_child_append_func menuitem_child_append = NULL;
-dbusmenu_menuitem_property_set_func menuitem_property_set = NULL;
-dbusmenu_menuitem_property_set_variant_func menuitem_property_set_variant =
-    NULL;
-dbusmenu_menuitem_property_set_bool_func menuitem_property_set_bool = NULL;
-dbusmenu_menuitem_property_set_int_func menuitem_property_set_int = NULL;
-
-// DbusmenuServer methods:
-dbusmenu_server_new_func server_new = NULL;
-dbusmenu_server_set_root_func server_set_root = NULL;
-
-// Properties that we set on menu items:
-const char kPropertyEnabled[] = "enabled";
-const char kPropertyLabel[] = "label";
-const char kPropertyShortcut[] = "shortcut";
-const char kPropertyType[] = "type";
-const char kPropertyToggleType[] = "toggle-type";
-const char kPropertyToggleState[] = "toggle-state";
-const char kPropertyVisible[] = "visible";
-const char kPropertyChildrenDisplay[] = "children-display";
-
-const char kToggleCheck[] = "checkmark";
-const char kToggleRadio[] = "radio";
-const char kTypeSeparator[] = "separator";
-const char kDisplaySubmenu[] = "submenu";
-
-void EnsureMethodsLoaded() {
-  static bool attempted_load = false;
-  if (attempted_load)
-    return;
-  attempted_load = true;
-
-  void* dbusmenu_lib = dlopen("libdbusmenu-glib.so", RTLD_LAZY);
-  if (!dbusmenu_lib)
-    dbusmenu_lib = dlopen("libdbusmenu-glib.so.4", RTLD_LAZY);
-  if (!dbusmenu_lib)
-    return;
-
-  // DbusmenuMenuItem methods.
-  menuitem_new = reinterpret_cast<dbusmenu_menuitem_new_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new"));
-  menuitem_new_with_id = reinterpret_cast<dbusmenu_menuitem_new_with_id_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new_with_id"));
-  menuitem_get_id = reinterpret_cast<dbusmenu_menuitem_get_id_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_id"));
-  menuitem_get_children = reinterpret_cast<dbusmenu_menuitem_get_children_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_children"));
-  menuitem_take_children =
-      reinterpret_cast<dbusmenu_menuitem_get_children_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_take_children"));
-  menuitem_child_append = reinterpret_cast<dbusmenu_menuitem_child_append_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_child_append"));
-  menuitem_property_set = reinterpret_cast<dbusmenu_menuitem_property_set_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set"));
-  menuitem_property_set_variant =
-      reinterpret_cast<dbusmenu_menuitem_property_set_variant_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_variant"));
-  menuitem_property_set_bool =
-      reinterpret_cast<dbusmenu_menuitem_property_set_bool_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_bool"));
-  menuitem_property_set_int =
-      reinterpret_cast<dbusmenu_menuitem_property_set_int_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_int"));
-
-  // DbusmenuServer methods.
-  server_new = reinterpret_cast<dbusmenu_server_new_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_server_new"));
-  server_set_root = reinterpret_cast<dbusmenu_server_set_root_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_server_set_root"));
-}
-
-AtomMenuModel* ModelForMenuItem(DbusmenuMenuitem* item) {
-  return reinterpret_cast<AtomMenuModel*>(
-      g_object_get_data(G_OBJECT(item), "model"));
-}
-
-bool GetMenuItemID(DbusmenuMenuitem* item, int* id) {
-  gpointer id_ptr = g_object_get_data(G_OBJECT(item), "menu-id");
-  if (id_ptr != NULL) {
-    *id = GPOINTER_TO_INT(id_ptr) - 1;
-    return true;
-  }
-
-  return false;
-}
-
-void SetMenuItemID(DbusmenuMenuitem* item, int id) {
-  DCHECK_GE(id, 0);
-
-  // Add 1 to the menu_id to avoid setting zero (null) to "menu-id".
-  g_object_set_data(G_OBJECT(item), "menu-id", GINT_TO_POINTER(id + 1));
-}
-
-std::string GetMenuModelStatus(AtomMenuModel* model) {
-  std::string ret;
-  for (int i = 0; i < model->GetItemCount(); ++i) {
-    int status = model->GetTypeAt(i) | (model->IsVisibleAt(i) << 3) |
-                 (model->IsEnabledAt(i) << 4) |
-                 (model->IsItemCheckedAt(i) << 5);
-    ret += base::StringPrintf(
-        "%s-%X\n", base::UTF16ToUTF8(model->GetLabelAt(i)).c_str(), status);
-  }
-  return ret;
-}
-
-}  // namespace
-
-GlobalMenuBarX11::GlobalMenuBarX11(NativeWindowViews* window)
-    : window_(window),
-      xid_(window_->GetNativeWindow()->GetHost()->GetAcceleratedWidget()) {
-  EnsureMethodsLoaded();
-  if (server_new)
-    InitServer(xid_);
-
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
-}
-
-GlobalMenuBarX11::~GlobalMenuBarX11() {
-  if (IsServerStarted())
-    g_object_unref(server_);
-
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
-}
-
-// static
-std::string GlobalMenuBarX11::GetPathForWindow(gfx::AcceleratedWidget xid) {
-  return base::StringPrintf("/com/canonical/menu/%lX", xid);
-}
-
-void GlobalMenuBarX11::SetMenu(AtomMenuModel* menu_model) {
-  if (!IsServerStarted())
-    return;
-
-  DbusmenuMenuitem* root_item = menuitem_new();
-  menuitem_property_set(root_item, kPropertyLabel, "Root");
-  menuitem_property_set_bool(root_item, kPropertyVisible, true);
-  if (menu_model != nullptr) {
-    BuildMenuFromModel(menu_model, root_item);
-  }
-
-  server_set_root(server_, root_item);
-  g_object_unref(root_item);
-}
-
-bool GlobalMenuBarX11::IsServerStarted() const {
-  return server_;
-}
-
-void GlobalMenuBarX11::InitServer(gfx::AcceleratedWidget xid) {
-  std::string path = GetPathForWindow(xid);
-  server_ = server_new(path.c_str());
-}
-
-void GlobalMenuBarX11::OnWindowMapped() {
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
-}
-
-void GlobalMenuBarX11::OnWindowUnmapped() {
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
-}
-
-void GlobalMenuBarX11::BuildMenuFromModel(AtomMenuModel* model,
-                                          DbusmenuMenuitem* parent) {
-  for (int i = 0; i < model->GetItemCount(); ++i) {
-    DbusmenuMenuitem* item = menuitem_new();
-    menuitem_property_set_bool(item, kPropertyVisible, model->IsVisibleAt(i));
-
-    AtomMenuModel::ItemType type = model->GetTypeAt(i);
-    if (type == AtomMenuModel::TYPE_SEPARATOR) {
-      menuitem_property_set(item, kPropertyType, kTypeSeparator);
-    } else {
-      std::string label = ui::ConvertAcceleratorsFromWindowsStyle(
-          base::UTF16ToUTF8(model->GetLabelAt(i)));
-      menuitem_property_set(item, kPropertyLabel, label.c_str());
-      menuitem_property_set_bool(item, kPropertyEnabled, model->IsEnabledAt(i));
-
-      g_object_set_data(G_OBJECT(item), "model", model);
-      SetMenuItemID(item, i);
-
-      if (type == AtomMenuModel::TYPE_SUBMENU) {
-        menuitem_property_set(item, kPropertyChildrenDisplay, kDisplaySubmenu);
-        g_signal_connect(item, "about-to-show", G_CALLBACK(OnSubMenuShowThunk),
-                         this);
-      } else {
-        ui::Accelerator accelerator;
-        if (model->GetAcceleratorAtWithParams(i, true, &accelerator))
-          RegisterAccelerator(item, accelerator);
-
-        g_signal_connect(item, "item-activated",
-                         G_CALLBACK(OnItemActivatedThunk), this);
-
-        if (type == AtomMenuModel::TYPE_CHECK ||
-            type == AtomMenuModel::TYPE_RADIO) {
-          menuitem_property_set(
-              item, kPropertyToggleType,
-              type == AtomMenuModel::TYPE_CHECK ? kToggleCheck : kToggleRadio);
-          menuitem_property_set_int(item, kPropertyToggleState,
-                                    model->IsItemCheckedAt(i));
-        }
-      }
-    }
-
-    menuitem_child_append(parent, item);
-    g_object_unref(item);
-  }
-}
-
-void GlobalMenuBarX11::RegisterAccelerator(DbusmenuMenuitem* item,
-                                           const ui::Accelerator& accelerator) {
-  // A translation of libdbusmenu-gtk's menuitem_property_set_shortcut()
-  // translated from GDK types to ui::Accelerator types.
-  GVariantBuilder builder;
-  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
-
-  if (accelerator.IsCtrlDown())
-    g_variant_builder_add(&builder, "s", "Control");
-  if (accelerator.IsAltDown())
-    g_variant_builder_add(&builder, "s", "Alt");
-  if (accelerator.IsShiftDown())
-    g_variant_builder_add(&builder, "s", "Shift");
-
-  char* name =
-      XKeysymToString(XKeysymForWindowsKeyCode(accelerator.key_code(), false));
-  if (!name) {
-    NOTIMPLEMENTED();
-    return;
-  }
-  g_variant_builder_add(&builder, "s", name);
-
-  GVariant* inside_array = g_variant_builder_end(&builder);
-  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
-  g_variant_builder_add_value(&builder, inside_array);
-  GVariant* outside_array = g_variant_builder_end(&builder);
-
-  menuitem_property_set_variant(item, kPropertyShortcut, outside_array);
-}
-
-void GlobalMenuBarX11::OnItemActivated(DbusmenuMenuitem* item,
-                                       unsigned int timestamp) {
-  int id;
-  AtomMenuModel* model = ModelForMenuItem(item);
-  if (model && GetMenuItemID(item, &id))
-    model->ActivatedAt(id, 0);
-}
-
-void GlobalMenuBarX11::OnSubMenuShow(DbusmenuMenuitem* item) {
-  int id;
-  AtomMenuModel* model = ModelForMenuItem(item);
-  if (!model || !GetMenuItemID(item, &id))
-    return;
-
-  // Do not update menu if the submenu has not been changed.
-  std::string status = GetMenuModelStatus(model);
-  char* old = static_cast<char*>(g_object_get_data(G_OBJECT(item), "status"));
-  if (old && status == old)
-    return;
-
-  // Save the new status.
-  g_object_set_data_full(G_OBJECT(item), "status", g_strdup(status.c_str()),
-                         g_free);
-
-  // Clear children.
-  GList* children = menuitem_take_children(item);
-  g_list_foreach(children, reinterpret_cast<GFunc>(g_object_unref), NULL);
-  g_list_free(children);
-
-  // Build children.
-  BuildMenuFromModel(model->GetSubmenuModelAt(id), item);
-}
-
-}  // namespace atom
removed in remote
  base   100644 89b2680cabebf967a45a5bfaea56151d8cc0a1e9 atom/browser/ui/views/global_menu_bar_x11.h
  our    100644 dde466c94e8297e8c629152658c844fe4d3600b4 atom/browser/ui/views/global_menu_bar_x11.h
@@ -1,81 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
-#define ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
-
-#include <string>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "ui/base/glib/glib_signal.h"
-#include "ui/gfx/native_widget_types.h"
-
-typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
-typedef struct _DbusmenuServer DbusmenuServer;
-
-namespace ui {
-class Accelerator;
-}
-
-namespace atom {
-
-class NativeWindowViews;
-
-// Controls the Mac style menu bar on Unity.
-//
-// Unity has an Apple-like menu bar at the top of the screen that changes
-// depending on the active window. In the GTK port, we had a hidden GtkMenuBar
-// object in each GtkWindow which existed only to be scrapped by the
-// libdbusmenu-gtk code. Since we don't have GtkWindows anymore, we need to
-// interface directly with the lower level libdbusmenu-glib, which we
-// opportunistically dlopen() since not everyone is running Ubuntu.
-//
-// This class is like the chrome's corresponding one, but it generates the menu
-// from menu models instead, and it is also per-window specific.
-class GlobalMenuBarX11 {
- public:
-  explicit GlobalMenuBarX11(NativeWindowViews* window);
-  virtual ~GlobalMenuBarX11();
-
-  // Creates the object path for DbusmenuServer which is attached to |xid|.
-  static std::string GetPathForWindow(gfx::AcceleratedWidget xid);
-
-  void SetMenu(AtomMenuModel* menu_model);
-  bool IsServerStarted() const;
-
-  // Called by NativeWindow when it show/hides.
-  void OnWindowMapped();
-  void OnWindowUnmapped();
-
- private:
-  // Creates a DbusmenuServer.
-  void InitServer(gfx::AcceleratedWidget xid);
-
-  // Create a menu from menu model.
-  void BuildMenuFromModel(AtomMenuModel* model, DbusmenuMenuitem* parent);
-
-  // Sets the accelerator for |item|.
-  void RegisterAccelerator(DbusmenuMenuitem* item,
-                           const ui::Accelerator& accelerator);
-
-  CHROMEG_CALLBACK_1(GlobalMenuBarX11,
-                     void,
-                     OnItemActivated,
-                     DbusmenuMenuitem*,
-                     unsigned int);
-  CHROMEG_CALLBACK_0(GlobalMenuBarX11, void, OnSubMenuShow, DbusmenuMenuitem*);
-
-  NativeWindowViews* window_;
-  gfx::AcceleratedWidget xid_;
-
-  DbusmenuServer* server_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(GlobalMenuBarX11);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
removed in remote
  base   100644 ba0a542c1e8df91a5be321b6ca2967f500421000 atom/browser/ui/views/menu_bar.cc
  our    100644 e838d3cc217b5ffdb77226beff0d7217539f23f9 atom/browser/ui/views/menu_bar.cc
@@ -1,187 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/menu_bar.h"
-
-#include "atom/browser/ui/views/menu_delegate.h"
-#include "atom/browser/ui/views/submenu_button.h"
-#include "ui/base/models/menu_model.h"
-#include "ui/views/background.h"
-#include "ui/views/layout/box_layout.h"
-
-#if defined(OS_WIN)
-#include "ui/gfx/color_utils.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-// Default color of the menu bar.
-const SkColor kDefaultColor = SkColorSetARGB(255, 233, 233, 233);
-
-}  // namespace
-
-const char MenuBar::kViewClassName[] = "ElectronMenuBar";
-
-MenuBar::MenuBar(views::View* window)
-    : background_color_(kDefaultColor), window_(window) {
-  RefreshColorCache();
-  UpdateViewColors();
-  SetLayoutManager(
-      std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal));
-  window_->GetFocusManager()->AddFocusChangeListener(this);
-}
-
-MenuBar::~MenuBar() {
-  window_->GetFocusManager()->RemoveFocusChangeListener(this);
-}
-
-void MenuBar::SetMenu(AtomMenuModel* model) {
-  menu_model_ = model;
-  RebuildChildren();
-}
-
-void MenuBar::SetAcceleratorVisibility(bool visible) {
-  for (auto* child : GetChildrenInZOrder())
-    static_cast<SubmenuButton*>(child)->SetAcceleratorVisibility(visible);
-}
-
-MenuBar::View* MenuBar::FindAccelChild(base::char16 key) {
-  for (auto* child : GetChildrenInZOrder()) {
-    if (static_cast<SubmenuButton*>(child)->accelerator() == key)
-      return child;
-  }
-  return nullptr;
-}
-
-bool MenuBar::HasAccelerator(base::char16 key) {
-  return FindAccelChild(key) != nullptr;
-}
-
-void MenuBar::ActivateAccelerator(base::char16 key) {
-  auto* child = FindAccelChild(key);
-  if (child)
-    static_cast<SubmenuButton*>(child)->Activate(nullptr);
-}
-
-int MenuBar::GetItemCount() const {
-  return menu_model_ ? menu_model_->GetItemCount() : 0;
-}
-
-bool MenuBar::GetMenuButtonFromScreenPoint(const gfx::Point& screenPoint,
-                                           AtomMenuModel** menu_model,
-                                           views::MenuButton** button) {
-  if (!GetBoundsInScreen().Contains(screenPoint))
-    return false;
-
-  auto children = GetChildrenInZOrder();
-  for (int i = 0, n = children.size(); i < n; ++i) {
-    if (children[i]->GetBoundsInScreen().Contains(screenPoint) &&
-        (menu_model_->GetTypeAt(i) == AtomMenuModel::TYPE_SUBMENU)) {
-      *menu_model = menu_model_->GetSubmenuModelAt(i);
-      *button = static_cast<views::MenuButton*>(children[i]);
-      return true;
-    }
-  }
-
-  return false;
-}
-
-const char* MenuBar::GetClassName() const {
-  return kViewClassName;
-}
-
-void MenuBar::OnMenuButtonClicked(views::MenuButton* source,
-                                  const gfx::Point& point,
-                                  const ui::Event* event) {
-  // Hide the accelerator when a submenu is activated.
-  SetAcceleratorVisibility(false);
-
-  if (!menu_model_)
-    return;
-
-  if (!window_->HasFocus())
-    window_->RequestFocus();
-
-  int id = source->tag();
-  AtomMenuModel::ItemType type = menu_model_->GetTypeAt(id);
-  if (type != AtomMenuModel::TYPE_SUBMENU) {
-    menu_model_->ActivatedAt(id, 0);
-    return;
-  }
-
-  // Deleted in MenuDelegate::OnMenuClosed
-  MenuDelegate* menu_delegate = new MenuDelegate(this);
-  menu_delegate->RunMenu(menu_model_->GetSubmenuModelAt(id), source);
-}
-
-void MenuBar::RefreshColorCache(const ui::NativeTheme* theme) {
-  if (!theme)
-    theme = ui::NativeTheme::GetInstanceForNativeUi();
-  if (theme) {
-    background_color_ =
-        theme->GetSystemColor(ui::NativeTheme::kColorId_MenuBackgroundColor);
-#if defined(USE_X11)
-    enabled_color_ = theme->GetSystemColor(
-        ui::NativeTheme::kColorId_EnabledMenuItemForegroundColor);
-    disabled_color_ = theme->GetSystemColor(
-        ui::NativeTheme::kColorId_DisabledMenuItemForegroundColor);
-#endif
-  }
-#if defined(OS_WIN)
-  background_color_ = color_utils::GetSysSkColor(COLOR_MENUBAR);
-#endif
-}
-
-void MenuBar::OnNativeThemeChanged(const ui::NativeTheme* theme) {
-  RefreshColorCache(theme);
-  UpdateViewColors();
-}
-
-void MenuBar::OnDidChangeFocus(View* focused_before, View* focused_now) {
-  // if we've changed focus, update our view
-  const auto had_focus = has_focus_;
-  has_focus_ = focused_now != nullptr;
-  if (has_focus_ != had_focus)
-    UpdateViewColors();
-}
-
-void MenuBar::RebuildChildren() {
-  RemoveAllChildViews(true);
-  for (int i = 0, n = GetItemCount(); i < n; ++i) {
-    auto* button =
-        new SubmenuButton(menu_model_->GetLabelAt(i), this, background_color_);
-    button->set_tag(i);
-    AddChildView(button);
-  }
-  UpdateViewColors();
-}
-
-void MenuBar::UpdateViewColors() {
-  // set menubar background color
-  SetBackground(views::CreateSolidBackground(background_color_));
-
-  // set child colors
-  if (menu_model_ == nullptr)
-    return;
-#if defined(USE_X11)
-  const auto& textColor = has_focus_ ? enabled_color_ : disabled_color_;
-  for (auto* child : GetChildrenInZOrder()) {
-    auto* button = static_cast<SubmenuButton*>(child);
-    button->SetTextColor(views::Button::STATE_NORMAL, textColor);
-    button->SetTextColor(views::Button::STATE_DISABLED, disabled_color_);
-    button->SetTextColor(views::Button::STATE_PRESSED, enabled_color_);
-    button->SetTextColor(views::Button::STATE_HOVERED, textColor);
-    button->SetUnderlineColor(textColor);
-  }
-#elif defined(OS_WIN)
-  for (auto* child : GetChildrenInZOrder()) {
-    auto* button = static_cast<SubmenuButton*>(child);
-    button->SetUnderlineColor(color_utils::GetSysSkColor(COLOR_MENUTEXT));
-  }
-#endif
-}
-
-}  // namespace atom
removed in remote
  base   100644 9d77cfdf2a22c7927132e91eaa06fc030731a26e atom/browser/ui/views/menu_bar.h
  our    100644 2b10ba3e3bf2ccfc0453fdb59ad022ef7da8ed5b atom/browser/ui/views/menu_bar.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
-#define ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/views/controls/button/menu_button_listener.h"
-#include "ui/views/focus/focus_manager.h"
-#include "ui/views/view.h"
-
-namespace views {
-class MenuButton;
-}
-
-namespace atom {
-
-class MenuDelegate;
-
-class MenuBar : public views::View,
-                public views::MenuButtonListener,
-                public views::FocusChangeListener {
- public:
-  static const char kViewClassName[];
-
-  explicit MenuBar(views::View* window);
-  ~MenuBar() override;
-
-  // Replaces current menu with a new one.
-  void SetMenu(AtomMenuModel* menu_model);
-
-  // Shows underline under accelerators.
-  void SetAcceleratorVisibility(bool visible);
-
-  // Returns true if the submenu has accelerator |key|
-  bool HasAccelerator(base::char16 key);
-
-  // Shows the submenu whose accelerator is |key|.
-  void ActivateAccelerator(base::char16 key);
-
-  // Returns there are how many items in the root menu.
-  int GetItemCount() const;
-
-  // Get the menu under specified screen point.
-  bool GetMenuButtonFromScreenPoint(const gfx::Point& point,
-                                    AtomMenuModel** menu_model,
-                                    views::MenuButton** button);
-
- protected:
-  // views::View:
-  const char* GetClassName() const override;
-
-  // views::MenuButtonListener:
-  void OnMenuButtonClicked(views::MenuButton* source,
-                           const gfx::Point& point,
-                           const ui::Event* event) override;
-  void OnNativeThemeChanged(const ui::NativeTheme* theme) override;
-
-  // views::FocusChangeListener:
-  void OnDidChangeFocus(View* focused_before, View* focused_now) override;
-  void OnWillChangeFocus(View* focused_before, View* focused_now) override {}
-
- private:
-  void RebuildChildren();
-  void UpdateViewColors();
-
-  void RefreshColorCache(const ui::NativeTheme* theme = nullptr);
-  SkColor background_color_;
-#if defined(USE_X11)
-  SkColor enabled_color_;
-  SkColor disabled_color_;
-#endif
-
-  views::View* window_ = nullptr;
-  AtomMenuModel* menu_model_ = nullptr;
-
-  View* FindAccelChild(base::char16 key);
-
-  bool has_focus_ = true;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuBar);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
removed in remote
  base   100644 f0ecf13b36b65aa96bee3e55ee459a9d3dad2aaf atom/browser/ui/views/menu_delegate.cc
  our    100644 d8cb592293a765d96f1c9c743535224835d8476a atom/browser/ui/views/menu_delegate.cc
@@ -1,125 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/menu_delegate.h"
-
-#include "atom/browser/ui/views/menu_bar.h"
-#include "atom/browser/ui/views/menu_model_adapter.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/views/controls/button/menu_button.h"
-#include "ui/views/controls/menu/menu_item_view.h"
-#include "ui/views/controls/menu/menu_runner.h"
-#include "ui/views/widget/widget.h"
-
-namespace atom {
-
-MenuDelegate::MenuDelegate(MenuBar* menu_bar) : menu_bar_(menu_bar), id_(-1) {}
-
-MenuDelegate::~MenuDelegate() {}
-
-void MenuDelegate::RunMenu(AtomMenuModel* model, views::MenuButton* button) {
-  gfx::Point screen_loc;
-  views::View::ConvertPointToScreen(button, &screen_loc);
-  // Subtract 1 from the height to make the popup flush with the button border.
-  gfx::Rect bounds(screen_loc.x(), screen_loc.y(), button->width(),
-                   button->height() - 1);
-
-  id_ = button->tag();
-  adapter_.reset(new MenuModelAdapter(model));
-
-  views::MenuItemView* item = new views::MenuItemView(this);
-  static_cast<MenuModelAdapter*>(adapter_.get())->BuildMenu(item);
-
-  menu_runner_.reset(new views::MenuRunner(
-      item,
-      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
-  menu_runner_->RunMenuAt(button->GetWidget()->GetTopLevelWidget(), button,
-                          bounds, views::MENU_ANCHOR_TOPRIGHT,
-                          ui::MENU_SOURCE_MOUSE);
-}
-
-void MenuDelegate::ExecuteCommand(int id) {
-  adapter_->ExecuteCommand(id);
-}
-
-void MenuDelegate::ExecuteCommand(int id, int mouse_event_flags) {
-  adapter_->ExecuteCommand(id, mouse_event_flags);
-}
-
-bool MenuDelegate::IsTriggerableEvent(views::MenuItemView* source,
-                                      const ui::Event& e) {
-  return adapter_->IsTriggerableEvent(source, e);
-}
-
-bool MenuDelegate::GetAccelerator(int id, ui::Accelerator* accelerator) const {
-  return adapter_->GetAccelerator(id, accelerator);
-}
-
-base::string16 MenuDelegate::GetLabel(int id) const {
-  return adapter_->GetLabel(id);
-}
-
-const gfx::FontList* MenuDelegate::GetLabelFontList(int id) const {
-  return adapter_->GetLabelFontList(id);
-}
-
-bool MenuDelegate::IsCommandEnabled(int id) const {
-  return adapter_->IsCommandEnabled(id);
-}
-
-bool MenuDelegate::IsCommandVisible(int id) const {
-  return adapter_->IsCommandVisible(id);
-}
-
-bool MenuDelegate::IsItemChecked(int id) const {
-  return adapter_->IsItemChecked(id);
-}
-
-void MenuDelegate::SelectionChanged(views::MenuItemView* menu) {
-  adapter_->SelectionChanged(menu);
-}
-
-void MenuDelegate::WillShowMenu(views::MenuItemView* menu) {
-  adapter_->WillShowMenu(menu);
-}
-
-void MenuDelegate::WillHideMenu(views::MenuItemView* menu) {
-  adapter_->WillHideMenu(menu);
-}
-
-void MenuDelegate::OnMenuClosed(views::MenuItemView* menu) {
-  // Only switch to new menu when current menu is closed.
-  if (button_to_open_)
-    button_to_open_->Activate(nullptr);
-  delete this;
-}
-
-views::MenuItemView* MenuDelegate::GetSiblingMenu(
-    views::MenuItemView* menu,
-    const gfx::Point& screen_point,
-    views::MenuAnchorPosition* anchor,
-    bool* has_mnemonics,
-    views::MenuButton**) {
-  // TODO(zcbenz): We should follow Chromium's logics on implementing the
-  // sibling menu switches, this code is almost a hack.
-  views::MenuButton* button;
-  AtomMenuModel* model;
-  if (menu_bar_->GetMenuButtonFromScreenPoint(screen_point, &model, &button) &&
-      button->tag() != id_) {
-    bool switch_in_progress = !!button_to_open_;
-    // Always update target to open.
-    button_to_open_ = button;
-    // Switching menu asyncnously to avoid crash.
-    if (!switch_in_progress) {
-      content::BrowserThread::PostTask(
-          content::BrowserThread::UI, FROM_HERE,
-          base::Bind(&views::MenuRunner::Cancel,
-                     base::Unretained(menu_runner_.get())));
-    }
-  }
-
-  return nullptr;
-}
-
-}  // namespace atom
removed in remote
  base   100644 211ddb57bc39086d183aeb96cce683cc901a99c7 atom/browser/ui/views/menu_delegate.h
  our    100644 e23262a3aa7f6a5ff5ea0ba30b3b3f17c7c51735 atom/browser/ui/views/menu_delegate.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
-#define ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
-
-#include <memory>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/views/controls/menu/menu_delegate.h"
-
-namespace views {
-class MenuRunner;
-}
-
-namespace atom {
-
-class MenuBar;
-
-class MenuDelegate : public views::MenuDelegate {
- public:
-  explicit MenuDelegate(MenuBar* menu_bar);
-  ~MenuDelegate() override;
-
-  void RunMenu(AtomMenuModel* model, views::MenuButton* button);
-
- protected:
-  // views::MenuDelegate:
-  void ExecuteCommand(int id) override;
-  void ExecuteCommand(int id, int mouse_event_flags) override;
-  bool IsTriggerableEvent(views::MenuItemView* source,
-                          const ui::Event& e) override;
-  bool GetAccelerator(int id, ui::Accelerator* accelerator) const override;
-  base::string16 GetLabel(int id) const override;
-  const gfx::FontList* GetLabelFontList(int id) const override;
-  bool IsCommandEnabled(int id) const override;
-  bool IsCommandVisible(int id) const override;
-  bool IsItemChecked(int id) const override;
-  void SelectionChanged(views::MenuItemView* menu) override;
-  void WillShowMenu(views::MenuItemView* menu) override;
-  void WillHideMenu(views::MenuItemView* menu) override;
-  void OnMenuClosed(views::MenuItemView* menu) override;
-  views::MenuItemView* GetSiblingMenu(views::MenuItemView* menu,
-                                      const gfx::Point& screen_point,
-                                      views::MenuAnchorPosition* anchor,
-                                      bool* has_mnemonics,
-                                      views::MenuButton** button) override;
-
- private:
-  MenuBar* menu_bar_;
-  int id_;
-  std::unique_ptr<views::MenuDelegate> adapter_;
-  std::unique_ptr<views::MenuRunner> menu_runner_;
-
-  // The menu button to switch to.
-  views::MenuButton* button_to_open_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
removed in remote
  base   100644 134255f48458c86a7993e5924c26c64eeaf3aada atom/browser/ui/views/native_frame_view.cc
  our    100644 2501373851a6ee76d568ffb113bc728cf147a452 atom/browser/ui/views/native_frame_view.cc
@@ -1,28 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/native_frame_view.h"
-
-#include "atom/browser/native_window.h"
-
-namespace atom {
-
-const char NativeFrameView::kViewClassName[] = "AtomNativeFrameView";
-
-NativeFrameView::NativeFrameView(NativeWindow* window, views::Widget* widget)
-    : views::NativeFrameView(widget), window_(window) {}
-
-gfx::Size NativeFrameView::GetMinimumSize() const {
-  return window_->GetMinimumSize();
-}
-
-gfx::Size NativeFrameView::GetMaximumSize() const {
-  return window_->GetMaximumSize();
-}
-
-const char* NativeFrameView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 670459f1cbd0a42fef1f6ec31ad8705092fc73a6 atom/browser/ui/views/native_frame_view.h
  our    100644 22aa0ff94e82d76be109ffcdc708611e12b1c7ea atom/browser/ui/views/native_frame_view.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
-
-#include "ui/views/window/native_frame_view.h"
-
-namespace atom {
-
-class NativeWindow;
-
-// Like the views::NativeFrameView, but returns the min/max size from the
-// NativeWindowViews.
-class NativeFrameView : public views::NativeFrameView {
- public:
-  static const char kViewClassName[];
-  NativeFrameView(NativeWindow* window, views::Widget* widget);
-
- protected:
-  // views::View:
-  gfx::Size GetMinimumSize() const override;
-  gfx::Size GetMaximumSize() const override;
-  const char* GetClassName() const override;
-
- private:
-  NativeWindow* window_;  // weak ref.
-
-  DISALLOW_COPY_AND_ASSIGN(NativeFrameView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
removed in remote
  base   100644 72cab258cbecc9219b0fc508cb5d7e65ab642ab2 atom/browser/ui/views/submenu_button.cc
  our    100644 1124d3d01471876fefa2757570ba3cff796a991c atom/browser/ui/views/submenu_button.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/submenu_button.h"
-
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "ui/gfx/canvas.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/gfx/text_utils.h"
-#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
-#include "ui/views/animation/ink_drop_host_view.h"
-#include "ui/views/animation/ink_drop_impl.h"
-#include "ui/views/controls/button/label_button_border.h"
-
-namespace atom {
-
-SubmenuButton::SubmenuButton(const base::string16& title,
-                             views::MenuButtonListener* menu_button_listener,
-                             const SkColor& background_color)
-    : views::MenuButton(gfx::RemoveAcceleratorChar(title, '&', NULL, NULL),
-                        menu_button_listener,
-                        false),
-      background_color_(background_color) {
-#if defined(OS_LINUX)
-  // Dont' use native style border.
-  SetBorder(CreateDefaultBorder());
-#endif
-
-  if (GetUnderlinePosition(title, &accelerator_, &underline_start_,
-                           &underline_end_))
-    gfx::Canvas::SizeStringInt(GetText(), gfx::FontList(), &text_width_,
-                               &text_height_, 0, 0);
-
-  SetInkDropMode(InkDropMode::ON);
-  set_ink_drop_base_color(
-      color_utils::BlendTowardOppositeLuma(background_color_, 0x61));
-}
-
-SubmenuButton::~SubmenuButton() {}
-
-std::unique_ptr<views::InkDropRipple> SubmenuButton::CreateInkDropRipple()
-    const {
-  std::unique_ptr<views::InkDropRipple> ripple(
-      new views::FloodFillInkDropRipple(
-          size(), GetInkDropCenterBasedOnLastEvent(), GetInkDropBaseColor(),
-          ink_drop_visible_opacity()));
-  return ripple;
-}
-
-std::unique_ptr<views::InkDrop> SubmenuButton::CreateInkDrop() {
-  std::unique_ptr<views::InkDropImpl> ink_drop =
-      views::Button::CreateDefaultInkDropImpl();
-  ink_drop->SetShowHighlightOnHover(false);
-  return std::move(ink_drop);
-}
-
-void SubmenuButton::SetAcceleratorVisibility(bool visible) {
-  if (visible == show_underline_)
-    return;
-
-  show_underline_ = visible;
-  SchedulePaint();
-}
-
-void SubmenuButton::SetUnderlineColor(SkColor color) {
-  underline_color_ = color;
-}
-
-void SubmenuButton::PaintButtonContents(gfx::Canvas* canvas) {
-  views::MenuButton::PaintButtonContents(canvas);
-
-  if (show_underline_ && (underline_start_ != underline_end_)) {
-    int padding = (width() - text_width_) / 2;
-    int underline_height = (height() + text_height_) / 2 - 2;
-    canvas->DrawLine(gfx::Point(underline_start_ + padding, underline_height),
-                     gfx::Point(underline_end_ + padding, underline_height),
-                     underline_color_);
-  }
-}
-
-bool SubmenuButton::GetUnderlinePosition(const base::string16& text,
-                                         base::char16* accelerator,
-                                         int* start,
-                                         int* end) const {
-  int pos, span;
-  base::string16 trimmed = gfx::RemoveAcceleratorChar(text, '&', &pos, &span);
-  if (pos > -1 && span != 0) {
-    *accelerator = base::ToUpperASCII(trimmed[pos]);
-    GetCharacterPosition(trimmed, pos, start);
-    GetCharacterPosition(trimmed, pos + span, end);
-    return true;
-  }
-
-  return false;
-}
-
-void SubmenuButton::GetCharacterPosition(const base::string16& text,
-                                         int index,
-                                         int* pos) const {
-  int height = 0;
-  gfx::Canvas::SizeStringInt(text.substr(0, index), gfx::FontList(), pos,
-                             &height, 0, 0);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3f72a60c10b499e42c9a2b63218397911f17910e atom/browser/ui/views/submenu_button.h
  our    100644 d8b7785da131271e88533879d090badfd6e49dd5 atom/browser/ui/views/submenu_button.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
-#define ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
-
-#include "ui/views/animation/ink_drop_highlight.h"
-#include "ui/views/controls/button/menu_button.h"
-
-namespace atom {
-
-// Special button that used by menu bar to show submenus.
-class SubmenuButton : public views::MenuButton {
- public:
-  SubmenuButton(const base::string16& title,
-                views::MenuButtonListener* menu_button_listener,
-                const SkColor& background_color);
-  ~SubmenuButton() override;
-
-  void SetAcceleratorVisibility(bool visible);
-  void SetUnderlineColor(SkColor color);
-
-  base::char16 accelerator() const { return accelerator_; }
-
-  // views::MenuButton:
-  void PaintButtonContents(gfx::Canvas* canvas) override;
-
-  // views::InkDropHostView:
-  std::unique_ptr<views::InkDropRipple> CreateInkDropRipple() const override;
-  std::unique_ptr<views::InkDrop> CreateInkDrop() override;
-
- private:
-  bool GetUnderlinePosition(const base::string16& text,
-                            base::char16* accelerator,
-                            int* start,
-                            int* end) const;
-  void GetCharacterPosition(const base::string16& text,
-                            int index,
-                            int* pos) const;
-
-  base::char16 accelerator_ = 0;
-
-  bool show_underline_ = false;
-
-  int underline_start_ = 0;
-  int underline_end_ = 0;
-  int text_width_ = 0;
-  int text_height_ = 0;
-  SkColor underline_color_ = SK_ColorBLACK;
-  SkColor background_color_;
-
-  DISALLOW_COPY_AND_ASSIGN(SubmenuButton);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
removed in remote
  base   100644 fca7cb23347c6d2fbc056384fcec9de5bcdb2501 atom/browser/ui/views/win_frame_view.cc
  our    100644 8f2139cb90fab876a1db1b17cac016997a3904ba atom/browser/ui/views/win_frame_view.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/win_frame_view.h"
-
-#include "atom/browser/native_window_views.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/win/hwnd_util.h"
-
-namespace atom {
-
-const char WinFrameView::kViewClassName[] = "WinFrameView";
-
-WinFrameView::WinFrameView() {}
-
-WinFrameView::~WinFrameView() {}
-
-gfx::Rect WinFrameView::GetWindowBoundsForClientBounds(
-    const gfx::Rect& client_bounds) const {
-  return views::GetWindowBoundsForClientBounds(
-      static_cast<views::View*>(const_cast<WinFrameView*>(this)),
-      client_bounds);
-}
-
-int WinFrameView::NonClientHitTest(const gfx::Point& point) {
-  if (window_->has_frame())
-    return frame_->client_view()->NonClientHitTest(point);
-  else
-    return FramelessView::NonClientHitTest(point);
-}
-
-const char* WinFrameView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 b2c1ef3a15de9a222233a27193ed811a8add09f6 atom/browser/ui/views/win_frame_view.h
  our    100644 a6ffd7f363304913bb124908f138258bb804e56f atom/browser/ui/views/win_frame_view.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
-
-#include "atom/browser/ui/views/frameless_view.h"
-
-namespace atom {
-
-class WinFrameView : public FramelessView {
- public:
-  static const char kViewClassName[];
-  WinFrameView();
-  ~WinFrameView() override;
-
-  // views::NonClientFrameView:
-  gfx::Rect GetWindowBoundsForClientBounds(
-      const gfx::Rect& client_bounds) const override;
-  int NonClientHitTest(const gfx::Point& point) override;
-
-  // views::View:
-  const char* GetClassName() const override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(WinFrameView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
removed in remote
  base   100644 84a6d9aa3e50ced33616fb4b78e124f39461cd0e atom/browser/ui/win/atom_desktop_window_tree_host_win.cc
  our    100644 97857d6515aa5617cf8c1972690a1dcdfd645ac1 atom/browser/ui/win/atom_desktop_window_tree_host_win.cc
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/atom_desktop_window_tree_host_win.h"
-
-#include "atom/browser/ui/win/message_handler_delegate.h"
-
-namespace atom {
-
-AtomDesktopWindowTreeHostWin::AtomDesktopWindowTreeHostWin(
-    MessageHandlerDelegate* delegate,
-    views::internal::NativeWidgetDelegate* native_widget_delegate,
-    views::DesktopNativeWidgetAura* desktop_native_widget_aura)
-    : views::DesktopWindowTreeHostWin(native_widget_delegate,
-                                      desktop_native_widget_aura),
-      delegate_(delegate) {}
-
-AtomDesktopWindowTreeHostWin::~AtomDesktopWindowTreeHostWin() {}
-
-bool AtomDesktopWindowTreeHostWin::PreHandleMSG(UINT message,
-                                                WPARAM w_param,
-                                                LPARAM l_param,
-                                                LRESULT* result) {
-  return delegate_->PreHandleMSG(message, w_param, l_param, result);
-}
-
-bool AtomDesktopWindowTreeHostWin::HasNativeFrame() const {
-  // Since we never use chromium's titlebar implementation, we can just say
-  // that we use a native titlebar. This will disable the repaint locking when
-  // DWM composition is disabled.
-  return true;
-}
-
-}  // namespace atom
removed in remote
  base   100644 47e4cb6aed2a962bfdd2a92edaca74b452d15c4d atom/browser/ui/win/atom_desktop_window_tree_host_win.h
  our    100644 30af3cc162b4429cb3335c6864b801eac1d5f963 atom/browser/ui/win/atom_desktop_window_tree_host_win.h
@@ -1,42 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
-#define ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
-
-#include <windows.h>
-
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
-
-namespace atom {
-
-class MessageHandlerDelegate;
-
-class AtomDesktopWindowTreeHostWin : public views::DesktopWindowTreeHostWin {
- public:
-  AtomDesktopWindowTreeHostWin(
-      MessageHandlerDelegate* delegate,
-      views::internal::NativeWidgetDelegate* native_widget_delegate,
-      views::DesktopNativeWidgetAura* desktop_native_widget_aura);
-  ~AtomDesktopWindowTreeHostWin() override;
-
- protected:
-  bool PreHandleMSG(UINT message,
-                    WPARAM w_param,
-                    LPARAM l_param,
-                    LRESULT* result) override;
-  bool HasNativeFrame() const override;
-
- private:
-  MessageHandlerDelegate* delegate_;  // weak ref
-
-  DISALLOW_COPY_AND_ASSIGN(AtomDesktopWindowTreeHostWin);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
removed in remote
  base   100644 791d1fd816d9ea2459c930e536c125c7851ccbc8 atom/browser/ui/win/message_handler_delegate.cc
  our    100644 d8b4a42ffacbfd70bf9c8049f7966de450627064 atom/browser/ui/win/message_handler_delegate.cc
@@ -1,16 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/message_handler_delegate.h"
-
-namespace atom {
-
-bool MessageHandlerDelegate::PreHandleMSG(UINT message,
-                                          WPARAM w_param,
-                                          LPARAM l_param,
-                                          LRESULT* result) {
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 d8cfcf7fc43b9089c01055aafa337ca0ee2d1038 atom/browser/ui/win/message_handler_delegate.h
  our    100644 1eb490a28d7bfa4b77c80a691c4f1ab8c56403ca atom/browser/ui/win/message_handler_delegate.h
@@ -1,28 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
-#define ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
-
-#include <windows.h>
-
-namespace atom {
-
-class MessageHandlerDelegate {
- public:
-  // Catch-all message handling and filtering. Called before
-  // HWNDMessageHandler's built-in handling, which may pre-empt some
-  // expectations in Views/Aura if messages are consumed. Returns true if the
-  // message was consumed by the delegate and should not be processed further
-  // by the HWNDMessageHandler. In this case, |result| is returned. |result| is
-  // not modified otherwise.
-  virtual bool PreHandleMSG(UINT message,
-                            WPARAM w_param,
-                            LPARAM l_param,
-                            LRESULT* result);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
removed in remote
  base   100644 112473013808250a317da6422c6143829ac69677 atom/browser/ui/win/notify_icon.cc
  our    100644 9b01de8a49f6ca3daa61b5c8e7d863e87b5e573d atom/browser/ui/win/notify_icon.cc
@@ -1,175 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon.h"
-
-#include "atom/browser/ui/win/notify_icon_host.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/windows_version.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/display/screen.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/gfx/geometry/point.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-#include "ui/views/controls/menu/menu_runner.h"
-
-namespace atom {
-
-NotifyIcon::NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message)
-    : host_(host), icon_id_(id), window_(window), message_id_(message) {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_MESSAGE;
-  icon_data.uCallbackMessage = message_id_;
-  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
-  // This can happen if the explorer process isn't running when we try to
-  // create the icon for some reason (for example, at startup).
-  if (!result)
-    LOG(WARNING) << "Unable to create status tray icon.";
-}
-
-NotifyIcon::~NotifyIcon() {
-  // Remove our icon.
-  host_->Remove(this);
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  Shell_NotifyIcon(NIM_DELETE, &icon_data);
-}
-
-void NotifyIcon::HandleClickEvent(int modifiers,
-                                  bool left_mouse_click,
-                                  bool double_button_click) {
-  gfx::Rect bounds = GetBounds();
-
-  if (left_mouse_click) {
-    if (double_button_click)  // double left click
-      NotifyDoubleClicked(bounds, modifiers);
-    else  // single left click
-      NotifyClicked(bounds,
-                    display::Screen::GetScreen()->GetCursorScreenPoint(),
-                    modifiers);
-    return;
-  } else if (!double_button_click) {  // single right click
-    if (menu_model_)
-      PopUpContextMenu(gfx::Point(), menu_model_);
-    else
-      NotifyRightClicked(bounds, modifiers);
-  }
-}
-
-void NotifyIcon::ResetIcon() {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  // Delete any previously existing icon.
-  Shell_NotifyIcon(NIM_DELETE, &icon_data);
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_MESSAGE;
-  icon_data.uCallbackMessage = message_id_;
-  icon_data.hIcon = icon_.get();
-  // If we have an image, then set the NIF_ICON flag, which tells
-  // Shell_NotifyIcon() to set the image for the status icon it creates.
-  if (icon_data.hIcon)
-    icon_data.uFlags |= NIF_ICON;
-  // Re-add our icon.
-  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to re-create status tray icon.";
-}
-
-void NotifyIcon::SetImage(HICON image) {
-  icon_ = base::win::ScopedHICON(CopyIcon(image));
-
-  // Create the icon.
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_ICON;
-  icon_data.hIcon = image;
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Error setting status tray icon image";
-}
-
-void NotifyIcon::SetPressedImage(HICON image) {
-  // Ignore pressed images, since the standard on Windows is to not highlight
-  // pressed status icons.
-}
-
-void NotifyIcon::SetToolTip(const std::string& tool_tip) {
-  // Create the icon.
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_TIP;
-  wcsncpy_s(icon_data.szTip, base::UTF8ToUTF16(tool_tip).c_str(), _TRUNCATE);
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to set tooltip for status tray icon";
-}
-
-void NotifyIcon::DisplayBalloon(HICON icon,
-                                const base::string16& title,
-                                const base::string16& contents) {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_INFO;
-  icon_data.dwInfoFlags = NIIF_INFO;
-  wcsncpy_s(icon_data.szInfoTitle, title.c_str(), _TRUNCATE);
-  wcsncpy_s(icon_data.szInfo, contents.c_str(), _TRUNCATE);
-  icon_data.uTimeout = 0;
-  icon_data.hBalloonIcon = icon;
-  icon_data.dwInfoFlags = NIIF_USER | NIIF_LARGE_ICON;
-
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to create status tray balloon.";
-}
-
-void NotifyIcon::PopUpContextMenu(const gfx::Point& pos,
-                                  AtomMenuModel* menu_model) {
-  // Returns if context menu isn't set.
-  if (menu_model == nullptr && menu_model_ == nullptr)
-    return;
-
-  // Set our window as the foreground window, so the context menu closes when
-  // we click away from it.
-  if (!SetForegroundWindow(window_))
-    return;
-
-  // Show menu at mouse's position by default.
-  gfx::Rect rect(pos, gfx::Size());
-  if (pos.IsOrigin())
-    rect.set_origin(display::Screen::GetScreen()->GetCursorScreenPoint());
-
-  menu_runner_.reset(new views::MenuRunner(
-      menu_model != nullptr ? menu_model : menu_model_,
-      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
-  menu_runner_->RunMenuAt(NULL, NULL, rect, views::MENU_ANCHOR_TOPLEFT,
-                          ui::MENU_SOURCE_MOUSE);
-}
-
-void NotifyIcon::SetContextMenu(AtomMenuModel* menu_model) {
-  menu_model_ = menu_model;
-}
-
-gfx::Rect NotifyIcon::GetBounds() {
-  NOTIFYICONIDENTIFIER icon_id;
-  memset(&icon_id, 0, sizeof(NOTIFYICONIDENTIFIER));
-  icon_id.uID = icon_id_;
-  icon_id.hWnd = window_;
-  icon_id.cbSize = sizeof(NOTIFYICONIDENTIFIER);
-
-  RECT rect = {0};
-  Shell_NotifyIconGetRect(&icon_id, &rect);
-  return display::win::ScreenWin::ScreenToDIPRect(window_, gfx::Rect(rect));
-}
-
-void NotifyIcon::InitIconData(NOTIFYICONDATA* icon_data) {
-  memset(icon_data, 0, sizeof(NOTIFYICONDATA));
-  icon_data->cbSize = sizeof(NOTIFYICONDATA);
-  icon_data->hWnd = window_;
-  icon_data->uID = icon_id_;
-}
-
-}  // namespace atom
removed in remote
  base   100644 53ed49b937c162e9406c176e84a69689c7ecfef4 atom/browser/ui/win/notify_icon.h
  our    100644 bd4c17d2fcee53c7c106b0912252848cd6de0dc7 atom/browser/ui/win/notify_icon.h
@@ -1,92 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
-#define ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
-
-#include <windows.h>  // windows.h must be included first
-
-#include <shellapi.h>
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "base/win/scoped_gdi_object.h"
-
-namespace gfx {
-class Point;
-}
-
-namespace views {
-class MenuRunner;
-}
-
-namespace atom {
-
-class NotifyIconHost;
-
-class NotifyIcon : public TrayIcon {
- public:
-  // Constructor which provides this icon's unique ID and messaging window.
-  NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message);
-  ~NotifyIcon() override;
-
-  // Handles a click event from the user - if |left_button_click| is true and
-  // there is a registered observer, passes the click event to the observer,
-  // otherwise displays the context menu if there is one.
-  void HandleClickEvent(int modifiers,
-                        bool left_button_click,
-                        bool double_button_click);
-
-  // Re-creates the status tray icon now after the taskbar has been created.
-  void ResetIcon();
-
-  UINT icon_id() const { return icon_id_; }
-  HWND window() const { return window_; }
-  UINT message_id() const { return message_id_; }
-
-  // Overridden from TrayIcon:
-  void SetImage(HICON image) override;
-  void SetPressedImage(HICON image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void DisplayBalloon(HICON icon,
-                      const base::string16& title,
-                      const base::string16& contents) override;
-  void PopUpContextMenu(const gfx::Point& pos,
-                        AtomMenuModel* menu_model) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-  gfx::Rect GetBounds() override;
-
- private:
-  void InitIconData(NOTIFYICONDATA* icon_data);
-
-  // The tray that owns us.  Weak.
-  NotifyIconHost* host_;
-
-  // The unique ID corresponding to this icon.
-  UINT icon_id_;
-
-  // Window used for processing messages from this icon.
-  HWND window_;
-
-  // The message identifier used for status icon messages.
-  UINT message_id_;
-
-  // The currently-displayed icon for the window.
-  base::win::ScopedHICON icon_;
-
-  // The context menu.
-  AtomMenuModel* menu_model_ = nullptr;
-
-  // Context menu associated with this icon (if any).
-  std::unique_ptr<views::MenuRunner> menu_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(NotifyIcon);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
removed in remote
  base   100644 1f0b35b09fd24c625cf6ebc0704691ebb1dcf0df atom/browser/ui/win/notify_icon_host.cc
  our    100644 435ec050be4315d42cac4985f122fbb7e62702e5 atom/browser/ui/win/notify_icon_host.cc
@@ -1,183 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon_host.h"
-
-#include <commctrl.h>
-#include <winuser.h>
-
-#include "atom/browser/ui/win/notify_icon.h"
-#include "base/bind.h"
-#include "base/stl_util.h"
-#include "base/win/win_util.h"
-#include "base/win/wrapped_window_proc.h"
-#include "ui/events/event_constants.h"
-#include "ui/events/win/system_event_state_lookup.h"
-#include "ui/gfx/win/hwnd_util.h"
-
-namespace atom {
-
-namespace {
-
-const UINT kNotifyIconMessage = WM_APP + 1;
-
-// |kBaseIconId| is 2 to avoid conflicts with plugins that hard-code id 1.
-const UINT kBaseIconId = 2;
-
-const wchar_t kNotifyIconHostWindowClass[] = L"Electron_NotifyIconHostWindow";
-
-bool IsWinPressed() {
-  return ((::GetKeyState(VK_LWIN) & 0x8000) == 0x8000) ||
-         ((::GetKeyState(VK_RWIN) & 0x8000) == 0x8000);
-}
-
-int GetKeyboardModifers() {
-  int modifiers = ui::EF_NONE;
-  if (ui::win::IsShiftPressed())
-    modifiers |= ui::EF_SHIFT_DOWN;
-  if (ui::win::IsCtrlPressed())
-    modifiers |= ui::EF_CONTROL_DOWN;
-  if (ui::win::IsAltPressed())
-    modifiers |= ui::EF_ALT_DOWN;
-  if (IsWinPressed())
-    modifiers |= ui::EF_COMMAND_DOWN;
-  return modifiers;
-}
-
-}  // namespace
-
-NotifyIconHost::NotifyIconHost() {
-  // Register our window class
-  WNDCLASSEX window_class;
-  base::win::InitializeWindowClass(
-      kNotifyIconHostWindowClass,
-      &base::win::WrappedWindowProc<NotifyIconHost::WndProcStatic>, 0, 0, 0,
-      NULL, NULL, NULL, NULL, NULL, &window_class);
-  instance_ = window_class.hInstance;
-  atom_ = RegisterClassEx(&window_class);
-  CHECK(atom_);
-
-  // If the taskbar is re-created after we start up, we have to rebuild all of
-  // our icons.
-  taskbar_created_message_ = RegisterWindowMessage(TEXT("TaskbarCreated"));
-
-  // Create an offscreen window for handling messages for the status icons. We
-  // create a hidden WS_POPUP window instead of an HWND_MESSAGE window, because
-  // only top-level windows such as popups can receive broadcast messages like
-  // "TaskbarCreated".
-  window_ = CreateWindow(MAKEINTATOM(atom_), 0, WS_POPUP, 0, 0, 0, 0, 0, 0,
-                         instance_, 0);
-  gfx::CheckWindowCreated(window_);
-  gfx::SetWindowUserData(window_, this);
-}
-
-NotifyIconHost::~NotifyIconHost() {
-  if (window_)
-    DestroyWindow(window_);
-
-  if (atom_)
-    UnregisterClass(MAKEINTATOM(atom_), instance_);
-
-  for (NotifyIcon* ptr : notify_icons_)
-    delete ptr;
-}
-
-NotifyIcon* NotifyIconHost::CreateNotifyIcon() {
-  NotifyIcon* notify_icon =
-      new NotifyIcon(this, NextIconId(), window_, kNotifyIconMessage);
-  notify_icons_.push_back(notify_icon);
-  return notify_icon;
-}
-
-void NotifyIconHost::Remove(NotifyIcon* icon) {
-  NotifyIcons::iterator i(
-      std::find(notify_icons_.begin(), notify_icons_.end(), icon));
-
-  if (i == notify_icons_.end()) {
-    NOTREACHED();
-    return;
-  }
-
-  notify_icons_.erase(i);
-}
-
-LRESULT CALLBACK NotifyIconHost::WndProcStatic(HWND hwnd,
-                                               UINT message,
-                                               WPARAM wparam,
-                                               LPARAM lparam) {
-  NotifyIconHost* msg_wnd =
-      reinterpret_cast<NotifyIconHost*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
-  if (msg_wnd)
-    return msg_wnd->WndProc(hwnd, message, wparam, lparam);
-  else
-    return ::DefWindowProc(hwnd, message, wparam, lparam);
-}
-
-LRESULT CALLBACK NotifyIconHost::WndProc(HWND hwnd,
-                                         UINT message,
-                                         WPARAM wparam,
-                                         LPARAM lparam) {
-  if (message == taskbar_created_message_) {
-    // We need to reset all of our icons because the taskbar went away.
-    for (NotifyIcons::const_iterator i(notify_icons_.begin());
-         i != notify_icons_.end(); ++i) {
-      NotifyIcon* win_icon = static_cast<NotifyIcon*>(*i);
-      win_icon->ResetIcon();
-    }
-    return TRUE;
-  } else if (message == kNotifyIconMessage) {
-    NotifyIcon* win_icon = NULL;
-
-    // Find the selected status icon.
-    for (NotifyIcons::const_iterator i(notify_icons_.begin());
-         i != notify_icons_.end(); ++i) {
-      NotifyIcon* current_win_icon = static_cast<NotifyIcon*>(*i);
-      if (current_win_icon->icon_id() == wparam) {
-        win_icon = current_win_icon;
-        break;
-      }
-    }
-
-    // It is possible for this procedure to be called with an obsolete icon
-    // id.  In that case we should just return early before handling any
-    // actions.
-    if (!win_icon)
-      return TRUE;
-
-    switch (lparam) {
-      case TB_CHECKBUTTON:
-        win_icon->NotifyBalloonShow();
-        return TRUE;
-
-      case TB_INDETERMINATE:
-        win_icon->NotifyBalloonClicked();
-        return TRUE;
-
-      case TB_HIDEBUTTON:
-        win_icon->NotifyBalloonClosed();
-        return TRUE;
-
-      case WM_LBUTTONDOWN:
-      case WM_RBUTTONDOWN:
-      case WM_LBUTTONDBLCLK:
-      case WM_RBUTTONDBLCLK:
-      case WM_CONTEXTMENU:
-        // Walk our icons, find which one was clicked on, and invoke its
-        // HandleClickEvent() method.
-        win_icon->HandleClickEvent(
-            GetKeyboardModifers(),
-            (lparam == WM_LBUTTONDOWN || lparam == WM_LBUTTONDBLCLK),
-            (lparam == WM_LBUTTONDBLCLK || lparam == WM_RBUTTONDBLCLK));
-        return TRUE;
-    }
-  }
-  return ::DefWindowProc(hwnd, message, wparam, lparam);
-}
-
-UINT NotifyIconHost::NextIconId() {
-  UINT icon_id = next_icon_id_++;
-  return kBaseIconId + icon_id;
-}
-
-}  // namespace atom
removed in remote
  base   100644 6797d4f6a54c9530be2f71d16b9681432ab65452 atom/browser/ui/win/notify_icon_host.h
  our    100644 6e4dd4e552233e09be8c034198c4d43fde07dbbc atom/browser/ui/win/notify_icon_host.h
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
-#define ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
-
-#include <windows.h>
-
-#include <vector>
-
-#include "base/macros.h"
-
-namespace atom {
-
-class NotifyIcon;
-
-class NotifyIconHost {
- public:
-  NotifyIconHost();
-  ~NotifyIconHost();
-
-  NotifyIcon* CreateNotifyIcon();
-  void Remove(NotifyIcon* notify_icon);
-
- private:
-  typedef std::vector<NotifyIcon*> NotifyIcons;
-
-  // Static callback invoked when a message comes in to our messaging window.
-  static LRESULT CALLBACK WndProcStatic(HWND hwnd,
-                                        UINT message,
-                                        WPARAM wparam,
-                                        LPARAM lparam);
-
-  LRESULT CALLBACK WndProc(HWND hwnd,
-                           UINT message,
-                           WPARAM wparam,
-                           LPARAM lparam);
-
-  UINT NextIconId();
-
-  // The unique icon ID we will assign to the next icon.
-  UINT next_icon_id_ = 1;
-
-  // List containing all active NotifyIcons.
-  NotifyIcons notify_icons_;
-
-  // The window class of |window_|.
-  ATOM atom_ = 0;
-
-  // The handle of the module that contains the window procedure of |window_|.
-  HMODULE instance_ = nullptr;
-
-  // The window used for processing events.
-  HWND window_ = nullptr;
-
-  // The message ID of the "TaskbarCreated" message, sent to us when we need to
-  // reset our status icons.
-  UINT taskbar_created_message_ = 0;
-
-  DISALLOW_COPY_AND_ASSIGN(NotifyIconHost);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
removed in remote
  base   100644 f7841cfa856c7c9d6a5ac362ccf39bfce972438a atom/browser/ui/win/taskbar_host.cc
  our    100644 c4b92a24aefb3afa3ff2929eea59940d439e8709 atom/browser/ui/win/taskbar_host.cc
@@ -1,226 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/taskbar_host.h"
-
-#include <objbase.h>
-#include <string>
-
-#include "atom/browser/native_window.h"
-#include "base/stl_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/scoped_gdi_object.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/gfx/icon_util.h"
-
-namespace atom {
-
-namespace {
-
-// From MSDN:
-// https://msdn.microsoft.com/en-us/library/windows/desktop/dd378460(v=vs.85).aspx#thumbbars
-// The thumbnail toolbar has a maximum of seven buttons due to the limited room.
-const size_t kMaxButtonsCount = 7;
-
-// The base id of Thumbar button.
-const int kButtonIdBase = 40001;
-
-bool GetThumbarButtonFlags(const std::vector<std::string>& flags,
-                           THUMBBUTTONFLAGS* out) {
-  THUMBBUTTONFLAGS result = THBF_ENABLED;  // THBF_ENABLED == 0
-  for (const auto& flag : flags) {
-    if (flag == "disabled")
-      result |= THBF_DISABLED;
-    else if (flag == "dismissonclick")
-      result |= THBF_DISMISSONCLICK;
-    else if (flag == "nobackground")
-      result |= THBF_NOBACKGROUND;
-    else if (flag == "hidden")
-      result |= THBF_HIDDEN;
-    else if (flag == "noninteractive")
-      result |= THBF_NONINTERACTIVE;
-    else
-      return false;
-  }
-  *out = result;
-  return true;
-}
-
-}  // namespace
-
-TaskbarHost::ThumbarButton::ThumbarButton() = default;
-TaskbarHost::ThumbarButton::ThumbarButton(const TaskbarHost::ThumbarButton&) =
-    default;
-TaskbarHost::ThumbarButton::~ThumbarButton() = default;
-
-TaskbarHost::TaskbarHost() {}
-
-TaskbarHost::~TaskbarHost() {}
-
-bool TaskbarHost::SetThumbarButtons(HWND window,
-                                    const std::vector<ThumbarButton>& buttons) {
-  if (buttons.size() > kMaxButtonsCount || !InitializeTaskbar())
-    return false;
-
-  callback_map_.clear();
-
-  // The number of buttons in thumbar can not be changed once it is created,
-  // so we have to claim kMaxButtonsCount buttons initialy in case users add
-  // more buttons later.
-  base::win::ScopedHICON icons[kMaxButtonsCount] = {};
-  THUMBBUTTON thumb_buttons[kMaxButtonsCount] = {};
-
-  for (size_t i = 0; i < kMaxButtonsCount; ++i) {
-    THUMBBUTTON& thumb_button = thumb_buttons[i];
-
-    // Set ID.
-    thumb_button.iId = kButtonIdBase + i;
-    thumb_button.dwMask = THB_FLAGS;
-
-    if (i >= buttons.size()) {
-      // This button is used to occupy the place in toolbar, and it does not
-      // show.
-      thumb_button.dwFlags = THBF_HIDDEN;
-      continue;
-    }
-
-    // This button is user's button.
-    const ThumbarButton& button = buttons[i];
-
-    // Generate flags.
-    thumb_button.dwFlags = THBF_ENABLED;
-    if (!GetThumbarButtonFlags(button.flags, &thumb_button.dwFlags))
-      return false;
-
-    // Set icon.
-    if (!button.icon.IsEmpty()) {
-      thumb_button.dwMask |= THB_ICON;
-      icons[i] = IconUtil::CreateHICONFromSkBitmap(button.icon.AsBitmap());
-      thumb_button.hIcon = icons[i].get();
-    }
-
-    // Set tooltip.
-    if (!button.tooltip.empty()) {
-      thumb_button.dwMask |= THB_TOOLTIP;
-      wcsncpy_s(thumb_button.szTip, base::UTF8ToUTF16(button.tooltip).c_str(),
-                _TRUNCATE);
-    }
-
-    // Save callback.
-    callback_map_[thumb_button.iId] = button.clicked_callback;
-  }
-
-  // Finally add them to taskbar.
-  HRESULT r;
-  if (thumbar_buttons_added_)
-    r = taskbar_->ThumbBarUpdateButtons(window, kMaxButtonsCount,
-                                        thumb_buttons);
-  else
-    r = taskbar_->ThumbBarAddButtons(window, kMaxButtonsCount, thumb_buttons);
-
-  thumbar_buttons_added_ = true;
-  last_buttons_ = buttons;
-  return SUCCEEDED(r);
-}
-
-void TaskbarHost::RestoreThumbarButtons(HWND window) {
-  if (thumbar_buttons_added_) {
-    thumbar_buttons_added_ = false;
-    SetThumbarButtons(window, last_buttons_);
-  }
-}
-
-bool TaskbarHost::SetProgressBar(HWND window,
-                                 double value,
-                                 const NativeWindow::ProgressState state) {
-  if (!InitializeTaskbar())
-    return false;
-
-  bool success;
-  if (value > 1.0 || state == NativeWindow::PROGRESS_INDETERMINATE) {
-    success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_INDETERMINATE));
-  } else if (value < 0 || state == NativeWindow::PROGRESS_NONE) {
-    success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_NOPROGRESS));
-  } else {
-    // Unless SetProgressState set a blocking state (TBPF_ERROR, TBPF_PAUSED)
-    // for the window, a call to SetProgressValue assumes the TBPF_NORMAL
-    // state even if it is not explicitly set.
-    // SetProgressValue overrides and clears the TBPF_INDETERMINATE state.
-    if (state == NativeWindow::PROGRESS_ERROR) {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_ERROR));
-    } else if (state == NativeWindow::PROGRESS_PAUSED) {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_PAUSED));
-    } else {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_NORMAL));
-    }
-
-    if (success) {
-      int val = static_cast<int>(value * 100);
-      success = SUCCEEDED(taskbar_->SetProgressValue(window, val, 100));
-    }
-  }
-
-  return success;
-}
-
-bool TaskbarHost::SetOverlayIcon(HWND window,
-                                 const gfx::Image& overlay,
-                                 const std::string& text) {
-  if (!InitializeTaskbar())
-    return false;
-
-  base::win::ScopedHICON icon(
-      IconUtil::CreateHICONFromSkBitmap(overlay.AsBitmap()));
-  return SUCCEEDED(taskbar_->SetOverlayIcon(window, icon.get(),
-                                            base::UTF8ToUTF16(text).c_str()));
-}
-
-bool TaskbarHost::SetThumbnailClip(HWND window, const gfx::Rect& region) {
-  if (!InitializeTaskbar())
-    return false;
-
-  if (region.IsEmpty()) {
-    return SUCCEEDED(taskbar_->SetThumbnailClip(window, NULL));
-  } else {
-    RECT rect =
-        display::win::ScreenWin::DIPToScreenRect(window, region).ToRECT();
-    return SUCCEEDED(taskbar_->SetThumbnailClip(window, &rect));
-  }
-}
-
-bool TaskbarHost::SetThumbnailToolTip(HWND window, const std::string& tooltip) {
-  if (!InitializeTaskbar())
-    return false;
-
-  return SUCCEEDED(taskbar_->SetThumbnailTooltip(
-      window, base::UTF8ToUTF16(tooltip).c_str()));
-}
-
-bool TaskbarHost::HandleThumbarButtonEvent(int button_id) {
-  if (ContainsKey(callback_map_, button_id)) {
-    auto callback = callback_map_[button_id];
-    if (!callback.is_null())
-      callback.Run();
-    return true;
-  }
-  return false;
-}
-
-bool TaskbarHost::InitializeTaskbar() {
-  if (taskbar_)
-    return true;
-
-  if (FAILED(::CoCreateInstance(CLSID_TaskbarList, nullptr,
-                                CLSCTX_INPROC_SERVER,
-                                IID_PPV_ARGS(&taskbar_))) ||
-      FAILED(taskbar_->HrInit())) {
-    taskbar_.Reset();
-    return false;
-  } else {
-    return true;
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 185b88a6b5b6f0570ce55c82d8db6b9c2a608073 atom/browser/ui/win/taskbar_host.h
  our    100644 2182d377a7736f5e135d2f518c2a0a838cd0d1a0 atom/browser/ui/win/taskbar_host.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
-#define ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
-
-#include <shobjidl.h>
-#include <wrl/client.h>
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "base/callback.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-
-namespace atom {
-
-class TaskbarHost {
- public:
-  struct ThumbarButton {
-    std::string tooltip;
-    gfx::Image icon;
-    std::vector<std::string> flags;
-    base::Closure clicked_callback;
-
-    ThumbarButton();
-    ThumbarButton(const ThumbarButton&);
-    ~ThumbarButton();
-  };
-
-  TaskbarHost();
-  virtual ~TaskbarHost();
-
-  // Add or update the buttons in thumbar.
-  bool SetThumbarButtons(HWND window,
-                         const std::vector<ThumbarButton>& buttons);
-
-  void RestoreThumbarButtons(HWND window);
-
-  // Set the progress state in taskbar.
-  bool SetProgressBar(HWND window,
-                      double value,
-                      const NativeWindow::ProgressState state);
-
-  // Set the overlay icon in taskbar.
-  bool SetOverlayIcon(HWND window,
-                      const gfx::Image& overlay,
-                      const std::string& text);
-
-  // Set the region of the window to show as a thumbnail in taskbar.
-  bool SetThumbnailClip(HWND window, const gfx::Rect& region);
-
-  // Set the tooltip for the thumbnail in taskbar.
-  bool SetThumbnailToolTip(HWND window, const std::string& tooltip);
-
-  // Called by the window that there is a button in thumbar clicked.
-  bool HandleThumbarButtonEvent(int button_id);
-
- private:
-  // Initialize the taskbar object.
-  bool InitializeTaskbar();
-
-  using CallbackMap = std::map<int, base::Closure>;
-  CallbackMap callback_map_;
-
-  std::vector<ThumbarButton> last_buttons_;
-
-  // The COM object of taskbar.
-  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar_;
-
-  // Whether we have already added the buttons to thumbar.
-  bool thumbar_buttons_added_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskbarHost);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
removed in remote
  base   100644 e1b2716b868f2c441ea43b7b9cf2b31ac1c1f300 atom/browser/ui/x/window_state_watcher.cc
  our    100644 9eebc361d7d0c5915345e73f0a6eba8f5336b003 atom/browser/ui/x/window_state_watcher.cc
@@ -1,64 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/x/window_state_watcher.h"
-
-#include "ui/events/platform/platform_event_source.h"
-#include "ui/gfx/x/x11.h"
-#include "ui/gfx/x/x11_atom_cache.h"
-
-namespace atom {
-
-WindowStateWatcher::WindowStateWatcher(NativeWindowViews* window)
-    : window_(window), widget_(window->GetAcceleratedWidget()) {
-  ui::PlatformEventSource::GetInstance()->AddPlatformEventObserver(this);
-}
-
-WindowStateWatcher::~WindowStateWatcher() {
-  ui::PlatformEventSource::GetInstance()->RemovePlatformEventObserver(this);
-}
-
-void WindowStateWatcher::WillProcessEvent(const ui::PlatformEvent& event) {
-  if (IsWindowStateEvent(event)) {
-    was_minimized_ = window_->IsMinimized();
-    was_maximized_ = window_->IsMaximized();
-  }
-}
-
-void WindowStateWatcher::DidProcessEvent(const ui::PlatformEvent& event) {
-  if (IsWindowStateEvent(event)) {
-    bool is_minimized = window_->IsMinimized();
-    bool is_maximized = window_->IsMaximized();
-    bool is_fullscreen = window_->IsFullscreen();
-    if (is_minimized != was_minimized_) {
-      if (is_minimized)
-        window_->NotifyWindowMinimize();
-      else
-        window_->NotifyWindowRestore();
-    } else if (is_maximized != was_maximized_) {
-      if (is_maximized)
-        window_->NotifyWindowMaximize();
-      else
-        window_->NotifyWindowUnmaximize();
-    } else {
-      // If this is neither a "maximize" or "minimize" event, then we think it
-      // is a "fullscreen" event.
-      // The "IsFullscreen()" becomes true immediately before "WillProcessEvent"
-      // is called, so we can not handle this like "maximize" and "minimize" by
-      // watching whether they have changed.
-      if (is_fullscreen)
-        window_->NotifyWindowEnterFullScreen();
-      else
-        window_->NotifyWindowLeaveFullScreen();
-    }
-  }
-}
-
-bool WindowStateWatcher::IsWindowStateEvent(const ui::PlatformEvent& event) {
-  ::Atom changed_atom = event->xproperty.atom;
-  return (changed_atom == gfx::GetAtom("_NET_WM_STATE") &&
-          event->type == PropertyNotify && event->xproperty.window == widget_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 2888c9fc6fec1e68c33479c06c1c017608fa43c1 atom/browser/ui/x/window_state_watcher.h
  our    100644 7d65b08d8bb32316c509f7aaaa14d5b4e337b7f5 atom/browser/ui/x/window_state_watcher.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
-#define ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
-
-#include "ui/events/platform/platform_event_observer.h"
-
-#include "atom/browser/native_window_views.h"
-
-namespace atom {
-
-class WindowStateWatcher : public ui::PlatformEventObserver {
- public:
-  explicit WindowStateWatcher(NativeWindowViews* window);
-  ~WindowStateWatcher() override;
-
- protected:
-  // ui::PlatformEventObserver:
-  void WillProcessEvent(const ui::PlatformEvent& event) override;
-  void DidProcessEvent(const ui::PlatformEvent& event) override;
-
- private:
-  bool IsWindowStateEvent(const ui::PlatformEvent& event);
-
-  NativeWindowViews* window_;
-  gfx::AcceleratedWidget widget_;
-
-  bool was_minimized_ = false;
-  bool was_maximized_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(WindowStateWatcher);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
removed in remote
  base   100644 db83753bb3765a585cd2ff1989aecfac87457cdb atom/browser/ui/x/x_window_utils.cc
  our    100644 ecc2f906e5849595010ffe549b3bbe999b173a0a atom/browser/ui/x/x_window_utils.cc
@@ -1,90 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/x/x_window_utils.h"
-
-#include <X11/Xatom.h>
-
-#include "base/environment.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_restrictions.h"
-#include "dbus/bus.h"
-#include "dbus/message.h"
-#include "dbus/object_proxy.h"
-#include "ui/base/x/x11_util.h"
-
-namespace atom {
-
-::Atom GetAtom(const char* name) {
-  return XInternAtom(gfx::GetXDisplay(), name, false);
-}
-
-void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state) {
-  XEvent xclient;
-  memset(&xclient, 0, sizeof(xclient));
-  xclient.type = ClientMessage;
-  xclient.xclient.window = xwindow;
-  xclient.xclient.message_type = GetAtom("_NET_WM_STATE");
-  xclient.xclient.format = 32;
-  xclient.xclient.data.l[0] = enabled ? 1 : 0;
-  xclient.xclient.data.l[1] = state;
-  xclient.xclient.data.l[2] = x11::None;
-  xclient.xclient.data.l[3] = 1;
-  xclient.xclient.data.l[4] = 0;
-
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  XSendEvent(xdisplay, DefaultRootWindow(xdisplay), x11::False,
-             SubstructureRedirectMask | SubstructureNotifyMask, &xclient);
-}
-
-void SetWindowType(::Window xwindow, const std::string& type) {
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  std::string type_prefix = "_NET_WM_WINDOW_TYPE_";
-  ::Atom window_type = XInternAtom(
-      xdisplay, (type_prefix + base::ToUpperASCII(type)).c_str(), x11::False);
-  XChangeProperty(xdisplay, xwindow,
-                  XInternAtom(xdisplay, "_NET_WM_WINDOW_TYPE", x11::False),
-                  XA_ATOM, 32, PropModeReplace,
-                  reinterpret_cast<unsigned char*>(&window_type), 1);
-}
-
-bool ShouldUseGlobalMenuBar() {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  if (env->HasVar("ELECTRON_FORCE_WINDOW_MENU_BAR"))
-    return false;
-
-  dbus::Bus::Options options;
-  scoped_refptr<dbus::Bus> bus(new dbus::Bus(options));
-
-  dbus::ObjectProxy* object_proxy =
-      bus->GetObjectProxy(DBUS_SERVICE_DBUS, dbus::ObjectPath(DBUS_PATH_DBUS));
-  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS, "ListNames");
-  std::unique_ptr<dbus::Response> response(object_proxy->CallMethodAndBlock(
-      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT));
-  if (!response) {
-    bus->ShutdownAndBlock();
-    return false;
-  }
-
-  dbus::MessageReader reader(response.get());
-  dbus::MessageReader array_reader(NULL);
-  if (!reader.PopArray(&array_reader)) {
-    bus->ShutdownAndBlock();
-    return false;
-  }
-  while (array_reader.HasMoreData()) {
-    std::string name;
-    if (array_reader.PopString(&name) &&
-        name == "com.canonical.AppMenu.Registrar") {
-      bus->ShutdownAndBlock();
-      return true;
-    }
-  }
-
-  bus->ShutdownAndBlock();
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 16f3ddac6ccd860a3f2400d1d6272d79c79f2cd8 atom/browser/ui/x/x_window_utils.h
  our    100644 5888a2b25663aef10e1700688807e24c693f298a atom/browser/ui/x/x_window_utils.h
@@ -1,28 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
-#define ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
-
-#include <string>
-
-#include "ui/gfx/x/x11.h"
-
-namespace atom {
-
-::Atom GetAtom(const char* name);
-
-// Sends a message to the x11 window manager, enabling or disabling the |state|
-// for _NET_WM_STATE.
-void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state);
-
-// Sets the _NET_WM_WINDOW_TYPE of window.
-void SetWindowType(::Window xwindow, const std::string& type);
-
-// Returns true if the bus name "com.canonical.AppMenu.Registrar" is available.
-bool ShouldUseGlobalMenuBar();
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
removed in remote
  base   100644 d018e1d09dbcd220f4007368e19c553c696c1f10 atom/browser/web_contents_permission_helper.cc
  our    100644 1b3d809b1e724da4f5d1105ab61c4ddb6f8f4274 atom/browser/web_contents_permission_helper.cc
@@ -1,105 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_permission_helper.h"
-
-#include <string>
-
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "brightray/browser/media/media_stream_devices_controller.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_process_host.h"
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::WebContentsPermissionHelper);
-
-namespace atom {
-
-namespace {
-
-void MediaAccessAllowed(const content::MediaStreamRequest& request,
-                        const content::MediaResponseCallback& callback,
-                        bool allowed) {
-  brightray::MediaStreamDevicesController controller(request, callback);
-  if (allowed)
-    controller.TakeAction();
-  else
-    controller.Deny(content::MEDIA_DEVICE_PERMISSION_DENIED);
-}
-
-void OnPointerLockResponse(content::WebContents* web_contents, bool allowed) {
-  if (web_contents)
-    web_contents->GotResponseToLockMouseRequest(allowed);
-}
-
-void OnPermissionResponse(const base::Callback<void(bool)>& callback,
-                          blink::mojom::PermissionStatus status) {
-  if (status == blink::mojom::PermissionStatus::GRANTED)
-    callback.Run(true);
-  else
-    callback.Run(false);
-}
-
-}  // namespace
-
-WebContentsPermissionHelper::WebContentsPermissionHelper(
-    content::WebContents* web_contents)
-    : web_contents_(web_contents) {}
-
-WebContentsPermissionHelper::~WebContentsPermissionHelper() {}
-
-void WebContentsPermissionHelper::RequestPermission(
-    content::PermissionType permission,
-    const base::Callback<void(bool)>& callback,
-    bool user_gesture,
-    const base::DictionaryValue* details) {
-  auto* rfh = web_contents_->GetMainFrame();
-  auto* permission_manager = static_cast<AtomPermissionManager*>(
-      web_contents_->GetBrowserContext()->GetPermissionManager());
-  auto origin = web_contents_->GetLastCommittedURL();
-  permission_manager->RequestPermissionWithDetails(
-      permission, rfh, origin, false, details,
-      base::Bind(&OnPermissionResponse, callback));
-}
-
-void WebContentsPermissionHelper::RequestFullscreenPermission(
-    const base::Callback<void(bool)>& callback) {
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::FULLSCREEN),
-      callback);
-}
-
-void WebContentsPermissionHelper::RequestMediaAccessPermission(
-    const content::MediaStreamRequest& request,
-    const content::MediaResponseCallback& response_callback) {
-  auto callback = base::Bind(&MediaAccessAllowed, request, response_callback);
-  // The permission type doesn't matter here, AUDIO_CAPTURE/VIDEO_CAPTURE
-  // are presented as same type in content_converter.h.
-  RequestPermission(content::PermissionType::AUDIO_CAPTURE, callback);
-}
-
-void WebContentsPermissionHelper::RequestWebNotificationPermission(
-    const base::Callback<void(bool)>& callback) {
-  RequestPermission(content::PermissionType::NOTIFICATIONS, callback);
-}
-
-void WebContentsPermissionHelper::RequestPointerLockPermission(
-    bool user_gesture) {
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::POINTER_LOCK),
-      base::Bind(&OnPointerLockResponse, web_contents_), user_gesture);
-}
-
-void WebContentsPermissionHelper::RequestOpenExternalPermission(
-    const base::Callback<void(bool)>& callback,
-    bool user_gesture,
-    const GURL& url) {
-  base::DictionaryValue details;
-  details.SetString("externalURL", url.spec());
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::OPEN_EXTERNAL),
-      callback, user_gesture, &details);
-}
-
-}  // namespace atom
removed in remote
  base   100644 90ae6dff56f5249aeb880e52b6839f26017d474f atom/browser/web_contents_permission_helper.h
  our    100644 322e0972fdec97ec445abc591711b0bab33f54f2 atom/browser/web_contents_permission_helper.h
@@ -1,53 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
-#define ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
-
-#include "content/public/browser/permission_type.h"
-#include "content/public/browser/web_contents_user_data.h"
-#include "content/public/common/media_stream_request.h"
-
-namespace atom {
-
-// Applies the permission requested for WebContents.
-class WebContentsPermissionHelper
-    : public content::WebContentsUserData<WebContentsPermissionHelper> {
- public:
-  ~WebContentsPermissionHelper() override;
-
-  enum class PermissionType {
-    POINTER_LOCK = static_cast<int>(content::PermissionType::NUM) + 1,
-    FULLSCREEN,
-    OPEN_EXTERNAL,
-  };
-
-  void RequestFullscreenPermission(const base::Callback<void(bool)>& callback);
-  void RequestMediaAccessPermission(
-      const content::MediaStreamRequest& request,
-      const content::MediaResponseCallback& callback);
-  void RequestWebNotificationPermission(
-      const base::Callback<void(bool)>& callback);
-  void RequestPointerLockPermission(bool user_gesture);
-  void RequestOpenExternalPermission(const base::Callback<void(bool)>& callback,
-                                     bool user_gesture,
-                                     const GURL& url);
-
- private:
-  explicit WebContentsPermissionHelper(content::WebContents* web_contents);
-  friend class content::WebContentsUserData<WebContentsPermissionHelper>;
-
-  void RequestPermission(content::PermissionType permission,
-                         const base::Callback<void(bool)>& callback,
-                         bool user_gesture = false,
-                         const base::DictionaryValue* details = nullptr);
-
-  content::WebContents* web_contents_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsPermissionHelper);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
removed in remote
  base   100644 3939c59b8cd5ede3e64b93e4e6ea6555f1b2d947 atom/browser/web_contents_preferences.cc
  our    100644 c21c93383155091a7481cdd4e741cefad90a4a55 atom/browser/web_contents_preferences.cc
@@ -1,395 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_preferences.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/memory/ptr_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "cc/base/switches.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/common/content_switches.h"
-#include "content/public/common/web_preferences.h"
-#include "native_mate/dictionary.h"
-#include "net/base/filename_util.h"
-
-#if defined(OS_WIN)
-#include "ui/gfx/switches.h"
-#endif
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::WebContentsPreferences);
-
-namespace {
-
-bool GetAsString(const base::Value* val,
-                 const base::StringPiece& path,
-                 std::string* out) {
-  if (val) {
-    auto* found = val->FindKeyOfType(path, base::Value::Type::STRING);
-    if (found) {
-      *out = found->GetString();
-      return true;
-    }
-  }
-  return false;
-}
-
-bool GetAsString(const base::Value* val,
-                 const base::StringPiece& path,
-                 base::string16* out) {
-  if (val) {
-    auto* found = val->FindKeyOfType(path, base::Value::Type::STRING);
-    if (found) {
-      *out = base::UTF8ToUTF16(found->GetString());
-      return true;
-    }
-  }
-  return false;
-}
-
-bool GetAsInteger(const base::Value* val,
-                  const base::StringPiece& path,
-                  int* out) {
-  if (val) {
-    auto* found = val->FindKey(path);
-    if (found && found->is_int()) {
-      *out = found->GetInt();
-      return true;
-    } else if (found && found->is_string()) {
-      return base::StringToInt(found->GetString(), out);
-    }
-  }
-  return false;
-}
-
-}  // namespace
-
-namespace atom {
-
-// static
-std::vector<WebContentsPreferences*> WebContentsPreferences::instances_;
-
-WebContentsPreferences::WebContentsPreferences(
-    content::WebContents* web_contents,
-    const mate::Dictionary& web_preferences)
-    : web_contents_(web_contents) {
-  v8::Isolate* isolate = web_preferences.isolate();
-  mate::Dictionary copied(isolate, web_preferences.GetHandle()->Clone());
-  // Following fields should not be stored.
-  copied.Delete("embedder");
-  copied.Delete("isGuest");
-  copied.Delete("session");
-
-  mate::ConvertFromV8(isolate, copied.GetHandle(), &preference_);
-  web_contents->SetUserData(UserDataKey(), base::WrapUnique(this));
-
-  instances_.push_back(this);
-
-  // Set WebPreferences defaults onto the JS object
-  SetDefaultBoolIfUndefined(options::kPlugins, false);
-  SetDefaultBoolIfUndefined(options::kExperimentalFeatures, false);
-  bool node = SetDefaultBoolIfUndefined(options::kNodeIntegration, true);
-  SetDefaultBoolIfUndefined(options::kNodeIntegrationInWorker, false);
-  SetDefaultBoolIfUndefined(options::kWebviewTag, node);
-  SetDefaultBoolIfUndefined(options::kSandbox, false);
-  SetDefaultBoolIfUndefined(options::kNativeWindowOpen, false);
-  SetDefaultBoolIfUndefined(options::kContextIsolation, false);
-  SetDefaultBoolIfUndefined("javascript", true);
-  SetDefaultBoolIfUndefined("images", true);
-  SetDefaultBoolIfUndefined("textAreasAreResizable", true);
-  SetDefaultBoolIfUndefined("webgl", true);
-  bool webSecurity = true;
-  SetDefaultBoolIfUndefined(options::kWebSecurity, webSecurity);
-  // If webSecurity was explicity set to false, let's inherit that into
-  // insecureContent
-  if (web_preferences.Get(options::kWebSecurity, &webSecurity) &&
-      !webSecurity) {
-    SetDefaultBoolIfUndefined(options::kAllowRunningInsecureContent, true);
-  } else {
-    SetDefaultBoolIfUndefined(options::kAllowRunningInsecureContent, false);
-  }
-#if defined(OS_MACOSX)
-  SetDefaultBoolIfUndefined(options::kScrollBounce, false);
-#endif
-  SetDefaultBoolIfUndefined(options::kOffscreen, false);
-
-  last_preference_ = preference_.Clone();
-}
-
-WebContentsPreferences::~WebContentsPreferences() {
-  instances_.erase(std::remove(instances_.begin(), instances_.end(), this),
-                   instances_.end());
-}
-
-bool WebContentsPreferences::SetDefaultBoolIfUndefined(
-    const base::StringPiece& key,
-    bool val) {
-  auto* current_value =
-      preference_.FindKeyOfType(key, base::Value::Type::BOOLEAN);
-  if (current_value) {
-    return current_value->GetBool();
-  } else {
-    preference_.SetKey(key, base::Value(val));
-    return val;
-  }
-}
-
-bool WebContentsPreferences::IsEnabled(const base::StringPiece& name,
-                                       bool default_value) const {
-  auto* current_value =
-      preference_.FindKeyOfType(name, base::Value::Type::BOOLEAN);
-  if (current_value)
-    return current_value->GetBool();
-  return default_value;
-}
-
-void WebContentsPreferences::Merge(const base::DictionaryValue& extend) {
-  if (preference_.is_dict())
-    static_cast<base::DictionaryValue*>(&preference_)->MergeDictionary(&extend);
-}
-
-void WebContentsPreferences::Clear() {
-  if (preference_.is_dict())
-    static_cast<base::DictionaryValue*>(&preference_)->Clear();
-}
-
-bool WebContentsPreferences::GetPreference(const base::StringPiece& name,
-                                           std::string* value) const {
-  return GetAsString(&preference_, name, value);
-}
-
-bool WebContentsPreferences::GetPreloadPath(
-    base::FilePath::StringType* path) const {
-  DCHECK(path);
-  base::FilePath::StringType preload;
-  if (GetAsString(&preference_, options::kPreloadScript, &preload)) {
-    if (base::FilePath(preload).IsAbsolute()) {
-      *path = std::move(preload);
-      return true;
-    } else {
-      LOG(ERROR) << "preload script must have absolute path.";
-    }
-  } else if (GetAsString(&preference_, options::kPreloadURL, &preload)) {
-    // Translate to file path if there is "preload-url" option.
-    base::FilePath preload_path;
-    if (net::FileURLToFilePath(GURL(preload), &preload_path)) {
-      *path = std::move(preload_path.value());
-      return true;
-    } else {
-      LOG(ERROR) << "preload url must be file:// protocol.";
-    }
-  }
-  return false;
-}
-
-// static
-content::WebContents* WebContentsPreferences::GetWebContentsFromProcessID(
-    int process_id) {
-  for (WebContentsPreferences* preferences : instances_) {
-    content::WebContents* web_contents = preferences->web_contents_;
-    if (web_contents->GetMainFrame()->GetProcess()->GetID() == process_id)
-      return web_contents;
-  }
-  return nullptr;
-}
-
-// static
-WebContentsPreferences* WebContentsPreferences::From(
-    content::WebContents* web_contents) {
-  if (!web_contents)
-    return nullptr;
-  return FromWebContents(web_contents);
-}
-
-void WebContentsPreferences::AppendCommandLineSwitches(
-    base::CommandLine* command_line) {
-  // Check if plugins are enabled.
-  if (IsEnabled(options::kPlugins))
-    command_line->AppendSwitch(switches::kEnablePlugins);
-
-  // Experimental flags.
-  if (IsEnabled(options::kExperimentalFeatures))
-    command_line->AppendSwitch(
-        ::switches::kEnableExperimentalWebPlatformFeatures);
-
-  // Check if we have node integration specified.
-  bool enable_node_integration = IsEnabled(options::kNodeIntegration, true);
-  command_line->AppendSwitchASCII(switches::kNodeIntegration,
-                                  enable_node_integration ? "true" : "false");
-
-  // Whether to enable node integration in Worker.
-  if (IsEnabled(options::kNodeIntegrationInWorker))
-    command_line->AppendSwitch(switches::kNodeIntegrationInWorker);
-
-  // Check if webview tag creation is enabled, default to nodeIntegration value.
-  // TODO(kevinsawicki): Default to false in 2.0
-  bool webview_tag = IsEnabled(options::kWebviewTag, enable_node_integration);
-  command_line->AppendSwitchASCII(switches::kWebviewTag,
-                                  webview_tag ? "true" : "false");
-
-  // If the `sandbox` option was passed to the BrowserWindow's webPreferences,
-  // pass `--enable-sandbox` to the renderer so it won't have any node.js
-  // integration.
-  if (IsEnabled(options::kSandbox))
-    command_line->AppendSwitch(switches::kEnableSandbox);
-  else if (!command_line->HasSwitch(switches::kEnableSandbox))
-    command_line->AppendSwitch(::switches::kNoSandbox);
-
-  // Check if nativeWindowOpen is enabled.
-  if (IsEnabled(options::kNativeWindowOpen))
-    command_line->AppendSwitch(switches::kNativeWindowOpen);
-
-  // The preload script.
-  base::FilePath::StringType preload;
-  if (GetPreloadPath(&preload))
-    command_line->AppendSwitchNative(switches::kPreloadScript, preload);
-
-  // Custom args for renderer process
-  auto* customArgs =
-      preference_.FindKeyOfType(options::kCustomArgs, base::Value::Type::LIST);
-  if (customArgs) {
-    for (const auto& customArg : customArgs->GetList()) {
-      if (customArg.is_string())
-        command_line->AppendArg(customArg.GetString());
-    }
-  }
-
-  // Run Electron APIs and preload script in isolated world
-  if (IsEnabled(options::kContextIsolation))
-    command_line->AppendSwitch(switches::kContextIsolation);
-
-  // --background-color.
-  std::string s;
-  if (GetAsString(&preference_, options::kBackgroundColor, &s))
-    command_line->AppendSwitchASCII(switches::kBackgroundColor, s);
-
-  // --guest-instance-id, which is used to identify guest WebContents.
-  int guest_instance_id = 0;
-  if (GetAsInteger(&preference_, options::kGuestInstanceID, &guest_instance_id))
-    command_line->AppendSwitchASCII(switches::kGuestInstanceID,
-                                    base::IntToString(guest_instance_id));
-
-  // Pass the opener's window id.
-  int opener_id;
-  if (GetAsInteger(&preference_, options::kOpenerID, &opener_id))
-    command_line->AppendSwitchASCII(switches::kOpenerID,
-                                    base::IntToString(opener_id));
-
-#if defined(OS_MACOSX)
-  // Enable scroll bounce.
-  if (IsEnabled(options::kScrollBounce))
-    command_line->AppendSwitch(switches::kScrollBounce);
-#endif
-
-  // Custom command line switches.
-  auto* args =
-      preference_.FindKeyOfType("commandLineSwitches", base::Value::Type::LIST);
-  if (args) {
-    for (const auto& arg : args->GetList()) {
-      if (arg.is_string()) {
-        const auto& arg_val = arg.GetString();
-        if (!arg_val.empty())
-          command_line->AppendSwitch(arg_val);
-      }
-    }
-  }
-
-  // Enable blink features.
-  if (GetAsString(&preference_, options::kEnableBlinkFeatures, &s))
-    command_line->AppendSwitchASCII(::switches::kEnableBlinkFeatures, s);
-
-  // Disable blink features.
-  if (GetAsString(&preference_, options::kDisableBlinkFeatures, &s))
-    command_line->AppendSwitchASCII(::switches::kDisableBlinkFeatures, s);
-
-  if (guest_instance_id) {
-    // Webview `document.visibilityState` tracks window visibility so we need
-    // to let it know if the window happens to be hidden right now.
-    auto* manager = WebViewManager::GetWebViewManager(web_contents_);
-    if (manager) {
-      auto* embedder = manager->GetEmbedder(guest_instance_id);
-      if (embedder) {
-        auto* relay = NativeWindowRelay::FromWebContents(embedder);
-        if (relay) {
-          auto* window = relay->window.get();
-          if (window) {
-            const bool visible = window->IsVisible() && !window->IsMinimized();
-            if (!visible) {
-              command_line->AppendSwitch(switches::kHiddenPage);
-            }
-          }
-        }
-      }
-    }
-  }
-
-  // We are appending args to a webContents so let's save the current state
-  // of our preferences object so that during the lifetime of the WebContents
-  // we can fetch the options used to initally configure the WebContents
-  last_preference_ = preference_.Clone();
-}
-
-void WebContentsPreferences::OverrideWebkitPrefs(
-    content::WebPreferences* prefs) {
-  prefs->javascript_enabled = IsEnabled("javascript", true /* default_value */);
-  prefs->images_enabled = IsEnabled("images", true /* default_value */);
-  prefs->text_areas_are_resizable =
-      IsEnabled("textAreasAreResizable", true /* default_value */);
-  prefs->navigate_on_drag_drop =
-      IsEnabled("navigateOnDragDrop", false /* default_value */);
-
-  // Check if webgl should be enabled.
-  bool is_webgl_enabled = IsEnabled("webgl", true /* default_value */);
-  prefs->webgl1_enabled = is_webgl_enabled;
-  prefs->webgl2_enabled = is_webgl_enabled;
-
-  // Check if web security should be enabled.
-  bool is_web_security_enabled =
-      IsEnabled(options::kWebSecurity, true /* default_value */);
-  prefs->web_security_enabled = is_web_security_enabled;
-  prefs->allow_running_insecure_content =
-      IsEnabled(options::kAllowRunningInsecureContent,
-                !is_web_security_enabled /* default_value */);
-
-  auto* fonts_dict = preference_.FindKeyOfType("defaultFontFamily",
-                                               base::Value::Type::DICTIONARY);
-  if (fonts_dict) {
-    base::string16 font;
-    if (GetAsString(fonts_dict, "standard", &font))
-      prefs->standard_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "serif", &font))
-      prefs->serif_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "sansSerif", &font))
-      prefs->sans_serif_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "monospace", &font))
-      prefs->fixed_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "cursive", &font))
-      prefs->cursive_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "fantasy", &font))
-      prefs->fantasy_font_family_map[content::kCommonScript] = font;
-  }
-
-  int size;
-  if (GetAsInteger(&preference_, "defaultFontSize", &size))
-    prefs->default_font_size = size;
-  if (GetAsInteger(&preference_, "defaultMonospaceFontSize", &size))
-    prefs->default_fixed_font_size = size;
-  if (GetAsInteger(&preference_, "minimumFontSize", &size))
-    prefs->minimum_font_size = size;
-  std::string encoding;
-  if (GetAsString(&preference_, "defaultEncoding", &encoding))
-    prefs->default_encoding = encoding;
-}
-
-}  // namespace atom
removed in remote
  base   100644 dd98a9658acfce4154da3bd64e6faa4698a9cd33 atom/browser/web_contents_preferences.h
  our    100644 d835347afcd259f473f95271a2c19e42afcc6f2b atom/browser/web_contents_preferences.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
-#define ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
-
-#include <string>
-#include <vector>
-
-#include "base/values.h"
-#include "content/public/browser/web_contents_user_data.h"
-
-namespace base {
-class CommandLine;
-}
-
-namespace content {
-struct WebPreferences;
-}
-
-namespace mate {
-class Dictionary;
-}
-
-namespace atom {
-
-// Stores and applies the preferences of WebContents.
-class WebContentsPreferences
-    : public content::WebContentsUserData<WebContentsPreferences> {
- public:
-  // Get self from WebContents.
-  static WebContentsPreferences* From(content::WebContents* web_contents);
-
-  WebContentsPreferences(content::WebContents* web_contents,
-                         const mate::Dictionary& web_preferences);
-  ~WebContentsPreferences() override;
-
-  // A simple way to know whether a Boolean property is enabled.
-  bool IsEnabled(const base::StringPiece& name,
-                 bool default_value = false) const;
-
-  // $.extend(|web_preferences|, |new_web_preferences|).
-  void Merge(const base::DictionaryValue& new_web_preferences);
-
-  // Append command paramters according to preferences.
-  void AppendCommandLineSwitches(base::CommandLine* command_line);
-
-  // Modify the WebPreferences according to preferences.
-  void OverrideWebkitPrefs(content::WebPreferences* prefs);
-
-  // Clear the current WebPreferences.
-  void Clear();
-
-  // Return true if the particular preference value exists.
-  bool GetPreference(const base::StringPiece& name, std::string* value) const;
-
-  // Returns the preload script path.
-  bool GetPreloadPath(base::FilePath::StringType* path) const;
-
-  // Returns the web preferences.
-  base::Value* preference() { return &preference_; }
-  base::Value* last_preference() { return &last_preference_; }
-
- private:
-  friend class content::WebContentsUserData<WebContentsPreferences>;
-  friend class AtomBrowserClient;
-
-  // Get WebContents according to process ID.
-  static content::WebContents* GetWebContentsFromProcessID(int process_id);
-
-  // Set preference value to given bool if user did not provide value
-  bool SetDefaultBoolIfUndefined(const base::StringPiece& key, bool val);
-
-  static std::vector<WebContentsPreferences*> instances_;
-
-  content::WebContents* web_contents_;
-
-  base::Value preference_ = base::Value(base::Value::Type::DICTIONARY);
-  base::Value last_preference_ = base::Value(base::Value::Type::DICTIONARY);
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsPreferences);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
removed in remote
  base   100644 c3d2a1d0f23fb5bdb77a377f8ad1e5697e76ed42 atom/browser/web_dialog_helper.cc
  our    100644 74c8573d13f15bcaa189abdc40fa0cd8e48f89be atom/browser/web_dialog_helper.cc
@@ -1,261 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_dialog_helper.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "base/bind.h"
-#include "base/files/file_enumerator.h"
-#include "base/files/file_path.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/file_chooser_file_info.h"
-#include "content/public/common/file_chooser_params.h"
-#include "net/base/mime_util.h"
-#include "ui/shell_dialogs/selected_file_info.h"
-
-namespace {
-
-class FileSelectHelper : public base::RefCounted<FileSelectHelper>,
-                         public content::WebContentsObserver {
- public:
-  FileSelectHelper(content::RenderFrameHost* render_frame_host,
-                   const content::FileChooserParams::Mode& mode)
-      : render_frame_host_(render_frame_host), mode_(mode) {
-    auto* web_contents =
-        content::WebContents::FromRenderFrameHost(render_frame_host);
-    content::WebContentsObserver::Observe(web_contents);
-  }
-
-  void ShowOpenDialog(const file_dialog::DialogSettings& settings) {
-    auto callback = base::Bind(&FileSelectHelper::OnOpenDialogDone, this);
-    file_dialog::ShowOpenDialog(settings, callback);
-  }
-
-  void ShowSaveDialog(const file_dialog::DialogSettings& settings) {
-    auto callback = base::Bind(&FileSelectHelper::OnSaveDialogDone, this);
-    file_dialog::ShowSaveDialog(settings, callback);
-  }
-
- private:
-  friend class base::RefCounted<FileSelectHelper>;
-
-  ~FileSelectHelper() override {}
-
-#if defined(MAS_BUILD)
-  void OnOpenDialogDone(bool result,
-                        const std::vector<base::FilePath>& paths,
-                        const std::vector<std::string>& bookmarks)
-#else
-  void OnOpenDialogDone(bool result, const std::vector<base::FilePath>& paths)
-#endif
-  {
-    std::vector<content::FileChooserFileInfo> file_info;
-    if (result) {
-      for (auto& path : paths) {
-        content::FileChooserFileInfo info;
-        info.file_path = path;
-        info.display_name = path.BaseName().value();
-        file_info.push_back(info);
-      }
-
-      if (render_frame_host_ && !paths.empty()) {
-        auto* browser_context = static_cast<atom::AtomBrowserContext*>(
-            render_frame_host_->GetProcess()->GetBrowserContext());
-        browser_context->prefs()->SetFilePath(prefs::kSelectFileLastDirectory,
-                                              paths[0].DirName());
-      }
-    }
-    OnFilesSelected(file_info);
-  }
-
-#if defined(MAS_BUILD)
-  void OnSaveDialogDone(bool result,
-                        const base::FilePath& path,
-                        const std::string& bookmark)
-#else
-  void OnSaveDialogDone(bool result, const base::FilePath& path)
-#endif
-  {
-    std::vector<content::FileChooserFileInfo> file_info;
-    if (result) {
-      content::FileChooserFileInfo info;
-      info.file_path = path;
-      info.display_name = path.BaseName().value();
-      file_info.push_back(info);
-    }
-    OnFilesSelected(file_info);
-  }
-
-  void OnFilesSelected(
-      const std::vector<content::FileChooserFileInfo>& file_info) {
-    if (render_frame_host_)
-      render_frame_host_->FilesSelectedInChooser(file_info, mode_);
-  }
-
-  // content::WebContentsObserver:
-  void RenderFrameHostChanged(content::RenderFrameHost* old_host,
-                              content::RenderFrameHost* new_host) override {
-    if (old_host == render_frame_host_)
-      render_frame_host_ = nullptr;
-  }
-
-  // content::WebContentsObserver:
-  void RenderFrameDeleted(content::RenderFrameHost* deleted_host) override {
-    if (deleted_host == render_frame_host_)
-      render_frame_host_ = nullptr;
-  }
-
-  // content::WebContentsObserver:
-  void WebContentsDestroyed() override { render_frame_host_ = nullptr; }
-
-  content::RenderFrameHost* render_frame_host_;
-  content::FileChooserParams::Mode mode_;
-};
-
-file_dialog::Filters GetFileTypesFromAcceptType(
-    const std::vector<base::string16>& accept_types) {
-  file_dialog::Filters filters;
-  if (accept_types.empty())
-    return filters;
-
-  std::vector<base::FilePath::StringType> extensions;
-
-  int valid_type_count = 0;
-  std::string description;
-
-  for (const auto& accept_type : accept_types) {
-    std::string ascii_type = base::UTF16ToASCII(accept_type);
-    auto old_extension_size = extensions.size();
-
-    if (ascii_type[0] == '.') {
-      // If the type starts with a period it is assumed to be a file extension,
-      // like `.txt`, // so we just have to add it to the list.
-      base::FilePath::StringType extension(ascii_type.begin(),
-                                           ascii_type.end());
-      // Skip the first character.
-      extensions.push_back(extension.substr(1));
-    } else {
-      if (ascii_type == "image/*")
-        description = "Image Files";
-      else if (ascii_type == "audio/*")
-        description = "Audio Files";
-      else if (ascii_type == "video/*")
-        description = "Video Files";
-
-      // For MIME Type, `audio/*, video/*, image/*
-      net::GetExtensionsForMimeType(ascii_type, &extensions);
-    }
-
-    if (extensions.size() > old_extension_size)
-      valid_type_count++;
-  }
-
-  // If no valid exntesion is added, return empty filters.
-  if (extensions.empty())
-    return filters;
-
-  filters.push_back(file_dialog::Filter());
-
-  if (valid_type_count > 1 || (valid_type_count == 1 && description.empty()))
-    description = "Custom Files";
-
-  DCHECK(!description.empty());
-  filters[0].first = description;
-
-  for (const auto& extension : extensions) {
-#if defined(OS_WIN)
-    filters[0].second.push_back(base::UTF16ToASCII(extension));
-#else
-    filters[0].second.push_back(extension);
-#endif
-  }
-
-  // Allow all files when extension is specified.
-  filters.push_back(file_dialog::Filter());
-  filters.back().first = "All Files";
-  filters.back().second.push_back("*");
-
-  return filters;
-}
-
-}  // namespace
-
-namespace atom {
-
-WebDialogHelper::WebDialogHelper(NativeWindow* window, bool offscreen)
-    : window_(window), offscreen_(offscreen), weak_factory_(this) {}
-
-WebDialogHelper::~WebDialogHelper() {}
-
-void WebDialogHelper::RunFileChooser(
-    content::RenderFrameHost* render_frame_host,
-    const content::FileChooserParams& params) {
-  std::vector<content::FileChooserFileInfo> result;
-
-  file_dialog::DialogSettings settings;
-  settings.force_detached = offscreen_;
-  settings.filters = GetFileTypesFromAcceptType(params.accept_types);
-  settings.parent_window = window_;
-  settings.title = base::UTF16ToUTF8(params.title);
-
-  scoped_refptr<FileSelectHelper> file_select_helper(
-      new FileSelectHelper(render_frame_host, params.mode));
-  if (params.mode == content::FileChooserParams::Save) {
-    settings.default_path = params.default_file_name;
-    file_select_helper->ShowSaveDialog(settings);
-  } else {
-    int flags = file_dialog::FILE_DIALOG_CREATE_DIRECTORY;
-    switch (params.mode) {
-      case content::FileChooserParams::OpenMultiple:
-        flags |= file_dialog::FILE_DIALOG_MULTI_SELECTIONS;
-        FALLTHROUGH;
-      case content::FileChooserParams::Open:
-        flags |= file_dialog::FILE_DIALOG_OPEN_FILE;
-        flags |= file_dialog::FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY;
-        break;
-      case content::FileChooserParams::UploadFolder:
-        flags |= file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
-        break;
-      default:
-        NOTREACHED();
-    }
-
-    auto* browser_context = static_cast<atom::AtomBrowserContext*>(
-        render_frame_host->GetProcess()->GetBrowserContext());
-    settings.default_path = browser_context->prefs()
-                                ->GetFilePath(prefs::kSelectFileLastDirectory)
-                                .Append(params.default_file_name);
-    settings.properties = flags;
-    file_select_helper->ShowOpenDialog(settings);
-  }
-}
-
-void WebDialogHelper::EnumerateDirectory(content::WebContents* web_contents,
-                                         int request_id,
-                                         const base::FilePath& dir) {
-  int types = base::FileEnumerator::FILES | base::FileEnumerator::DIRECTORIES |
-              base::FileEnumerator::INCLUDE_DOT_DOT;
-  base::FileEnumerator file_enum(dir, false, types);
-
-  base::FilePath path;
-  std::vector<base::FilePath> paths;
-  while (!(path = file_enum.Next()).empty())
-    paths.push_back(path);
-
-  web_contents->GetRenderViewHost()->DirectoryEnumerationFinished(request_id,
-                                                                  paths);
-}
-
-}  // namespace atom
removed in remote
  base   100644 a3472da4acbb936659f05670214fad62a98f5aa5 atom/browser/web_dialog_helper.h
  our    100644 e08a1a915bc29c049e9258a4f213e3dc4428208e atom/browser/web_dialog_helper.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_DIALOG_HELPER_H_
-#define ATOM_BROWSER_WEB_DIALOG_HELPER_H_
-
-#include "base/memory/weak_ptr.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace content {
-struct FileChooserParams;
-class RenderFrameHost;
-class WebContents;
-}  // namespace content
-
-namespace atom {
-
-class NativeWindow;
-
-class WebDialogHelper {
- public:
-  WebDialogHelper(NativeWindow* window, bool offscreen);
-  ~WebDialogHelper();
-
-  void RunFileChooser(content::RenderFrameHost* render_frame_host,
-                      const content::FileChooserParams& params);
-  void EnumerateDirectory(content::WebContents* web_contents,
-                          int request_id,
-                          const base::FilePath& path);
-
- private:
-  NativeWindow* window_;
-  bool offscreen_;
-
-  base::WeakPtrFactory<WebDialogHelper> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebDialogHelper);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_DIALOG_HELPER_H_
removed in remote
  base   100644 6abb9713bfac2ee22a0c0cd5a8f601887a3d5503 atom/browser/web_view_guest_delegate.cc
  our    100644 27fbff7e9e3633bd17c54b4c67ba4a1d5993e449 atom/browser/web_view_guest_delegate.cc
@@ -1,116 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_view_guest_delegate.h"
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "content/browser/web_contents/web_contents_impl.h"
-#include "content/public/browser/navigation_handle.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/render_widget_host_view.h"
-
-namespace atom {
-
-WebViewGuestDelegate::WebViewGuestDelegate(content::WebContents* embedder,
-                                           api::WebContents* api_web_contents)
-    : embedder_web_contents_(embedder), api_web_contents_(api_web_contents) {}
-
-WebViewGuestDelegate::~WebViewGuestDelegate() {
-  ResetZoomController();
-}
-
-void WebViewGuestDelegate::AttachToIframe(
-    content::WebContents* embedder_web_contents,
-    int embedder_frame_id) {
-  embedder_web_contents_ = embedder_web_contents;
-
-  int embedder_process_id =
-      embedder_web_contents_->GetMainFrame()->GetProcess()->GetID();
-  auto* embedder_frame =
-      content::RenderFrameHost::FromID(embedder_process_id, embedder_frame_id);
-  DCHECK_EQ(embedder_web_contents_,
-            content::WebContents::FromRenderFrameHost(embedder_frame));
-
-  // Attach this inner WebContents |guest_web_contents| to the outer
-  // WebContents |embedder_web_contents|. The outer WebContents's
-  // frame |embedder_frame| hosts the inner WebContents.
-  api_web_contents_->web_contents()->AttachToOuterWebContentsFrame(
-      embedder_web_contents_, embedder_frame);
-
-  ResetZoomController();
-
-  embedder_zoom_controller_ =
-      WebContentsZoomController::FromWebContents(embedder_web_contents_);
-  embedder_zoom_controller_->AddObserver(this);
-  auto* zoom_controller = api_web_contents_->GetZoomController();
-  zoom_controller->SetEmbedderZoomController(embedder_zoom_controller_);
-
-  api_web_contents_->Emit("did-attach");
-}
-
-void WebViewGuestDelegate::DidDetach() {
-  ResetZoomController();
-}
-
-content::WebContents* WebViewGuestDelegate::GetOwnerWebContents() const {
-  return embedder_web_contents_;
-}
-
-void WebViewGuestDelegate::OnZoomLevelChanged(
-    content::WebContents* web_contents,
-    double level,
-    bool is_temporary) {
-  if (web_contents == GetOwnerWebContents()) {
-    if (is_temporary) {
-      api_web_contents_->GetZoomController()->SetTemporaryZoomLevel(level);
-    } else {
-      api_web_contents_->GetZoomController()->SetZoomLevel(level);
-    }
-    // Change the default zoom factor to match the embedders' new zoom level.
-    double zoom_factor = content::ZoomLevelToZoomFactor(level);
-    api_web_contents_->GetZoomController()->SetDefaultZoomFactor(zoom_factor);
-  }
-}
-
-void WebViewGuestDelegate::OnZoomControllerWebContentsDestroyed() {
-  ResetZoomController();
-}
-
-void WebViewGuestDelegate::ResetZoomController() {
-  if (embedder_zoom_controller_) {
-    embedder_zoom_controller_->RemoveObserver(this);
-    embedder_zoom_controller_ = nullptr;
-  }
-}
-
-content::RenderWidgetHost* WebViewGuestDelegate::GetOwnerRenderWidgetHost() {
-  return embedder_web_contents_->GetRenderViewHost()->GetWidget();
-}
-
-content::SiteInstance* WebViewGuestDelegate::GetOwnerSiteInstance() {
-  return embedder_web_contents_->GetSiteInstance();
-}
-
-content::WebContents* WebViewGuestDelegate::CreateNewGuestWindow(
-    const content::WebContents::CreateParams& create_params) {
-  // Code below mirrors what content::WebContentsImpl::CreateNewWindow
-  // does for non-guest sources
-  content::WebContents::CreateParams guest_params(create_params);
-  guest_params.initial_size =
-      embedder_web_contents_->GetContainerBounds().size();
-  guest_params.context = embedder_web_contents_->GetNativeView();
-  auto* guest_contents = content::WebContents::Create(guest_params);
-  auto* guest_contents_impl =
-      static_cast<content::WebContentsImpl*>(guest_contents);
-  guest_contents_impl->GetView()->CreateViewForWidget(
-      guest_contents->GetRenderViewHost()->GetWidget(), false);
-
-  return guest_contents;
-}
-
-}  // namespace atom
removed in remote
  base   100644 95888ff749fda896a7355d7af743918a670a1bc6 atom/browser/web_view_guest_delegate.h
  our    100644 6d9f440588d1d38a869ca6b6a33fd31031091efa atom/browser/web_view_guest_delegate.h
@@ -1,60 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
-#define ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
-
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "content/public/browser/browser_plugin_guest_delegate.h"
-
-namespace atom {
-
-namespace api {
-class WebContents;
-}
-
-class WebViewGuestDelegate : public content::BrowserPluginGuestDelegate,
-                             public WebContentsZoomController::Observer {
- public:
-  WebViewGuestDelegate(content::WebContents* embedder,
-                       api::WebContents* api_web_contents);
-  ~WebViewGuestDelegate() override;
-
-  // Attach to the iframe.
-  void AttachToIframe(content::WebContents* embedder_web_contents,
-                      int embedder_frame_id);
-
- protected:
-  // content::BrowserPluginGuestDelegate:
-  void DidDetach() final;
-  content::WebContents* GetOwnerWebContents() const final;
-  content::RenderWidgetHost* GetOwnerRenderWidgetHost() final;
-  content::SiteInstance* GetOwnerSiteInstance() final;
-  content::WebContents* CreateNewGuestWindow(
-      const content::WebContents::CreateParams& create_params) final;
-
-  // WebContentsZoomController::Observer:
-  void OnZoomLevelChanged(content::WebContents* web_contents,
-                          double level,
-                          bool is_temporary) override;
-  void OnZoomControllerWebContentsDestroyed() override;
-
- private:
-  void ResetZoomController();
-
-  // The WebContents that attaches this guest view.
-  content::WebContents* embedder_web_contents_ = nullptr;
-
-  // The zoom controller of the embedder that is used
-  // to subscribe for zoom changes.
-  WebContentsZoomController* embedder_zoom_controller_ = nullptr;
-
-  api::WebContents* api_web_contents_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(WebViewGuestDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
removed in remote
  base   100644 d404c1a4368011301c2f133fac5e4934ada03c04 atom/browser/web_view_manager.cc
  our    100644 9448f58d51388c31f4b1ed97e36ea20f1d7dc26c atom/browser/web_view_manager.cc
@@ -1,86 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_view_manager.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-WebViewManager::WebViewManager() {}
-
-WebViewManager::~WebViewManager() {}
-
-void WebViewManager::AddGuest(int guest_instance_id,
-                              int element_instance_id,
-                              content::WebContents* embedder,
-                              content::WebContents* web_contents) {
-  web_contents_embedder_map_[guest_instance_id] = {web_contents, embedder};
-
-  // Map the element in embedder to guest.
-  int owner_process_id = embedder->GetMainFrame()->GetProcess()->GetID();
-  ElementInstanceKey key(owner_process_id, element_instance_id);
-  element_instance_id_to_guest_map_[key] = guest_instance_id;
-}
-
-void WebViewManager::RemoveGuest(int guest_instance_id) {
-  if (!base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return;
-
-  web_contents_embedder_map_.erase(guest_instance_id);
-
-  // Remove the record of element in embedder too.
-  for (const auto& element : element_instance_id_to_guest_map_)
-    if (element.second == guest_instance_id) {
-      element_instance_id_to_guest_map_.erase(element.first);
-      break;
-    }
-}
-
-content::WebContents* WebViewManager::GetEmbedder(int guest_instance_id) {
-  if (base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return web_contents_embedder_map_[guest_instance_id].embedder;
-  else
-    return nullptr;
-}
-
-content::WebContents* WebViewManager::GetGuestByInstanceID(
-    int owner_process_id,
-    int element_instance_id) {
-  ElementInstanceKey key(owner_process_id, element_instance_id);
-  if (!base::ContainsKey(element_instance_id_to_guest_map_, key))
-    return nullptr;
-
-  int guest_instance_id = element_instance_id_to_guest_map_[key];
-  if (base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return web_contents_embedder_map_[guest_instance_id].web_contents;
-  else
-    return nullptr;
-}
-
-bool WebViewManager::ForEachGuest(content::WebContents* embedder_web_contents,
-                                  const GuestCallback& callback) {
-  for (auto& item : web_contents_embedder_map_)
-    if (item.second.embedder == embedder_web_contents &&
-        callback.Run(item.second.web_contents))
-      return true;
-  return false;
-}
-
-// static
-WebViewManager* WebViewManager::GetWebViewManager(
-    content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  if (context) {
-    auto* manager = context->GetGuestManager();
-    return static_cast<WebViewManager*>(manager);
-  } else {
-    return nullptr;
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 ff9a8ecba2abca5e8b3c5513694ec01c95190e93 atom/browser/web_view_manager.h
  our    100644 1adc27678da96b72889c246674afedda30dc37f0 atom/browser/web_view_manager.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_VIEW_MANAGER_H_
-#define ATOM_BROWSER_WEB_VIEW_MANAGER_H_
-
-#include <map>
-
-#include "content/public/browser/browser_plugin_guest_manager.h"
-
-namespace atom {
-
-class WebViewManager : public content::BrowserPluginGuestManager {
- public:
-  WebViewManager();
-  ~WebViewManager() override;
-
-  void AddGuest(int guest_instance_id,
-                int element_instance_id,
-                content::WebContents* embedder,
-                content::WebContents* web_contents);
-  void RemoveGuest(int guest_instance_id);
-  content::WebContents* GetEmbedder(int guest_instance_id);
-
-  static WebViewManager* GetWebViewManager(content::WebContents* web_contents);
-
- protected:
-  // content::BrowserPluginGuestManager:
-  content::WebContents* GetGuestByInstanceID(int owner_process_id,
-                                             int element_instance_id) override;
-  bool ForEachGuest(content::WebContents* embedder,
-                    const GuestCallback& callback) override;
-
- private:
-  struct WebContentsWithEmbedder {
-    content::WebContents* web_contents;
-    content::WebContents* embedder;
-  };
-  // guest_instance_id => (web_contents, embedder)
-  std::map<int, WebContentsWithEmbedder> web_contents_embedder_map_;
-
-  struct ElementInstanceKey {
-    int embedder_process_id;
-    int element_instance_id;
-
-    ElementInstanceKey(int embedder_process_id, int element_instance_id)
-        : embedder_process_id(embedder_process_id),
-          element_instance_id(element_instance_id) {}
-
-    bool operator<(const ElementInstanceKey& other) const {
-      if (embedder_process_id != other.embedder_process_id)
-        return embedder_process_id < other.embedder_process_id;
-      return element_instance_id < other.element_instance_id;
-    }
-
-    bool operator==(const ElementInstanceKey& other) const {
-      return (embedder_process_id == other.embedder_process_id) &&
-             (element_instance_id == other.element_instance_id);
-    }
-  };
-  // (embedder_process_id, element_instance_id) => guest_instance_id
-  std::map<ElementInstanceKey, int> element_instance_id_to_guest_map_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebViewManager);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_VIEW_MANAGER_H_
removed in remote
  base   100644 b3bec5d08c1c017105cde2b9e034a3e7c49d15c5 atom/browser/window_list.cc
  our    100644 97561d16f38d29429550a611d58fc08ae06edd38 atom/browser/window_list.cc
@@ -1,103 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/window_list.h"
-
-#include <algorithm>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list_observer.h"
-#include "base/logging.h"
-
-namespace atom {
-
-// static
-base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
-    WindowList::observers_ = LAZY_INSTANCE_INITIALIZER;
-
-// static
-WindowList* WindowList::instance_ = nullptr;
-
-// static
-WindowList* WindowList::GetInstance() {
-  if (!instance_)
-    instance_ = new WindowList;
-  return instance_;
-}
-
-// static
-WindowList::WindowVector WindowList::GetWindows() {
-  return GetInstance()->windows_;
-}
-
-// static
-bool WindowList::IsEmpty() {
-  return GetInstance()->windows_.empty();
-}
-
-// static
-void WindowList::AddWindow(NativeWindow* window) {
-  DCHECK(window);
-  // Push |window| on the appropriate list instance.
-  WindowVector& windows = GetInstance()->windows_;
-  windows.push_back(window);
-
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowAdded(window);
-}
-
-// static
-void WindowList::RemoveWindow(NativeWindow* window) {
-  WindowVector& windows = GetInstance()->windows_;
-  windows.erase(std::remove(windows.begin(), windows.end(), window),
-                windows.end());
-
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowRemoved(window);
-
-  if (windows.empty()) {
-    for (WindowListObserver& observer : observers_.Get())
-      observer.OnWindowAllClosed();
-  }
-}
-
-// static
-void WindowList::WindowCloseCancelled(NativeWindow* window) {
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowCloseCancelled(window);
-}
-
-// static
-void WindowList::AddObserver(WindowListObserver* observer) {
-  observers_.Get().AddObserver(observer);
-}
-
-// static
-void WindowList::RemoveObserver(WindowListObserver* observer) {
-  observers_.Get().RemoveObserver(observer);
-}
-
-// static
-void WindowList::CloseAllWindows() {
-  WindowVector windows = GetInstance()->windows_;
-#if defined(OS_MACOSX)
-  std::reverse(windows.begin(), windows.end());
-#endif
-  for (auto* const& window : windows)
-    if (!window->IsClosed())
-      window->Close();
-}
-
-// static
-void WindowList::DestroyAllWindows() {
-  WindowVector windows = GetInstance()->windows_;
-  for (auto* const& window : windows)
-    window->CloseImmediately();  // e.g. Destroy()
-}
-
-WindowList::WindowList() {}
-
-WindowList::~WindowList() {}
-
-}  // namespace atom
removed in remote
  base   100644 3dd87b2c34c296ef2e25c6ad21be318987fc3680 atom/browser/window_list.h
  our    100644 e336c8073dc86e2a3124457afe009b703b667658 atom/browser/window_list.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WINDOW_LIST_H_
-#define ATOM_BROWSER_WINDOW_LIST_H_
-
-#include <vector>
-
-#include "base/lazy_instance.h"
-#include "base/macros.h"
-#include "base/observer_list.h"
-
-namespace atom {
-
-class NativeWindow;
-class WindowListObserver;
-
-class WindowList {
- public:
-  typedef std::vector<NativeWindow*> WindowVector;
-
-  static WindowVector GetWindows();
-  static bool IsEmpty();
-
-  // Adds or removes |window| from the list it is associated with.
-  static void AddWindow(NativeWindow* window);
-  static void RemoveWindow(NativeWindow* window);
-
-  // Called by window when a close is cancelled by beforeunload handler.
-  static void WindowCloseCancelled(NativeWindow* window);
-
-  // Adds and removes |observer| from the observer list.
-  static void AddObserver(WindowListObserver* observer);
-  static void RemoveObserver(WindowListObserver* observer);
-
-  // Closes all windows.
-  static void CloseAllWindows();
-
-  // Destroy all windows.
-  static void DestroyAllWindows();
-
- private:
-  static WindowList* GetInstance();
-
-  WindowList();
-  ~WindowList();
-
-  // A vector of the windows in this list, in the order they were added.
-  WindowVector windows_;
-
-  // A list of observers which will be notified of every window addition and
-  // removal across all WindowLists.
-  static base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
-      observers_;
-
-  static WindowList* instance_;
-
-  DISALLOW_COPY_AND_ASSIGN(WindowList);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WINDOW_LIST_H_
removed in remote
  base   100644 424efa25a2b01aba5f640f672b7015d547c861ba atom/browser/window_list_observer.h
  our    100644 424efa25a2b01aba5f640f672b7015d547c861ba atom/browser/window_list_observer.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
-#define ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
-
-namespace atom {
-
-class NativeWindow;
-
-class WindowListObserver {
- public:
-  // Called immediately after a window is added to the list.
-  virtual void OnWindowAdded(NativeWindow* window) {}
-
-  // Called immediately after a window is removed from the list.
-  virtual void OnWindowRemoved(NativeWindow* window) {}
-
-  // Called when a window close is cancelled by beforeunload handler.
-  virtual void OnWindowCloseCancelled(NativeWindow* window) {}
-
-  // Called immediately after all windows are closed.
-  virtual void OnWindowAllClosed() {}
-
- protected:
-  virtual ~WindowListObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
removed in remote
  base   100644 eeb26614847b0bbe33b006909103f6e23ceb1bac atom/common/api/api_messages.h
  our    100644 6131a7a473c68e31790fcd8697c8f380c65ad275 atom/common/api/api_messages.h
@@ -1,71 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Multiply-included file, no traditional include guard.
-
-#include "atom/common/draggable_region.h"
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "content/public/common/common_param_traits.h"
-#include "content/public/common/referrer.h"
-#include "ipc/ipc_message_macros.h"
-#include "ui/gfx/geometry/rect_f.h"
-#include "ui/gfx/ipc/gfx_param_traits.h"
-#include "url/gurl.h"
-
-// The message starter should be declared in ipc/ipc_message_start.h. Since
-// we don't want to patch Chromium, we just pretend to be Content Shell.
-
-#define IPC_MESSAGE_START ShellMsgStart
-
-IPC_STRUCT_TRAITS_BEGIN(atom::DraggableRegion)
-  IPC_STRUCT_TRAITS_MEMBER(draggable)
-  IPC_STRUCT_TRAITS_MEMBER(bounds)
-IPC_STRUCT_TRAITS_END()
-
-IPC_MESSAGE_ROUTED2(AtomFrameHostMsg_Message,
-                    base::string16 /* channel */,
-                    base::ListValue /* arguments */)
-
-IPC_SYNC_MESSAGE_ROUTED2_1(AtomFrameHostMsg_Message_Sync,
-                           base::string16 /* channel */,
-                           base::ListValue /* arguments */,
-                           base::ListValue /* result */)
-
-IPC_MESSAGE_ROUTED3(AtomFrameMsg_Message,
-                    bool /* send_to_all */,
-                    base::string16 /* channel */,
-                    base::ListValue /* arguments */)
-
-IPC_MESSAGE_ROUTED0(AtomViewMsg_Offscreen)
-
-IPC_MESSAGE_ROUTED3(AtomAutofillFrameHostMsg_ShowPopup,
-                    gfx::RectF /* bounds */,
-                    std::vector<base::string16> /* values */,
-                    std::vector<base::string16> /* labels */)
-
-IPC_MESSAGE_ROUTED0(AtomAutofillFrameHostMsg_HidePopup)
-
-IPC_MESSAGE_ROUTED1(AtomAutofillFrameMsg_AcceptSuggestion,
-                    base::string16 /* suggestion */)
-
-// Sent by the renderer when the draggable regions are updated.
-IPC_MESSAGE_ROUTED1(AtomFrameHostMsg_UpdateDraggableRegions,
-                    std::vector<atom::DraggableRegion> /* regions */)
-
-// Update renderer process preferences.
-IPC_MESSAGE_CONTROL1(AtomMsg_UpdatePreferences, base::ListValue)
-
-// Sent by renderer to set the temporary zoom level.
-IPC_SYNC_MESSAGE_ROUTED1_1(AtomFrameHostMsg_SetTemporaryZoomLevel,
-                           double /* zoom level */,
-                           double /* result */)
-
-// Sent by renderer to get the zoom level.
-IPC_SYNC_MESSAGE_ROUTED0_1(AtomFrameHostMsg_GetZoomLevel, double /* result */)
-
-// Brings up SaveAs... dialog to save specified URL.
-IPC_MESSAGE_ROUTED2(AtomFrameHostMsg_PDFSaveURLAs,
-                    GURL /* url */,
-                    content::Referrer /* referrer */)
removed in remote
  base   100644 4bfb0ed4c1beed178c3a9cc5270a480deb511f52 atom/common/api/atom_api_asar.cc
  our    100644 240b5504c248b8199a4abb5b213a14ab5c072971 atom/common/api/atom_api_asar.cc
@@ -1,155 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <stddef.h>
-
-#include <vector>
-
-#include "atom/common/asar/archive.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "native_mate/wrappable.h"
-
-#include "atom/common/node_includes.h"
-#include "atom_natives.h"  // NOLINT: This file is generated with js2c.
-
-namespace {
-
-class Archive : public mate::Wrappable<Archive> {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate,
-                                     const base::FilePath& path) {
-    auto archive = std::make_unique<asar::Archive>(path);
-    if (!archive->Init())
-      return v8::False(isolate);
-    return (new Archive(isolate, std::move(archive)))->GetWrapper();
-  }
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-    prototype->SetClassName(mate::StringToV8(isolate, "Archive"));
-    mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-        .SetProperty("path", &Archive::GetPath)
-        .SetMethod("getFileInfo", &Archive::GetFileInfo)
-        .SetMethod("stat", &Archive::Stat)
-        .SetMethod("readdir", &Archive::Readdir)
-        .SetMethod("realpath", &Archive::Realpath)
-        .SetMethod("copyFileOut", &Archive::CopyFileOut)
-        .SetMethod("getFd", &Archive::GetFD)
-        .SetMethod("destroy", &Archive::Destroy);
-  }
-
- protected:
-  Archive(v8::Isolate* isolate, std::unique_ptr<asar::Archive> archive)
-      : archive_(std::move(archive)) {
-    Init(isolate);
-  }
-
-  // Returns the path of the file.
-  base::FilePath GetPath() { return archive_->path(); }
-
-  // Reads the offset and size of file.
-  v8::Local<v8::Value> GetFileInfo(v8::Isolate* isolate,
-                                   const base::FilePath& path) {
-    asar::Archive::FileInfo info;
-    if (!archive_ || !archive_->GetFileInfo(path, &info))
-      return v8::False(isolate);
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("size", info.size);
-    dict.Set("unpacked", info.unpacked);
-    dict.Set("offset", info.offset);
-    return dict.GetHandle();
-  }
-
-  // Returns a fake result of fs.stat(path).
-  v8::Local<v8::Value> Stat(v8::Isolate* isolate, const base::FilePath& path) {
-    asar::Archive::Stats stats;
-    if (!archive_ || !archive_->Stat(path, &stats))
-      return v8::False(isolate);
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("size", stats.size);
-    dict.Set("offset", stats.offset);
-    dict.Set("isFile", stats.is_file);
-    dict.Set("isDirectory", stats.is_directory);
-    dict.Set("isLink", stats.is_link);
-    return dict.GetHandle();
-  }
-
-  // Returns all files under a directory.
-  v8::Local<v8::Value> Readdir(v8::Isolate* isolate,
-                               const base::FilePath& path) {
-    std::vector<base::FilePath> files;
-    if (!archive_ || !archive_->Readdir(path, &files))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, files);
-  }
-
-  // Returns the path of file with symbol link resolved.
-  v8::Local<v8::Value> Realpath(v8::Isolate* isolate,
-                                const base::FilePath& path) {
-    base::FilePath realpath;
-    if (!archive_ || !archive_->Realpath(path, &realpath))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, realpath);
-  }
-
-  // Copy the file out into a temporary file and returns the new path.
-  v8::Local<v8::Value> CopyFileOut(v8::Isolate* isolate,
-                                   const base::FilePath& path) {
-    base::FilePath new_path;
-    if (!archive_ || !archive_->CopyFileOut(path, &new_path))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, new_path);
-  }
-
-  // Return the file descriptor.
-  int GetFD() const {
-    if (!archive_)
-      return -1;
-    return archive_->GetFD();
-  }
-
-  // Free the resources used by archive.
-  void Destroy() { archive_.reset(); }
-
- private:
-  std::unique_ptr<asar::Archive> archive_;
-
-  DISALLOW_COPY_AND_ASSIGN(Archive);
-};
-
-void InitAsarSupport(v8::Isolate* isolate,
-                     v8::Local<v8::Value> process,
-                     v8::Local<v8::Value> require) {
-  // Evaluate asar_init.js.
-  v8::Local<v8::Script> asar_init =
-      v8::Script::Compile(node::asar_init_value.ToStringChecked(isolate));
-  v8::Local<v8::Value> result = asar_init->Run();
-
-  // Initialize asar support.
-  if (result->IsFunction()) {
-    v8::Local<v8::Value> args[] = {
-        process,
-        require,
-        node::asar_value.ToStringChecked(isolate),
-    };
-    result.As<v8::Function>()->Call(result, 3, args);
-  }
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("createArchive", &Archive::Create);
-  dict.SetMethod("initAsarSupport", &InitAsarSupport);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_asar, Initialize)
removed in remote
  base   100644 1f75f2cd3fe77ba3dd4c43ae0ef20d3d9ef04ad5 atom/common/api/atom_api_clipboard.cc
  our    100644 7502b1cb3627582e15de5cad27189cd68a8d7596 atom/common/api/atom_api_clipboard.cc
@@ -1,226 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_clipboard.h"
-
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/strings/utf_string_conversions.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "third_party/skia/include/core/SkPixmap.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-ui::ClipboardType Clipboard::GetClipboardType(mate::Arguments* args) {
-  std::string type;
-  if (args->GetNext(&type) && type == "selection")
-    return ui::CLIPBOARD_TYPE_SELECTION;
-  else
-    return ui::CLIPBOARD_TYPE_COPY_PASTE;
-}
-
-std::vector<base::string16> Clipboard::AvailableFormats(mate::Arguments* args) {
-  std::vector<base::string16> format_types;
-  bool ignore;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadAvailableTypes(GetClipboardType(args), &format_types, &ignore);
-  return format_types;
-}
-
-bool Clipboard::Has(const std::string& format_string, mate::Arguments* args) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
-  return clipboard->IsFormatAvailable(format, GetClipboardType(args));
-}
-
-std::string Clipboard::Read(const std::string& format_string) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
-
-  std::string data;
-  clipboard->ReadData(format, &data);
-  return data;
-}
-
-v8::Local<v8::Value> Clipboard::ReadBuffer(const std::string& format_string,
-                                           mate::Arguments* args) {
-  std::string data = Read(format_string);
-  return node::Buffer::Copy(args->isolate(), data.data(), data.length())
-      .ToLocalChecked();
-}
-
-void Clipboard::WriteBuffer(const std::string& format,
-                            const v8::Local<v8::Value> buffer,
-                            mate::Arguments* args) {
-  if (!node::Buffer::HasInstance(buffer)) {
-    args->ThrowError("buffer must be a node Buffer");
-    return;
-  }
-
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteData(node::Buffer::Data(buffer), node::Buffer::Length(buffer),
-                   ui::Clipboard::GetFormatType(format));
-}
-
-void Clipboard::Write(const mate::Dictionary& data, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  base::string16 text, html, bookmark;
-  gfx::Image image;
-
-  if (data.Get("text", &text)) {
-    writer.WriteText(text);
-
-    if (data.Get("bookmark", &bookmark))
-      writer.WriteBookmark(bookmark, base::UTF16ToUTF8(text));
-  }
-
-  if (data.Get("rtf", &text)) {
-    std::string rtf = base::UTF16ToUTF8(text);
-    writer.WriteRTF(rtf);
-  }
-
-  if (data.Get("html", &html))
-    writer.WriteHTML(html, std::string());
-
-  if (data.Get("image", &image))
-    writer.WriteImage(image.AsBitmap());
-}
-
-base::string16 Clipboard::ReadText(mate::Arguments* args) {
-  base::string16 data;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  auto type = GetClipboardType(args);
-  if (clipboard->IsFormatAvailable(ui::Clipboard::GetPlainTextWFormatType(),
-                                   type)) {
-    clipboard->ReadText(type, &data);
-  } else if (clipboard->IsFormatAvailable(
-                 ui::Clipboard::GetPlainTextFormatType(), type)) {
-    std::string result;
-    clipboard->ReadAsciiText(type, &result);
-    data = base::ASCIIToUTF16(result);
-  }
-  return data;
-}
-
-void Clipboard::WriteText(const base::string16& text, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteText(text);
-}
-
-base::string16 Clipboard::ReadRTF(mate::Arguments* args) {
-  std::string data;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadRTF(GetClipboardType(args), &data);
-  return base::UTF8ToUTF16(data);
-}
-
-void Clipboard::WriteRTF(const std::string& text, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteRTF(text);
-}
-
-base::string16 Clipboard::ReadHTML(mate::Arguments* args) {
-  base::string16 data;
-  base::string16 html;
-  std::string url;
-  uint32_t start;
-  uint32_t end;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadHTML(GetClipboardType(args), &html, &url, &start, &end);
-  data = html.substr(start, end - start);
-  return data;
-}
-
-void Clipboard::WriteHTML(const base::string16& html, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteHTML(html, std::string());
-}
-
-v8::Local<v8::Value> Clipboard::ReadBookmark(mate::Arguments* args) {
-  base::string16 title;
-  std::string url;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(args->isolate());
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadBookmark(&title, &url);
-  dict.Set("title", title);
-  dict.Set("url", url);
-  return dict.GetHandle();
-}
-
-void Clipboard::WriteBookmark(const base::string16& title,
-                              const std::string& url,
-                              mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteBookmark(title, url);
-}
-
-gfx::Image Clipboard::ReadImage(mate::Arguments* args) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  SkBitmap bitmap = clipboard->ReadImage(GetClipboardType(args));
-  return gfx::Image::CreateFrom1xBitmap(bitmap);
-}
-
-void Clipboard::WriteImage(const gfx::Image& image, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  SkBitmap orig = image.AsBitmap();
-  SkBitmap bmp;
-
-  if (bmp.tryAllocPixels(orig.info()) &&
-      orig.readPixels(bmp.info(), bmp.getPixels(), bmp.rowBytes(), 0, 0)) {
-    writer.WriteImage(bmp);
-  }
-}
-
-#if !defined(OS_MACOSX)
-void Clipboard::WriteFindText(const base::string16& text) {}
-base::string16 Clipboard::ReadFindText() {
-  return base::string16();
-}
-#endif
-
-void Clipboard::Clear(mate::Arguments* args) {
-  ui::Clipboard::GetForCurrentThread()->Clear(GetClipboardType(args));
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("availableFormats", &atom::api::Clipboard::AvailableFormats);
-  dict.SetMethod("has", &atom::api::Clipboard::Has);
-  dict.SetMethod("read", &atom::api::Clipboard::Read);
-  dict.SetMethod("write", &atom::api::Clipboard::Write);
-  dict.SetMethod("readText", &atom::api::Clipboard::ReadText);
-  dict.SetMethod("writeText", &atom::api::Clipboard::WriteText);
-  dict.SetMethod("readRTF", &atom::api::Clipboard::ReadRTF);
-  dict.SetMethod("writeRTF", &atom::api::Clipboard::WriteRTF);
-  dict.SetMethod("readHTML", &atom::api::Clipboard::ReadHTML);
-  dict.SetMethod("writeHTML", &atom::api::Clipboard::WriteHTML);
-  dict.SetMethod("readBookmark", &atom::api::Clipboard::ReadBookmark);
-  dict.SetMethod("writeBookmark", &atom::api::Clipboard::WriteBookmark);
-  dict.SetMethod("readImage", &atom::api::Clipboard::ReadImage);
-  dict.SetMethod("writeImage", &atom::api::Clipboard::WriteImage);
-  dict.SetMethod("readFindText", &atom::api::Clipboard::ReadFindText);
-  dict.SetMethod("writeFindText", &atom::api::Clipboard::WriteFindText);
-  dict.SetMethod("readBuffer", &atom::api::Clipboard::ReadBuffer);
-  dict.SetMethod("writeBuffer", &atom::api::Clipboard::WriteBuffer);
-  dict.SetMethod("clear", &atom::api::Clipboard::Clear);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_clipboard, Initialize)
removed in remote
  base   100644 e1932ad7f5f03aea890c5aa7949d79cf630e58d2 atom/common/api/atom_api_crash_reporter.cc
  our    100644 4aa48085d4d390c7b33994dacdf292f257c31157 atom/common/api/atom_api_crash_reporter.cc
@@ -1,67 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <map>
-#include <string>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/bind.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using crash_reporter::CrashReporter;
-
-namespace mate {
-
-template <>
-struct Converter<CrashReporter::UploadReportResult> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const CrashReporter::UploadReportResult& reports) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("date", v8::Date::New(isolate, reports.first * 1000.0));
-    dict.Set("id", reports.second);
-    return dict.GetHandle();
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void AddExtraParameter(const std::string& key, const std::string& value) {
-  CrashReporter::GetInstance()->AddExtraParameter(key, value);
-}
-
-void RemoveExtraParameter(const std::string& key) {
-  CrashReporter::GetInstance()->RemoveExtraParameter(key);
-}
-
-std::map<std::string, std::string> GetParameters() {
-  return CrashReporter::GetInstance()->GetParameters();
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  auto reporter = base::Unretained(CrashReporter::GetInstance());
-  dict.SetMethod("start", base::Bind(&CrashReporter::Start, reporter));
-  dict.SetMethod("addExtraParameter", &AddExtraParameter);
-  dict.SetMethod("removeExtraParameter", &RemoveExtraParameter);
-  dict.SetMethod("getParameters", &GetParameters);
-  dict.SetMethod("getUploadedReports",
-                 base::Bind(&CrashReporter::GetUploadedReports, reporter));
-  dict.SetMethod("setUploadToServer",
-                 base::Bind(&CrashReporter::SetUploadToServer, reporter));
-  dict.SetMethod("getUploadToServer",
-                 base::Bind(&CrashReporter::GetUploadToServer, reporter));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_crash_reporter, Initialize)
removed in remote
  base   100644 3dda326f59fda31ca29b5bccf7e0335babcc1b3e atom/common/api/atom_api_native_image.cc
  our    100644 09edfdaac9107386241505d2d5763b1b24aa73a4 atom/common/api/atom_api_native_image.cc
@@ -1,624 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_native_image.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/files/file_util.h"
-#include "base/strings/pattern.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_restrictions.h"
-#include "native_mate/object_template_builder.h"
-#include "net/base/data_url.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "third_party/skia/include/core/SkPixelRef.h"
-#include "ui/base/layout.h"
-#include "ui/base/webui/web_ui_util.h"
-#include "ui/gfx/codec/jpeg_codec.h"
-#include "ui/gfx/codec/png_codec.h"
-#include "ui/gfx/geometry/size.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/image/image_skia_operations.h"
-#include "ui/gfx/image/image_util.h"
-
-#if defined(OS_WIN)
-#include "atom/common/asar/archive.h"
-#include "base/win/scoped_gdi_object.h"
-#include "ui/gfx/icon_util.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-struct ScaleFactorPair {
-  const char* name;
-  float scale;
-};
-
-ScaleFactorPair kScaleFactorPairs[] = {
-    // The "@2x" is put as first one to make scale matching faster.
-    {"@2x", 2.0f},   {"@3x", 3.0f},     {"@1x", 1.0f},     {"@4x", 4.0f},
-    {"@5x", 5.0f},   {"@1.25x", 1.25f}, {"@1.33x", 1.33f}, {"@1.4x", 1.4f},
-    {"@1.5x", 1.5f}, {"@1.8x", 1.8f},   {"@2.5x", 2.5f},
-};
-
-float GetScaleFactorFromPath(const base::FilePath& path) {
-  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
-
-  // We don't try to convert string to float here because it is very very
-  // expensive.
-  for (const auto& kScaleFactorPair : kScaleFactorPairs) {
-    if (base::EndsWith(filename, kScaleFactorPair.name,
-                       base::CompareCase::INSENSITIVE_ASCII))
-      return kScaleFactorPair.scale;
-  }
-
-  return 1.0f;
-}
-
-// Get the scale factor from options object at the first argument
-float GetScaleFactorFromOptions(mate::Arguments* args) {
-  float scale_factor = 1.0f;
-  mate::Dictionary options;
-  if (args->GetNext(&options))
-    options.Get("scaleFactor", &scale_factor);
-  return scale_factor;
-}
-
-bool AddImageSkiaRep(gfx::ImageSkia* image,
-                     const unsigned char* data,
-                     size_t size,
-                     int width,
-                     int height,
-                     double scale_factor) {
-  auto decoded = std::make_unique<SkBitmap>();
-
-  // Try PNG first.
-  if (!gfx::PNGCodec::Decode(data, size, decoded.get())) {
-    // Try JPEG.
-    decoded = gfx::JPEGCodec::Decode(data, size);
-    if (decoded) {
-      // `JPEGCodec::Decode()` doesn't tell `SkBitmap` instance it creates
-      // that all of its pixels are opaque, that's why the bitmap gets
-      // an alpha type `kPremul_SkAlphaType` instead of `kOpaque_SkAlphaType`.
-      // Let's fix it here.
-      // TODO(alexeykuzmin): This workaround should be removed
-      // when the `JPEGCodec::Decode()` code is fixed.
-      // See https://github.com/electron/electron/issues/11294.
-      decoded->setAlphaType(SkAlphaType::kOpaque_SkAlphaType);
-    }
-  }
-
-  if (!decoded) {
-    // Try Bitmap
-    if (width > 0 && height > 0) {
-      decoded.reset(new SkBitmap);
-      decoded->allocN32Pixels(width, height, false);
-      decoded->setPixels(
-          const_cast<void*>(reinterpret_cast<const void*>(data)));
-    } else {
-      return false;
-    }
-  }
-
-  image->AddRepresentation(gfx::ImageSkiaRep(*decoded, scale_factor));
-  return true;
-}
-
-bool AddImageSkiaRep(gfx::ImageSkia* image,
-                     const base::FilePath& path,
-                     double scale_factor) {
-  std::string file_contents;
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (!asar::ReadFileToString(path, &file_contents))
-      return false;
-  }
-
-  const unsigned char* data =
-      reinterpret_cast<const unsigned char*>(file_contents.data());
-  size_t size = file_contents.size();
-  return AddImageSkiaRep(image, data, size, 0, 0, scale_factor);
-}
-
-bool PopulateImageSkiaRepsFromPath(gfx::ImageSkia* image,
-                                   const base::FilePath& path) {
-  bool succeed = false;
-  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
-  if (base::MatchPattern(filename, "*@*x"))
-    // Don't search for other representations if the DPI has been specified.
-    return AddImageSkiaRep(image, path, GetScaleFactorFromPath(path));
-  else
-    succeed |= AddImageSkiaRep(image, path, 1.0f);
-
-  for (const ScaleFactorPair& pair : kScaleFactorPairs)
-    succeed |= AddImageSkiaRep(
-        image, path.InsertBeforeExtensionASCII(pair.name), pair.scale);
-  return succeed;
-}
-
-base::FilePath NormalizePath(const base::FilePath& path) {
-  if (!path.ReferencesParent()) {
-    return path;
-  }
-
-  base::FilePath absolute_path = MakeAbsoluteFilePath(path);
-  // MakeAbsoluteFilePath returns an empty path on failures so use original path
-  if (absolute_path.empty()) {
-    return path;
-  } else {
-    return absolute_path;
-  }
-}
-
-#if defined(OS_MACOSX)
-bool IsTemplateFilename(const base::FilePath& path) {
-  return (base::MatchPattern(path.value(), "*Template.*") ||
-          base::MatchPattern(path.value(), "*Template@*x.*"));
-}
-#endif
-
-#if defined(OS_WIN)
-base::win::ScopedHICON ReadICOFromPath(int size, const base::FilePath& path) {
-  // If file is in asar archive, we extract it to a temp file so LoadImage can
-  // load it.
-  base::FilePath asar_path, relative_path;
-  base::FilePath image_path(path);
-  if (asar::GetAsarArchivePath(image_path, &asar_path, &relative_path)) {
-    std::shared_ptr<asar::Archive> archive =
-        asar::GetOrCreateAsarArchive(asar_path);
-    if (archive)
-      archive->CopyFileOut(relative_path, &image_path);
-  }
-
-  // Load the icon from file.
-  return base::win::ScopedHICON(
-      static_cast<HICON>(LoadImage(NULL, image_path.value().c_str(), IMAGE_ICON,
-                                   size, size, LR_LOADFROMFILE)));
-}
-
-bool ReadImageSkiaFromICO(gfx::ImageSkia* image, HICON icon) {
-  // Convert the icon from the Windows specific HICON to gfx::ImageSkia.
-  std::unique_ptr<SkBitmap> bitmap(IconUtil::CreateSkBitmapFromHICON(icon));
-  if (!bitmap)
-    return false;
-
-  image->AddRepresentation(gfx::ImageSkiaRep(*bitmap, 1.0f));
-  return true;
-}
-#endif
-
-void Noop(char*, void*) {}
-
-}  // namespace
-
-NativeImage::NativeImage(v8::Isolate* isolate, const gfx::Image& image)
-    : image_(image) {
-  Init(isolate);
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate->AdjustAmountOfExternalAllocatedMemory(
-        image_.ToImageSkia()->bitmap()->computeByteSize());
-  }
-}
-
-#if defined(OS_WIN)
-NativeImage::NativeImage(v8::Isolate* isolate, const base::FilePath& hicon_path)
-    : hicon_path_(hicon_path) {
-  // Use the 256x256 icon as fallback icon.
-  gfx::ImageSkia image_skia;
-  ReadImageSkiaFromICO(&image_skia, GetHICON(256));
-  image_ = gfx::Image(image_skia);
-  Init(isolate);
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate->AdjustAmountOfExternalAllocatedMemory(
-        image_.ToImageSkia()->bitmap()->computeByteSize());
-  }
-}
-#endif
-
-NativeImage::~NativeImage() {
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate()->AdjustAmountOfExternalAllocatedMemory(-static_cast<int64_t>(
-        image_.ToImageSkia()->bitmap()->computeByteSize()));
-  }
-}
-
-#if defined(OS_WIN)
-HICON NativeImage::GetHICON(int size) {
-  auto iter = hicons_.find(size);
-  if (iter != hicons_.end())
-    return iter->second.get();
-
-  // First try loading the icon with specified size.
-  if (!hicon_path_.empty()) {
-    hicons_[size] = ReadICOFromPath(size, hicon_path_);
-    return hicons_[size].get();
-  }
-
-  // Then convert the image to ICO.
-  if (image_.IsEmpty())
-    return NULL;
-  hicons_[size] = IconUtil::CreateHICONFromSkBitmap(image_.AsBitmap());
-  return hicons_[size].get();
-}
-#endif
-
-v8::Local<v8::Value> NativeImage::ToPNG(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  if (scale_factor == 1.0f) {
-    // Use raw 1x PNG bytes when available
-    scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
-    if (png->size() > 0) {
-      const char* data = reinterpret_cast<const char*>(png->front());
-      size_t size = png->size();
-      return node::Buffer::Copy(args->isolate(), data, size).ToLocalChecked();
-    }
-  }
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  std::vector<unsigned char> encoded;
-  gfx::PNGCodec::EncodeBGRASkBitmap(bitmap, false, &encoded);
-  const char* data = reinterpret_cast<char*>(encoded.data());
-  size_t size = encoded.size();
-  return node::Buffer::Copy(args->isolate(), data, size).ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::ToBitmap(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  SkPixelRef* ref = bitmap.pixelRef();
-  if (!ref)
-    return node::Buffer::New(args->isolate(), 0).ToLocalChecked();
-  return node::Buffer::Copy(args->isolate(),
-                            reinterpret_cast<const char*>(ref->pixels()),
-                            bitmap.computeByteSize())
-      .ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::ToJPEG(v8::Isolate* isolate, int quality) {
-  std::vector<unsigned char> output;
-  gfx::JPEG1xEncodedDataFromImage(image_, quality, &output);
-  if (output.empty())
-    return node::Buffer::New(isolate, 0).ToLocalChecked();
-  return node::Buffer::Copy(isolate,
-                            reinterpret_cast<const char*>(&output.front()),
-                            output.size())
-      .ToLocalChecked();
-}
-
-std::string NativeImage::ToDataURL(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  if (scale_factor == 1.0f) {
-    // Use raw 1x PNG bytes when available
-    scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
-    if (png->size() > 0)
-      return webui::GetPngDataUrl(png->front(), png->size());
-  }
-
-  return webui::GetBitmapDataUrl(
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap());
-}
-
-v8::Local<v8::Value> NativeImage::GetBitmap(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  SkPixelRef* ref = bitmap.pixelRef();
-  if (!ref)
-    return node::Buffer::New(args->isolate(), 0).ToLocalChecked();
-  return node::Buffer::New(args->isolate(),
-                           reinterpret_cast<char*>(ref->pixels()),
-                           bitmap.computeByteSize(), &Noop, nullptr)
-      .ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::GetNativeHandle(v8::Isolate* isolate,
-                                                  mate::Arguments* args) {
-#if defined(OS_MACOSX)
-  if (IsEmpty())
-    return node::Buffer::New(isolate, 0).ToLocalChecked();
-
-  NSImage* ptr = image_.AsNSImage();
-  return node::Buffer::Copy(isolate, reinterpret_cast<char*>(ptr),
-                            sizeof(void*))
-      .ToLocalChecked();
-#else
-  args->ThrowError("Not implemented");
-  return v8::Undefined(isolate);
-#endif
-}
-
-bool NativeImage::IsEmpty() {
-  return image_.IsEmpty();
-}
-
-gfx::Size NativeImage::GetSize() {
-  return image_.Size();
-}
-
-float NativeImage::GetAspectRatio() {
-  gfx::Size size = GetSize();
-  if (size.IsEmpty())
-    return 1.f;
-  else
-    return static_cast<float>(size.width()) / static_cast<float>(size.height());
-}
-
-mate::Handle<NativeImage> NativeImage::Resize(
-    v8::Isolate* isolate,
-    const base::DictionaryValue& options) {
-  gfx::Size size = GetSize();
-  int width = size.width();
-  int height = size.height();
-  bool width_set = options.GetInteger("width", &width);
-  bool height_set = options.GetInteger("height", &height);
-  size.SetSize(width, height);
-
-  if (width_set && !height_set) {
-    // Scale height to preserve original aspect ratio
-    size.set_height(width);
-    size = gfx::ScaleToRoundedSize(size, 1.f, 1.f / GetAspectRatio());
-  } else if (height_set && !width_set) {
-    // Scale width to preserve original aspect ratio
-    size.set_width(height);
-    size = gfx::ScaleToRoundedSize(size, GetAspectRatio(), 1.f);
-  }
-
-  skia::ImageOperations::ResizeMethod method =
-      skia::ImageOperations::ResizeMethod::RESIZE_BEST;
-  std::string quality;
-  options.GetString("quality", &quality);
-  if (quality == "good")
-    method = skia::ImageOperations::ResizeMethod::RESIZE_GOOD;
-  else if (quality == "better")
-    method = skia::ImageOperations::ResizeMethod::RESIZE_BETTER;
-
-  gfx::ImageSkia resized = gfx::ImageSkiaOperations::CreateResizedImage(
-      image_.AsImageSkia(), method, size);
-  return mate::CreateHandle(isolate,
-                            new NativeImage(isolate, gfx::Image(resized)));
-}
-
-mate::Handle<NativeImage> NativeImage::Crop(v8::Isolate* isolate,
-                                            const gfx::Rect& rect) {
-  gfx::ImageSkia cropped =
-      gfx::ImageSkiaOperations::ExtractSubset(image_.AsImageSkia(), rect);
-  return mate::CreateHandle(isolate,
-                            new NativeImage(isolate, gfx::Image(cropped)));
-}
-
-void NativeImage::AddRepresentation(const mate::Dictionary& options) {
-  int width = 0;
-  int height = 0;
-  float scale_factor = 1.0f;
-  options.Get("width", &width);
-  options.Get("height", &height);
-  options.Get("scaleFactor", &scale_factor);
-
-  bool skia_rep_added = false;
-  gfx::ImageSkia image_skia = image_.AsImageSkia();
-
-  v8::Local<v8::Value> buffer;
-  GURL url;
-  if (options.Get("buffer", &buffer) && node::Buffer::HasInstance(buffer)) {
-    AddImageSkiaRep(
-        &image_skia,
-        reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
-        node::Buffer::Length(buffer), width, height, scale_factor);
-    skia_rep_added = true;
-  } else if (options.Get("dataURL", &url)) {
-    std::string mime_type, charset, data;
-    if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
-      if (mime_type == "image/png" || mime_type == "image/jpeg") {
-        AddImageSkiaRep(&image_skia,
-                        reinterpret_cast<const unsigned char*>(data.c_str()),
-                        data.size(), width, height, scale_factor);
-        skia_rep_added = true;
-      }
-    }
-  }
-
-  // Re-initialize image when first representationis added to an empty image
-  if (skia_rep_added && IsEmpty()) {
-    gfx::Image image(image_skia);
-    image_ = std::move(image);
-  }
-}
-
-#if !defined(OS_MACOSX)
-void NativeImage::SetTemplateImage(bool setAsTemplate) {}
-
-bool NativeImage::IsTemplateImage() {
-  return false;
-}
-#endif
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateEmpty(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new NativeImage(isolate, gfx::Image()));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::Create(v8::Isolate* isolate,
-                                              const gfx::Image& image) {
-  return mate::CreateHandle(isolate, new NativeImage(isolate, image));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromPNG(v8::Isolate* isolate,
-                                                     const char* buffer,
-                                                     size_t length) {
-  gfx::Image image = gfx::Image::CreateFrom1xPNGBytes(
-      reinterpret_cast<const unsigned char*>(buffer), length);
-  return Create(isolate, image);
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromJPEG(v8::Isolate* isolate,
-                                                      const char* buffer,
-                                                      size_t length) {
-  gfx::Image image = gfx::ImageFrom1xJPEGEncodedData(
-      reinterpret_cast<const unsigned char*>(buffer), length);
-  return Create(isolate, image);
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromPath(
-    v8::Isolate* isolate,
-    const base::FilePath& path) {
-  base::FilePath image_path = NormalizePath(path);
-#if defined(OS_WIN)
-  if (image_path.MatchesExtension(FILE_PATH_LITERAL(".ico"))) {
-    return mate::CreateHandle(isolate, new NativeImage(isolate, image_path));
-  }
-#endif
-  gfx::ImageSkia image_skia;
-  PopulateImageSkiaRepsFromPath(&image_skia, image_path);
-  gfx::Image image(image_skia);
-  mate::Handle<NativeImage> handle = Create(isolate, image);
-#if defined(OS_MACOSX)
-  if (IsTemplateFilename(image_path))
-    handle->SetTemplateImage(true);
-#endif
-  return handle;
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromBuffer(
-    mate::Arguments* args,
-    v8::Local<v8::Value> buffer) {
-  int width = 0;
-  int height = 0;
-  double scale_factor = 1.;
-
-  mate::Dictionary options;
-  if (args->GetNext(&options)) {
-    options.Get("width", &width);
-    options.Get("height", &height);
-    options.Get("scaleFactor", &scale_factor);
-  }
-
-  gfx::ImageSkia image_skia;
-  AddImageSkiaRep(&image_skia,
-                  reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
-                  node::Buffer::Length(buffer), width, height, scale_factor);
-  return Create(args->isolate(), gfx::Image(image_skia));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromDataURL(v8::Isolate* isolate,
-                                                         const GURL& url) {
-  std::string mime_type, charset, data;
-  if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
-    if (mime_type == "image/png")
-      return CreateFromPNG(isolate, data.c_str(), data.size());
-    else if (mime_type == "image/jpeg")
-      return CreateFromJPEG(isolate, data.c_str(), data.size());
-  }
-
-  return CreateEmpty(isolate);
-}
-
-#if !defined(OS_MACOSX)
-mate::Handle<NativeImage> NativeImage::CreateFromNamedImage(
-    mate::Arguments* args,
-    const std::string& name) {
-  return CreateEmpty(args->isolate());
-}
-#endif
-
-// static
-void NativeImage::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "NativeImage"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("toPNG", &NativeImage::ToPNG)
-      .SetMethod("toJPEG", &NativeImage::ToJPEG)
-      .SetMethod("toBitmap", &NativeImage::ToBitmap)
-      .SetMethod("getBitmap", &NativeImage::GetBitmap)
-      .SetMethod("getNativeHandle", &NativeImage::GetNativeHandle)
-      .SetMethod("toDataURL", &NativeImage::ToDataURL)
-      .SetMethod("isEmpty", &NativeImage::IsEmpty)
-      .SetMethod("getSize", &NativeImage::GetSize)
-      .SetMethod("setTemplateImage", &NativeImage::SetTemplateImage)
-      .SetMethod("isTemplateImage", &NativeImage::IsTemplateImage)
-      .SetMethod("resize", &NativeImage::Resize)
-      .SetMethod("crop", &NativeImage::Crop)
-      .SetMethod("getAspectRatio", &NativeImage::GetAspectRatio)
-      .SetMethod("addRepresentation", &NativeImage::AddRepresentation);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-v8::Local<v8::Value> Converter<mate::Handle<atom::api::NativeImage>>::ToV8(
-    v8::Isolate* isolate,
-    const mate::Handle<atom::api::NativeImage>& val) {
-  return val.ToV8();
-}
-
-bool Converter<mate::Handle<atom::api::NativeImage>>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    mate::Handle<atom::api::NativeImage>* out) {
-  // Try converting from file path.
-  base::FilePath path;
-  if (ConvertFromV8(isolate, val, &path)) {
-    *out = atom::api::NativeImage::CreateFromPath(isolate, path);
-    // Should throw when failed to initialize from path.
-    return !(*out)->image().IsEmpty();
-  }
-
-  WrappableBase* wrapper =
-      static_cast<WrappableBase*>(internal::FromV8Impl(isolate, val));
-  if (!wrapper)
-    return false;
-
-  *out = CreateHandle(isolate, static_cast<atom::api::NativeImage*>(wrapper));
-  return true;
-}
-
-}  // namespace mate
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("createEmpty", &atom::api::NativeImage::CreateEmpty);
-  dict.SetMethod("createFromPath", &atom::api::NativeImage::CreateFromPath);
-  dict.SetMethod("createFromBuffer", &atom::api::NativeImage::CreateFromBuffer);
-  dict.SetMethod("createFromDataURL",
-                 &atom::api::NativeImage::CreateFromDataURL);
-  dict.SetMethod("createFromNamedImage",
-                 &atom::api::NativeImage::CreateFromNamedImage);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_native_image, Initialize)
removed in remote
  base   100644 145f5ff1dcdceed2e63e5ff0171cac00283f4a9e atom/common/api/atom_api_native_image.h
  our    100644 f945e3d4df39a83d667c5c3eb290293ed2788f4a atom/common/api/atom_api_native_image.h
@@ -1,129 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
-#define ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
-
-#include <map>
-#include <string>
-
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-
-#if defined(OS_WIN)
-#include "base/files/file_path.h"
-#include "base/win/scoped_gdi_object.h"
-#endif
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace gfx {
-class Size;
-}
-
-namespace mate {
-class Arguments;
-}
-
-namespace atom {
-
-namespace api {
-
-class NativeImage : public mate::Wrappable<NativeImage> {
- public:
-  static mate::Handle<NativeImage> CreateEmpty(v8::Isolate* isolate);
-  static mate::Handle<NativeImage> Create(v8::Isolate* isolate,
-                                          const gfx::Image& image);
-  static mate::Handle<NativeImage> CreateFromPNG(v8::Isolate* isolate,
-                                                 const char* buffer,
-                                                 size_t length);
-  static mate::Handle<NativeImage> CreateFromJPEG(v8::Isolate* isolate,
-                                                  const char* buffer,
-                                                  size_t length);
-  static mate::Handle<NativeImage> CreateFromPath(v8::Isolate* isolate,
-                                                  const base::FilePath& path);
-  static mate::Handle<NativeImage> CreateFromBuffer(
-      mate::Arguments* args,
-      v8::Local<v8::Value> buffer);
-  static mate::Handle<NativeImage> CreateFromDataURL(v8::Isolate* isolate,
-                                                     const GURL& url);
-  static mate::Handle<NativeImage> CreateFromNamedImage(
-      mate::Arguments* args,
-      const std::string& name);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(OS_WIN)
-  HICON GetHICON(int size);
-#endif
-
-  const gfx::Image& image() const { return image_; }
-
- protected:
-  NativeImage(v8::Isolate* isolate, const gfx::Image& image);
-#if defined(OS_WIN)
-  NativeImage(v8::Isolate* isolate, const base::FilePath& hicon_path);
-#endif
-  ~NativeImage() override;
-
- private:
-  v8::Local<v8::Value> ToPNG(mate::Arguments* args);
-  v8::Local<v8::Value> ToJPEG(v8::Isolate* isolate, int quality);
-  v8::Local<v8::Value> ToBitmap(mate::Arguments* args);
-  v8::Local<v8::Value> GetBitmap(mate::Arguments* args);
-  v8::Local<v8::Value> GetNativeHandle(v8::Isolate* isolate,
-                                       mate::Arguments* args);
-  mate::Handle<NativeImage> Resize(v8::Isolate* isolate,
-                                   const base::DictionaryValue& options);
-  mate::Handle<NativeImage> Crop(v8::Isolate* isolate, const gfx::Rect& rect);
-  std::string ToDataURL(mate::Arguments* args);
-  bool IsEmpty();
-  gfx::Size GetSize();
-  float GetAspectRatio();
-  void AddRepresentation(const mate::Dictionary& options);
-
-  // Mark the image as template image.
-  void SetTemplateImage(bool setAsTemplate);
-  // Determine if the image is a template image.
-  bool IsTemplateImage();
-
-#if defined(OS_WIN)
-  base::FilePath hicon_path_;
-  std::map<int, base::win::ScopedHICON> hicons_;
-#endif
-
-  gfx::Image image_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeImage);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-// A custom converter that allows converting path to NativeImage.
-template <>
-struct Converter<mate::Handle<atom::api::NativeImage>> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const mate::Handle<atom::api::NativeImage>& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     mate::Handle<atom::api::NativeImage>* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
removed in remote
  base   100644 ad72d4b149246ef77a06369359b33fe26c1db3ff atom/common/api/atom_api_native_image_mac.mm
  our    100644 df1cec129f310bbd51448444a256a7be6d3b1a5c atom/common/api/atom_api_native_image_mac.mm
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_native_image.h"
-
-#import <Cocoa/Cocoa.h>
-
-#include "base/strings/sys_string_conversions.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/image/image_skia_operations.h"
-
-namespace atom {
-
-namespace api {
-
-NSData* bufferFromNSImage(NSImage* image) {
-  CGImageRef ref = [image CGImageForProposedRect:nil context:nil hints:nil];
-  NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithCGImage:ref];
-  [rep setSize:[image size]];
-  return [rep representationUsingType:NSPNGFileType
-                           properties:[[NSDictionary alloc] init]];
-}
-
-double safeShift(double in, double def) {
-  if (in >= 0 || in <= 1 || in == def)
-    return in;
-  return def;
-}
-
-mate::Handle<NativeImage> NativeImage::CreateFromNamedImage(
-    mate::Arguments* args,
-    const std::string& name) {
-  @autoreleasepool {
-    std::vector<double> hsl_shift;
-    NSImage* image = [NSImage imageNamed:base::SysUTF8ToNSString(name)];
-    if (!image.valid) {
-      return CreateEmpty(args->isolate());
-    }
-
-    NSData* png_data = bufferFromNSImage(image);
-
-    if (args->GetNext(&hsl_shift) && hsl_shift.size() == 3) {
-      gfx::Image gfx_image = gfx::Image::CreateFrom1xPNGBytes(
-          reinterpret_cast<const unsigned char*>((char*)[png_data bytes]),
-          [png_data length]);
-      color_utils::HSL shift = {safeShift(hsl_shift[0], -1),
-                                safeShift(hsl_shift[1], 0.5),
-                                safeShift(hsl_shift[2], 0.5)};
-      png_data = bufferFromNSImage(
-          gfx::Image(gfx::ImageSkiaOperations::CreateHSLShiftedImage(
-                         gfx_image.AsImageSkia(), shift))
-              .CopyNSImage());
-    }
-
-    return CreateFromPNG(args->isolate(), (char*)[png_data bytes],
-                         [png_data length]);
-  }
-}
-
-void NativeImage::SetTemplateImage(bool setAsTemplate) {
-  [image_.AsNSImage() setTemplate:setAsTemplate];
-}
-
-bool NativeImage::IsTemplateImage() {
-  return [image_.AsNSImage() isTemplate];
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 f99e2ba1854e0bdeb35d9adb327f04c8a84d7392 atom/common/api/atom_api_shell.cc
  our    100644 1323cd6402d295ccc804da6c3d42c5d7472a564e atom/common/api/atom_api_shell.cc
@@ -1,157 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/platform_util.h"
-#include "native_mate/dictionary.h"
-
-#if defined(OS_WIN)
-#include "base/win/scoped_com_initializer.h"
-#include "base/win/shortcut.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::win::ShortcutOperation> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     base::win::ShortcutOperation* out) {
-    std::string operation;
-    if (!ConvertFromV8(isolate, val, &operation))
-      return false;
-    if (operation.empty() || operation == "create")
-      *out = base::win::SHORTCUT_CREATE_ALWAYS;
-    else if (operation == "update")
-      *out = base::win::SHORTCUT_UPDATE_EXISTING;
-    else if (operation == "replace")
-      *out = base::win::SHORTCUT_REPLACE_EXISTING;
-    else
-      return false;
-    return true;
-  }
-};
-
-}  // namespace mate
-#endif
-
-namespace {
-
-void OnOpenExternalFinished(
-    v8::Isolate* isolate,
-    const base::Callback<void(v8::Local<v8::Value>)>& callback,
-    const std::string& error) {
-  if (error.empty())
-    callback.Run(v8::Null(isolate));
-  else
-    callback.Run(v8::String::NewFromUtf8(isolate, error.c_str()));
-}
-
-bool OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    mate::Arguments* args) {
-  bool activate = true;
-  if (args->Length() >= 2) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("activate", &activate);
-    }
-  }
-
-  if (args->Length() >= 3) {
-    base::Callback<void(v8::Local<v8::Value>)> callback;
-    if (args->GetNext(&callback)) {
-      platform_util::OpenExternal(
-          url, activate,
-          base::Bind(&OnOpenExternalFinished, args->isolate(), callback));
-      return true;
-    }
-  }
-
-  return platform_util::OpenExternal(url, activate);
-}
-
-#if defined(OS_WIN)
-bool WriteShortcutLink(const base::FilePath& shortcut_path,
-                       mate::Arguments* args) {
-  base::win::ShortcutOperation operation = base::win::SHORTCUT_CREATE_ALWAYS;
-  args->GetNext(&operation);
-  mate::Dictionary options = mate::Dictionary::CreateEmpty(args->isolate());
-  if (!args->GetNext(&options)) {
-    args->ThrowError();
-    return false;
-  }
-
-  base::win::ShortcutProperties properties;
-  base::FilePath path;
-  base::string16 str;
-  int index;
-  if (options.Get("target", &path))
-    properties.set_target(path);
-  if (options.Get("cwd", &path))
-    properties.set_working_dir(path);
-  if (options.Get("args", &str))
-    properties.set_arguments(str);
-  if (options.Get("description", &str))
-    properties.set_description(str);
-  if (options.Get("icon", &path) && options.Get("iconIndex", &index))
-    properties.set_icon(path, index);
-  if (options.Get("appUserModelId", &str))
-    properties.set_app_id(str);
-
-  base::win::ScopedCOMInitializer com_initializer;
-  return base::win::CreateOrUpdateShortcutLink(shortcut_path, properties,
-                                               operation);
-}
-
-v8::Local<v8::Value> ReadShortcutLink(mate::Arguments* args,
-                                      const base::FilePath& path) {
-  using base::win::ShortcutProperties;
-  mate::Dictionary options = mate::Dictionary::CreateEmpty(args->isolate());
-  base::win::ScopedCOMInitializer com_initializer;
-  base::win::ShortcutProperties properties;
-  if (!base::win::ResolveShortcutProperties(
-          path, ShortcutProperties::PROPERTIES_ALL, &properties)) {
-    args->ThrowError("Failed to read shortcut link");
-    return v8::Null(args->isolate());
-  }
-  options.Set("target", properties.target);
-  options.Set("cwd", properties.working_dir);
-  options.Set("args", properties.arguments);
-  options.Set("description", properties.description);
-  options.Set("icon", properties.icon);
-  options.Set("iconIndex", properties.icon_index);
-  options.Set("appUserModelId", properties.app_id);
-  return options.GetHandle();
-}
-#endif
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("showItemInFolder", &platform_util::ShowItemInFolder);
-  dict.SetMethod("openItem", &platform_util::OpenItem);
-  dict.SetMethod("openExternal", &OpenExternal);
-  dict.SetMethod("moveItemToTrash", &platform_util::MoveItemToTrash);
-  dict.SetMethod("beep", &platform_util::Beep);
-#if defined(OS_WIN)
-  dict.SetMethod("writeShortcutLink", &WriteShortcutLink);
-  dict.SetMethod("readShortcutLink", &ReadShortcutLink);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_shell, Initialize)
removed in remote
  base   100644 0ebd939398f1f6987f179a97664d1c12878c58b9 atom/common/api/atom_api_v8_util.cc
  our    100644 3d80db0c0a4cdbb4c7a78fa7e4266fc6fc87193f atom/common/api/atom_api_v8_util.cc
@@ -1,129 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-#include <utility>
-
-#include "atom/common/api/atom_api_key_weak_map.h"
-#include "atom/common/api/remote_callback_freer.h"
-#include "atom/common/api/remote_object_freer.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/hash.h"
-#include "native_mate/dictionary.h"
-#include "url/origin.h"
-#include "v8/include/v8-profiler.h"
-
-namespace std {
-
-// The hash function used by DoubleIDWeakMap.
-template <typename Type1, typename Type2>
-struct hash<std::pair<Type1, Type2>> {
-  std::size_t operator()(std::pair<Type1, Type2> value) const {
-    return base::HashInts(base::Hash(value.first), value.second);
-  }
-};
-
-}  // namespace std
-
-namespace mate {
-
-template <typename Type1, typename Type2>
-struct Converter<std::pair<Type1, Type2>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     std::pair<Type1, Type2>* out) {
-    if (!val->IsArray())
-      return false;
-
-    v8::Local<v8::Array> array(v8::Local<v8::Array>::Cast(val));
-    if (array->Length() != 2)
-      return false;
-    return Converter<Type1>::FromV8(isolate, array->Get(0), &out->first) &&
-           Converter<Type2>::FromV8(isolate, array->Get(1), &out->second);
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-v8::Local<v8::Value> GetHiddenValue(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    v8::Local<v8::String> key) {
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  v8::Local<v8::Value> value;
-  v8::Maybe<bool> result = object->HasPrivate(context, privateKey);
-  if (!(result.IsJust() && result.FromJust()))
-    return v8::Local<v8::Value>();
-  if (object->GetPrivate(context, privateKey).ToLocal(&value))
-    return value;
-  return v8::Local<v8::Value>();
-}
-
-void SetHiddenValue(v8::Isolate* isolate,
-                    v8::Local<v8::Object> object,
-                    v8::Local<v8::String> key,
-                    v8::Local<v8::Value> value) {
-  if (value.IsEmpty())
-    return;
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  object->SetPrivate(context, privateKey, value);
-}
-
-void DeleteHiddenValue(v8::Isolate* isolate,
-                       v8::Local<v8::Object> object,
-                       v8::Local<v8::String> key) {
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  // Actually deleting the value would make force the object into
-  // dictionary mode which is unnecessarily slow. Instead, we replace
-  // the hidden value with "undefined".
-  object->SetPrivate(context, privateKey, v8::Undefined(isolate));
-}
-
-int32_t GetObjectHash(v8::Local<v8::Object> object) {
-  return object->GetIdentityHash();
-}
-
-void TakeHeapSnapshot(v8::Isolate* isolate) {
-  isolate->GetHeapProfiler()->TakeHeapSnapshot();
-}
-
-void RequestGarbageCollectionForTesting(v8::Isolate* isolate) {
-  isolate->RequestGarbageCollectionForTesting(
-      v8::Isolate::GarbageCollectionType::kFullGarbageCollection);
-}
-
-bool IsSameOrigin(const GURL& l, const GURL& r) {
-  return url::Origin::Create(l).IsSameOriginWith(url::Origin::Create(r));
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("getHiddenValue", &GetHiddenValue);
-  dict.SetMethod("setHiddenValue", &SetHiddenValue);
-  dict.SetMethod("deleteHiddenValue", &DeleteHiddenValue);
-  dict.SetMethod("getObjectHash", &GetObjectHash);
-  dict.SetMethod("takeHeapSnapshot", &TakeHeapSnapshot);
-  dict.SetMethod("setRemoteCallbackFreer", &atom::RemoteCallbackFreer::BindTo);
-  dict.SetMethod("setRemoteObjectFreer", &atom::RemoteObjectFreer::BindTo);
-  dict.SetMethod("createIDWeakMap", &atom::api::KeyWeakMap<int32_t>::Create);
-  dict.SetMethod(
-      "createDoubleIDWeakMap",
-      &atom::api::KeyWeakMap<std::pair<std::string, int32_t>>::Create);
-  dict.SetMethod("requestGarbageCollectionForTesting",
-                 &RequestGarbageCollectionForTesting);
-  dict.SetMethod("isSameOrigin", &IsSameOrigin);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_v8_util, Initialize)
removed in remote
  base   100644 fe53d8793f2a765d050ea088add855d19f2cbd8f atom/common/api/atom_bindings.cc
  our    100644 3dba3d63673ca8eb02044bd1335a3095f0194971 atom/common/api/atom_bindings.cc
@@ -1,262 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_bindings.h"
-
-#include <algorithm>
-#include <iostream>
-#include <string>
-
-#include "atom/common/api/locker.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/logging.h"
-#include "base/process/process_info.h"
-#include "base/process/process_metrics_iocounters.h"
-#include "base/sys_info.h"
-#include "native_mate/dictionary.h"
-
-namespace atom {
-
-namespace {
-
-// Dummy class type that used for crashing the program.
-struct DummyClass {
-  bool crash;
-};
-
-// Called when there is a fatal error in V8, we just crash the process here so
-// we can get the stack trace.
-void FatalErrorCallback(const char* location, const char* message) {
-  LOG(ERROR) << "Fatal error in V8: " << location << " " << message;
-  AtomBindings::Crash();
-}
-
-}  // namespace
-
-AtomBindings::AtomBindings(uv_loop_t* loop) {
-  uv_async_init(loop, &call_next_tick_async_, OnCallNextTick);
-  call_next_tick_async_.data = this;
-  metrics_ = base::ProcessMetrics::CreateCurrentProcessMetrics();
-}
-
-AtomBindings::~AtomBindings() {
-  uv_close(reinterpret_cast<uv_handle_t*>(&call_next_tick_async_), nullptr);
-}
-
-void AtomBindings::BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process) {
-  isolate->SetFatalErrorHandler(FatalErrorCallback);
-
-  mate::Dictionary dict(isolate, process);
-  dict.SetMethod("crash", &AtomBindings::Crash);
-  dict.SetMethod("hang", &Hang);
-  dict.SetMethod("log", &Log);
-  dict.SetMethod("getHeapStatistics", &GetHeapStatistics);
-  dict.SetMethod("getProcessMemoryInfo", &GetProcessMemoryInfo);
-  dict.SetMethod("getCreationTime", &GetCreationTime);
-  dict.SetMethod("getSystemMemoryInfo", &GetSystemMemoryInfo);
-  dict.SetMethod("getCPUUsage", base::Bind(&AtomBindings::GetCPUUsage,
-                                           base::Unretained(metrics_.get())));
-  dict.SetMethod("getIOCounters", &GetIOCounters);
-#if defined(OS_POSIX)
-  dict.SetMethod("setFdLimit", &base::SetFdLimit);
-#endif
-  dict.SetMethod("activateUvLoop", base::Bind(&AtomBindings::ActivateUVLoop,
-                                              base::Unretained(this)));
-
-#if defined(MAS_BUILD)
-  dict.Set("mas", true);
-#endif
-
-  mate::Dictionary versions;
-  if (dict.Get("versions", &versions)) {
-    // TODO(kevinsawicki): Make read-only in 2.0 to match node
-    versions.Set(ATOM_PROJECT_NAME, ATOM_VERSION_STRING);
-    versions.Set("chrome", CHROME_VERSION_STRING);
-  }
-}
-
-void AtomBindings::EnvironmentDestroyed(node::Environment* env) {
-  auto it =
-      std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env);
-  if (it != pending_next_ticks_.end())
-    pending_next_ticks_.erase(it);
-}
-
-void AtomBindings::ActivateUVLoop(v8::Isolate* isolate) {
-  node::Environment* env = node::Environment::GetCurrent(isolate);
-  if (std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env) !=
-      pending_next_ticks_.end())
-    return;
-
-  pending_next_ticks_.push_back(env);
-  uv_async_send(&call_next_tick_async_);
-}
-
-// static
-void AtomBindings::OnCallNextTick(uv_async_t* handle) {
-  AtomBindings* self = static_cast<AtomBindings*>(handle->data);
-  for (std::list<node::Environment*>::const_iterator it =
-           self->pending_next_ticks_.begin();
-       it != self->pending_next_ticks_.end(); ++it) {
-    node::Environment* env = *it;
-    mate::Locker locker(env->isolate());
-    v8::Context::Scope context_scope(env->context());
-    node::InternalCallbackScope scope(
-        env, v8::Local<v8::Object>(), {0, 0},
-        node::InternalCallbackScope::kAllowEmptyResource);
-  }
-
-  self->pending_next_ticks_.clear();
-}
-
-// static
-void AtomBindings::Log(const base::string16& message) {
-  std::cout << message << std::flush;
-}
-
-// static
-void AtomBindings::Crash() {
-  static_cast<DummyClass*>(nullptr)->crash = true;
-}
-
-// static
-void AtomBindings::Hang() {
-  for (;;)
-    base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(1));
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetHeapStatistics(v8::Isolate* isolate) {
-  v8::HeapStatistics v8_heap_stats;
-  isolate->GetHeapStatistics(&v8_heap_stats);
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("totalHeapSize",
-           static_cast<double>(v8_heap_stats.total_heap_size() >> 10));
-  dict.Set(
-      "totalHeapSizeExecutable",
-      static_cast<double>(v8_heap_stats.total_heap_size_executable() >> 10));
-  dict.Set("totalPhysicalSize",
-           static_cast<double>(v8_heap_stats.total_physical_size() >> 10));
-  dict.Set("totalAvailableSize",
-           static_cast<double>(v8_heap_stats.total_available_size() >> 10));
-  dict.Set("usedHeapSize",
-           static_cast<double>(v8_heap_stats.used_heap_size() >> 10));
-  dict.Set("heapSizeLimit",
-           static_cast<double>(v8_heap_stats.heap_size_limit() >> 10));
-  dict.Set("mallocedMemory",
-           static_cast<double>(v8_heap_stats.malloced_memory() >> 10));
-  dict.Set("peakMallocedMemory",
-           static_cast<double>(v8_heap_stats.peak_malloced_memory() >> 10));
-  dict.Set("doesZapGarbage",
-           static_cast<bool>(v8_heap_stats.does_zap_garbage()));
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetProcessMemoryInfo(v8::Isolate* isolate) {
-  auto metrics = base::ProcessMetrics::CreateCurrentProcessMetrics();
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("workingSetSize",
-           static_cast<double>(metrics->GetWorkingSetSize() >> 10));
-  dict.Set("peakWorkingSetSize",
-           static_cast<double>(metrics->GetPeakWorkingSetSize() >> 10));
-
-  size_t private_bytes, shared_bytes;
-  if (metrics->GetMemoryBytes(&private_bytes, &shared_bytes)) {
-    dict.Set("privateBytes", static_cast<double>(private_bytes >> 10));
-    dict.Set("sharedBytes", static_cast<double>(shared_bytes >> 10));
-  }
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetCreationTime(v8::Isolate* isolate) {
-  auto timeValue = base::CurrentProcessInfo::CreationTime();
-  if (timeValue.is_null()) {
-    return v8::Null(isolate);
-  }
-  double jsTime = timeValue.ToJsTime();
-  return v8::Number::New(isolate, jsTime);
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetSystemMemoryInfo(v8::Isolate* isolate,
-                                                       mate::Arguments* args) {
-  base::SystemMemoryInfoKB mem_info;
-  if (!base::GetSystemMemoryInfo(&mem_info)) {
-    args->ThrowError("Unable to retrieve system memory information");
-    return v8::Undefined(isolate);
-  }
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("total", mem_info.total);
-
-  // See Chromium's "base/process/process_metrics.h" for an explanation.
-  int free =
-#if defined(OS_WIN)
-      mem_info.avail_phys;
-#else
-      mem_info.free;
-#endif
-  dict.Set("free", free);
-
-  // NB: These return bogus values on macOS
-#if !defined(OS_MACOSX)
-  dict.Set("swapTotal", mem_info.swap_total);
-  dict.Set("swapFree", mem_info.swap_free);
-#endif
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetCPUUsage(base::ProcessMetrics* metrics,
-                                               v8::Isolate* isolate) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  int processor_count = base::SysInfo::NumberOfProcessors();
-  dict.Set("percentCPUUsage",
-           metrics->GetPlatformIndependentCPUUsage() / processor_count);
-
-  // NB: This will throw NOTIMPLEMENTED() on Windows
-  // For backwards compatibility, we'll return 0
-#if !defined(OS_WIN)
-  dict.Set("idleWakeupsPerSecond", metrics->GetIdleWakeupsPerSecond());
-#else
-  dict.Set("idleWakeupsPerSecond", 0);
-#endif
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetIOCounters(v8::Isolate* isolate) {
-  auto metrics = base::ProcessMetrics::CreateCurrentProcessMetrics();
-  base::IoCounters io_counters;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-
-  if (metrics->GetIOCounters(&io_counters)) {
-    dict.Set("readOperationCount", io_counters.ReadOperationCount);
-    dict.Set("writeOperationCount", io_counters.WriteOperationCount);
-    dict.Set("otherOperationCount", io_counters.OtherOperationCount);
-    dict.Set("readTransferCount", io_counters.ReadTransferCount);
-    dict.Set("writeTransferCount", io_counters.WriteTransferCount);
-    dict.Set("otherTransferCount", io_counters.OtherTransferCount);
-  }
-
-  return dict.GetHandle();
-}
-
-}  // namespace atom
removed in remote
  base   100644 9460145d2391a10fe0e18f2be29a9765862639ac atom/common/api/atom_bindings.h
  our    100644 ba8385c979b15286fd7647582e7d0aee93e1974e atom/common/api/atom_bindings.h
@@ -1,61 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_ATOM_BINDINGS_H_
-#define ATOM_COMMON_API_ATOM_BINDINGS_H_
-
-#include <list>
-
-#include "base/macros.h"
-#include "base/process/process_metrics.h"
-#include "base/strings/string16.h"
-#include "native_mate/arguments.h"
-#include "uv.h"  // NOLINT(build/include)
-#include "v8/include/v8.h"
-
-namespace node {
-class Environment;
-}
-
-namespace atom {
-
-class AtomBindings {
- public:
-  explicit AtomBindings(uv_loop_t* loop);
-  virtual ~AtomBindings();
-
-  // Add process.atomBinding function, which behaves like process.binding but
-  // load native code from Electron instead.
-  void BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process);
-
-  // Should be called when a node::Environment has been destroyed.
-  void EnvironmentDestroyed(node::Environment* env);
-
-  static void Log(const base::string16& message);
-  static void Crash();
-  static void Hang();
-  static v8::Local<v8::Value> GetHeapStatistics(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetProcessMemoryInfo(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetCreationTime(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetSystemMemoryInfo(v8::Isolate* isolate,
-                                                  mate::Arguments* args);
-  static v8::Local<v8::Value> GetCPUUsage(base::ProcessMetrics* metrics,
-                                          v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetIOCounters(v8::Isolate* isolate);
-
- private:
-  void ActivateUVLoop(v8::Isolate* isolate);
-
-  static void OnCallNextTick(uv_async_t* handle);
-
-  uv_async_t call_next_tick_async_;
-  std::list<node::Environment*> pending_next_ticks_;
-  std::unique_ptr<base::ProcessMetrics> metrics_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBindings);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_API_ATOM_BINDINGS_H_
removed in remote
  base   100644 4b44553d37401947f2c47e55949d8a4f51cbe6b2 atom/common/api/event_emitter_caller.cc
  our    100644 a3b9187d68e32038df191a93305c39d7dd104a97 atom/common/api/event_emitter_caller.cc
@@ -1,38 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/event_emitter_caller.h"
-
-#include "atom/common/api/locker.h"
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace internal {
-
-v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> obj,
-                                        const char* method,
-                                        ValueVector* args) {
-  // Perform microtask checkpoint after running JavaScript.
-  v8::MicrotasksScope script_scope(isolate,
-                                   v8::MicrotasksScope::kRunMicrotasks);
-  // Use node::MakeCallback to call the callback, and it will also run pending
-  // tasks in Node.js.
-  v8::MaybeLocal<v8::Value> ret = node::MakeCallback(
-      isolate, obj, method, args->size(), &args->front(), {0, 0});
-  // If the JS function throws an exception (doesn't return a value) the result
-  // of MakeCallback will be empty and therefore ToLocal will be false, in this
-  // case we need to return "false" as that indicates that the event emitter did
-  // not handle the event
-  v8::Local<v8::Value> localRet;
-  if (ret.ToLocal(&localRet)) {
-    return localRet;
-  }
-  return v8::Boolean::New(isolate, false);
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 a2567da9d109131c87d4a20bdcea64d739119c6c atom/common/api/event_emitter_caller.h
  our    100644 023fb0a1d72f4b08e1ca8fae3ea6b74edb4bfcad atom/common/api/event_emitter_caller.h
@@ -1,68 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
-#define ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
-
-#include <vector>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "native_mate/converter.h"
-
-namespace mate {
-
-namespace internal {
-
-using ValueVector = std::vector<v8::Local<v8::Value>>;
-
-v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> obj,
-                                        const char* method,
-                                        ValueVector* args);
-
-}  // namespace internal
-
-// obj.emit.apply(obj, name, args...);
-// The caller is responsible of allocating a HandleScope.
-template <typename StringType>
-v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
-                               v8::Local<v8::Object> obj,
-                               const StringType& name,
-                               const internal::ValueVector& args) {
-  internal::ValueVector concatenated_args = {StringToV8(isolate, name)};
-  concatenated_args.reserve(1 + args.size());
-  concatenated_args.insert(concatenated_args.end(), args.begin(), args.end());
-  return internal::CallMethodWithArgs(isolate, obj, "emit", &concatenated_args);
-}
-
-// obj.emit(name, args...);
-// The caller is responsible of allocating a HandleScope.
-template <typename StringType, typename... Args>
-v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
-                               v8::Local<v8::Object> obj,
-                               const StringType& name,
-                               const Args&... args) {
-  internal::ValueVector converted_args = {
-      StringToV8(isolate, name),
-      ConvertToV8(isolate, args)...,
-  };
-  return internal::CallMethodWithArgs(isolate, obj, "emit", &converted_args);
-}
-
-// obj.custom_emit(args...)
-template <typename... Args>
-v8::Local<v8::Value> CustomEmit(v8::Isolate* isolate,
-                                v8::Local<v8::Object> object,
-                                const char* custom_emit,
-                                const Args&... args) {
-  internal::ValueVector converted_args = {
-      ConvertToV8(isolate, args)...,
-  };
-  return internal::CallMethodWithArgs(isolate, object, custom_emit,
-                                      &converted_args);
-}
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
removed in remote
  base   100644 fe0b23479a46a90aa32ebf3ba93aae0c9302accc atom/common/api/locker.cc
  our    100644 0ae695a1f056722c24e6281ecbddad54032534ad atom/common/api/locker.cc
@@ -1,16 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE.chromium file.
-
-#include "atom/common/api/locker.h"
-
-namespace mate {
-
-Locker::Locker(v8::Isolate* isolate) {
-  if (IsBrowserProcess())
-    locker_.reset(new v8::Locker(isolate));
-}
-
-Locker::~Locker() {}
-
-}  // namespace mate
removed in remote
  base   100644 201217ff625af48a4f0985272757cd058e9d5271 atom/common/api/locker.h
  our    100644 e64ef1853ec5df933a78873cb7c23a975c122894 atom/common/api/locker.h
@@ -1,36 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE.chromium file.
-
-#ifndef ATOM_COMMON_API_LOCKER_H_
-#define ATOM_COMMON_API_LOCKER_H_
-
-#include <memory>
-
-#include "base/macros.h"
-#include "v8/include/v8.h"
-
-namespace mate {
-
-// Only lock when lockers are used in current thread.
-class Locker {
- public:
-  explicit Locker(v8::Isolate* isolate);
-  ~Locker();
-
-  // Returns whether current process is browser process, currently we detect it
-  // by checking whether current has used V8 Lock, but it might be a bad idea.
-  static inline bool IsBrowserProcess() { return v8::Locker::IsActive(); }
-
- private:
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
-  std::unique_ptr<v8::Locker> locker_;
-
-  DISALLOW_COPY_AND_ASSIGN(Locker);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_LOCKER_H_
removed in remote
  base   100644 916ad8a5177ae5e359aeff96a8ec91fce99c6030 atom/common/api/object_life_monitor.cc
  our    100644 4f83a76cf682f3071e2f948fb897069dbdbb0844 atom/common/api/object_life_monitor.cc
@@ -1,41 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 Intel Corp. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/object_life_monitor.h"
-
-#include "base/bind.h"
-#include "base/message_loop/message_loop.h"
-
-namespace atom {
-
-ObjectLifeMonitor::ObjectLifeMonitor(v8::Isolate* isolate,
-                                     v8::Local<v8::Object> target)
-    : target_(isolate, target), weak_ptr_factory_(this) {
-  target_.SetWeak(this, OnObjectGC, v8::WeakCallbackType::kParameter);
-}
-
-ObjectLifeMonitor::~ObjectLifeMonitor() {
-  if (target_.IsEmpty())
-    return;
-  target_.ClearWeak();
-  target_.Reset();
-}
-
-// static
-void ObjectLifeMonitor::OnObjectGC(
-    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
-  ObjectLifeMonitor* self = data.GetParameter();
-  self->target_.Reset();
-  self->RunDestructor();
-  data.SetSecondPassCallback(Free);
-}
-
-// static
-void ObjectLifeMonitor::Free(
-    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
-  delete data.GetParameter();
-}
-
-}  // namespace atom
removed in remote
  base   100644 82d923fcedb7db9d26472e7ee8750cfbfe3c69c6 atom/common/api/object_life_monitor.h
  our    100644 e047960e8130771fb1f240d84b53b181e868670e atom/common/api/object_life_monitor.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
-#define ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-class ObjectLifeMonitor {
- protected:
-  ObjectLifeMonitor(v8::Isolate* isolate, v8::Local<v8::Object> target);
-  virtual ~ObjectLifeMonitor();
-
-  virtual void RunDestructor() = 0;
-
- private:
-  static void OnObjectGC(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
-  static void Free(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
-
-  v8::Global<v8::Object> target_;
-
-  base::WeakPtrFactory<ObjectLifeMonitor> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ObjectLifeMonitor);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
removed in remote
  base   100644 01fe23a889225b1002b1f75b7787ef4f12e78cb7 atom/common/asar/archive.cc
  our    100644 9b37f94a4dc462c0cc84e0182654ff2571952df9 atom/common/asar/archive.cc
@@ -1,315 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/archive.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/scoped_temporary_file.h"
-#include "base/files/file.h"
-#include "base/files/file_util.h"
-#include "base/json/json_reader.h"
-#include "base/logging.h"
-#include "base/pickle.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/values.h"
-
-#if defined(OS_WIN)
-#include <io.h>
-#endif
-
-namespace asar {
-
-namespace {
-
-#if defined(OS_WIN)
-const char kSeparators[] = "\\/";
-#else
-const char kSeparators[] = "/";
-#endif
-
-bool GetNodeFromPath(std::string path,
-                     const base::DictionaryValue* root,
-                     const base::DictionaryValue** out);
-
-// Gets the "files" from "dir".
-bool GetFilesNode(const base::DictionaryValue* root,
-                  const base::DictionaryValue* dir,
-                  const base::DictionaryValue** out) {
-  // Test for symbol linked directory.
-  std::string link;
-  if (dir->GetStringWithoutPathExpansion("link", &link)) {
-    const base::DictionaryValue* linked_node = nullptr;
-    if (!GetNodeFromPath(link, root, &linked_node))
-      return false;
-    dir = linked_node;
-  }
-
-  return dir->GetDictionaryWithoutPathExpansion("files", out);
-}
-
-// Gets sub-file "name" from "dir".
-bool GetChildNode(const base::DictionaryValue* root,
-                  const std::string& name,
-                  const base::DictionaryValue* dir,
-                  const base::DictionaryValue** out) {
-  if (name == "") {
-    *out = root;
-    return true;
-  }
-
-  const base::DictionaryValue* files = nullptr;
-  return GetFilesNode(root, dir, &files) &&
-         files->GetDictionaryWithoutPathExpansion(name, out);
-}
-
-// Gets the node of "path" from "root".
-bool GetNodeFromPath(std::string path,
-                     const base::DictionaryValue* root,
-                     const base::DictionaryValue** out) {
-  if (path == "") {
-    *out = root;
-    return true;
-  }
-
-  const base::DictionaryValue* dir = root;
-  for (size_t delimiter_position = path.find_first_of(kSeparators);
-       delimiter_position != std::string::npos;
-       delimiter_position = path.find_first_of(kSeparators)) {
-    const base::DictionaryValue* child = nullptr;
-    if (!GetChildNode(root, path.substr(0, delimiter_position), dir, &child))
-      return false;
-
-    dir = child;
-    path.erase(0, delimiter_position + 1);
-  }
-
-  return GetChildNode(root, path, dir, out);
-}
-
-bool FillFileInfoWithNode(Archive::FileInfo* info,
-                          uint32_t header_size,
-                          const base::DictionaryValue* node) {
-  int size;
-  if (!node->GetInteger("size", &size))
-    return false;
-  info->size = static_cast<uint32_t>(size);
-
-  if (node->GetBoolean("unpacked", &info->unpacked) && info->unpacked)
-    return true;
-
-  std::string offset;
-  if (!node->GetString("offset", &offset))
-    return false;
-  if (!base::StringToUint64(offset, &info->offset))
-    return false;
-  info->offset += header_size;
-
-  node->GetBoolean("executable", &info->executable);
-
-  return true;
-}
-
-}  // namespace
-
-Archive::Archive(const base::FilePath& path)
-    : path_(path), file_(base::File::FILE_OK) {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  file_.Initialize(path_, base::File::FLAG_OPEN | base::File::FLAG_READ);
-#if defined(OS_WIN)
-  fd_ = _open_osfhandle(reinterpret_cast<intptr_t>(file_.GetPlatformFile()), 0);
-#elif defined(OS_POSIX)
-  fd_ = file_.GetPlatformFile();
-#endif
-}
-
-Archive::~Archive() {
-#if defined(OS_WIN)
-  if (fd_ != -1) {
-    _close(fd_);
-    // Don't close the handle since we already closed the fd.
-    file_.TakePlatformFile();
-  }
-#endif
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  file_.Close();
-}
-
-bool Archive::Init() {
-  if (!file_.IsValid()) {
-    if (file_.error_details() != base::File::FILE_ERROR_NOT_FOUND) {
-      LOG(WARNING) << "Opening " << path_.value() << ": "
-                   << base::File::ErrorToString(file_.error_details());
-    }
-    return false;
-  }
-
-  std::vector<char> buf;
-  int len;
-
-  buf.resize(8);
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    len = file_.ReadAtCurrentPos(buf.data(), buf.size());
-  }
-  if (len != static_cast<int>(buf.size())) {
-    PLOG(ERROR) << "Failed to read header size from " << path_.value();
-    return false;
-  }
-
-  uint32_t size;
-  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size()))
-           .ReadUInt32(&size)) {
-    LOG(ERROR) << "Failed to parse header size from " << path_.value();
-    return false;
-  }
-
-  buf.resize(size);
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    len = file_.ReadAtCurrentPos(buf.data(), buf.size());
-  }
-  if (len != static_cast<int>(buf.size())) {
-    PLOG(ERROR) << "Failed to read header from " << path_.value();
-    return false;
-  }
-
-  std::string header;
-  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size()))
-           .ReadString(&header)) {
-    LOG(ERROR) << "Failed to parse header from " << path_.value();
-    return false;
-  }
-
-  std::string error;
-  base::JSONReader reader;
-  std::unique_ptr<base::Value> value(reader.ReadToValue(header));
-  if (!value || !value->is_dict()) {
-    LOG(ERROR) << "Failed to parse header: " << error;
-    return false;
-  }
-
-  header_size_ = 8 + size;
-  header_.reset(static_cast<base::DictionaryValue*>(value.release()));
-  return true;
-}
-
-bool Archive::GetFileInfo(const base::FilePath& path, FileInfo* info) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  std::string link;
-  if (node->GetString("link", &link))
-    return GetFileInfo(base::FilePath::FromUTF8Unsafe(link), info);
-
-  return FillFileInfoWithNode(info, header_size_, node);
-}
-
-bool Archive::Stat(const base::FilePath& path, Stats* stats) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  if (node->FindKey("link")) {
-    stats->is_file = false;
-    stats->is_link = true;
-    return true;
-  }
-
-  if (node->FindKey("files")) {
-    stats->is_file = false;
-    stats->is_directory = true;
-    return true;
-  }
-
-  return FillFileInfoWithNode(stats, header_size_, node);
-}
-
-bool Archive::Readdir(const base::FilePath& path,
-                      std::vector<base::FilePath>* list) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  const base::DictionaryValue* files;
-  if (!GetFilesNode(header_.get(), node, &files))
-    return false;
-
-  base::DictionaryValue::Iterator iter(*files);
-  while (!iter.IsAtEnd()) {
-    list->push_back(base::FilePath::FromUTF8Unsafe(iter.key()));
-    iter.Advance();
-  }
-  return true;
-}
-
-bool Archive::Realpath(const base::FilePath& path, base::FilePath* realpath) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  std::string link;
-  if (node->GetString("link", &link)) {
-    *realpath = base::FilePath::FromUTF8Unsafe(link);
-    return true;
-  }
-
-  *realpath = path;
-  return true;
-}
-
-bool Archive::CopyFileOut(const base::FilePath& path, base::FilePath* out) {
-  auto it = external_files_.find(path.value());
-  if (it != external_files_.end()) {
-    *out = it->second->path();
-    return true;
-  }
-
-  FileInfo info;
-  if (!GetFileInfo(path, &info))
-    return false;
-
-  if (info.unpacked) {
-    *out = path_.AddExtension(FILE_PATH_LITERAL("unpacked")).Append(path);
-    return true;
-  }
-
-  auto temp_file = std::make_unique<ScopedTemporaryFile>();
-  base::FilePath::StringType ext = path.Extension();
-  if (!temp_file->InitFromFile(&file_, ext, info.offset, info.size))
-    return false;
-
-#if defined(OS_POSIX)
-  if (info.executable) {
-    // chmod a+x temp_file;
-    base::SetPosixFilePermissions(temp_file->path(), 0755);
-  }
-#endif
-
-  *out = temp_file->path();
-  external_files_[path.value()] = std::move(temp_file);
-  return true;
-}
-
-int Archive::GetFD() const {
-  return fd_;
-}
-
-}  // namespace asar
removed in remote
  base   100644 79b848623c99ec2260283ad3ca2d9ded729a397c atom/common/asar/archive.h
  our    100644 5715578ca16aae2c948f914a1352efbdcae1de3e atom/common/asar/archive.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_ARCHIVE_H_
-#define ATOM_COMMON_ASAR_ARCHIVE_H_
-
-#include <memory>
-#include <unordered_map>
-#include <vector>
-
-#include "base/files/file.h"
-#include "base/files/file_path.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace asar {
-
-class ScopedTemporaryFile;
-
-// This class represents an asar package, and provides methods to read
-// information from it.
-class Archive {
- public:
-  struct FileInfo {
-    FileInfo() : unpacked(false), executable(false), size(0), offset(0) {}
-    bool unpacked;
-    bool executable;
-    uint32_t size;
-    uint64_t offset;
-  };
-
-  struct Stats : public FileInfo {
-    Stats() : is_file(true), is_directory(false), is_link(false) {}
-    bool is_file;
-    bool is_directory;
-    bool is_link;
-  };
-
-  explicit Archive(const base::FilePath& path);
-  virtual ~Archive();
-
-  // Read and parse the header.
-  bool Init();
-
-  // Get the info of a file.
-  bool GetFileInfo(const base::FilePath& path, FileInfo* info);
-
-  // Fs.stat(path).
-  bool Stat(const base::FilePath& path, Stats* stats);
-
-  // Fs.readdir(path).
-  bool Readdir(const base::FilePath& path, std::vector<base::FilePath>* files);
-
-  // Fs.realpath(path).
-  bool Realpath(const base::FilePath& path, base::FilePath* realpath);
-
-  // Copy the file into a temporary file, and return the new path.
-  // For unpacked file, this method will return its real path.
-  bool CopyFileOut(const base::FilePath& path, base::FilePath* out);
-
-  // Returns the file's fd.
-  int GetFD() const;
-
-  base::FilePath path() const { return path_; }
-  base::DictionaryValue* header() const { return header_.get(); }
-
- private:
-  base::FilePath path_;
-  base::File file_;
-  int fd_ = -1;
-  uint32_t header_size_ = 0;
-  std::unique_ptr<base::DictionaryValue> header_;
-
-  // Cached external temporary files.
-  std::unordered_map<base::FilePath::StringType,
-                     std::unique_ptr<ScopedTemporaryFile>>
-      external_files_;
-
-  DISALLOW_COPY_AND_ASSIGN(Archive);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_ARCHIVE_H_
removed in remote
  base   100644 1eee09949aff3b4079b2687ad1be2071e7021f01 atom/common/asar/asar_util.cc
  our    100644 b564a75dc7223b118c03441d5cbfa63337a89efc atom/common/asar/asar_util.cc
@@ -1,100 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/asar_util.h"
-
-#include <map>
-#include <string>
-
-#include "atom/common/asar/archive.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/lazy_instance.h"
-#include "base/stl_util.h"
-#include "base/threading/thread_local.h"
-
-namespace asar {
-
-namespace {
-
-// The global instance of ArchiveMap, will be destroyed on exit.
-typedef std::map<base::FilePath, std::shared_ptr<Archive>> ArchiveMap;
-base::LazyInstance<base::ThreadLocalPointer<ArchiveMap>>::Leaky
-    g_archive_map_tls = LAZY_INSTANCE_INITIALIZER;
-
-const base::FilePath::CharType kAsarExtension[] = FILE_PATH_LITERAL(".asar");
-
-}  // namespace
-
-std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path) {
-  if (!g_archive_map_tls.Pointer()->Get())
-    g_archive_map_tls.Pointer()->Set(new ArchiveMap);
-  ArchiveMap& archive_map = *g_archive_map_tls.Pointer()->Get();
-  if (!ContainsKey(archive_map, path)) {
-    std::shared_ptr<Archive> archive(new Archive(path));
-    if (!archive->Init())
-      return nullptr;
-    archive_map[path] = archive;
-  }
-  return archive_map[path];
-}
-
-void ClearArchives() {
-  if (g_archive_map_tls.Pointer()->Get())
-    delete g_archive_map_tls.Pointer()->Get();
-}
-
-bool GetAsarArchivePath(const base::FilePath& full_path,
-                        base::FilePath* asar_path,
-                        base::FilePath* relative_path) {
-  base::FilePath iter = full_path;
-  while (true) {
-    base::FilePath dirname = iter.DirName();
-    if (iter.MatchesExtension(kAsarExtension))
-      break;
-    else if (iter == dirname)
-      return false;
-    iter = dirname;
-  }
-
-  base::FilePath tail;
-  if (!iter.AppendRelativePath(full_path, &tail))
-    return false;
-
-  *asar_path = iter;
-  *relative_path = tail;
-  return true;
-}
-
-bool ReadFileToString(const base::FilePath& path, std::string* contents) {
-  base::FilePath asar_path, relative_path;
-  if (!GetAsarArchivePath(path, &asar_path, &relative_path))
-    return base::ReadFileToString(path, contents);
-
-  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
-  if (!archive)
-    return false;
-
-  Archive::FileInfo info;
-  if (!archive->GetFileInfo(relative_path, &info))
-    return false;
-
-  if (info.unpacked) {
-    base::FilePath real_path;
-    // For unpacked file it will return the real path instead of doing the copy.
-    archive->CopyFileOut(relative_path, &real_path);
-    return base::ReadFileToString(real_path, contents);
-  }
-
-  base::File src(asar_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
-  if (!src.IsValid())
-    return false;
-
-  contents->resize(info.size);
-  return static_cast<int>(info.size) ==
-         src.Read(info.offset, const_cast<char*>(contents->data()),
-                  contents->size());
-}
-
-}  // namespace asar
removed in remote
  base   100644 4cb5b88e04838199024c28ace4679fdcc424c674 atom/common/asar/asar_util.h
  our    100644 90ffb9b46a3008cbcdd9e94ffe69594349dd4d25 atom/common/asar/asar_util.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_ASAR_UTIL_H_
-#define ATOM_COMMON_ASAR_ASAR_UTIL_H_
-
-#include <memory>
-#include <string>
-
-namespace base {
-class FilePath;
-}
-
-namespace asar {
-
-class Archive;
-
-// Gets or creates a new Archive from the path.
-std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path);
-
-// Destroy cached Archive objects.
-void ClearArchives();
-
-// Separates the path to Archive out.
-bool GetAsarArchivePath(const base::FilePath& full_path,
-                        base::FilePath* asar_path,
-                        base::FilePath* relative_path);
-
-// Same with base::ReadFileToString but supports asar Archive.
-bool ReadFileToString(const base::FilePath& path, std::string* contents);
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_ASAR_UTIL_H_
removed in remote
  base   100644 8578d90d9074f2124cf746260c5bad394f7d5b31 atom/common/asar/scoped_temporary_file.cc
  our    100644 f96eabc7a60dd73a556ef8e083fca51e72abdf7b atom/common/asar/scoped_temporary_file.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/scoped_temporary_file.h"
-
-#include <vector>
-
-#include "base/files/file_util.h"
-#include "base/threading/thread_restrictions.h"
-
-namespace asar {
-
-ScopedTemporaryFile::ScopedTemporaryFile() {}
-
-ScopedTemporaryFile::~ScopedTemporaryFile() {
-  if (!path_.empty()) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    // On Windows it is very likely the file is already in use (because it is
-    // mostly used for Node native modules), so deleting it now will halt the
-    // program.
-#if defined(OS_WIN)
-    base::DeleteFileAfterReboot(path_);
-#else
-    base::DeleteFile(path_, false);
-#endif
-  }
-}
-
-bool ScopedTemporaryFile::Init(const base::FilePath::StringType& ext) {
-  if (!path_.empty())
-    return true;
-
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  if (!base::CreateTemporaryFile(&path_))
-    return false;
-
-#if defined(OS_WIN)
-  // Keep the original extension.
-  if (!ext.empty()) {
-    base::FilePath new_path = path_.AddExtension(ext);
-    if (!base::Move(path_, new_path))
-      return false;
-    path_ = new_path;
-  }
-#endif
-
-  return true;
-}
-
-bool ScopedTemporaryFile::InitFromFile(base::File* src,
-                                       const base::FilePath::StringType& ext,
-                                       uint64_t offset,
-                                       uint64_t size) {
-  if (!src->IsValid())
-    return false;
-
-  if (!Init(ext))
-    return false;
-
-  std::vector<char> buf(size);
-  int len = src->Read(offset, buf.data(), buf.size());
-  if (len != static_cast<int>(size))
-    return false;
-
-  base::File dest(path_, base::File::FLAG_OPEN | base::File::FLAG_WRITE);
-  if (!dest.IsValid())
-    return false;
-
-  return dest.WriteAtCurrentPos(buf.data(), buf.size()) ==
-         static_cast<int>(size);
-}
-
-}  // namespace asar
removed in remote
  base   100644 5931d9b87af7853cfbc18f6153ac17a5ff5a09a2 atom/common/asar/scoped_temporary_file.h
  our    100644 4a55958b80842224916973e8df410784a8f5e1b6 atom/common/asar/scoped_temporary_file.h
@@ -1,44 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
-#define ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
-
-#include "base/files/file_path.h"
-
-namespace base {
-class File;
-}
-
-namespace asar {
-
-// An object representing a temporary file that should be cleaned up when this
-// object goes out of scope.  Note that since deletion occurs during the
-// destructor, no further error handling is possible if the directory fails to
-// be deleted.  As a result, deletion is not guaranteed by this class.
-class ScopedTemporaryFile {
- public:
-  ScopedTemporaryFile();
-  virtual ~ScopedTemporaryFile();
-
-  // Init an empty temporary file with a certain extension.
-  bool Init(const base::FilePath::StringType& ext);
-
-  // Init an temporary file and fill it with content of |path|.
-  bool InitFromFile(base::File* src,
-                    const base::FilePath::StringType& ext,
-                    uint64_t offset,
-                    uint64_t size);
-
-  base::FilePath path() const { return path_; }
-
- private:
-  base::FilePath path_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedTemporaryFile);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
removed in remote
  base   100644 2ac62385aeaccc7cd7cce840b098f55cd091b2c0 atom/common/atom_command_line.cc
  our    100644 287e43f75fef778948ef9acdac8b9a7edfe07d0a atom/common/atom_command_line.cc
@@ -1,36 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/atom_command_line.h"
-
-#include "base/command_line.h"
-#include "uv.h"  // NOLINT(build/include)
-
-namespace atom {
-
-// static
-base::CommandLine::StringVector AtomCommandLine::argv_;
-
-// static
-void AtomCommandLine::Init(int argc, base::CommandLine::CharType** argv) {
-  DCHECK(argv_.empty());
-
-  // NOTE: uv_setup_args does nothing on Windows, so we don't need to call it.
-  // Otherwise we'd have to convert the arguments from UTF16.
-#if !defined(OS_WIN)
-  // Hack around with the argv pointer. Used for process.title = "blah"
-  argv = uv_setup_args(argc, argv);
-#endif
-
-  argv_.assign(argv, argv + argc);
-}
-
-#if defined(OS_LINUX)
-// static
-void AtomCommandLine::InitializeFromCommandLine() {
-  argv_ = base::CommandLine::ForCurrentProcess()->argv();
-}
-#endif
-
-}  // namespace atom
removed in remote
  base   100644 b5915533a41bd12ef17a3a748e6a503f7c04ea26 atom/common/atom_command_line.h
  our    100644 57dab57e78c4785bc847cb36dc11c893cc055b32 atom/common/atom_command_line.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_COMMAND_LINE_H_
-#define ATOM_COMMON_ATOM_COMMAND_LINE_H_
-
-#include <string>
-#include <vector>
-
-#include "base/command_line.h"
-#include "base/macros.h"
-#include "build/build_config.h"
-
-namespace atom {
-
-// Singleton to remember the original "argc" and "argv".
-class AtomCommandLine {
- public:
-  static const base::CommandLine::StringVector& argv() { return argv_; }
-
-  static void Init(int argc, base::CommandLine::CharType** argv);
-
-#if defined(OS_LINUX)
-  // On Linux the command line has to be read from base::CommandLine since
-  // it is using zygote.
-  static void InitializeFromCommandLine();
-#endif
-
- private:
-  static base::CommandLine::StringVector argv_;
-
-  DISALLOW_IMPLICIT_CONSTRUCTORS(AtomCommandLine);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_ATOM_COMMAND_LINE_H_
removed in remote
  base   100644 dacda3c816c80611ff88b50813e899173c025886 atom/common/atom_constants.cc
  our    100644 f5188983cc04b6873f71a0d35211a73b9b583771 atom/common/atom_constants.cc
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/atom_constants.h"
-
-namespace atom {
-
-const char kCORSHeader[] = "Access-Control-Allow-Origin: *";
-
-const char kSHA1Certificate[] = "SHA-1 Certificate";
-const char kSHA1MajorDescription[] =
-    "The certificate for this site expires in 2017 or later, "
-    "and the certificate chain contains a certificate signed using SHA-1.";
-const char kSHA1MinorDescription[] =
-    "The certificate for this site expires in 2016, "
-    "and the certificate chain contains a certificate signed using SHA-1.";
-const char kCertificateError[] = "Certificate Error";
-const char kValidCertificate[] = "Valid Certificate";
-const char kValidCertificateDescription[] =
-    "The connection to this site is using a valid, trusted server certificate.";
-const char kSecureProtocol[] = "Secure TLS connection";
-const char kSecureProtocolDescription[] =
-    "The connection to this site is using a strong protocol version "
-    "and cipher suite.";
-
-#if defined(ENABLE_PDF_VIEWER)
-const char kPdfPluginMimeType[] = "application/x-google-chrome-pdf";
-const char kPdfPluginPath[] = "chrome://pdf-viewer/";
-const char kPdfPluginSrc[] = "src";
-
-const char kPdfViewerUIOrigin[] = "chrome://pdf-viewer/";
-const char kPdfViewerUIHost[] = "pdf-viewer";
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace atom
removed in remote
  base   100644 e0d42e83eef95790260f80ff026d3baaa74dd311 atom/common/atom_constants.h
  our    100644 7ad948f43f96edf174d23e16525ecd6cdd86a48f atom/common/atom_constants.h
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_CONSTANTS_H_
-#define ATOM_COMMON_ATOM_CONSTANTS_H_
-
-namespace atom {
-
-// Header to ignore CORS.
-extern const char kCORSHeader[];
-
-// Strings describing Chrome security policy for DevTools security panel.
-extern const char kSHA1Certificate[];
-extern const char kSHA1MajorDescription[];
-extern const char kSHA1MinorDescription[];
-extern const char kCertificateError[];
-extern const char kValidCertificate[];
-extern const char kValidCertificateDescription[];
-extern const char kSecureProtocol[];
-extern const char kSecureProtocolDescription[];
-
-#if defined(ENABLE_PDF_VIEWER)
-// The MIME type used for the PDF plugin.
-extern const char kPdfPluginMimeType[];
-extern const char kPdfPluginPath[];
-extern const char kPdfPluginSrc[];
-
-// Constants for PDF viewer webui.
-extern const char kPdfViewerUIOrigin[];
-extern const char kPdfViewerUIHost[];
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_ATOM_CONSTANTS_H_
removed in remote
  base   100644 cb470529340495fe91e08f0f9ab5f20ba250d0a2 atom/common/atom_version.h
  our    100644 65e7d19911559a40b1b258319df5fe0fa180354f atom/common/atom_version.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_VERSION_H_
-#define ATOM_COMMON_ATOM_VERSION_H_
-
-#define ATOM_MAJOR_VERSION 4
-#define ATOM_MINOR_VERSION 0
-#define ATOM_PATCH_VERSION 0
-#define ATOM_PRE_RELEASE_VERSION -nightly.20180821
-
-#ifndef ATOM_STRINGIFY
-#define ATOM_STRINGIFY(n) ATOM_STRINGIFY_HELPER(n)
-#define ATOM_STRINGIFY_HELPER(n) #n
-#endif
-
-#ifndef ATOM_PRE_RELEASE_VERSION
-#define ATOM_VERSION_STRING          \
-  ATOM_STRINGIFY(ATOM_MAJOR_VERSION) \
-  "." ATOM_STRINGIFY(ATOM_MINOR_VERSION) "." ATOM_STRINGIFY(ATOM_PATCH_VERSION)
-#else
-#define ATOM_VERSION_STRING                                  \
-  ATOM_STRINGIFY(ATOM_MAJOR_VERSION)                         \
-  "." ATOM_STRINGIFY(ATOM_MINOR_VERSION) "." ATOM_STRINGIFY( \
-      ATOM_PATCH_VERSION) ATOM_STRINGIFY(ATOM_PRE_RELEASE_VERSION)
-#endif
-
-#define ATOM_VERSION "v" ATOM_VERSION_STRING
-
-#endif  // ATOM_COMMON_ATOM_VERSION_H_
removed in remote
  base   100644 8b9b7ef0c826c84b9a2bbe31f6204c620d3e0c5d atom/common/chrome_version.h
  our    100644 35666ab599410942900abd2a7d9ad4b3e5c138af atom/common/chrome_version.h
@@ -1,14 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// This file is generated by script/bootstrap.py, you should never modify it
-// by hand.
-
-#ifndef ATOM_COMMON_CHROME_VERSION_H_
-#define ATOM_COMMON_CHROME_VERSION_H_
-
-#define CHROME_VERSION_STRING "66.0.3359.181"
-#define CHROME_VERSION "v" CHROME_VERSION_STRING
-
-#endif  // ATOM_COMMON_CHROME_VERSION_H_
removed in remote
  base   100644 854fc8778e9c02875db341c8cb809232f53af602 atom/common/common_message_generator.cc
  our    100644 09f5bdcfb02987607ad97fbecb3fbff0ca5404b1 atom/common/common_message_generator.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Get basic type definitions.
-#define IPC_MESSAGE_IMPL
-#include "atom/common/common_message_generator.h"
-
-// Generate constructors.
-#include "ipc/struct_constructor_macros.h"
-
-// must go after struct_contructor_macros
-#include "atom/common/common_message_generator.h"
-
-// Generate destructors.
-#include "ipc/struct_destructor_macros.h"
-
-// must go after struct_destructor_macros
-#include "atom/common/common_message_generator.h"
-
-// Generate param traits write methods.
-#include "ipc/param_traits_write_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
-
-// Generate param traits read methods.
-#include "ipc/param_traits_read_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
-
-// Generate param traits log methods.
-#include "ipc/param_traits_log_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
\ No newline at end of file
removed in remote
  base   100644 832de1abf739f9e70019d35e8dd44e2f54efdc37 atom/common/common_message_generator.h
  our    100644 7e9cba51d9f7b1b915adc82df5fbadbf314261e8 atom/common/common_message_generator.h
@@ -1,10 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Multiply-included file, no traditional include guard.
-
-#include "atom/common/api/api_messages.h"
-#include "chrome/common/chrome_utility_printing_messages.h"
-#include "chrome/common/print_messages.h"
-#include "chrome/common/tts_messages.h"
removed in remote
  base   100644 f4f0ff9b7b1631b940218944f47377369e1afb29 atom/common/crash_reporter/crash_reporter.cc
  our    100644 f804f983e59aa49e32e94d901b585c68a4204c9d atom/common/crash_reporter/crash_reporter.cc
@@ -1,127 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
-#include "base/threading/thread_restrictions.h"
-#include "content/public/common/content_switches.h"
-
-namespace crash_reporter {
-
-CrashReporter::CrashReporter() {
-  auto* cmd = base::CommandLine::ForCurrentProcess();
-  is_browser_ = cmd->GetSwitchValueASCII(switches::kProcessType).empty();
-}
-
-CrashReporter::~CrashReporter() {}
-
-void CrashReporter::Start(const std::string& product_name,
-                          const std::string& company_name,
-                          const std::string& submit_url,
-                          const base::FilePath& crashes_dir,
-                          bool upload_to_server,
-                          bool skip_system_crash_handler,
-                          const StringMap& extra_parameters) {
-  SetUploadParameters(extra_parameters);
-
-  InitBreakpad(product_name, ATOM_VERSION_STRING, company_name, submit_url,
-               crashes_dir, upload_to_server, skip_system_crash_handler);
-}
-
-void CrashReporter::SetUploadParameters(const StringMap& parameters) {
-  upload_parameters_ = parameters;
-  upload_parameters_["process_type"] = is_browser_ ? "browser" : "renderer";
-
-  // Setting platform dependent parameters.
-  SetUploadParameters();
-}
-
-void CrashReporter::SetUploadToServer(const bool upload_to_server) {}
-
-bool CrashReporter::GetUploadToServer() {
-  return true;
-}
-
-std::vector<CrashReporter::UploadReportResult>
-CrashReporter::GetUploadedReports(const base::FilePath& crashes_dir) {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  std::string file_content;
-  std::vector<CrashReporter::UploadReportResult> result;
-  base::FilePath uploads_path =
-      crashes_dir.Append(FILE_PATH_LITERAL("uploads.log"));
-  if (base::ReadFileToString(uploads_path, &file_content)) {
-    std::vector<std::string> reports = base::SplitString(
-        file_content, "\n", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-    for (const std::string& report : reports) {
-      std::vector<std::string> report_item = base::SplitString(
-          report, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-      int report_time = 0;
-      if (report_item.size() >= 2 &&
-          base::StringToInt(report_item[0], &report_time)) {
-        result.push_back(
-            CrashReporter::UploadReportResult(report_time, report_item[1]));
-      }
-    }
-  }
-  return result;
-}
-
-void CrashReporter::InitBreakpad(const std::string& product_name,
-                                 const std::string& version,
-                                 const std::string& company_name,
-                                 const std::string& submit_url,
-                                 const base::FilePath& crashes_dir,
-                                 bool auto_submit,
-                                 bool skip_system_crash_handler) {}
-
-void CrashReporter::SetUploadParameters() {}
-
-void CrashReporter::AddExtraParameter(const std::string& key,
-                                      const std::string& value) {}
-
-void CrashReporter::RemoveExtraParameter(const std::string& key) {}
-
-std::map<std::string, std::string> CrashReporter::GetParameters() const {
-  return upload_parameters_;
-}
-
-#if defined(OS_MACOSX) && defined(MAS_BUILD)
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  static CrashReporter crash_reporter;
-  return &crash_reporter;
-}
-#endif
-
-void CrashReporter::StartInstance(const mate::Dictionary& options) {
-  auto* reporter = GetInstance();
-  if (!reporter)
-    return;
-
-  std::string product_name;
-  options.Get("productName", &product_name);
-  std::string company_name;
-  options.Get("companyName", &company_name);
-  std::string submit_url;
-  options.Get("submitURL", &submit_url);
-  base::FilePath crashes_dir;
-  options.Get("crashesDirectory", &crashes_dir);
-  StringMap extra_parameters;
-  options.Get("extra", &extra_parameters);
-
-  extra_parameters["_productName"] = product_name;
-  extra_parameters["_companyName"] = company_name;
-
-  reporter->Start(product_name, company_name, submit_url, crashes_dir, true,
-                  false, extra_parameters);
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 eebbe16dca82210c861c5472802f4c56632d1773 atom/common/crash_reporter/crash_reporter.h
  our    100644 99c4c9818d8c41a9e15690bd17379b864953a723 atom/common/crash_reporter/crash_reporter.h
@@ -1,69 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
-
-#include <map>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "native_mate/dictionary.h"
-
-namespace crash_reporter {
-
-class CrashReporter {
- public:
-  typedef std::map<std::string, std::string> StringMap;
-  typedef std::pair<int, std::string> UploadReportResult;  // upload-date, id
-
-  static CrashReporter* GetInstance();
-  static void StartInstance(const mate::Dictionary& options);
-
-  void Start(const std::string& product_name,
-             const std::string& company_name,
-             const std::string& submit_url,
-             const base::FilePath& crashes_dir,
-             bool upload_to_server,
-             bool skip_system_crash_handler,
-             const StringMap& extra_parameters);
-
-  virtual std::vector<CrashReporter::UploadReportResult> GetUploadedReports(
-      const base::FilePath& crashes_dir);
-
-  virtual void SetUploadToServer(bool upload_to_server);
-  virtual bool GetUploadToServer();
-  virtual void AddExtraParameter(const std::string& key,
-                                 const std::string& value);
-  virtual void RemoveExtraParameter(const std::string& key);
-  virtual std::map<std::string, std::string> GetParameters() const;
-
- protected:
-  CrashReporter();
-  virtual ~CrashReporter();
-
-  virtual void InitBreakpad(const std::string& product_name,
-                            const std::string& version,
-                            const std::string& company_name,
-                            const std::string& submit_url,
-                            const base::FilePath& crashes_dir,
-                            bool upload_to_server,
-                            bool skip_system_crash_handler);
-  virtual void SetUploadParameters();
-
-  StringMap upload_parameters_;
-  bool is_browser_;
-
- private:
-  void SetUploadParameters(const StringMap& parameters);
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporter);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
removed in remote
  base   100644 6fe69f486956c129b3c598d9fde96393498f193d atom/common/crash_reporter/crash_reporter_linux.cc
  our    100644 7928c64fb8daccc781ae70ab1acb54f68752a0fe atom/common/crash_reporter/crash_reporter_linux.cc
@@ -1,144 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_linux.h"
-
-#include <sys/time.h>
-#include <unistd.h>
-
-#include <string>
-
-#include "base/debug/crash_logging.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/linux_util.h"
-#include "base/logging.h"
-#include "base/memory/singleton.h"
-#include "base/process/memory.h"
-#include "base/threading/thread_restrictions.h"
-#include "breakpad/src/client/linux/handler/exception_handler.h"
-#include "breakpad/src/common/linux/linux_libc_support.h"
-
-using google_breakpad::ExceptionHandler;
-using google_breakpad::MinidumpDescriptor;
-
-namespace crash_reporter {
-
-namespace {
-
-// Define a preferred limit on minidump sizes, because Crash Server currently
-// throws away any larger than 1.2MB (1.2 * 1024 * 1024).  A value of -1 means
-// no limit.
-static const off_t kMaxMinidumpFileSize = 1258291;
-
-}  // namespace
-
-CrashReporterLinux::CrashReporterLinux() : pid_(getpid()) {
-  // Set the base process start time value.
-  struct timeval tv;
-  if (!gettimeofday(&tv, NULL)) {
-    uint64_t ret = tv.tv_sec;
-    ret *= 1000;
-    ret += tv.tv_usec / 1000;
-    process_start_time_ = ret;
-  }
-
-  // Make base::g_linux_distro work.
-  base::SetLinuxDistro(base::GetLinuxDistro());
-}
-
-CrashReporterLinux::~CrashReporterLinux() {}
-
-void CrashReporterLinux::InitBreakpad(const std::string& product_name,
-                                      const std::string& version,
-                                      const std::string& company_name,
-                                      const std::string& submit_url,
-                                      const base::FilePath& crashes_dir,
-                                      bool upload_to_server,
-                                      bool skip_system_crash_handler) {
-  EnableCrashDumping(crashes_dir);
-
-  crash_keys_.reset(new CrashKeyStorage());
-
-  crash_keys_->SetKeyValue("prod", ATOM_PRODUCT_NAME);
-  crash_keys_->SetKeyValue("ver", version.c_str());
-  upload_url_ = submit_url;
-  upload_to_server_ = upload_to_server;
-
-  for (StringMap::const_iterator iter = upload_parameters_.begin();
-       iter != upload_parameters_.end(); ++iter)
-    crash_keys_->SetKeyValue(iter->first.c_str(), iter->second.c_str());
-}
-
-void CrashReporterLinux::SetUploadParameters() {
-  upload_parameters_["platform"] = "linux";
-}
-
-void CrashReporterLinux::SetUploadToServer(const bool upload_to_server) {
-  upload_to_server_ = upload_to_server;
-}
-
-bool CrashReporterLinux::GetUploadToServer() {
-  return upload_to_server_;
-}
-
-void CrashReporterLinux::EnableCrashDumping(const base::FilePath& crashes_dir) {
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    base::CreateDirectory(crashes_dir);
-  }
-  std::string log_file = crashes_dir.Append("uploads.log").value();
-  strncpy(g_crash_log_path, log_file.c_str(), sizeof(g_crash_log_path));
-
-  MinidumpDescriptor minidump_descriptor(crashes_dir.value());
-  minidump_descriptor.set_size_limit(kMaxMinidumpFileSize);
-
-  breakpad_.reset(new ExceptionHandler(minidump_descriptor, NULL, CrashDone,
-                                       this,
-                                       true,  // Install handlers.
-                                       -1));
-}
-
-bool CrashReporterLinux::CrashDone(const MinidumpDescriptor& minidump,
-                                   void* context,
-                                   const bool succeeded) {
-  CrashReporterLinux* self = static_cast<CrashReporterLinux*>(context);
-
-  // WARNING: this code runs in a compromised context. It may not call into
-  // libc nor allocate memory normally.
-  if (!succeeded) {
-    const char msg[] = "Failed to generate minidump.";
-    WriteLog(msg, sizeof(msg) - 1);
-    return false;
-  }
-
-  DCHECK(!minidump.IsFD());
-
-  BreakpadInfo info = {0};
-  info.filename = minidump.path();
-  info.fd = minidump.fd();
-  info.distro = base::g_linux_distro;
-  info.distro_length = my_strlen(base::g_linux_distro);
-  info.upload = self->upload_to_server_;
-  info.process_start_time = self->process_start_time_;
-  info.oom_size = base::g_oom_size;
-  info.pid = self->pid_;
-  info.upload_url = self->upload_url_.c_str();
-  info.crash_keys = self->crash_keys_.get();
-  HandleCrashDump(info);
-  return true;
-}
-
-// static
-CrashReporterLinux* CrashReporterLinux::GetInstance() {
-  return base::Singleton<CrashReporterLinux>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterLinux::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 165c288ab2b1caeb065e59a6164b50ba701a1d5c atom/common/crash_reporter/crash_reporter_linux.h
  our    100644 ce9d85fa4b8c744ac4be5b14ea89272b1c5ca6c8 atom/common/crash_reporter/crash_reporter_linux.h
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/crash_reporter/linux/crash_dump_handler.h"
-#include "base/compiler_specific.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace google_breakpad {
-class ExceptionHandler;
-class MinidumpDescriptor;
-}  // namespace google_breakpad
-
-namespace crash_reporter {
-
-class CrashReporterLinux : public CrashReporter {
- public:
-  static CrashReporterLinux* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadToServer(bool upload_to_server) override;
-  void SetUploadParameters() override;
-  bool GetUploadToServer() override;
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterLinux>;
-
-  CrashReporterLinux();
-  ~CrashReporterLinux() override;
-
-  void EnableCrashDumping(const base::FilePath& crashes_dir);
-
-  static bool CrashDone(const google_breakpad::MinidumpDescriptor& minidump,
-                        void* context,
-                        const bool succeeded);
-
-  std::unique_ptr<google_breakpad::ExceptionHandler> breakpad_;
-  std::unique_ptr<CrashKeyStorage> crash_keys_;
-
-  uint64_t process_start_time_ = 0;
-  pid_t pid_ = 0;
-  std::string upload_url_;
-  bool upload_to_server_ = true;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterLinux);
-};
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
removed in remote
  base   100644 f031543591559307420aa08001c5bbf73f53b2cb atom/common/crash_reporter/crash_reporter_mac.h
  our    100644 359875319d6eea5436c805d300eeb4f2dc7533f4 atom/common/crash_reporter/crash_reporter_mac.h
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "base/compiler_specific.h"
-#include "base/strings/string_piece.h"
-#include "crashpad/client/crash_report_database.h"
-#include "crashpad/client/simple_string_dictionary.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace crash_reporter {
-
-class CrashReporterMac : public CrashReporter {
- public:
-  static CrashReporterMac* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadParameters() override;
-  void SetUploadToServer(bool upload_to_server) override;
-  bool GetUploadToServer() override;
-  void AddExtraParameter(const std::string& key,
-                         const std::string& value) override;
-  void RemoveExtraParameter(const std::string& key) override;
-  std::map<std::string, std::string> GetParameters() const override;
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterMac>;
-
-  CrashReporterMac();
-  ~CrashReporterMac() override;
-
-  void SetUploadsEnabled(bool enable_uploads);
-  void SetCrashKeyValue(const base::StringPiece& key,
-                        const base::StringPiece& value);
-
-  std::vector<UploadReportResult> GetUploadedReports(
-      const base::FilePath& crashes_dir) override;
-
-  std::unique_ptr<crashpad::SimpleStringDictionary> simple_string_dictionary_;
-  std::unique_ptr<crashpad::CrashReportDatabase> database_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterMac);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
removed in remote
  base   100644 130a421665f76b625e71b30374e30ff2d62a3235 atom/common/crash_reporter/crash_reporter_mac.mm
  our    100644 636ce4b065fdbccd50470193e627c8f0ea1e2364 atom/common/crash_reporter/crash_reporter_mac.mm
@@ -1,182 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_mac.h"
-
-#include <memory>
-
-#include "base/files/file_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/mac_util.h"
-#include "base/memory/singleton.h"
-#include "base/strings/string_piece.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/threading/thread_restrictions.h"
-#include "crashpad/client/crashpad_client.h"
-#include "crashpad/client/crashpad_info.h"
-#include "crashpad/client/settings.h"
-
-namespace crash_reporter {
-
-CrashReporterMac::CrashReporterMac() {}
-
-CrashReporterMac::~CrashReporterMac() {}
-
-void CrashReporterMac::InitBreakpad(const std::string& product_name,
-                                    const std::string& version,
-                                    const std::string& company_name,
-                                    const std::string& submit_url,
-                                    const base::FilePath& crashes_dir,
-                                    bool upload_to_server,
-                                    bool skip_system_crash_handler) {
-  // check whether crashpad has been initialized.
-  // Only need to initialize once.
-  if (simple_string_dictionary_)
-    return;
-
-  if (is_browser_) {
-    @autoreleasepool {
-      base::FilePath framework_bundle_path = base::mac::FrameworkBundlePath();
-      base::FilePath handler_path =
-          framework_bundle_path.Append("Resources").Append("crashpad_handler");
-
-      std::vector<std::string> args = {
-          "--no-rate-limit",
-          "--no-upload-gzip",  // not all servers accept gzip
-      };
-
-      crashpad::CrashpadClient crashpad_client;
-      crashpad_client.StartHandler(handler_path, crashes_dir, crashes_dir,
-                                   submit_url, StringMap(), args, true, false);
-    }  // @autoreleasepool
-  }
-
-  crashpad::CrashpadInfo* crashpad_info =
-      crashpad::CrashpadInfo::GetCrashpadInfo();
-  if (skip_system_crash_handler) {
-    crashpad_info->set_system_crash_reporter_forwarding(
-        crashpad::TriState::kDisabled);
-  }
-
-  simple_string_dictionary_.reset(new crashpad::SimpleStringDictionary());
-  crashpad_info->set_simple_annotations(simple_string_dictionary_.get());
-
-  SetCrashKeyValue("prod", ATOM_PRODUCT_NAME);
-  SetCrashKeyValue("process_type", is_browser_ ? "browser" : "renderer");
-  SetCrashKeyValue("ver", version);
-
-  for (const auto& upload_parameter : upload_parameters_) {
-    SetCrashKeyValue(upload_parameter.first, upload_parameter.second);
-  }
-  if (is_browser_) {
-    database_ = crashpad::CrashReportDatabase::Initialize(crashes_dir);
-    SetUploadToServer(upload_to_server);
-  }
-}
-
-bool CrashReporterMac::GetUploadToServer() {
-  bool enabled = true;
-  if (database_) {
-    database_->GetSettings()->GetUploadsEnabled(&enabled);
-  }
-  return enabled;
-}
-
-void CrashReporterMac::SetUploadToServer(const bool upload_to_server) {
-  if (database_) {
-    database_->GetSettings()->SetUploadsEnabled(upload_to_server);
-  }
-}
-
-void CrashReporterMac::SetUploadParameters() {
-  upload_parameters_["platform"] = "darwin";
-}
-
-void CrashReporterMac::SetCrashKeyValue(const base::StringPiece& key,
-                                        const base::StringPiece& value) {
-  simple_string_dictionary_->SetKeyValue(key.data(), value.data());
-}
-
-void CrashReporterMac::AddExtraParameter(const std::string& key,
-                                         const std::string& value) {
-  if (simple_string_dictionary_) {
-    SetCrashKeyValue(key, value);
-  } else {
-    upload_parameters_[key] = value;
-  }
-}
-
-void CrashReporterMac::RemoveExtraParameter(const std::string& key) {
-  if (simple_string_dictionary_)
-    simple_string_dictionary_->RemoveKey(key.data());
-  else
-    upload_parameters_.erase(key);
-}
-
-std::map<std::string, std::string> CrashReporterMac::GetParameters() const {
-  if (simple_string_dictionary_) {
-    std::map<std::string, std::string> ret;
-    crashpad::SimpleStringDictionary::Iterator iter(*simple_string_dictionary_);
-    for (;;) {
-      auto* const entry = iter.Next();
-      if (!entry)
-        break;
-      ret[entry->key] = entry->value;
-    }
-    return ret;
-  }
-  return upload_parameters_;
-}
-
-std::vector<CrashReporter::UploadReportResult>
-CrashReporterMac::GetUploadedReports(const base::FilePath& crashes_dir) {
-  std::vector<CrashReporter::UploadReportResult> uploaded_reports;
-
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (!base::PathExists(crashes_dir)) {
-      return uploaded_reports;
-    }
-  }
-  // Load crashpad database.
-  std::unique_ptr<crashpad::CrashReportDatabase> database =
-      crashpad::CrashReportDatabase::Initialize(crashes_dir);
-  DCHECK(database);
-
-  std::vector<crashpad::CrashReportDatabase::Report> completed_reports;
-  crashpad::CrashReportDatabase::OperationStatus status =
-      database->GetCompletedReports(&completed_reports);
-  if (status != crashpad::CrashReportDatabase::kNoError) {
-    return uploaded_reports;
-  }
-
-  for (const crashpad::CrashReportDatabase::Report& completed_report :
-       completed_reports) {
-    if (completed_report.uploaded) {
-      uploaded_reports.push_back(
-          UploadReportResult(static_cast<int>(completed_report.creation_time),
-                             completed_report.id));
-    }
-  }
-
-  auto sort_by_time = [](const UploadReportResult& a,
-                         const UploadReportResult& b) {
-    return a.first >= b.first;
-  };
-  std::sort(uploaded_reports.begin(), uploaded_reports.end(), sort_by_time);
-  return uploaded_reports;
-}
-
-// static
-CrashReporterMac* CrashReporterMac::GetInstance() {
-  return base::Singleton<CrashReporterMac>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterMac::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 939a02f090c55aed3eb3db1d54e9b16d2ced2814 atom/common/crash_reporter/crash_reporter_win.cc
  our    100644 c574da71c9de9bd8c7b7cad57d3a0f84708fb97c atom/common/crash_reporter/crash_reporter_win.cc
@@ -1,281 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_win.h"
-
-#include <string>
-
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/memory/singleton.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/common/result_codes.h"
-#include "gin/public/debug.h"
-#include "sandbox/win/src/nt_internals.h"
-
-#pragma intrinsic(_AddressOfReturnAddress)
-#pragma intrinsic(_ReturnAddress)
-
-#ifdef _WIN64
-// See http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx
-typedef struct _UNWIND_INFO {
-  unsigned char Version : 3;
-  unsigned char Flags : 5;
-  unsigned char SizeOfProlog;
-  unsigned char CountOfCodes;
-  unsigned char FrameRegister : 4;
-  unsigned char FrameOffset : 4;
-  ULONG ExceptionHandler;
-} UNWIND_INFO, *PUNWIND_INFO;
-#endif
-
-namespace crash_reporter {
-
-namespace {
-
-// Minidump with stacks, PEB, TEB, and unloaded module list.
-const MINIDUMP_TYPE kSmallDumpType = static_cast<MINIDUMP_TYPE>(
-    MiniDumpWithProcessThreadData |  // Get PEB and TEB.
-    MiniDumpWithUnloadedModules);    // Get unloaded modules when available.
-
-const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
-const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
-
-// Matches breakpad/src/client/windows/common/ipc_protocol.h.
-const int kNameMaxLength = 64;
-const int kValueMaxLength = 64;
-
-typedef NTSTATUS(WINAPI* NtTerminateProcessPtr)(HANDLE ProcessHandle,
-                                                NTSTATUS ExitStatus);
-char* g_real_terminate_process_stub = NULL;
-
-void TerminateProcessWithoutDump() {
-  // Patched stub exists based on conditions (See InitCrashReporter).
-  // As a side note this function also gets called from
-  // WindowProcExceptionFilter.
-  if (g_real_terminate_process_stub == NULL) {
-    ::TerminateProcess(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
-  } else {
-    NtTerminateProcessPtr real_terminate_proc =
-        reinterpret_cast<NtTerminateProcessPtr>(
-            static_cast<char*>(g_real_terminate_process_stub));
-    real_terminate_proc(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
-  }
-}
-
-#ifdef _WIN64
-int CrashForExceptionInNonABICompliantCodeRange(
-    PEXCEPTION_RECORD ExceptionRecord,
-    ULONG64 EstablisherFrame,
-    PCONTEXT ContextRecord,
-    PDISPATCHER_CONTEXT DispatcherContext) {
-  EXCEPTION_POINTERS info = {ExceptionRecord, ContextRecord};
-  if (!CrashReporter::GetInstance())
-    return EXCEPTION_CONTINUE_SEARCH;
-  return static_cast<CrashReporterWin*>(CrashReporter::GetInstance())
-      ->CrashForException(&info);
-}
-
-struct ExceptionHandlerRecord {
-  RUNTIME_FUNCTION runtime_function;
-  UNWIND_INFO unwind_info;
-  unsigned char thunk[12];
-};
-
-bool RegisterNonABICompliantCodeRange(void* start, size_t size_in_bytes) {
-  ExceptionHandlerRecord* record =
-      reinterpret_cast<ExceptionHandlerRecord*>(start);
-
-  // We assume that the first page of the code range is executable and
-  // committed and reserved for breakpad. What could possibly go wrong?
-
-  // All addresses are 32bit relative offsets to start.
-  record->runtime_function.BeginAddress = 0;
-  record->runtime_function.EndAddress =
-      base::checked_cast<DWORD>(size_in_bytes);
-  record->runtime_function.UnwindData =
-      offsetof(ExceptionHandlerRecord, unwind_info);
-
-  // Create unwind info that only specifies an exception handler.
-  record->unwind_info.Version = 1;
-  record->unwind_info.Flags = UNW_FLAG_EHANDLER;
-  record->unwind_info.SizeOfProlog = 0;
-  record->unwind_info.CountOfCodes = 0;
-  record->unwind_info.FrameRegister = 0;
-  record->unwind_info.FrameOffset = 0;
-  record->unwind_info.ExceptionHandler =
-      offsetof(ExceptionHandlerRecord, thunk);
-
-  // Hardcoded thunk.
-  // mov imm64, rax
-  record->thunk[0] = 0x48;
-  record->thunk[1] = 0xb8;
-  void* handler = &CrashForExceptionInNonABICompliantCodeRange;
-  memcpy(&record->thunk[2], &handler, 8);
-
-  // jmp rax
-  record->thunk[10] = 0xff;
-  record->thunk[11] = 0xe0;
-
-  // Protect reserved page against modifications.
-  DWORD old_protect;
-  return VirtualProtect(start, sizeof(ExceptionHandlerRecord),
-                        PAGE_EXECUTE_READ, &old_protect) &&
-         RtlAddFunctionTable(&record->runtime_function, 1,
-                             reinterpret_cast<DWORD64>(start));
-}
-
-void UnregisterNonABICompliantCodeRange(void* start) {
-  ExceptionHandlerRecord* record =
-      reinterpret_cast<ExceptionHandlerRecord*>(start);
-
-  RtlDeleteFunctionTable(&record->runtime_function);
-}
-#endif  // _WIN64
-
-}  // namespace
-
-CrashReporterWin::CrashReporterWin() {}
-
-CrashReporterWin::~CrashReporterWin() {}
-
-void CrashReporterWin::InitBreakpad(const std::string& product_name,
-                                    const std::string& version,
-                                    const std::string& company_name,
-                                    const std::string& submit_url,
-                                    const base::FilePath& crashes_dir,
-                                    bool upload_to_server,
-                                    bool skip_system_crash_handler) {
-  skip_system_crash_handler_ = skip_system_crash_handler;
-
-  base::string16 pipe_name = base::ReplaceStringPlaceholders(
-      kPipeNameFormat, base::UTF8ToUTF16(product_name), NULL);
-  base::string16 wait_name = base::ReplaceStringPlaceholders(
-      kWaitEventFormat, base::UTF8ToUTF16(product_name), NULL);
-
-  // Wait until the crash service is started.
-  HANDLE wait_event = ::CreateEventW(NULL, TRUE, FALSE, wait_name.c_str());
-  if (wait_event != NULL) {
-    WaitForSingleObject(wait_event, 1000);
-    CloseHandle(wait_event);
-  }
-
-  // ExceptionHandler() attaches our handler and ~ExceptionHandler() detaches
-  // it, so we must explicitly reset *before* we instantiate our new handler
-  // to allow any previous handler to detach in the correct order.
-  breakpad_.reset();
-
-  breakpad_.reset(new google_breakpad::ExceptionHandler(
-      crashes_dir.DirName().value(), FilterCallback, MinidumpCallback, this,
-      google_breakpad::ExceptionHandler::HANDLER_ALL, kSmallDumpType,
-      pipe_name.c_str(),
-      GetCustomInfo(product_name, version, company_name, upload_to_server)));
-
-  if (!breakpad_->IsOutOfProcess())
-    LOG(ERROR) << "Cannot initialize out-of-process crash handler";
-
-#ifdef _WIN64
-  // Hook up V8 to breakpad.
-  if (!code_range_registered_) {
-    code_range_registered_ = true;
-    // gin::Debug::SetCodeRangeCreatedCallback only runs the callback when
-    // Isolate is just created, so we have to manually run following code here.
-    void* code_range = nullptr;
-    size_t size = 0;
-    v8::Isolate::GetCurrent()->GetCodeRange(&code_range, &size);
-    if (code_range && size &&
-        RegisterNonABICompliantCodeRange(code_range, size)) {
-      gin::Debug::SetCodeRangeDeletedCallback(
-          UnregisterNonABICompliantCodeRange);
-    }
-  }
-#endif
-}
-
-void CrashReporterWin::SetUploadParameters() {
-  upload_parameters_["platform"] = "win32";
-}
-
-int CrashReporterWin::CrashForException(EXCEPTION_POINTERS* info) {
-  if (breakpad_) {
-    breakpad_->WriteMinidumpForException(info);
-    if (skip_system_crash_handler_)
-      TerminateProcessWithoutDump();
-    else
-      RaiseFailFastException(info->ExceptionRecord, info->ContextRecord, 0);
-  }
-  return EXCEPTION_CONTINUE_SEARCH;
-}
-
-// static
-bool CrashReporterWin::FilterCallback(void* context,
-                                      EXCEPTION_POINTERS* exinfo,
-                                      MDRawAssertionInfo* assertion) {
-  return true;
-}
-
-// static
-bool CrashReporterWin::MinidumpCallback(const wchar_t* dump_path,
-                                        const wchar_t* minidump_id,
-                                        void* context,
-                                        EXCEPTION_POINTERS* exinfo,
-                                        MDRawAssertionInfo* assertion,
-                                        bool succeeded) {
-  CrashReporterWin* self = static_cast<CrashReporterWin*>(context);
-  if (succeeded && self->skip_system_crash_handler_)
-    return true;
-  else
-    return false;
-}
-
-google_breakpad::CustomClientInfo* CrashReporterWin::GetCustomInfo(
-    const std::string& product_name,
-    const std::string& version,
-    const std::string& company_name,
-    bool upload_to_server) {
-  custom_info_entries_.clear();
-  custom_info_entries_.reserve(3 + upload_parameters_.size());
-
-  custom_info_entries_.push_back(
-      google_breakpad::CustomInfoEntry(L"prod", L"Electron"));
-  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
-      L"ver", base::UTF8ToWide(version).c_str()));
-  if (!upload_to_server) {
-    custom_info_entries_.push_back(
-        google_breakpad::CustomInfoEntry(L"skip_upload", L"1"));
-  }
-
-  for (StringMap::const_iterator iter = upload_parameters_.begin();
-       iter != upload_parameters_.end(); ++iter) {
-    // breakpad has hardcoded the length of name/value, and doesn't truncate
-    // the values itself, so we have to truncate them here otherwise weird
-    // things may happen.
-    std::wstring name = base::UTF8ToWide(iter->first);
-    std::wstring value = base::UTF8ToWide(iter->second);
-    if (name.length() > kNameMaxLength - 1)
-      name.resize(kNameMaxLength - 1);
-    if (value.length() > kValueMaxLength - 1)
-      value.resize(kValueMaxLength - 1);
-
-    custom_info_entries_.push_back(
-        google_breakpad::CustomInfoEntry(name.c_str(), value.c_str()));
-  }
-
-  custom_info_.entries = &custom_info_entries_.front();
-  custom_info_.count = custom_info_entries_.size();
-  return &custom_info_;
-}
-
-// static
-CrashReporterWin* CrashReporterWin::GetInstance() {
-  return base::Singleton<CrashReporterWin>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterWin::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 181c9eabd23cf61719beb20484977f9ac5daaa21 atom/common/crash_reporter/crash_reporter_win.h
  our    100644 89a2a5966d6caf3c13643065ef084e98b69efcaf atom/common/crash_reporter/crash_reporter_win.h
@@ -1,78 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "base/compiler_specific.h"
-#include "breakpad/src/client/windows/handler/exception_handler.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace crash_reporter {
-
-class CrashReporterWin : public CrashReporter {
- public:
-  static CrashReporterWin* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadParameters() override;
-
-  // Crashes the process after generating a dump for the provided exception.
-  int CrashForException(EXCEPTION_POINTERS* info);
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterWin>;
-
-  CrashReporterWin();
-  ~CrashReporterWin() override;
-
-  static bool FilterCallback(void* context,
-                             EXCEPTION_POINTERS* exinfo,
-                             MDRawAssertionInfo* assertion);
-
-  static bool MinidumpCallback(const wchar_t* dump_path,
-                               const wchar_t* minidump_id,
-                               void* context,
-                               EXCEPTION_POINTERS* exinfo,
-                               MDRawAssertionInfo* assertion,
-                               bool succeeded);
-
-  // Returns the custom info structure based on parameters.
-  google_breakpad::CustomClientInfo* GetCustomInfo(
-      const std::string& product_name,
-      const std::string& version,
-      const std::string& company_name,
-      bool upload_to_server);
-
-  // Custom information to be passed to crash handler.
-  std::vector<google_breakpad::CustomInfoEntry> custom_info_entries_;
-  google_breakpad::CustomClientInfo custom_info_;
-
-  bool skip_system_crash_handler_ = false;
-#ifdef _WIN64
-  bool code_range_registered_ = false;
-#endif
-  std::unique_ptr<google_breakpad::ExceptionHandler> breakpad_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterWin);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
removed in remote
  base   100644 56a5e094d446315fbc5565b115e84b775f433c88 atom/common/crash_reporter/linux/crash_dump_handler.cc
  our    100644 8b0e3de5cecdda5c97237ebd5d6e0bbbd99a280b atom/common/crash_reporter/linux/crash_dump_handler.cc
@@ -1,753 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// For linux_syscall_support.h. This makes it safe to call embedded system
-// calls when in seccomp mode.
-
-#include "atom/common/crash_reporter/linux/crash_dump_handler.h"
-
-#include <poll.h>
-
-#include <algorithm>
-
-#include "base/posix/eintr_wrapper.h"
-#include "breakpad/src/client/linux/minidump_writer/directory_reader.h"
-#include "breakpad/src/common/linux/linux_libc_support.h"
-#include "breakpad/src/common/memory_allocator.h"
-
-#include "third_party/lss/linux_syscall_support.h"
-
-// Some versions of gcc are prone to warn about unused return values. In cases
-// where we either a) know the call cannot fail, or b) there is nothing we
-// can do when a call fails, we mark the return code as ignored. This avoids
-// spurious compiler warnings.
-#define IGNORE_RET(x) \
-  do {                \
-    if (x)            \
-      ;               \
-  } while (0)
-
-namespace crash_reporter {
-
-namespace {
-
-// String buffer size to use to convert a uint64_t to string.
-const size_t kUint64StringSize = 21;
-
-// Writes the value |v| as 16 hex characters to the memory pointed at by
-// |output|.
-void write_uint64_hex(char* output, uint64_t v) {
-  static const char hextable[] = "0123456789abcdef";
-
-  for (int i = 15; i >= 0; --i) {
-    output[i] = hextable[v & 15];
-    v >>= 4;
-  }
-}
-
-// uint64_t version of my_int_len() from
-// breakpad/src/common/linux/linux_libc_support.h. Return the length of the
-// given, non-negative integer when expressed in base 10.
-unsigned my_uint64_len(uint64_t i) {
-  if (!i)
-    return 1;
-
-  unsigned len = 0;
-  while (i) {
-    len++;
-    i /= 10;
-  }
-
-  return len;
-}
-
-// uint64_t version of my_uitos() from
-// breakpad/src/common/linux/linux_libc_support.h. Convert a non-negative
-// integer to a string (not null-terminated).
-void my_uint64tos(char* output, uint64_t i, unsigned i_len) {
-  for (unsigned index = i_len; index; --index, i /= 10)
-    output[index - 1] = '0' + (i % 10);
-}
-
-// Converts a struct timeval to milliseconds.
-uint64_t kernel_timeval_to_ms(struct kernel_timeval* tv) {
-  uint64_t ret = tv->tv_sec;  // Avoid overflow by explicitly using a uint64_t.
-  ret *= 1000;
-  ret += tv->tv_usec / 1000;
-  return ret;
-}
-
-bool my_isxdigit(char c) {
-  return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f');
-}
-
-size_t LengthWithoutTrailingSpaces(const char* str, size_t len) {
-  while (len > 0 && str[len - 1] == ' ') {
-    len--;
-  }
-  return len;
-}
-
-// MIME substrings.
-const char g_rn[] = "\r\n";
-const char g_form_data_msg[] = "Content-Disposition: form-data; name=\"";
-const char g_quote_msg[] = "\"";
-const char g_dashdash_msg[] = "--";
-const char g_dump_msg[] = "upload_file_minidump\"; filename=\"dump\"";
-const char g_content_type_msg[] = "Content-Type: application/octet-stream";
-
-// MimeWriter manages an iovec for writing MIMEs to a file.
-class MimeWriter {
- public:
-  static const int kIovCapacity = 30;
-  static const size_t kMaxCrashChunkSize = 64;
-
-  MimeWriter(int fd, const char* const mime_boundary);
-  ~MimeWriter();
-
-  // Append boundary.
-  virtual void AddBoundary();
-
-  // Append end of file boundary.
-  virtual void AddEnd();
-
-  // Append key/value pair with specified sizes.
-  virtual void AddPairData(const char* msg_type,
-                           size_t msg_type_size,
-                           const char* msg_data,
-                           size_t msg_data_size);
-
-  // Append key/value pair.
-  void AddPairString(const char* msg_type, const char* msg_data) {
-    AddPairData(msg_type, my_strlen(msg_type), msg_data, my_strlen(msg_data));
-  }
-
-  // Append key/value pair, splitting value into chunks no larger than
-  // |chunk_size|. |chunk_size| cannot be greater than |kMaxCrashChunkSize|.
-  // The msg_type string will have a counter suffix to distinguish each chunk.
-  virtual void AddPairDataInChunks(const char* msg_type,
-                                   size_t msg_type_size,
-                                   const char* msg_data,
-                                   size_t msg_data_size,
-                                   size_t chunk_size,
-                                   bool strip_trailing_spaces);
-
-  // Add binary file contents to be uploaded with the specified filename.
-  virtual void AddFileContents(const char* filename_msg,
-                               uint8_t* file_data,
-                               size_t file_size);
-
-  // Flush any pending iovecs to the output file.
-  void Flush() {
-    IGNORE_RET(sys_writev(fd_, iov_, iov_index_));
-    iov_index_ = 0;
-  }
-
- protected:
-  void AddItem(const void* base, size_t size);
-  // Minor performance trade-off for easier-to-maintain code.
-  void AddString(const char* str) { AddItem(str, my_strlen(str)); }
-  void AddItemWithoutTrailingSpaces(const void* base, size_t size);
-
-  struct kernel_iovec iov_[kIovCapacity];
-  int iov_index_ = 0;
-
-  // Output file descriptor.
-  int fd_ = -1;
-
-  const char* const mime_boundary_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(MimeWriter);
-};
-
-MimeWriter::MimeWriter(int fd, const char* const mime_boundary)
-    : fd_(fd), mime_boundary_(mime_boundary) {}
-
-MimeWriter::~MimeWriter() {}
-
-void MimeWriter::AddBoundary() {
-  AddString(mime_boundary_);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddEnd() {
-  AddString(mime_boundary_);
-  AddString(g_dashdash_msg);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddPairData(const char* msg_type,
-                             size_t msg_type_size,
-                             const char* msg_data,
-                             size_t msg_data_size) {
-  AddString(g_form_data_msg);
-  AddItem(msg_type, msg_type_size);
-  AddString(g_quote_msg);
-  AddString(g_rn);
-  AddString(g_rn);
-  AddItem(msg_data, msg_data_size);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddPairDataInChunks(const char* msg_type,
-                                     size_t msg_type_size,
-                                     const char* msg_data,
-                                     size_t msg_data_size,
-                                     size_t chunk_size,
-                                     bool strip_trailing_spaces) {
-  if (chunk_size > kMaxCrashChunkSize)
-    return;
-
-  unsigned i = 0;
-  size_t done = 0, msg_length = msg_data_size;
-
-  while (msg_length) {
-    char num[kUint64StringSize];
-    const unsigned num_len = my_uint_len(++i);
-    my_uitos(num, i, num_len);
-
-    size_t chunk_len = std::min(chunk_size, msg_length);
-
-    AddString(g_form_data_msg);
-    AddItem(msg_type, msg_type_size);
-    AddItem(num, num_len);
-    AddString(g_quote_msg);
-    AddString(g_rn);
-    AddString(g_rn);
-    if (strip_trailing_spaces) {
-      AddItemWithoutTrailingSpaces(msg_data + done, chunk_len);
-    } else {
-      AddItem(msg_data + done, chunk_len);
-    }
-    AddString(g_rn);
-    AddBoundary();
-    Flush();
-
-    done += chunk_len;
-    msg_length -= chunk_len;
-  }
-}
-
-void MimeWriter::AddFileContents(const char* filename_msg,
-                                 uint8_t* file_data,
-                                 size_t file_size) {
-  AddString(g_form_data_msg);
-  AddString(filename_msg);
-  AddString(g_rn);
-  AddString(g_content_type_msg);
-  AddString(g_rn);
-  AddString(g_rn);
-  AddItem(file_data, file_size);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddItem(const void* base, size_t size) {
-  // Check if the iovec is full and needs to be flushed to output file.
-  if (iov_index_ == kIovCapacity) {
-    Flush();
-  }
-  iov_[iov_index_].iov_base = const_cast<void*>(base);
-  iov_[iov_index_].iov_len = size;
-  ++iov_index_;
-}
-
-void MimeWriter::AddItemWithoutTrailingSpaces(const void* base, size_t size) {
-  AddItem(base,
-          LengthWithoutTrailingSpaces(static_cast<const char*>(base), size));
-}
-
-void LoadDataFromFD(google_breakpad::PageAllocator* allocator,
-                    int fd,
-                    bool close_fd,
-                    uint8_t** file_data,
-                    size_t* size) {
-  struct kernel_stat st;
-  if (sys_fstat(fd, &st) != 0) {
-    static const char msg[] = "Cannot upload crash dump: stat failed\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-
-  *file_data = reinterpret_cast<uint8_t*>(allocator->Alloc(st.st_size));
-  if (!(*file_data)) {
-    static const char msg[] = "Cannot upload crash dump: cannot alloc\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-  my_memset(*file_data, 0xf, st.st_size);
-
-  *size = st.st_size;
-  int byte_read = sys_read(fd, *file_data, *size);
-  if (byte_read == -1) {
-    static const char msg[] = "Cannot upload crash dump: read failed\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-
-  if (close_fd)
-    IGNORE_RET(sys_close(fd));
-}
-
-void LoadDataFromFile(google_breakpad::PageAllocator* allocator,
-                      const char* filename,
-                      int* fd,
-                      uint8_t** file_data,
-                      size_t* size) {
-  // WARNING: this code runs in a compromised context. It may not call into
-  // libc nor allocate memory normally.
-  *fd = sys_open(filename, O_RDONLY, 0);
-  *size = 0;
-
-  if (*fd < 0) {
-    static const char msg[] = "Cannot upload crash dump: failed to open\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    return;
-  }
-
-  LoadDataFromFD(allocator, *fd, true, file_data, size);
-}
-
-// Spawn the appropriate upload process for the current OS:
-// - generic Linux invokes wget.
-// - ChromeOS invokes crash_reporter.
-// |dumpfile| is the path to the dump data file.
-// |mime_boundary| is only used on Linux.
-// |exe_buf| is only used on CrOS and is the crashing process' name.
-void ExecUploadProcessOrTerminate(const BreakpadInfo& info,
-                                  const char* dumpfile,
-                                  const char* mime_boundary,
-                                  const char* exe_buf,
-                                  google_breakpad::PageAllocator* allocator) {
-  // The --header argument to wget looks like:
-  //   --header=Content-Type: multipart/form-data; boundary=XYZ
-  // where the boundary has two fewer leading '-' chars
-  static const char header_msg[] =
-      "--header=Content-Type: multipart/form-data; boundary=";
-  char* const header = reinterpret_cast<char*>(
-      allocator->Alloc(sizeof(header_msg) - 1 + strlen(mime_boundary) - 2 + 1));
-  memcpy(header, header_msg, sizeof(header_msg) - 1);
-  memcpy(header + sizeof(header_msg) - 1, mime_boundary + 2,
-         strlen(mime_boundary) - 2);
-  // We grab the NUL byte from the end of |mime_boundary|.
-
-  // The --post-file argument to wget looks like:
-  //   --post-file=/tmp/...
-  static const char post_file_msg[] = "--post-file=";
-  char* const post_file = reinterpret_cast<char*>(
-      allocator->Alloc(sizeof(post_file_msg) - 1 + strlen(dumpfile) + 1));
-  memcpy(post_file, post_file_msg, sizeof(post_file_msg) - 1);
-  memcpy(post_file + sizeof(post_file_msg) - 1, dumpfile, strlen(dumpfile));
-
-  static const char kWgetBinary[] = "/usr/bin/wget";
-  const char* args[] = {
-      kWgetBinary,    header, post_file, info.upload_url,
-      "--timeout=60",  // Set a timeout so we don't hang forever.
-      "--tries=1",     // Don't retry if the upload fails.
-      "--quiet",       // Be silent.
-      "-O",            // output reply to /dev/null.
-      "/dev/fd/3",    NULL,
-  };
-  static const char msg[] =
-      "Cannot upload crash dump: cannot exec "
-      "/usr/bin/wget\n";
-  execve(args[0], const_cast<char**>(args), environ);
-  WriteLog(msg, sizeof(msg) - 1);
-  sys__exit(1);
-}
-
-// Runs in the helper process to wait for the upload process running
-// ExecUploadProcessOrTerminate() to finish. Returns the number of bytes written
-// to |fd| and save the written contents to |buf|.
-// |buf| needs to be big enough to hold |bytes_to_read| + 1 characters.
-size_t WaitForCrashReportUploadProcess(int fd,
-                                       size_t bytes_to_read,
-                                       char* buf) {
-  size_t bytes_read = 0;
-
-  // Upload should finish in about 10 seconds. Add a few more 500 ms
-  // internals to account for process startup time.
-  for (size_t wait_count = 0; wait_count < 24; ++wait_count) {
-    struct kernel_pollfd poll_fd;
-    poll_fd.fd = fd;
-    poll_fd.events = POLLIN | POLLPRI | POLLERR;
-    int ret = sys_poll(&poll_fd, 1, 500);
-    if (ret < 0) {
-      // Error
-      break;
-    } else if (ret > 0) {
-      // There is data to read.
-      ssize_t len = HANDLE_EINTR(
-          sys_read(fd, buf + bytes_read, bytes_to_read - bytes_read));
-      if (len < 0)
-        break;
-      bytes_read += len;
-      if (bytes_read == bytes_to_read)
-        break;
-    }
-    // |ret| == 0 -> timed out, continue waiting.
-    // or |bytes_read| < |bytes_to_read| still, keep reading.
-  }
-  buf[bytes_to_read] = 0;  // Always NUL terminate the buffer.
-  return bytes_read;
-}
-
-// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
-bool IsValidCrashReportId(const char* buf,
-                          size_t bytes_read,
-                          size_t expected_len) {
-  if (bytes_read != expected_len)
-    return false;
-  for (size_t i = 0; i < bytes_read; ++i) {
-    if (!my_isxdigit(buf[i]) && buf[i] != '-')
-      return false;
-  }
-  return true;
-}
-
-// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
-void HandleCrashReportId(const char* buf,
-                         size_t bytes_read,
-                         size_t expected_len) {
-  if (!IsValidCrashReportId(buf, bytes_read, expected_len)) {
-    static const char msg[] = "Failed to get crash dump id.";
-    WriteLog(msg, sizeof(msg) - 1);
-    WriteNewline();
-
-    static const char id_msg[] = "Report Id: ";
-    WriteLog(id_msg, sizeof(id_msg) - 1);
-    WriteLog(buf, bytes_read);
-    WriteNewline();
-    return;
-  }
-
-  // Write crash dump id to stderr.
-  static const char msg[] = "Crash dump id: ";
-  WriteLog(msg, sizeof(msg) - 1);
-  WriteLog(buf, my_strlen(buf));
-  WriteNewline();
-
-  // Write crash dump id to crash log as: seconds_since_epoch,crash_id
-  struct kernel_timeval tv;
-  if (!sys_gettimeofday(&tv, NULL)) {
-    uint64_t time = kernel_timeval_to_ms(&tv) / 1000;
-    char time_str[kUint64StringSize];
-    const unsigned time_len = my_uint64_len(time);
-    my_uint64tos(time_str, time, time_len);
-
-    const int kLogOpenFlags = O_CREAT | O_WRONLY | O_APPEND | O_CLOEXEC;
-    int log_fd = sys_open(g_crash_log_path, kLogOpenFlags, 0600);
-    if (log_fd > 0) {
-      sys_write(log_fd, time_str, time_len);
-      sys_write(log_fd, ",", 1);
-      sys_write(log_fd, buf, my_strlen(buf));
-      sys_write(log_fd, "\n", 1);
-      IGNORE_RET(sys_close(log_fd));
-    }
-  }
-}
-
-}  // namespace
-
-char g_crash_log_path[256];
-
-void HandleCrashDump(const BreakpadInfo& info) {
-  int dumpfd;
-  bool keep_fd = false;
-  size_t dump_size;
-  uint8_t* dump_data;
-  google_breakpad::PageAllocator allocator;
-  const char* exe_buf = NULL;
-
-  if (info.fd != -1) {
-    // Dump is provided with an open FD.
-    keep_fd = true;
-    dumpfd = info.fd;
-
-    // The FD is pointing to the end of the file.
-    // Rewind, we'll read the data next.
-    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
-      static const char msg[] =
-          "Cannot upload crash dump: failed to "
-          "reposition minidump FD\n";
-      WriteLog(msg, sizeof(msg) - 1);
-      IGNORE_RET(sys_close(dumpfd));
-      return;
-    }
-    LoadDataFromFD(&allocator, info.fd, false, &dump_data, &dump_size);
-  } else {
-    // Dump is provided with a path.
-    keep_fd = false;
-    LoadDataFromFile(&allocator, info.filename, &dumpfd, &dump_data,
-                     &dump_size);
-  }
-
-  // We need to build a MIME block for uploading to the server. Since we are
-  // going to fork and run wget, it needs to be written to a temp file.
-  const int ufd = sys_open("/dev/urandom", O_RDONLY, 0);
-  if (ufd < 0) {
-    static const char msg[] =
-        "Cannot upload crash dump because /dev/urandom"
-        " is missing\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    return;
-  }
-
-  static const char temp_file_template[] =
-      "/tmp/chromium-upload-XXXXXXXXXXXXXXXX";
-  char temp_file[sizeof(temp_file_template)];
-  int temp_file_fd = -1;
-  if (keep_fd) {
-    temp_file_fd = dumpfd;
-    // Rewind the destination, we are going to overwrite it.
-    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
-      static const char msg[] =
-          "Cannot upload crash dump: failed to "
-          "reposition minidump FD (2)\n";
-      WriteLog(msg, sizeof(msg) - 1);
-      IGNORE_RET(sys_close(dumpfd));
-      return;
-    }
-  } else {
-    if (info.upload) {
-      memcpy(temp_file, temp_file_template, sizeof(temp_file_template));
-
-      for (unsigned i = 0; i < 10; ++i) {
-        uint64_t t;
-        sys_read(ufd, &t, sizeof(t));
-        write_uint64_hex(temp_file + sizeof(temp_file) - (16 + 1), t);
-
-        temp_file_fd = sys_open(temp_file, O_WRONLY | O_CREAT | O_EXCL, 0600);
-        if (temp_file_fd >= 0)
-          break;
-      }
-
-      if (temp_file_fd < 0) {
-        static const char msg[] =
-            "Failed to create temporary file in /tmp: "
-            "cannot upload crash dump\n";
-        WriteLog(msg, sizeof(msg) - 1);
-        IGNORE_RET(sys_close(ufd));
-        return;
-      }
-    } else {
-      temp_file_fd = sys_open(info.filename, O_WRONLY, 0600);
-      if (temp_file_fd < 0) {
-        static const char msg[] = "Failed to save crash dump: failed to open\n";
-        WriteLog(msg, sizeof(msg) - 1);
-        IGNORE_RET(sys_close(ufd));
-        return;
-      }
-    }
-  }
-
-  // The MIME boundary is 28 hyphens, followed by a 64-bit nonce and a NUL.
-  char mime_boundary[28 + 16 + 1];
-  my_memset(mime_boundary, '-', 28);
-  uint64_t boundary_rand;
-  sys_read(ufd, &boundary_rand, sizeof(boundary_rand));
-  write_uint64_hex(mime_boundary + 28, boundary_rand);
-  mime_boundary[28 + 16] = 0;
-  IGNORE_RET(sys_close(ufd));
-
-  // The MIME block looks like this:
-  //   BOUNDARY \r\n
-  //   Content-Disposition: form-data; name="prod" \r\n \r\n
-  //   Chrome_Linux \r\n
-  //   BOUNDARY \r\n
-  //   Content-Disposition: form-data; name="ver" \r\n \r\n
-  //   1.2.3.4 \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="ptime" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="ptype" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="lsb-release" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="oom-size" \r\n \r\n
-  //   1234567890 \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or more (up to CrashKeyStorage::num_entries = 64):
-  //   Content-Disposition: form-data; name=crash-key-name \r\n
-  //   crash-key-value \r\n
-  //   BOUNDARY \r\n
-  //
-  //   Content-Disposition: form-data; name="dump"; filename="dump" \r\n
-  //   Content-Type: application/octet-stream \r\n \r\n
-  //   <dump contents>
-  //   \r\n BOUNDARY -- \r\n
-
-  MimeWriter writer(temp_file_fd, mime_boundary);
-  {
-    writer.AddBoundary();
-    if (info.pid > 0) {
-      char pid_value_buf[kUint64StringSize];
-      uint64_t pid_value_len = my_uint64_len(info.pid);
-      my_uint64tos(pid_value_buf, info.pid, pid_value_len);
-      static const char pid_key_name[] = "pid";
-      writer.AddPairData(pid_key_name, sizeof(pid_key_name) - 1, pid_value_buf,
-                         pid_value_len);
-      writer.AddBoundary();
-    }
-    writer.Flush();
-  }
-
-  if (info.process_start_time > 0) {
-    struct kernel_timeval tv;
-    if (!sys_gettimeofday(&tv, NULL)) {
-      uint64_t time = kernel_timeval_to_ms(&tv);
-      if (time > info.process_start_time) {
-        time -= info.process_start_time;
-        char time_str[kUint64StringSize];
-        const unsigned time_len = my_uint64_len(time);
-        my_uint64tos(time_str, time, time_len);
-
-        static const char process_time_msg[] = "ptime";
-        writer.AddPairData(process_time_msg, sizeof(process_time_msg) - 1,
-                           time_str, time_len);
-        writer.AddBoundary();
-        writer.Flush();
-      }
-    }
-  }
-
-  if (info.distro_length) {
-    static const char distro_msg[] = "lsb-release";
-    writer.AddPairString(distro_msg, info.distro);
-    writer.AddBoundary();
-    writer.Flush();
-  }
-
-  if (info.oom_size) {
-    char oom_size_str[kUint64StringSize];
-    const unsigned oom_size_len = my_uint64_len(info.oom_size);
-    my_uint64tos(oom_size_str, info.oom_size, oom_size_len);
-    static const char oom_size_msg[] = "oom-size";
-    writer.AddPairData(oom_size_msg, sizeof(oom_size_msg) - 1, oom_size_str,
-                       oom_size_len);
-    writer.AddBoundary();
-    writer.Flush();
-  }
-
-  if (info.crash_keys) {
-    CrashKeyStorage::Iterator crash_key_iterator(*info.crash_keys);
-    const CrashKeyStorage::Entry* entry;
-    while ((entry = crash_key_iterator.Next())) {
-      writer.AddPairString(entry->key, entry->value);
-      writer.AddBoundary();
-      writer.Flush();
-    }
-  }
-
-  writer.AddFileContents(g_dump_msg, dump_data, dump_size);
-  writer.AddEnd();
-  writer.Flush();
-
-  IGNORE_RET(sys_close(temp_file_fd));
-
-  if (!info.upload)
-    return;
-
-  const pid_t child = sys_fork();
-  if (!child) {
-    // Spawned helper process.
-    //
-    // This code is called both when a browser is crashing (in which case,
-    // nothing really matters any more) and when a renderer/plugin crashes, in
-    // which case we need to continue.
-    //
-    // Since we are a multithreaded app, if we were just to fork(), we might
-    // grab file descriptors which have just been created in another thread and
-    // hold them open for too long.
-    //
-    // Thus, we have to loop and try and close everything.
-    const int fd = sys_open("/proc/self/fd", O_DIRECTORY | O_RDONLY, 0);
-    if (fd < 0) {
-      for (unsigned i = 3; i < 8192; ++i)
-        IGNORE_RET(sys_close(i));
-    } else {
-      google_breakpad::DirectoryReader reader(fd);
-      const char* name;
-      while (reader.GetNextEntry(&name)) {
-        int i;
-        if (my_strtoui(&i, name) && i > 2 && i != fd)
-          IGNORE_RET(sys_close(i));
-        reader.PopEntry();
-      }
-
-      IGNORE_RET(sys_close(fd));
-    }
-
-    IGNORE_RET(sys_setsid());
-
-    // Leave one end of a pipe in the upload process and watch for it getting
-    // closed by the upload process exiting.
-    int fds[2];
-    if (sys_pipe(fds) >= 0) {
-      const pid_t upload_child = sys_fork();
-      if (!upload_child) {
-        // Upload process.
-        IGNORE_RET(sys_close(fds[0]));
-        IGNORE_RET(sys_dup2(fds[1], 3));
-        ExecUploadProcessOrTerminate(info, temp_file, mime_boundary, exe_buf,
-                                     &allocator);
-      }
-
-      // Helper process.
-      if (upload_child > 0) {
-        IGNORE_RET(sys_close(fds[1]));
-
-        const size_t kCrashIdLength = 36;
-        char id_buf[kCrashIdLength + 1];
-        size_t bytes_read =
-            WaitForCrashReportUploadProcess(fds[0], kCrashIdLength, id_buf);
-        HandleCrashReportId(id_buf, bytes_read, kCrashIdLength);
-
-        if (sys_waitpid(upload_child, NULL, WNOHANG) == 0) {
-          // Upload process is still around, kill it.
-          sys_kill(upload_child, SIGKILL);
-        }
-      }
-    }
-
-    // Helper process.
-    IGNORE_RET(sys_unlink(info.filename));
-    IGNORE_RET(sys_unlink(temp_file));
-    sys__exit(0);
-  }
-
-  // Main browser process.
-  if (child <= 0)
-    return;
-  (void)HANDLE_EINTR(sys_waitpid(child, NULL, 0));
-}
-
-size_t WriteLog(const char* buf, size_t nbytes) {
-  return sys_write(2, buf, nbytes);
-}
-
-size_t WriteNewline() {
-  return WriteLog("\n", 1);
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 f10c5212254ea0bcc4cd9deb9764f42fe9e4ceea atom/common/crash_reporter/linux/crash_dump_handler.h
  our    100644 99843c39fdfd011804b9b50a11232cfa8567228e atom/common/crash_reporter/linux/crash_dump_handler.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
-#define ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "base/macros.h"
-#include "breakpad/src/common/simple_string_dictionary.h"
-
-namespace crash_reporter {
-
-typedef google_breakpad::NonAllocatingMap<256, 256, 64> CrashKeyStorage;
-
-// BreakpadInfo describes a crash report.
-// The minidump information can either be contained in a file descriptor (fd) or
-// in a file (whose path is in filename).
-struct BreakpadInfo {
-  int fd;                       // File descriptor to the Breakpad dump data.
-  const char* filename;         // Path to the Breakpad dump data.
-  const char* distro;           // Linux distro string.
-  unsigned distro_length;       // Length of |distro|.
-  bool upload;                  // Whether to upload or save crash dump.
-  uint64_t process_start_time;  // Uptime of the crashing process.
-  size_t oom_size;              // Amount of memory requested if OOM.
-  uint64_t pid;                 // PID where applicable.
-  const char* upload_url;       // URL to upload the minidump.
-  CrashKeyStorage* crash_keys;
-};
-
-void HandleCrashDump(const BreakpadInfo& info);
-
-size_t WriteLog(const char* buf, size_t nbytes);
-size_t WriteNewline();
-
-// Global variable storing the path of upload log.
-extern char g_crash_log_path[256];
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
removed in remote
  base   100644 58c7c38632ed1bbe2a868a460c3b90af9fa5694b atom/common/crash_reporter/win/crash_service.cc
  our    100644 d13111f495be844df10deebacd572560021bbb4e atom/common/crash_reporter/win/crash_service.cc
@@ -1,507 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/win/crash_service.h"
-
-#include <windows.h>
-
-#include <sddl.h>
-#include <fstream>  // NOLINT
-#include <map>
-
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/time/time.h"
-#include "base/win/windows_version.h"
-#include "breakpad/src/client/windows/crash_generation/client_info.h"
-#include "breakpad/src/client/windows/crash_generation/crash_generation_server.h"
-#include "breakpad/src/client/windows/sender/crash_report_sender.h"
-
-namespace breakpad {
-
-namespace {
-
-const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
-const wchar_t kClassNameFormat[] = L"$1CrashServiceWindow";
-
-const wchar_t kTestPipeName[] = L"\\\\.\\pipe\\ChromeCrashServices";
-
-const wchar_t kGoogleReportURL[] = L"https://clients2.google.com/cr/report";
-const wchar_t kCheckPointFile[] = L"crash_checkpoint.txt";
-
-typedef std::map<std::wstring, std::wstring> CrashMap;
-
-bool CustomInfoToMap(const google_breakpad::ClientInfo* client_info,
-                     const std::wstring& reporter_tag,
-                     CrashMap* map) {
-  google_breakpad::CustomClientInfo info = client_info->GetCustomInfo();
-
-  for (uintptr_t i = 0; i < info.count; ++i) {
-    (*map)[info.entries[i].name] = info.entries[i].value;
-  }
-
-  (*map)[L"rept"] = reporter_tag;
-
-  return !map->empty();
-}
-
-bool WriteCustomInfoToFile(const std::wstring& dump_path, const CrashMap& map) {
-  std::wstring file_path(dump_path);
-  size_t last_dot = file_path.rfind(L'.');
-  if (last_dot == std::wstring::npos)
-    return false;
-  file_path.resize(last_dot);
-  file_path += L".txt";
-
-  std::wofstream file(file_path.c_str(), std::ios_base::out |
-                                             std::ios_base::app |
-                                             std::ios::binary);
-  if (!file.is_open())
-    return false;
-
-  CrashMap::const_iterator pos;
-  for (pos = map.begin(); pos != map.end(); ++pos) {
-    std::wstring line = pos->first;
-    line += L':';
-    line += pos->second;
-    line += L'\n';
-    file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
-  }
-  return true;
-}
-
-bool WriteReportIDToFile(const std::wstring& dump_path,
-                         const std::wstring& report_id) {
-  std::wstring file_path(dump_path);
-  size_t last_slash = file_path.rfind(L'\\');
-  if (last_slash == std::wstring::npos)
-    return false;
-  file_path.resize(last_slash);
-  file_path += L"\\uploads.log";
-
-  std::wofstream file(file_path.c_str(), std::ios_base::out |
-                                             std::ios_base::app |
-                                             std::ios::binary);
-  if (!file.is_open())
-    return false;
-
-  int64_t seconds_since_epoch =
-      (base::Time::Now() - base::Time::UnixEpoch()).InSeconds();
-  std::wstring line = base::Int64ToString16(seconds_since_epoch);
-  line += L',';
-  line += report_id;
-  line += L'\n';
-  file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
-  return true;
-}
-
-// The window procedure task is to handle when a) the user logs off.
-// b) the system shuts down or c) when the user closes the window.
-LRESULT __stdcall CrashSvcWndProc(HWND hwnd,
-                                  UINT message,
-                                  WPARAM wparam,
-                                  LPARAM lparam) {
-  switch (message) {
-    case WM_CLOSE:
-    case WM_ENDSESSION:
-    case WM_DESTROY:
-      PostQuitMessage(0);
-      break;
-    default:
-      return DefWindowProc(hwnd, message, wparam, lparam);
-  }
-  return 0;
-}
-
-// This is the main and only application window.
-HWND g_top_window = NULL;
-
-bool CreateTopWindow(HINSTANCE instance,
-                     const base::string16& application_name,
-                     bool visible) {
-  base::string16 class_name =
-      base::ReplaceStringPlaceholders(kClassNameFormat, application_name, NULL);
-
-  WNDCLASSEXW wcx = {0};
-  wcx.cbSize = sizeof(wcx);
-  wcx.style = CS_HREDRAW | CS_VREDRAW;
-  wcx.lpfnWndProc = CrashSvcWndProc;
-  wcx.hInstance = instance;
-  wcx.lpszClassName = class_name.c_str();
-  ::RegisterClassExW(&wcx);
-  DWORD style = visible ? WS_POPUPWINDOW | WS_VISIBLE : WS_OVERLAPPED;
-
-  // The window size is zero but being a popup window still shows in the
-  // task bar and can be closed using the system menu or using task manager.
-  HWND window = CreateWindowExW(0, wcx.lpszClassName, L"crash service", style,
-                                CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL,
-                                instance, NULL);
-  if (!window)
-    return false;
-
-  ::UpdateWindow(window);
-  VLOG(1) << "window handle is " << window;
-  g_top_window = window;
-  return true;
-}
-
-// Simple helper class to keep the process alive until the current request
-// finishes.
-class ProcessingLock {
- public:
-  ProcessingLock() { ::InterlockedIncrement(&op_count_); }
-  ~ProcessingLock() { ::InterlockedDecrement(&op_count_); }
-  static bool IsWorking() { return (op_count_ != 0); }
-
- private:
-  static volatile LONG op_count_;
-};
-
-volatile LONG ProcessingLock::op_count_ = 0;
-
-// This structure contains the information that the worker thread needs to
-// send a crash dump to the server.
-struct DumpJobInfo {
-  DWORD pid;
-  CrashService* self;
-  CrashMap map;
-  std::wstring dump_path;
-
-  DumpJobInfo(DWORD process_id,
-              CrashService* service,
-              const CrashMap& crash_map,
-              const std::wstring& path)
-      : pid(process_id), self(service), map(crash_map), dump_path(path) {}
-};
-
-}  // namespace
-
-// Command line switches:
-const char CrashService::kMaxReports[] = "max-reports";
-const char CrashService::kNoWindow[] = "no-window";
-const char CrashService::kReporterTag[] = "reporter";
-const char CrashService::kDumpsDir[] = "dumps-dir";
-const char CrashService::kPipeName[] = "pipe-name";
-const char CrashService::kReporterURL[] = "reporter-url";
-
-CrashService::CrashService() {}
-
-CrashService::~CrashService() {
-  base::AutoLock lock(sending_);
-  delete dumper_;
-  delete sender_;
-}
-
-bool CrashService::Initialize(const base::string16& application_name,
-                              const base::FilePath& operating_dir,
-                              const base::FilePath& dumps_path) {
-  using google_breakpad::CrashGenerationServer;
-  using google_breakpad::CrashReportSender;
-
-  std::wstring pipe_name = kTestPipeName;
-  int max_reports = -1;
-
-  // The checkpoint file allows CrashReportSender to enforce the maximum
-  // reports per day quota. Does not seem to serve any other purpose.
-  base::FilePath checkpoint_path = operating_dir.Append(kCheckPointFile);
-
-  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
-
-  base::FilePath dumps_path_to_use = dumps_path;
-
-  if (cmd_line.HasSwitch(kDumpsDir)) {
-    dumps_path_to_use =
-        base::FilePath(cmd_line.GetSwitchValueNative(kDumpsDir));
-  }
-
-  // We can override the send reports quota with a command line switch.
-  if (cmd_line.HasSwitch(kMaxReports))
-    max_reports = _wtoi(cmd_line.GetSwitchValueNative(kMaxReports).c_str());
-
-  // Allow the global pipe name to be overridden for better testability.
-  if (cmd_line.HasSwitch(kPipeName))
-    pipe_name = cmd_line.GetSwitchValueNative(kPipeName);
-
-  if (max_reports > 0) {
-    // Create the http sender object.
-    sender_ = new CrashReportSender(checkpoint_path.value());
-    sender_->set_max_reports_per_day(max_reports);
-  }
-
-  SECURITY_ATTRIBUTES security_attributes = {0};
-  SECURITY_DESCRIPTOR* security_descriptor =
-      reinterpret_cast<SECURITY_DESCRIPTOR*>(
-          GetSecurityDescriptorForLowIntegrity());
-  DCHECK(security_descriptor != NULL);
-
-  security_attributes.nLength = sizeof(security_attributes);
-  security_attributes.lpSecurityDescriptor = security_descriptor;
-  security_attributes.bInheritHandle = FALSE;
-
-  // Create the OOP crash generator object.
-  dumper_ = new CrashGenerationServer(
-      pipe_name, &security_attributes, &CrashService::OnClientConnected, this,
-      &CrashService::OnClientDumpRequest, this, &CrashService::OnClientExited,
-      this, NULL, NULL, true, &dumps_path_to_use.value());
-
-  if (!dumper_) {
-    LOG(ERROR) << "could not create dumper";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  if (!CreateTopWindow(::GetModuleHandleW(NULL), application_name,
-                       !cmd_line.HasSwitch(kNoWindow))) {
-    LOG(ERROR) << "could not create window";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  reporter_tag_ = L"crash svc";
-  if (cmd_line.HasSwitch(kReporterTag))
-    reporter_tag_ = cmd_line.GetSwitchValueNative(kReporterTag);
-
-  reporter_url_ = kGoogleReportURL;
-  if (cmd_line.HasSwitch(kReporterURL))
-    reporter_url_ = cmd_line.GetSwitchValueNative(kReporterURL);
-
-  // Log basic information.
-  VLOG(1) << "pipe name is " << pipe_name << "\ndumps at "
-          << dumps_path_to_use.value();
-
-  if (sender_) {
-    VLOG(1) << "checkpoint is " << checkpoint_path.value() << "\nserver is "
-            << reporter_url_ << "\nmaximum " << sender_->max_reports_per_day()
-            << " reports/day"
-            << "\nreporter is " << reporter_tag_;
-  }
-  // Start servicing clients.
-  if (!dumper_->Start()) {
-    LOG(ERROR) << "could not start dumper";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  if (security_attributes.lpSecurityDescriptor)
-    LocalFree(security_attributes.lpSecurityDescriptor);
-
-  // Create or open an event to signal the browser process that the crash
-  // service is initialized.
-  base::string16 wait_name =
-      base::ReplaceStringPlaceholders(kWaitEventFormat, application_name, NULL);
-  HANDLE wait_event = ::CreateEventW(NULL, TRUE, TRUE, wait_name.c_str());
-  ::SetEvent(wait_event);
-
-  return true;
-}
-
-void CrashService::OnClientConnected(
-    void* context,
-    const google_breakpad::ClientInfo* client_info) {
-  ProcessingLock lock;
-  VLOG(1) << "client start. pid = " << client_info->pid();
-  CrashService* self = static_cast<CrashService*>(context);
-  ::InterlockedIncrement(&self->clients_connected_);
-}
-
-void CrashService::OnClientExited(
-    void* context,
-    const google_breakpad::ClientInfo* client_info) {
-  ProcessingLock processing_lock;
-  VLOG(1) << "client end. pid = " << client_info->pid();
-  CrashService* self = static_cast<CrashService*>(context);
-  ::InterlockedIncrement(&self->clients_terminated_);
-
-  if (!self->sender_)
-    return;
-
-  // When we are instructed to send reports we need to exit if there are
-  // no more clients to service. The next client that runs will start us.
-  // Only chrome.exe starts crash_service with a non-zero max_reports.
-  if (self->clients_connected_ > self->clients_terminated_)
-    return;
-  if (self->sender_->max_reports_per_day() > 0) {
-    // Wait for the other thread to send crashes, if applicable. The sender
-    // thread takes the sending_ lock, so the sleep is just to give it a
-    // chance to start.
-    ::Sleep(1000);
-    base::AutoLock lock(self->sending_);
-    // Some people can restart chrome very fast, check again if we have
-    // a new client before exiting for real.
-    if (self->clients_connected_ == self->clients_terminated_) {
-      VLOG(1) << "zero clients. exiting";
-      ::PostMessage(g_top_window, WM_CLOSE, 0, 0);
-    }
-  }
-}
-
-void CrashService::OnClientDumpRequest(
-    void* context,
-    const google_breakpad::ClientInfo* client_info,
-    const std::wstring* file_path) {
-  ProcessingLock lock;
-
-  if (!file_path) {
-    LOG(ERROR) << "dump with no file path";
-    return;
-  }
-  if (!client_info) {
-    LOG(ERROR) << "dump with no client info";
-    return;
-  }
-
-  CrashService* self = static_cast<CrashService*>(context);
-  if (!self) {
-    LOG(ERROR) << "dump with no context";
-    return;
-  }
-
-  CrashMap map;
-  CustomInfoToMap(client_info, self->reporter_tag_, &map);
-
-  // Move dump file to the directory under client breakpad dump location.
-  base::FilePath dump_location = base::FilePath(*file_path);
-  CrashMap::const_iterator it = map.find(L"breakpad-dump-location");
-  if (it != map.end()) {
-    base::FilePath alternate_dump_location = base::FilePath(it->second);
-    base::CreateDirectoryW(alternate_dump_location);
-    alternate_dump_location =
-        alternate_dump_location.Append(dump_location.BaseName());
-    base::Move(dump_location, alternate_dump_location);
-    dump_location = alternate_dump_location;
-  }
-
-  DWORD pid = client_info->pid();
-  VLOG(1) << "dump for pid = " << pid << " is " << dump_location.value();
-
-  if (!WriteCustomInfoToFile(dump_location.value(), map)) {
-    LOG(ERROR) << "could not write custom info file";
-  }
-
-  if (!self->sender_ || map.find(L"skip_upload") != map.end())
-    return;
-
-  // Send the crash dump using a worker thread. This operation has retry
-  // logic in case there is no internet connection at the time.
-  DumpJobInfo* dump_job =
-      new DumpJobInfo(pid, self, map, dump_location.value());
-  if (!::QueueUserWorkItem(&CrashService::AsyncSendDump, dump_job,
-                           WT_EXECUTELONGFUNCTION)) {
-    LOG(ERROR) << "could not queue job";
-  }
-}
-
-// We are going to try sending the report several times. If we can't send,
-// we sleep from one minute to several hours depending on the retry round.
-DWORD CrashService::AsyncSendDump(void* context) {
-  if (!context)
-    return 0;
-
-  DumpJobInfo* info = static_cast<DumpJobInfo*>(context);
-
-  std::wstring report_id = L"<unsent>";
-
-  const DWORD kOneMinute = 60 * 1000;
-  const DWORD kOneHour = 60 * kOneMinute;
-
-  const DWORD kSleepSchedule[] = {24 * kOneHour, 8 * kOneHour,    4 * kOneHour,
-                                  kOneHour,      15 * kOneMinute, 0};
-
-  int retry_round = arraysize(kSleepSchedule) - 1;
-
-  do {
-    ::Sleep(kSleepSchedule[retry_round]);
-    {
-      // Take the server lock while sending. This also prevent early
-      // termination of the service object.
-      base::AutoLock lock(info->self->sending_);
-      VLOG(1) << "trying to send report for pid = " << info->pid;
-      std::map<std::wstring, std::wstring> file_map;
-      file_map[L"upload_file_minidump"] = info->dump_path;
-      google_breakpad::ReportResult send_result =
-          info->self->sender_->SendCrashReport(info->self->reporter_url_,
-                                               info->map, file_map, &report_id);
-      switch (send_result) {
-        case google_breakpad::RESULT_FAILED:
-          report_id = L"<network issue>";
-          break;
-        case google_breakpad::RESULT_REJECTED:
-          report_id = L"<rejected>";
-          ++info->self->requests_handled_;
-          retry_round = 0;
-          break;
-        case google_breakpad::RESULT_SUCCEEDED:
-          ++info->self->requests_sent_;
-          ++info->self->requests_handled_;
-          retry_round = 0;
-          WriteReportIDToFile(info->dump_path, report_id);
-          break;
-        case google_breakpad::RESULT_THROTTLED:
-          report_id = L"<throttled>";
-          break;
-        default:
-          report_id = L"<unknown>";
-          break;
-      }
-    }
-
-    VLOG(1) << "dump for pid =" << info->pid << " crash2 id =" << report_id;
-    --retry_round;
-  } while (retry_round >= 0);
-
-  if (!::DeleteFileW(info->dump_path.c_str()))
-    LOG(WARNING) << "could not delete " << info->dump_path;
-
-  delete info;
-  return 0;
-}
-
-int CrashService::ProcessingLoop() {
-  MSG msg;
-  while (GetMessage(&msg, NULL, 0, 0)) {
-    TranslateMessage(&msg);
-    DispatchMessage(&msg);
-  }
-
-  VLOG(1) << "session ending..";
-  while (ProcessingLock::IsWorking()) {
-    ::Sleep(50);
-  }
-
-  VLOG(1) << "clients connected :" << clients_connected_
-          << "\nclients terminated :" << clients_terminated_
-          << "\ndumps serviced :" << requests_handled_
-          << "\ndumps reported :" << requests_sent_;
-
-  return static_cast<int>(msg.wParam);
-}
-
-PSECURITY_DESCRIPTOR CrashService::GetSecurityDescriptorForLowIntegrity() {
-  // Build the SDDL string for the label.
-  std::wstring sddl = L"S:(ML;;NW;;;S-1-16-4096)";
-
-  PSECURITY_DESCRIPTOR sec_desc = NULL;
-
-  PACL sacl = NULL;
-  BOOL sacl_present = FALSE;
-  BOOL sacl_defaulted = FALSE;
-
-  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(
-          sddl.c_str(), SDDL_REVISION, &sec_desc, NULL)) {
-    if (::GetSecurityDescriptorSacl(sec_desc, &sacl_present, &sacl,
-                                    &sacl_defaulted)) {
-      return sec_desc;
-    }
-  }
-
-  return NULL;
-}
-
-}  // namespace breakpad
removed in remote
  base   100644 c05e0d5bf6e453950f584bc44a911ecaea55fe84 atom/common/crash_reporter/win/crash_service.h
  our    100644 93bbb7c36de3d256acae5ff8dfaa447f8a438b14 atom/common/crash_reporter/win/crash_service.h
@@ -1,130 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
-#define ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
-
-#include <string>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/synchronization/lock.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#endif  // defined(OS_WIN)
-
-namespace google_breakpad {
-
-class CrashReportSender;
-class CrashGenerationServer;
-class ClientInfo;
-
-}  // namespace google_breakpad
-
-namespace breakpad {
-
-// This class implements an out-of-process crash server. It uses breakpad's
-// CrashGenerationServer and CrashReportSender to generate and then send the
-// crash dumps. Internally, it uses OS specific pipe to allow applications to
-// register for crash dumps and later on when a registered application crashes
-// it will signal an event that causes this code to wake up and perform a
-// crash dump on the signaling process. The dump is then stored on disk and
-// possibly sent to the crash2 servers.
-class CrashService {
- public:
-  CrashService();
-  ~CrashService();
-
-  // Starts servicing crash dumps. Returns false if it failed. Do not use
-  // other members in that case. |operating_dir| is where the CrashService
-  // should store breakpad's checkpoint file. |dumps_path| is the directory
-  // where the crash dumps should be stored.
-  bool Initialize(const base::string16& application_name,
-                  const base::FilePath& operating_dir,
-                  const base::FilePath& dumps_path);
-
-  // Command line switches:
-  //
-  // --max-reports=<number>
-  // Allows to override the maximum number for reports per day. Normally
-  // the crash dumps are never sent so if you want to send any you must
-  // specify a positive number here.
-  static const char kMaxReports[];
-  // --no-window
-  // Does not create a visible window on the desktop. The window does not have
-  // any other functionality other than allowing the crash service to be
-  // gracefully closed.
-  static const char kNoWindow[];
-  // --reporter=<string>
-  // Allows to specify a custom string that appears on the detail crash report
-  // page in the crash server. This should be a 25 chars or less string.
-  // The default tag if not specified is 'crash svc'.
-  static const char kReporterTag[];
-  // --dumps-dir=<directory-path>
-  // Override the directory to which crash dump files will be written.
-  static const char kDumpsDir[];
-  // --pipe-name=<string>
-  // Override the name of the Windows named pipe on which we will
-  // listen for crash dump request messages.
-  static const char kPipeName[];
-  // --reporter-url=<string>
-  // Override the URL to which crash reports will be sent to.
-  static const char kReporterURL[];
-
-  // Returns number of crash dumps handled.
-  int requests_handled() const { return requests_handled_; }
-  // Returns number of crash clients registered.
-  int clients_connected() const { return clients_connected_; }
-  // Returns number of crash clients terminated.
-  int clients_terminated() const { return clients_terminated_; }
-
-  // Starts the processing loop. This function does not return unless the
-  // user is logging off or the user closes the crash service window. The
-  // return value is a good number to pass in ExitProcess().
-  int ProcessingLoop();
-
- private:
-  static void OnClientConnected(void* context,
-                                const google_breakpad::ClientInfo* client_info);
-
-  static void OnClientDumpRequest(
-      void* context,
-      const google_breakpad::ClientInfo* client_info,
-      const std::wstring* file_path);
-
-  static void OnClientExited(void* context,
-                             const google_breakpad::ClientInfo* client_info);
-
-  // This routine sends the crash dump to the server. It takes the sending_
-  // lock when it is performing the send.
-  static DWORD __stdcall AsyncSendDump(void* context);
-
-  // Returns the security descriptor which access to low integrity processes
-  // The caller is supposed to free the security descriptor by calling
-  // LocalFree.
-  PSECURITY_DESCRIPTOR GetSecurityDescriptorForLowIntegrity();
-
-  google_breakpad::CrashGenerationServer* dumper_ = nullptr;
-  google_breakpad::CrashReportSender* sender_ = nullptr;
-
-  // the extra tag sent to the server with each dump.
-  std::wstring reporter_tag_;
-
-  // receiver URL of crash reports.
-  std::wstring reporter_url_;
-
-  // clients serviced statistics:
-  int requests_handled_ = 0;
-  int requests_sent_ = 0;
-  volatile LONG clients_connected_ = 0;
-  volatile LONG clients_terminated_ = 0;
-  base::Lock sending_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashService);
-};
-
-}  // namespace breakpad
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
removed in remote
  base   100644 56d46970b67f7843328e291f15ab07ddead8aced atom/common/crash_reporter/win/crash_service_main.cc
  our    100644 c25ee858de0b5fd87229f3cfd658f7dd3e4f90c6 atom/common/crash_reporter/win/crash_service_main.cc
@@ -1,104 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/win/crash_service_main.h"
-
-#include "atom/common/crash_reporter/win/crash_service.h"
-#include "base/at_exit.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-
-namespace crash_service {
-
-namespace {
-
-const char kApplicationName[] = "application-name";
-const char kCrashesDirectory[] = "crashes-directory";
-
-const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
-const wchar_t kStandardLogFile[] = L"operation_log.txt";
-
-void InvalidParameterHandler(const wchar_t*,
-                             const wchar_t*,
-                             const wchar_t*,
-                             unsigned int,
-                             uintptr_t) {
-  // noop.
-}
-
-bool CreateCrashServiceDirectory(const base::FilePath& temp_dir) {
-  if (!base::PathExists(temp_dir)) {
-    if (!base::CreateDirectory(temp_dir))
-      return false;
-  }
-  return true;
-}
-
-}  // namespace.
-
-int Main(const wchar_t* cmd) {
-  // Ignore invalid parameter errors.
-  _set_invalid_parameter_handler(InvalidParameterHandler);
-
-  // Initialize all Chromium things.
-  base::AtExitManager exit_manager;
-  base::CommandLine::Init(0, NULL);
-  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
-
-  // Use the application's name as pipe name and output directory.
-  if (!cmd_line.HasSwitch(kApplicationName)) {
-    LOG(ERROR) << "Application's name must be specified with --"
-               << kApplicationName;
-    return 1;
-  }
-  std::wstring application_name =
-      cmd_line.GetSwitchValueNative(kApplicationName);
-
-  if (!cmd_line.HasSwitch(kCrashesDirectory)) {
-    LOG(ERROR) << "Crashes directory path must be specified with --"
-               << kCrashesDirectory;
-    return 1;
-  }
-
-  // We use/create a directory under the user's temp folder, for logging.
-  base::FilePath operating_dir(
-      cmd_line.GetSwitchValueNative(kCrashesDirectory));
-  CreateCrashServiceDirectory(operating_dir);
-  base::FilePath log_file = operating_dir.Append(kStandardLogFile);
-
-  // Logging to stderr (to help with debugging failures on the
-  // buildbots) and to a file.
-  logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_ALL;
-  settings.log_file = log_file.value().c_str();
-  logging::InitLogging(settings);
-  // Logging with pid, tid and timestamp.
-  logging::SetLogItems(true, true, true, false);
-
-  VLOG(1) << "Session start. cmdline is [" << cmd << "]";
-
-  // Setting the crash reporter.
-  base::string16 pipe_name =
-      base::ReplaceStringPlaceholders(kPipeNameFormat, application_name, NULL);
-  cmd_line.AppendSwitch("no-window");
-  cmd_line.AppendSwitchASCII("max-reports", "128");
-  cmd_line.AppendSwitchASCII("reporter", ATOM_PROJECT_NAME "-crash-service");
-  cmd_line.AppendSwitchNative("pipe-name", pipe_name);
-
-  breakpad::CrashService crash_service;
-  if (!crash_service.Initialize(application_name, operating_dir, operating_dir))
-    return 2;
-
-  VLOG(1) << "Ready to process crash requests";
-
-  // Enter the message loop.
-  int retv = crash_service.ProcessingLoop();
-  // Time to exit.
-  VLOG(1) << "Session end. return code is " << retv;
-  return retv;
-}
-
-}  // namespace crash_service
removed in remote
  base   100644 b536313dbc3213ab3c2666db50c80c1984ebace7 atom/common/crash_reporter/win/crash_service_main.h
  our    100644 b536313dbc3213ab3c2666db50c80c1984ebace7 atom/common/crash_reporter/win/crash_service_main.h
@@ -1,15 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
-#define ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
-
-namespace crash_service {
-
-// Program entry, should be called by main();
-int Main(const wchar_t* cmd_line);
-
-}  // namespace crash_service
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
removed in remote
  base   100644 f57719448a088e11cf173d69fb5b1dc17288e8e1 atom/common/draggable_region.cc
  our    100644 a571b2edf2b2937f8a4ddf30fc42fc927792a749 atom/common/draggable_region.cc
@@ -1,11 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/draggable_region.h"
-
-namespace atom {
-
-DraggableRegion::DraggableRegion() : draggable(false) {}
-
-}  // namespace atom
removed in remote
  base   100644 a007c8cb9fe54c9ae25438437ea95dc790d4bc33 atom/common/draggable_region.h
  our    100644 a007c8cb9fe54c9ae25438437ea95dc790d4bc33 atom/common/draggable_region.h
@@ -1,21 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_DRAGGABLE_REGION_H_
-#define ATOM_COMMON_DRAGGABLE_REGION_H_
-
-#include "ui/gfx/geometry/rect.h"
-
-namespace atom {
-
-struct DraggableRegion {
-  bool draggable;
-  gfx::Rect bounds;
-
-  DraggableRegion();
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_DRAGGABLE_REGION_H_
removed in remote
  base   100644 dc38272ec611ff47127cb7b4cc4e006a4eb9ac15 atom/common/google_api_key.h
  our    100644 d27934595eac9e442564ab4b6e04c092ca92a605 atom/common/google_api_key.h
@@ -1,17 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_GOOGLE_API_KEY_H_
-#define ATOM_COMMON_GOOGLE_API_KEY_H_
-
-#ifndef GOOGLEAPIS_ENDPOINT
-#define GOOGLEAPIS_ENDPOINT \
-  "https://www.googleapis.com/geolocation/v1/geolocate?key="
-#endif
-
-#ifndef GOOGLEAPIS_API_KEY
-#define GOOGLEAPIS_API_KEY "AIzaSyAQfxPJiounkhOjODEO5ZieffeBv6yft2Q"
-#endif
-
-#endif  // ATOM_COMMON_GOOGLE_API_KEY_H_
removed in remote
  base   100644 d860bc0c46c767f57b3c57632ea055d105042b1f atom/common/keyboard_util.cc
  our    100644 d0a12cb6d91b9688c1bed496e64d6bbaccaf244a atom/common/keyboard_util.cc
@@ -1,325 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-
-#include "atom/common/keyboard_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "ui/events/event_constants.h"
-
-namespace atom {
-
-namespace {
-
-// Return key code of the char, and also determine whether the SHIFT key is
-// pressed.
-ui::KeyboardCode KeyboardCodeFromCharCode(base::char16 c, bool* shifted) {
-  c = base::ToLowerASCII(c);
-  *shifted = false;
-  switch (c) {
-    case 0x08:
-      return ui::VKEY_BACK;
-    case 0x7F:
-      return ui::VKEY_DELETE;
-    case 0x09:
-      return ui::VKEY_TAB;
-    case 0x0D:
-      return ui::VKEY_RETURN;
-    case 0x1B:
-      return ui::VKEY_ESCAPE;
-    case ' ':
-      return ui::VKEY_SPACE;
-
-    case 'a':
-      return ui::VKEY_A;
-    case 'b':
-      return ui::VKEY_B;
-    case 'c':
-      return ui::VKEY_C;
-    case 'd':
-      return ui::VKEY_D;
-    case 'e':
-      return ui::VKEY_E;
-    case 'f':
-      return ui::VKEY_F;
-    case 'g':
-      return ui::VKEY_G;
-    case 'h':
-      return ui::VKEY_H;
-    case 'i':
-      return ui::VKEY_I;
-    case 'j':
-      return ui::VKEY_J;
-    case 'k':
-      return ui::VKEY_K;
-    case 'l':
-      return ui::VKEY_L;
-    case 'm':
-      return ui::VKEY_M;
-    case 'n':
-      return ui::VKEY_N;
-    case 'o':
-      return ui::VKEY_O;
-    case 'p':
-      return ui::VKEY_P;
-    case 'q':
-      return ui::VKEY_Q;
-    case 'r':
-      return ui::VKEY_R;
-    case 's':
-      return ui::VKEY_S;
-    case 't':
-      return ui::VKEY_T;
-    case 'u':
-      return ui::VKEY_U;
-    case 'v':
-      return ui::VKEY_V;
-    case 'w':
-      return ui::VKEY_W;
-    case 'x':
-      return ui::VKEY_X;
-    case 'y':
-      return ui::VKEY_Y;
-    case 'z':
-      return ui::VKEY_Z;
-
-    case ')':
-      *shifted = true;
-      FALLTHROUGH;
-    case '0':
-      return ui::VKEY_0;
-    case '!':
-      *shifted = true;
-      FALLTHROUGH;
-    case '1':
-      return ui::VKEY_1;
-    case '@':
-      *shifted = true;
-      FALLTHROUGH;
-    case '2':
-      return ui::VKEY_2;
-    case '#':
-      *shifted = true;
-      FALLTHROUGH;
-    case '3':
-      return ui::VKEY_3;
-    case '$':
-      *shifted = true;
-      FALLTHROUGH;
-    case '4':
-      return ui::VKEY_4;
-    case '%':
-      *shifted = true;
-      FALLTHROUGH;
-    case '5':
-      return ui::VKEY_5;
-    case '^':
-      *shifted = true;
-      FALLTHROUGH;
-    case '6':
-      return ui::VKEY_6;
-    case '&':
-      *shifted = true;
-      FALLTHROUGH;
-    case '7':
-      return ui::VKEY_7;
-    case '*':
-      *shifted = true;
-      FALLTHROUGH;
-    case '8':
-      return ui::VKEY_8;
-    case '(':
-      *shifted = true;
-      FALLTHROUGH;
-    case '9':
-      return ui::VKEY_9;
-
-    case ':':
-      *shifted = true;
-      FALLTHROUGH;
-    case ';':
-      return ui::VKEY_OEM_1;
-    case '+':
-      *shifted = true;
-      FALLTHROUGH;
-    case '=':
-      return ui::VKEY_OEM_PLUS;
-    case '<':
-      *shifted = true;
-      FALLTHROUGH;
-    case ',':
-      return ui::VKEY_OEM_COMMA;
-    case '_':
-      *shifted = true;
-      FALLTHROUGH;
-    case '-':
-      return ui::VKEY_OEM_MINUS;
-    case '>':
-      *shifted = true;
-      FALLTHROUGH;
-    case '.':
-      return ui::VKEY_OEM_PERIOD;
-    case '?':
-      *shifted = true;
-      FALLTHROUGH;
-    case '/':
-      return ui::VKEY_OEM_2;
-    case '~':
-      *shifted = true;
-      FALLTHROUGH;
-    case '`':
-      return ui::VKEY_OEM_3;
-    case '{':
-      *shifted = true;
-      FALLTHROUGH;
-    case '[':
-      return ui::VKEY_OEM_4;
-    case '|':
-      *shifted = true;
-      FALLTHROUGH;
-    case '\\':
-      return ui::VKEY_OEM_5;
-    case '}':
-      *shifted = true;
-      FALLTHROUGH;
-    case ']':
-      return ui::VKEY_OEM_6;
-    case '"':
-      *shifted = true;
-      FALLTHROUGH;
-    case '\'':
-      return ui::VKEY_OEM_7;
-
-    default:
-      return ui::VKEY_UNKNOWN;
-  }
-}
-
-// Return key code represented by |str|.
-ui::KeyboardCode KeyboardCodeFromKeyIdentifier(const std::string& s,
-                                               bool* shifted) {
-  std::string str = base::ToLowerASCII(s);
-  if (str == "ctrl" || str == "control") {
-    return ui::VKEY_CONTROL;
-  } else if (str == "super" || str == "cmd" || str == "command" ||
-             str == "meta") {
-    return ui::VKEY_COMMAND;
-  } else if (str == "commandorcontrol" || str == "cmdorctrl") {
-#if defined(OS_MACOSX)
-    return ui::VKEY_COMMAND;
-#else
-    return ui::VKEY_CONTROL;
-#endif
-  } else if (str == "alt" || str == "option") {
-    return ui::VKEY_MENU;
-  } else if (str == "shift") {
-    return ui::VKEY_SHIFT;
-  } else if (str == "altgr") {
-    return ui::VKEY_ALTGR;
-  } else if (str == "plus") {
-    *shifted = true;
-    return ui::VKEY_OEM_PLUS;
-  } else if (str == "tab") {
-    return ui::VKEY_TAB;
-  } else if (str == "space") {
-    return ui::VKEY_SPACE;
-  } else if (str == "backspace") {
-    return ui::VKEY_BACK;
-  } else if (str == "delete") {
-    return ui::VKEY_DELETE;
-  } else if (str == "insert") {
-    return ui::VKEY_INSERT;
-  } else if (str == "enter" || str == "return") {
-    return ui::VKEY_RETURN;
-  } else if (str == "up") {
-    return ui::VKEY_UP;
-  } else if (str == "down") {
-    return ui::VKEY_DOWN;
-  } else if (str == "left") {
-    return ui::VKEY_LEFT;
-  } else if (str == "right") {
-    return ui::VKEY_RIGHT;
-  } else if (str == "home") {
-    return ui::VKEY_HOME;
-  } else if (str == "end") {
-    return ui::VKEY_END;
-  } else if (str == "pageup") {
-    return ui::VKEY_PRIOR;
-  } else if (str == "pagedown") {
-    return ui::VKEY_NEXT;
-  } else if (str == "esc" || str == "escape") {
-    return ui::VKEY_ESCAPE;
-  } else if (str == "volumemute") {
-    return ui::VKEY_VOLUME_MUTE;
-  } else if (str == "volumeup") {
-    return ui::VKEY_VOLUME_UP;
-  } else if (str == "volumedown") {
-    return ui::VKEY_VOLUME_DOWN;
-  } else if (str == "medianexttrack") {
-    return ui::VKEY_MEDIA_NEXT_TRACK;
-  } else if (str == "mediaprevioustrack") {
-    return ui::VKEY_MEDIA_PREV_TRACK;
-  } else if (str == "mediastop") {
-    return ui::VKEY_MEDIA_STOP;
-  } else if (str == "mediaplaypause") {
-    return ui::VKEY_MEDIA_PLAY_PAUSE;
-  } else if (str == "printscreen") {
-    return ui::VKEY_SNAPSHOT;
-  } else if (str.size() > 1 && str[0] == 'f') {
-    // F1 - F24.
-    int n;
-    if (base::StringToInt(str.c_str() + 1, &n) && n > 0 && n < 25) {
-      return static_cast<ui::KeyboardCode>(ui::VKEY_F1 + n - 1);
-    } else {
-      LOG(WARNING) << str << "is not available on keyboard";
-      return ui::VKEY_UNKNOWN;
-    }
-  } else {
-    if (str.size() > 2)
-      LOG(WARNING) << "Invalid accelerator token: " << str;
-    return ui::VKEY_UNKNOWN;
-  }
-}
-
-}  // namespace
-
-ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted) {
-  if (str.size() == 1)
-    return KeyboardCodeFromCharCode(str[0], shifted);
-  else
-    return KeyboardCodeFromKeyIdentifier(str, shifted);
-}
-
-int WebEventModifiersToEventFlags(int modifiers) {
-  int flags = 0;
-
-  if (modifiers & blink::WebInputEvent::kShiftKey)
-    flags |= ui::EF_SHIFT_DOWN;
-  if (modifiers & blink::WebInputEvent::kControlKey)
-    flags |= ui::EF_CONTROL_DOWN;
-  if (modifiers & blink::WebInputEvent::kAltKey)
-    flags |= ui::EF_ALT_DOWN;
-  if (modifiers & blink::WebInputEvent::kMetaKey)
-    flags |= ui::EF_COMMAND_DOWN;
-  if (modifiers & blink::WebInputEvent::kCapsLockOn)
-    flags |= ui::EF_CAPS_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kNumLockOn)
-    flags |= ui::EF_NUM_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kScrollLockOn)
-    flags |= ui::EF_SCROLL_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kLeftButtonDown)
-    flags |= ui::EF_LEFT_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kMiddleButtonDown)
-    flags |= ui::EF_MIDDLE_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kRightButtonDown)
-    flags |= ui::EF_RIGHT_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kIsAutoRepeat)
-    flags |= ui::EF_IS_REPEAT;
-
-  return flags;
-}
-
-}  // namespace atom
removed in remote
  base   100644 c9d1b809e8f7cebf3b0fea0cded6d09364ee20e1 atom/common/keyboard_util.h
  our    100644 651cf6a92024cc06d7d0e044efda744e70848479 atom/common/keyboard_util.h
@@ -1,23 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_KEYBOARD_UTIL_H_
-#define ATOM_COMMON_KEYBOARD_UTIL_H_
-
-#include <string>
-
-#include "ui/events/keycodes/keyboard_codes.h"
-
-namespace atom {
-
-// Return key code of the |str|, and also determine whether the SHIFT key is
-// pressed.
-ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted);
-
-// Ported from ui/events/blink/blink_event_util.h
-int WebEventModifiersToEventFlags(int modifiers);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_KEYBOARD_UTIL_H_
removed in remote
  base   100644 053bd4bb8634ccdc9903ec18cffa8ecdce410eaa atom/common/linux/application_info.cc
  our    100644 3354c73b8b60f77cf054f975ea713d96b7e7683e atom/common/linux/application_info.cc
@@ -1,79 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "brightray/common/application_info.h"
-
-#include <gio/gdesktopappinfo.h>
-#include <gio/gio.h>
-
-#include <memory>
-#include <string>
-
-#include "atom/common/atom_version.h"
-#include "base/environment.h"
-#include "base/logging.h"
-#include "brightray/common/platform_util.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-
-namespace {
-
-GDesktopAppInfo* get_desktop_app_info() {
-  GDesktopAppInfo* ret = nullptr;
-
-  std::string desktop_id;
-  if (brightray::platform_util::GetDesktopName(&desktop_id))
-    ret = g_desktop_app_info_new(desktop_id.c_str());
-
-  return ret;
-}
-
-}  // namespace
-
-namespace brightray {
-
-std::string GetApplicationName() {
-  // attempt #1: the string set in app.setName()
-  std::string ret = GetOverriddenApplicationName();
-
-  // attempt #2: the 'Name' entry from .desktop file's [Desktop] section
-  if (ret.empty()) {
-    GDesktopAppInfo* info = get_desktop_app_info();
-    if (info != nullptr) {
-      char* str = g_desktop_app_info_get_string(info, "Name");
-      g_clear_object(&info);
-      if (str != nullptr)
-        ret = str;
-      g_clear_pointer(&str, g_free);
-    }
-  }
-
-  // attempt #3: Electron's name
-  if (ret.empty()) {
-    ret = ATOM_PRODUCT_NAME;
-  }
-
-  return ret;
-}
-
-std::string GetApplicationVersion() {
-  std::string ret;
-
-  // ensure ATOM_PRODUCT_NAME and ATOM_PRODUCT_STRING match up
-  if (GetApplicationName() == ATOM_PRODUCT_NAME)
-    ret = ATOM_VERSION_STRING;
-
-  // try to use the string set in app.setVersion()
-  if (ret.empty())
-    ret = GetOverriddenApplicationVersion();
-
-  // no known version number; return some safe fallback
-  if (ret.empty()) {
-    LOG(WARNING) << "No version found. Was app.setVersion() called?";
-    ret = "0.0";
-  }
-
-  return ret;
-}
-
-}  // namespace brightray
removed in remote
  base   100644 69aadaa7a0464fc43e72d6826aad7ac513b39c24 atom/common/mouse_util.cc
  our    100644 d87be5b504e153e06dfd38965e262c6d630853a9 atom/common/mouse_util.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/mouse_util.h"
-#include <string>
-
-using Cursor = blink::WebCursorInfo::Type;
-
-namespace atom {
-
-std::string CursorTypeToString(const content::CursorInfo& info) {
-  switch (info.type) {
-    case Cursor::kTypePointer:
-      return "default";
-    case Cursor::kTypeCross:
-      return "crosshair";
-    case Cursor::kTypeHand:
-      return "pointer";
-    case Cursor::kTypeIBeam:
-      return "text";
-    case Cursor::kTypeWait:
-      return "wait";
-    case Cursor::kTypeHelp:
-      return "help";
-    case Cursor::kTypeEastResize:
-      return "e-resize";
-    case Cursor::kTypeNorthResize:
-      return "n-resize";
-    case Cursor::kTypeNorthEastResize:
-      return "ne-resize";
-    case Cursor::kTypeNorthWestResize:
-      return "nw-resize";
-    case Cursor::kTypeSouthResize:
-      return "s-resize";
-    case Cursor::kTypeSouthEastResize:
-      return "se-resize";
-    case Cursor::kTypeSouthWestResize:
-      return "sw-resize";
-    case Cursor::kTypeWestResize:
-      return "w-resize";
-    case Cursor::kTypeNorthSouthResize:
-      return "ns-resize";
-    case Cursor::kTypeEastWestResize:
-      return "ew-resize";
-    case Cursor::kTypeNorthEastSouthWestResize:
-      return "nesw-resize";
-    case Cursor::kTypeNorthWestSouthEastResize:
-      return "nwse-resize";
-    case Cursor::kTypeColumnResize:
-      return "col-resize";
-    case Cursor::kTypeRowResize:
-      return "row-resize";
-    case Cursor::kTypeMiddlePanning:
-      return "m-panning";
-    case Cursor::kTypeEastPanning:
-      return "e-panning";
-    case Cursor::kTypeNorthPanning:
-      return "n-panning";
-    case Cursor::kTypeNorthEastPanning:
-      return "ne-panning";
-    case Cursor::kTypeNorthWestPanning:
-      return "nw-panning";
-    case Cursor::kTypeSouthPanning:
-      return "s-panning";
-    case Cursor::kTypeSouthEastPanning:
-      return "se-panning";
-    case Cursor::kTypeSouthWestPanning:
-      return "sw-panning";
-    case Cursor::kTypeWestPanning:
-      return "w-panning";
-    case Cursor::kTypeMove:
-      return "move";
-    case Cursor::kTypeVerticalText:
-      return "vertical-text";
-    case Cursor::kTypeCell:
-      return "cell";
-    case Cursor::kTypeContextMenu:
-      return "context-menu";
-    case Cursor::kTypeAlias:
-      return "alias";
-    case Cursor::kTypeProgress:
-      return "progress";
-    case Cursor::kTypeNoDrop:
-      return "nodrop";
-    case Cursor::kTypeCopy:
-      return "copy";
-    case Cursor::kTypeNone:
-      return "none";
-    case Cursor::kTypeNotAllowed:
-      return "not-allowed";
-    case Cursor::kTypeZoomIn:
-      return "zoom-in";
-    case Cursor::kTypeZoomOut:
-      return "zoom-out";
-    case Cursor::kTypeGrab:
-      return "grab";
-    case Cursor::kTypeGrabbing:
-      return "grabbing";
-    case Cursor::kTypeCustom:
-      return "custom";
-    default:
-      return "default";
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 2fd937422dacbe184712e341fdb0c22d4fd1d7e0 atom/common/mouse_util.h
  our    100644 efc70eeb7bdfce0d8f4668c57f642b90e08769d4 atom/common/mouse_util.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_MOUSE_UTIL_H_
-#define ATOM_COMMON_MOUSE_UTIL_H_
-
-#include <string>
-#include "content/common/cursors/webcursor.h"
-#include "ipc/ipc_message_macros.h"
-
-// IPC macros similar to the already existing ones in the chromium source.
-// We need these to listen to the cursor change IPC message while still
-// letting chromium handle the actual cursor change by setting handled = false.
-#define IPC_MESSAGE_HANDLER_CODE(msg_class, member_func, code) \
-  IPC_MESSAGE_FORWARD_CODE(msg_class, this,                    \
-                           _IpcMessageHandlerClass::member_func, code)
-
-#define IPC_MESSAGE_FORWARD_CODE(msg_class, obj, member_func, code) \
-  case msg_class::ID: {                                             \
-    if (!msg_class::Dispatch(&ipc_message__, obj, this, param__,    \
-                             &member_func))                         \
-      ipc_message__.set_dispatch_error();                           \
-    code;                                                           \
-  } break;
-
-namespace atom {
-
-// Returns the cursor's type as a string.
-std::string CursorTypeToString(const content::CursorInfo& info);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_MOUSE_UTIL_H_
removed in remote
  base   100644 15eaafda2e3d51815f1398f6e510c0787d2bdf25 atom/common/native_mate_converters/accelerator_converter.cc
  our    100644 0958308871175b0afaa9f3ed450d77b437a0d317 atom/common/native_mate_converters/accelerator_converter.cc
@@ -1,23 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-
-#include <string>
-
-#include "atom/browser/ui/accelerator_util.h"
-
-namespace mate {
-
-// static
-bool Converter<ui::Accelerator>::FromV8(v8::Isolate* isolate,
-                                        v8::Local<v8::Value> val,
-                                        ui::Accelerator* out) {
-  std::string keycode;
-  if (!ConvertFromV8(isolate, val, &keycode))
-    return false;
-  return accelerator_util::StringToAccelerator(keycode, out);
-}
-
-}  // namespace mate
removed in remote
  base   100644 499077c08e287e6084356f0f216a54264d628f57 atom/common/native_mate_converters/accelerator_converter.h
  our    100644 f2f6b56e9851883fa45f0e0566de7318cc288f67 atom/common/native_mate_converters/accelerator_converter.h
@@ -1,25 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace ui {
-class Accelerator;
-}
-
-namespace mate {
-
-template <>
-struct Converter<ui::Accelerator> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ui::Accelerator* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
removed in remote
  base   100644 c58f830eb02e68eb2d06889cd026dbd3768673f2 atom/common/native_mate_converters/blink_converter.cc
  our    100644 f52ec9af2e405f3969453ac22cb402436610c317 atom/common/native_mate_converters/blink_converter.cc
@@ -1,544 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/blink_converter.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/common/keyboard_util.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/native_web_keyboard_event.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/platform/WebMouseEvent.h"
-#include "third_party/WebKit/public/platform/WebMouseWheelEvent.h"
-#include "third_party/WebKit/public/web/WebDeviceEmulationParams.h"
-#include "third_party/WebKit/public/web/WebFindOptions.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/events/keycodes/dom/keycode_converter.h"
-#include "ui/events/keycodes/keyboard_code_conversion.h"
-
-namespace {
-
-template <typename T>
-int VectorToBitArray(const std::vector<T>& vec) {
-  int bits = 0;
-  for (const T& item : vec)
-    bits |= item;
-  return bits;
-}
-
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<base::char16> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     base::char16* out) {
-    base::string16 code = base::UTF8ToUTF16(V8ToString(val));
-    if (code.length() != 1)
-      return false;
-    *out = code[0];
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebInputEvent::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebInputEvent::Type* out) {
-    std::string type = base::ToLowerASCII(V8ToString(val));
-    if (type == "mousedown")
-      *out = blink::WebInputEvent::kMouseDown;
-    else if (type == "mouseup")
-      *out = blink::WebInputEvent::kMouseUp;
-    else if (type == "mousemove")
-      *out = blink::WebInputEvent::kMouseMove;
-    else if (type == "mouseenter")
-      *out = blink::WebInputEvent::kMouseEnter;
-    else if (type == "mouseleave")
-      *out = blink::WebInputEvent::kMouseLeave;
-    else if (type == "contextmenu")
-      *out = blink::WebInputEvent::kContextMenu;
-    else if (type == "mousewheel")
-      *out = blink::WebInputEvent::kMouseWheel;
-    else if (type == "keydown")
-      *out = blink::WebInputEvent::kRawKeyDown;
-    else if (type == "keyup")
-      *out = blink::WebInputEvent::kKeyUp;
-    else if (type == "char")
-      *out = blink::WebInputEvent::kChar;
-    else if (type == "touchstart")
-      *out = blink::WebInputEvent::kTouchStart;
-    else if (type == "touchmove")
-      *out = blink::WebInputEvent::kTouchMove;
-    else if (type == "touchend")
-      *out = blink::WebInputEvent::kTouchEnd;
-    else if (type == "touchcancel")
-      *out = blink::WebInputEvent::kTouchCancel;
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebMouseEvent::Button> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebMouseEvent::Button* out) {
-    std::string button = base::ToLowerASCII(V8ToString(val));
-    if (button == "left")
-      *out = blink::WebMouseEvent::Button::kLeft;
-    else if (button == "middle")
-      *out = blink::WebMouseEvent::Button::kMiddle;
-    else if (button == "right")
-      *out = blink::WebMouseEvent::Button::kRight;
-    else
-      return false;
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebInputEvent::Modifiers> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebInputEvent::Modifiers* out) {
-    std::string modifier = base::ToLowerASCII(V8ToString(val));
-    if (modifier == "shift")
-      *out = blink::WebInputEvent::kShiftKey;
-    else if (modifier == "control" || modifier == "ctrl")
-      *out = blink::WebInputEvent::kControlKey;
-    else if (modifier == "alt")
-      *out = blink::WebInputEvent::kAltKey;
-    else if (modifier == "meta" || modifier == "command" || modifier == "cmd")
-      *out = blink::WebInputEvent::kMetaKey;
-    else if (modifier == "iskeypad")
-      *out = blink::WebInputEvent::kIsKeyPad;
-    else if (modifier == "isautorepeat")
-      *out = blink::WebInputEvent::kIsAutoRepeat;
-    else if (modifier == "leftbuttondown")
-      *out = blink::WebInputEvent::kLeftButtonDown;
-    else if (modifier == "middlebuttondown")
-      *out = blink::WebInputEvent::kMiddleButtonDown;
-    else if (modifier == "rightbuttondown")
-      *out = blink::WebInputEvent::kRightButtonDown;
-    else if (modifier == "capslock")
-      *out = blink::WebInputEvent::kCapsLockOn;
-    else if (modifier == "numlock")
-      *out = blink::WebInputEvent::kNumLockOn;
-    else if (modifier == "left")
-      *out = blink::WebInputEvent::kIsLeft;
-    else if (modifier == "right")
-      *out = blink::WebInputEvent::kIsRight;
-    return true;
-  }
-};
-
-blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val) {
-  blink::WebInputEvent::Type type = blink::WebInputEvent::kUndefined;
-  mate::Dictionary dict;
-  ConvertFromV8(isolate, val, &dict) && dict.Get("type", &type);
-  return type;
-}
-
-bool Converter<blink::WebInputEvent>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebInputEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  blink::WebInputEvent::Type type;
-  if (!dict.Get("type", &type))
-    return false;
-  out->SetType(type);
-  std::vector<blink::WebInputEvent::Modifiers> modifiers;
-  if (dict.Get("modifiers", &modifiers))
-    out->SetModifiers(VectorToBitArray(modifiers));
-  out->SetTimeStampSeconds(base::Time::Now().ToDoubleT());
-  return true;
-}
-
-bool Converter<blink::WebKeyboardEvent>::FromV8(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val,
-                                                blink::WebKeyboardEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
-    return false;
-
-  std::string str;
-  if (!dict.Get("keyCode", &str))
-    return false;
-
-  bool shifted = false;
-  ui::KeyboardCode keyCode = atom::KeyboardCodeFromStr(str, &shifted);
-  out->windows_key_code = keyCode;
-  if (shifted)
-    out->SetModifiers(out->GetModifiers() | blink::WebInputEvent::kShiftKey);
-
-  ui::DomCode domCode = ui::UsLayoutKeyboardCodeToDomCode(keyCode);
-  out->dom_code = static_cast<int>(domCode);
-
-  ui::DomKey domKey;
-  ui::KeyboardCode dummy_code;
-  int flags = atom::WebEventModifiersToEventFlags(out->GetModifiers());
-  if (ui::DomCodeToUsLayoutDomKey(domCode, flags, &domKey, &dummy_code))
-    out->dom_key = static_cast<int>(domKey);
-
-  if ((out->GetType() == blink::WebInputEvent::kChar ||
-       out->GetType() == blink::WebInputEvent::kRawKeyDown)) {
-    // Make sure to not read beyond the buffer in case some bad code doesn't
-    // NULL-terminate it (this is called from plugins).
-    size_t text_length_cap = blink::WebKeyboardEvent::kTextLengthCap;
-    base::string16 text16 = base::UTF8ToUTF16(str);
-
-    memset(out->text, 0, text_length_cap);
-    memset(out->unmodified_text, 0, text_length_cap);
-    for (size_t i = 0; i < std::min(text_length_cap, text16.size()); ++i) {
-      out->text[i] = text16[i];
-      out->unmodified_text[i] = text16[i];
-    }
-  }
-  return true;
-}
-
-bool Converter<content::NativeWebKeyboardEvent>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    content::NativeWebKeyboardEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebKeyboardEvent*>(out)))
-    return false;
-  dict.Get("skipInBrowser", &out->skip_in_browser);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<content::NativeWebKeyboardEvent>::ToV8(
-    v8::Isolate* isolate,
-    const content::NativeWebKeyboardEvent& in) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-
-  if (in.GetType() == blink::WebInputEvent::Type::kRawKeyDown)
-    dict.Set("type", "keyDown");
-  else if (in.GetType() == blink::WebInputEvent::Type::kKeyUp)
-    dict.Set("type", "keyUp");
-  dict.Set("key", ui::KeycodeConverter::DomKeyToKeyString(in.dom_key));
-  dict.Set("code", ui::KeycodeConverter::DomCodeToCodeString(
-                       static_cast<ui::DomCode>(in.dom_code)));
-
-  using Modifiers = blink::WebInputEvent::Modifiers;
-  dict.Set("isAutoRepeat", (in.GetModifiers() & Modifiers::kIsAutoRepeat) != 0);
-  dict.Set("shift", (in.GetModifiers() & Modifiers::kShiftKey) != 0);
-  dict.Set("control", (in.GetModifiers() & Modifiers::kControlKey) != 0);
-  dict.Set("alt", (in.GetModifiers() & Modifiers::kAltKey) != 0);
-  dict.Set("meta", (in.GetModifiers() & Modifiers::kMetaKey) != 0);
-
-  return dict.GetHandle();
-}
-
-bool Converter<blink::WebMouseEvent>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebMouseEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
-    return false;
-
-  float x = 0.f;
-  float y = 0.f;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  out->SetPositionInWidget(x, y);
-
-  if (!dict.Get("button", &out->button))
-    out->button = blink::WebMouseEvent::Button::kLeft;
-
-  float global_x = 0.f;
-  float global_y = 0.f;
-  dict.Get("globalX", &global_x);
-  dict.Get("globalY", &global_y);
-  out->SetPositionInScreen(global_x, global_y);
-
-  dict.Get("movementX", &out->movement_x);
-  dict.Get("movementY", &out->movement_y);
-  dict.Get("clickCount", &out->click_count);
-  return true;
-}
-
-bool Converter<blink::WebMouseWheelEvent>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::WebMouseWheelEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebMouseEvent*>(out)))
-    return false;
-  dict.Get("deltaX", &out->delta_x);
-  dict.Get("deltaY", &out->delta_y);
-  dict.Get("wheelTicksX", &out->wheel_ticks_x);
-  dict.Get("wheelTicksY", &out->wheel_ticks_y);
-  dict.Get("accelerationRatioX", &out->acceleration_ratio_x);
-  dict.Get("accelerationRatioY", &out->acceleration_ratio_y);
-  dict.Get("hasPreciseScrollingDeltas", &out->has_precise_scrolling_deltas);
-
-#if defined(USE_AURA)
-  // Matches the behavior of ui/events/blink/web_input_event_traits.cc:
-  bool can_scroll = true;
-  if (dict.Get("canScroll", &can_scroll) && !can_scroll) {
-    out->has_precise_scrolling_deltas = false;
-    out->SetModifiers(out->GetModifiers() & ~blink::WebInputEvent::kControlKey);
-  }
-#endif
-  return true;
-}
-
-bool Converter<blink::WebFloatPoint>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebFloatPoint* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
-}
-
-template <>
-struct Converter<base::Optional<blink::WebPoint>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::Optional<blink::WebPoint>* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    blink::WebPoint point;
-    bool success = dict.Get("x", &point.x) && dict.Get("y", &point.y);
-    if (!success)
-      return false;
-    out->emplace(point);
-    return true;
-  }
-};
-
-bool Converter<blink::WebSize>::FromV8(v8::Isolate* isolate,
-                                       v8::Local<v8::Value> val,
-                                       blink::WebSize* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  return dict.Get("width", &out->width) && dict.Get("height", &out->height);
-}
-
-bool Converter<blink::WebDeviceEmulationParams>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::WebDeviceEmulationParams* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  std::string screen_position;
-  if (dict.Get("screenPosition", &screen_position)) {
-    screen_position = base::ToLowerASCII(screen_position);
-    if (screen_position == "mobile")
-      out->screen_position = blink::WebDeviceEmulationParams::kMobile;
-    else if (screen_position == "desktop")
-      out->screen_position = blink::WebDeviceEmulationParams::kDesktop;
-    else
-      return false;
-  }
-
-  dict.Get("screenSize", &out->screen_size);
-  dict.Get("viewPosition", &out->view_position);
-  dict.Get("deviceScaleFactor", &out->device_scale_factor);
-  dict.Get("viewSize", &out->view_size);
-  dict.Get("scale", &out->scale);
-  return true;
-}
-
-bool Converter<blink::WebFindOptions>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              blink::WebFindOptions* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  dict.Get("forward", &out->forward);
-  dict.Get("matchCase", &out->match_case);
-  dict.Get("findNext", &out->find_next);
-  dict.Get("wordStart", &out->word_start);
-  dict.Get("medialCapitalAsWordStart", &out->medial_capital_as_word_start);
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebContextMenuData::MediaType>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebContextMenuData::MediaType& in) {
-  switch (in) {
-    case blink::WebContextMenuData::kMediaTypeImage:
-      return mate::StringToV8(isolate, "image");
-    case blink::WebContextMenuData::kMediaTypeVideo:
-      return mate::StringToV8(isolate, "video");
-    case blink::WebContextMenuData::kMediaTypeAudio:
-      return mate::StringToV8(isolate, "audio");
-    case blink::WebContextMenuData::kMediaTypeCanvas:
-      return mate::StringToV8(isolate, "canvas");
-    case blink::WebContextMenuData::kMediaTypeFile:
-      return mate::StringToV8(isolate, "file");
-    case blink::WebContextMenuData::kMediaTypePlugin:
-      return mate::StringToV8(isolate, "plugin");
-    default:
-      return mate::StringToV8(isolate, "none");
-  }
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebContextMenuData::InputFieldType>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebContextMenuData::InputFieldType& in) {
-  switch (in) {
-    case blink::WebContextMenuData::kInputFieldTypePlainText:
-      return mate::StringToV8(isolate, "plainText");
-    case blink::WebContextMenuData::kInputFieldTypePassword:
-      return mate::StringToV8(isolate, "password");
-    case blink::WebContextMenuData::kInputFieldTypeOther:
-      return mate::StringToV8(isolate, "other");
-    default:
-      return mate::StringToV8(isolate, "none");
-  }
-}
-
-v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("canUndo", !!(editFlags & blink::WebContextMenuData::kCanUndo));
-  dict.Set("canRedo", !!(editFlags & blink::WebContextMenuData::kCanRedo));
-  dict.Set("canCut", !!(editFlags & blink::WebContextMenuData::kCanCut));
-  dict.Set("canCopy", !!(editFlags & blink::WebContextMenuData::kCanCopy));
-
-  bool pasteFlag = false;
-  if (editFlags & blink::WebContextMenuData::kCanPaste) {
-    std::vector<base::string16> types;
-    bool ignore;
-    ui::Clipboard::GetForCurrentThread()->ReadAvailableTypes(
-        ui::CLIPBOARD_TYPE_COPY_PASTE, &types, &ignore);
-    pasteFlag = !types.empty();
-  }
-  dict.Set("canPaste", pasteFlag);
-
-  dict.Set("canDelete", !!(editFlags & blink::WebContextMenuData::kCanDelete));
-  dict.Set("canSelectAll",
-           !!(editFlags & blink::WebContextMenuData::kCanSelectAll));
-
-  return mate::ConvertToV8(isolate, dict);
-}
-
-v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("inError",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaInError));
-  dict.Set("isPaused",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaPaused));
-  dict.Set("isMuted", !!(mediaFlags & blink::WebContextMenuData::kMediaMuted));
-  dict.Set("hasAudio",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaHasAudio));
-  dict.Set("isLooping",
-           (mediaFlags & blink::WebContextMenuData::kMediaLoop) != 0);
-  dict.Set("isControlsVisible",
-           (mediaFlags & blink::WebContextMenuData::kMediaControls) != 0);
-  dict.Set("canToggleControls",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaCanToggleControls));
-  dict.Set("canRotate",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaCanRotate));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-v8::Local<v8::Value> Converter<blink::WebCache::ResourceTypeStat>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebCache::ResourceTypeStat& stat) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("count", static_cast<uint32_t>(stat.count));
-  dict.Set("size", static_cast<double>(stat.size));
-  dict.Set("liveSize", static_cast<double>(stat.decoded_size));
-  return dict.GetHandle();
-}
-
-v8::Local<v8::Value> Converter<blink::WebCache::ResourceTypeStats>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebCache::ResourceTypeStats& stats) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("images", stats.images);
-  dict.Set("scripts", stats.scripts);
-  dict.Set("cssStyleSheets", stats.css_style_sheets);
-  dict.Set("xslStyleSheets", stats.xsl_style_sheets);
-  dict.Set("fonts", stats.fonts);
-  dict.Set("other", stats.other);
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebReferrerPolicy>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebReferrerPolicy& in) {
-  switch (in) {
-    case blink::kWebReferrerPolicyDefault:
-      return mate::StringToV8(isolate, "default");
-    case blink::kWebReferrerPolicyAlways:
-      return mate::StringToV8(isolate, "unsafe-url");
-    case blink::kWebReferrerPolicyNoReferrerWhenDowngrade:
-      return mate::StringToV8(isolate, "no-referrer-when-downgrade");
-    case blink::kWebReferrerPolicyNever:
-      return mate::StringToV8(isolate, "no-referrer");
-    case blink::kWebReferrerPolicyOrigin:
-      return mate::StringToV8(isolate, "origin");
-    case blink::kWebReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin:
-      return mate::StringToV8(isolate, "strict-origin-when-cross-origin");
-    case blink::kWebReferrerPolicySameOrigin:
-      return mate::StringToV8(isolate, "same-origin");
-    case blink::kWebReferrerPolicyStrictOrigin:
-      return mate::StringToV8(isolate, "strict-origin");
-    default:
-      return mate::StringToV8(isolate, "no-referrer");
-  }
-}
-
-// static
-bool Converter<blink::WebReferrerPolicy>::FromV8(
-    v8::Isolate* isolate,
-    v8::Handle<v8::Value> val,
-    blink::WebReferrerPolicy* out) {
-  std::string policy = base::ToLowerASCII(V8ToString(val));
-  if (policy == "default")
-    *out = blink::kWebReferrerPolicyDefault;
-  else if (policy == "unsafe-url")
-    *out = blink::kWebReferrerPolicyAlways;
-  else if (policy == "no-referrer-when-downgrade")
-    *out = blink::kWebReferrerPolicyNoReferrerWhenDowngrade;
-  else if (policy == "no-referrer")
-    *out = blink::kWebReferrerPolicyNever;
-  else if (policy == "origin")
-    *out = blink::kWebReferrerPolicyOrigin;
-  else if (policy == "strict-origin-when-cross-origin")
-    *out =
-        blink::kWebReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin;
-  else if (policy == "same-origin")
-    *out = blink::kWebReferrerPolicySameOrigin;
-  else if (policy == "strict-origin")
-    *out = blink::kWebReferrerPolicyStrictOrigin;
-  else
-    return false;
-  return true;
-}
-
-}  // namespace mate
removed in remote
  base   100644 6a3601929214f42ddef1597dfb230ab6269fc4fb atom/common/native_mate_converters/blink_converter.h
  our    100644 5e6315d9b2499fd1e0853b8bd4258b887d222b21 atom/common/native_mate_converters/blink_converter.h
@@ -1,147 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
-
-#include "native_mate/converter.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/web/WebContextMenuData.h"
-
-namespace blink {
-class WebMouseEvent;
-class WebMouseWheelEvent;
-class WebKeyboardEvent;
-struct WebDeviceEmulationParams;
-struct WebFindOptions;
-struct WebFloatPoint;
-struct WebPoint;
-struct WebSize;
-}  // namespace blink
-
-namespace content {
-struct NativeWebKeyboardEvent;
-}
-
-namespace mate {
-
-blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val);
-
-template <>
-struct Converter<blink::WebInputEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebInputEvent* out);
-};
-
-template <>
-struct Converter<blink::WebKeyboardEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebKeyboardEvent* out);
-};
-
-template <>
-struct Converter<content::NativeWebKeyboardEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::NativeWebKeyboardEvent* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::NativeWebKeyboardEvent& in);
-};
-
-template <>
-struct Converter<blink::WebMouseEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebMouseEvent* out);
-};
-
-template <>
-struct Converter<blink::WebMouseWheelEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebMouseWheelEvent* out);
-};
-
-template <>
-struct Converter<blink::WebFloatPoint> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebFloatPoint* out);
-};
-
-template <>
-struct Converter<blink::WebPoint> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebPoint* out);
-};
-
-template <>
-struct Converter<blink::WebSize> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebSize* out);
-};
-
-template <>
-struct Converter<blink::WebDeviceEmulationParams> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebDeviceEmulationParams* out);
-};
-
-template <>
-struct Converter<blink::WebFindOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebFindOptions* out);
-};
-
-template <>
-struct Converter<blink::WebContextMenuData::MediaType> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebContextMenuData::MediaType& in);
-};
-
-template <>
-struct Converter<blink::WebContextMenuData::InputFieldType> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebContextMenuData::InputFieldType& in);
-};
-
-template <>
-struct Converter<blink::WebCache::ResourceTypeStat> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebCache::ResourceTypeStat& stat);
-};
-
-template <>
-struct Converter<blink::WebCache::ResourceTypeStats> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebCache::ResourceTypeStats& stats);
-};
-
-template <>
-struct Converter<blink::WebReferrerPolicy> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const blink::WebReferrerPolicy& in);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebReferrerPolicy* out);
-};
-
-v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags);
-v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags);
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
removed in remote
  base   100644 8bf5c459b0a2902638d09edd1b40355fa3ad9188 atom/common/native_mate_converters/callback.cc
  our    100644 f33cec720ea5df1c17c8d02d4aa2b70d2979e13b atom/common/native_mate_converters/callback.cc
@@ -1,127 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/callback.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-namespace internal {
-
-namespace {
-
-struct TranslaterHolder {
-  Translater translater;
-};
-
-// Cached JavaScript version of |CallTranslater|.
-v8::Persistent<v8::FunctionTemplate> g_call_translater;
-
-void CallTranslater(v8::Local<v8::External> external,
-                    v8::Local<v8::Object> state,
-                    mate::Arguments* args) {
-  v8::Isolate* isolate = args->isolate();
-
-  // Check if the callback has already been called.
-  v8::Local<v8::String> called_symbol = mate::StringToSymbol(isolate, "called");
-  if (state->Has(called_symbol)) {
-    args->ThrowError("callback can only be called for once");
-    return;
-  } else {
-    state->Set(called_symbol, v8::Boolean::New(isolate, true));
-  }
-
-  TranslaterHolder* holder = static_cast<TranslaterHolder*>(external->Value());
-  holder->translater.Run(args);
-  delete holder;
-}
-
-}  // namespace
-
-// Destroy the class on UI thread when possible.
-struct DeleteOnUIThread {
-  template <typename T>
-  static void Destruct(const T* x) {
-    if (Locker::IsBrowserProcess() &&
-        !BrowserThread::CurrentlyOn(BrowserThread::UI)) {
-      BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, x);
-    } else {
-      delete x;
-    }
-  }
-};
-
-// Like v8::Global, but ref-counted.
-template <typename T>
-class RefCountedGlobal
-    : public base::RefCountedThreadSafe<RefCountedGlobal<T>, DeleteOnUIThread> {
- public:
-  RefCountedGlobal(v8::Isolate* isolate, v8::Local<v8::Value> value)
-      : handle_(isolate, v8::Local<T>::Cast(value)) {}
-
-  bool IsAlive() const { return !handle_.IsEmpty(); }
-
-  v8::Local<T> NewHandle(v8::Isolate* isolate) const {
-    return v8::Local<T>::New(isolate, handle_);
-  }
-
- private:
-  v8::Global<T> handle_;
-
-  DISALLOW_COPY_AND_ASSIGN(RefCountedGlobal);
-};
-
-SafeV8Function::SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value)
-    : v8_function_(new RefCountedGlobal<v8::Function>(isolate, value)) {}
-
-SafeV8Function::SafeV8Function(const SafeV8Function& other)
-    : v8_function_(other.v8_function_) {}
-
-SafeV8Function::~SafeV8Function() {}
-
-bool SafeV8Function::IsAlive() const {
-  return v8_function_.get() && v8_function_->IsAlive();
-}
-
-v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
-  return v8_function_->NewHandle(isolate);
-}
-
-v8::Local<v8::Value> CreateFunctionFromTranslater(
-    v8::Isolate* isolate,
-    const Translater& translater) {
-  // The FunctionTemplate is cached.
-  if (g_call_translater.IsEmpty())
-    g_call_translater.Reset(isolate, mate::CreateFunctionTemplate(
-                                         isolate, base::Bind(&CallTranslater)));
-
-  v8::Local<v8::FunctionTemplate> call_translater =
-      v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
-  auto* holder = new TranslaterHolder;
-  holder->translater = translater;
-  return BindFunctionWith(
-      isolate, isolate->GetCurrentContext(), call_translater->GetFunction(),
-      v8::External::New(isolate, holder), v8::Object::New(isolate));
-}
-
-// func.bind(func, arg1).
-// NB(zcbenz): Using C++11 version crashes VS.
-v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
-                                      v8::Local<v8::Context> context,
-                                      v8::Local<v8::Function> func,
-                                      v8::Local<v8::Value> arg1,
-                                      v8::Local<v8::Value> arg2) {
-  v8::MaybeLocal<v8::Value> bind = func->Get(mate::StringToV8(isolate, "bind"));
-  CHECK(!bind.IsEmpty());
-  v8::Local<v8::Function> bind_func =
-      v8::Local<v8::Function>::Cast(bind.ToLocalChecked());
-  v8::Local<v8::Value> converted[] = {func, arg1, arg2};
-  return bind_func->Call(context, func, arraysize(converted), converted)
-      .ToLocalChecked();
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 6ef8e74c735a9ae3cef88dff0b1075faa4407c64 atom/common/native_mate_converters/callback.h
  our    100644 06140a3a7a7a928143e44e22113288b514409929 atom/common/native_mate_converters/callback.h
@@ -1,173 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
-
-#include <vector>
-
-#include "atom/common/api/locker.h"
-#include "base/bind.h"
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "base/message_loop/message_loop.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/function_template.h"
-#include "native_mate/scoped_persistent.h"
-
-namespace mate {
-
-namespace internal {
-
-template <typename T>
-class RefCountedGlobal;
-
-// Manages the V8 function with RAII.
-class SafeV8Function {
- public:
-  SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value);
-  SafeV8Function(const SafeV8Function& other);
-  ~SafeV8Function();
-
-  bool IsAlive() const;
-  v8::Local<v8::Function> NewHandle(v8::Isolate* isolate) const;
-
- private:
-  scoped_refptr<RefCountedGlobal<v8::Function>> v8_function_;
-};
-
-// Helper to invoke a V8 function with C++ parameters.
-template <typename Sig>
-struct V8FunctionInvoker {};
-
-template <typename... ArgTypes>
-struct V8FunctionInvoker<v8::Local<v8::Value>(ArgTypes...)> {
-  static v8::Local<v8::Value> Go(v8::Isolate* isolate,
-                                 const SafeV8Function& function,
-                                 ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::EscapableHandleScope handle_scope(isolate);
-    if (!function.IsAlive())
-      return v8::Null(isolate);
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    v8::Local<v8::Value> ret(holder->Call(
-        holder, args.size(), args.empty() ? nullptr : &args.front()));
-    return handle_scope.Escape(ret);
-  }
-};
-
-template <typename... ArgTypes>
-struct V8FunctionInvoker<void(ArgTypes...)> {
-  static void Go(v8::Isolate* isolate,
-                 const SafeV8Function& function,
-                 ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    if (!function.IsAlive())
-      return;
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    holder->Call(holder, args.size(), args.empty() ? nullptr : &args.front());
-  }
-};
-
-template <typename ReturnType, typename... ArgTypes>
-struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
-  static ReturnType Go(v8::Isolate* isolate,
-                       const SafeV8Function& function,
-                       ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    ReturnType ret = ReturnType();
-    if (!function.IsAlive())
-      return ret;
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    v8::Local<v8::Value> result;
-    auto maybe_result = holder->Call(context, holder, args.size(),
-                                     args.empty() ? nullptr : &args.front());
-    if (maybe_result.ToLocal(&result))
-      Converter<ReturnType>::FromV8(isolate, result, &ret);
-    return ret;
-  }
-};
-
-// Helper to pass a C++ funtion to JavaScript.
-using Translater = base::Callback<void(Arguments* args)>;
-v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
-                                                  const Translater& translater);
-v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
-                                      v8::Local<v8::Context> context,
-                                      v8::Local<v8::Function> func,
-                                      v8::Local<v8::Value> arg1,
-                                      v8::Local<v8::Value> arg2);
-
-// Calls callback with Arguments.
-template <typename Sig>
-struct NativeFunctionInvoker {};
-
-template <typename ReturnType, typename... ArgTypes>
-struct NativeFunctionInvoker<ReturnType(ArgTypes...)> {
-  static void Go(base::Callback<ReturnType(ArgTypes...)> val, Arguments* args) {
-    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
-    Invoker<Indices, ArgTypes...> invoker(args, 0);
-    if (invoker.IsOK())
-      invoker.DispatchToCallback(val);
-  }
-};
-
-}  // namespace internal
-
-template <typename Sig>
-struct Converter<base::OnceCallback<Sig>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::OnceCallback<Sig>* out) {
-    if (!val->IsFunction())
-      return false;
-
-    *out = base::BindOnce(&internal::V8FunctionInvoker<Sig>::Go, isolate,
-                          internal::SafeV8Function(isolate, val));
-    return true;
-  }
-};
-
-template <typename Sig>
-struct Converter<base::RepeatingCallback<Sig>> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::RepeatingCallback<Sig>& val) {
-    // We don't use CreateFunctionTemplate here because it creates a new
-    // FunctionTemplate everytime, which is cached by V8 and causes leaks.
-    internal::Translater translater =
-        base::BindRepeating(&internal::NativeFunctionInvoker<Sig>::Go, val);
-    return internal::CreateFunctionFromTranslater(isolate, translater);
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::RepeatingCallback<Sig>* out) {
-    if (!val->IsFunction())
-      return false;
-
-    *out = base::BindRepeating(&internal::V8FunctionInvoker<Sig>::Go, isolate,
-                               internal::SafeV8Function(isolate, val));
-    return true;
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
removed in remote
  base   100644 f5d81d085bc1a1ca7f9efa3c48d0ef3d05d88af9 atom/common/native_mate_converters/content_converter.cc
  our    100644 2684aa7dda07ac79e47823c3cf9bf00d3f5cf3f5 atom/common/native_mate_converters/content_converter.cc
@@ -1,251 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/content_converter.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/ui_base_types_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/context_menu_params.h"
-#include "native_mate/dictionary.h"
-
-namespace {
-
-void ExecuteCommand(content::WebContents* web_contents,
-                    int action,
-                    const content::CustomContextMenuContext& context) {
-  web_contents->ExecuteCustomContextMenuCommand(action, context);
-}
-
-// Forward declaration for nested recursive call.
-v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
-                              content::WebContents* web_contents,
-                              const content::CustomContextMenuContext& context,
-                              const std::vector<content::MenuItem>& menu);
-
-v8::Local<v8::Value> MenuItemToV8(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents,
-    const content::CustomContextMenuContext& context,
-    const content::MenuItem& item) {
-  mate::Dictionary v8_item = mate::Dictionary::CreateEmpty(isolate);
-  switch (item.type) {
-    case content::MenuItem::CHECKABLE_OPTION:
-    case content::MenuItem::GROUP:
-      v8_item.Set("checked", item.checked);
-      FALLTHROUGH;
-    case content::MenuItem::OPTION:
-    case content::MenuItem::SUBMENU:
-      v8_item.Set("label", item.label);
-      v8_item.Set("enabled", item.enabled);
-      FALLTHROUGH;
-    default:
-      v8_item.Set("type", item.type);
-  }
-  if (item.type == content::MenuItem::SUBMENU)
-    v8_item.Set("submenu",
-                MenuToV8(isolate, web_contents, context, item.submenu));
-  else if (item.action > 0)
-    v8_item.Set("click",
-                base::Bind(ExecuteCommand, web_contents, item.action, context));
-  return v8_item.GetHandle();
-}
-
-v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
-                              content::WebContents* web_contents,
-                              const content::CustomContextMenuContext& context,
-                              const std::vector<content::MenuItem>& menu) {
-  std::vector<v8::Local<v8::Value>> v8_menu;
-  for (const auto& menu_item : menu)
-    v8_menu.push_back(MenuItemToV8(isolate, web_contents, context, menu_item));
-  return mate::ConvertToV8(isolate, v8_menu);
-}
-
-}  // namespace
-
-namespace mate {
-
-// static
-v8::Local<v8::Value> Converter<content::MenuItem::Type>::ToV8(
-    v8::Isolate* isolate,
-    const content::MenuItem::Type& val) {
-  switch (val) {
-    case content::MenuItem::CHECKABLE_OPTION:
-      return StringToV8(isolate, "checkbox");
-    case content::MenuItem::GROUP:
-      return StringToV8(isolate, "radio");
-    case content::MenuItem::SEPARATOR:
-      return StringToV8(isolate, "separator");
-    case content::MenuItem::SUBMENU:
-      return StringToV8(isolate, "submenu");
-    case content::MenuItem::OPTION:
-    default:
-      return StringToV8(isolate, "normal");
-  }
-}
-
-// static
-v8::Local<v8::Value> Converter<ContextMenuParamsWithWebContents>::ToV8(
-    v8::Isolate* isolate,
-    const ContextMenuParamsWithWebContents& val) {
-  const auto& params = val.first;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("x", params.x);
-  dict.Set("y", params.y);
-  dict.Set("linkURL", params.link_url);
-  dict.Set("linkText", params.link_text);
-  dict.Set("pageURL", params.page_url);
-  dict.Set("frameURL", params.frame_url);
-  dict.Set("srcURL", params.src_url);
-  dict.Set("mediaType", params.media_type);
-  dict.Set("mediaFlags", MediaFlagsToV8(isolate, params.media_flags));
-  bool has_image_contents =
-      (params.media_type == blink::WebContextMenuData::kMediaTypeImage) &&
-      params.has_image_contents;
-  dict.Set("hasImageContents", has_image_contents);
-  dict.Set("isEditable", params.is_editable);
-  dict.Set("editFlags", EditFlagsToV8(isolate, params.edit_flags));
-  dict.Set("selectionText", params.selection_text);
-  dict.Set("titleText", params.title_text);
-  dict.Set("misspelledWord", params.misspelled_word);
-  dict.Set("frameCharset", params.frame_charset);
-  dict.Set("inputFieldType", params.input_field_type);
-  dict.Set("menuSourceType", params.source_type);
-
-  if (params.custom_context.is_pepper_menu)
-    dict.Set("menu", MenuToV8(isolate, val.second, params.custom_context,
-                              params.custom_items));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-bool Converter<blink::mojom::PermissionStatus>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::mojom::PermissionStatus* out) {
-  bool result;
-  if (!ConvertFromV8(isolate, val, &result))
-    return false;
-
-  if (result)
-    *out = blink::mojom::PermissionStatus::GRANTED;
-  else
-    *out = blink::mojom::PermissionStatus::DENIED;
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::PermissionType>::ToV8(
-    v8::Isolate* isolate,
-    const content::PermissionType& val) {
-  using PermissionType = atom::WebContentsPermissionHelper::PermissionType;
-  switch (val) {
-    case content::PermissionType::MIDI_SYSEX:
-      return StringToV8(isolate, "midiSysex");
-    case content::PermissionType::NOTIFICATIONS:
-      return StringToV8(isolate, "notifications");
-    case content::PermissionType::GEOLOCATION:
-      return StringToV8(isolate, "geolocation");
-    case content::PermissionType::AUDIO_CAPTURE:
-    case content::PermissionType::VIDEO_CAPTURE:
-      return StringToV8(isolate, "media");
-    case content::PermissionType::PROTECTED_MEDIA_IDENTIFIER:
-      return StringToV8(isolate, "mediaKeySystem");
-    case content::PermissionType::MIDI:
-      return StringToV8(isolate, "midi");
-    default:
-      break;
-  }
-
-  if (val == static_cast<content::PermissionType>(PermissionType::POINTER_LOCK))
-    return StringToV8(isolate, "pointerLock");
-  else if (val ==
-           static_cast<content::PermissionType>(PermissionType::FULLSCREEN))
-    return StringToV8(isolate, "fullscreen");
-  else if (val ==
-           static_cast<content::PermissionType>(PermissionType::OPEN_EXTERNAL))
-    return StringToV8(isolate, "openExternal");
-
-  return StringToV8(isolate, "unknown");
-}
-
-// static
-bool Converter<content::StopFindAction>::FromV8(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val,
-                                                content::StopFindAction* out) {
-  std::string action;
-  if (!ConvertFromV8(isolate, val, &action))
-    return false;
-
-  if (action == "clearSelection")
-    *out = content::STOP_FIND_ACTION_CLEAR_SELECTION;
-  else if (action == "keepSelection")
-    *out = content::STOP_FIND_ACTION_KEEP_SELECTION;
-  else if (action == "activateSelection")
-    *out = content::STOP_FIND_ACTION_ACTIVATE_SELECTION;
-  else
-    return false;
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::WebContents*>::ToV8(
-    v8::Isolate* isolate,
-    content::WebContents* val) {
-  if (!val)
-    return v8::Null(isolate);
-  return atom::api::WebContents::CreateFrom(isolate, val).ToV8();
-}
-
-// static
-bool Converter<content::WebContents*>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              content::WebContents** out) {
-  atom::api::WebContents* web_contents = nullptr;
-  if (!ConvertFromV8(isolate, val, &web_contents) || !web_contents)
-    return false;
-
-  *out = web_contents->web_contents();
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::Referrer>::ToV8(
-    v8::Isolate* isolate,
-    const content::Referrer& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("url", ConvertToV8(isolate, val.url));
-  dict.Set("policy", ConvertToV8(isolate, val.policy));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-bool Converter<content::Referrer>::FromV8(v8::Isolate* isolate,
-                                          v8::Local<v8::Value> val,
-                                          content::Referrer* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  if (!dict.Get("url", &out->url))
-    return false;
-
-  if (!dict.Get("policy", &out->policy))
-    return false;
-
-  return true;
-}
-
-}  // namespace mate
removed in remote
  base   100644 b1a42b6897ca23ce6ab2442dd2ac1d569e7adc2d atom/common/native_mate_converters/content_converter.h
  our    100644 18a2d5f1a7c8d0f33cb35e575bae7a4b2740d7cd atom/common/native_mate_converters/content_converter.h
@@ -1,79 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
-
-#include <utility>
-
-#include "content/public/browser/permission_type.h"
-#include "content/public/common/menu_item.h"
-#include "content/public/common/referrer.h"
-#include "content/public/common/stop_find_action.h"
-#include "native_mate/converter.h"
-#include "third_party/WebKit/public/platform/modules/permissions/permission_status.mojom.h"
-
-namespace content {
-struct ContextMenuParams;
-class WebContents;
-}  // namespace content
-
-using ContextMenuParamsWithWebContents =
-    std::pair<content::ContextMenuParams, content::WebContents*>;
-
-namespace mate {
-
-template <>
-struct Converter<content::MenuItem::Type> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::MenuItem::Type& val);
-};
-
-template <>
-struct Converter<ContextMenuParamsWithWebContents> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const ContextMenuParamsWithWebContents& val);
-};
-
-template <>
-struct Converter<blink::mojom::PermissionStatus> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::mojom::PermissionStatus* out);
-};
-
-template <>
-struct Converter<content::PermissionType> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::PermissionType& val);
-};
-
-template <>
-struct Converter<content::StopFindAction> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::StopFindAction* out);
-};
-
-template <>
-struct Converter<content::WebContents*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   content::WebContents* val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::WebContents** out);
-};
-
-template <>
-struct Converter<content::Referrer> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::Referrer& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::Referrer* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
removed in remote
  base   100644 7df1289e243be0f5f8dc9a114b3c98a1ba55ab37 atom/common/native_mate_converters/file_path_converter.h
  our    100644 c283d3370a61dc29724f7e5f5761ee6125eab516 atom/common/native_mate_converters/file_path_converter.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
-
-#include <string>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/files/file_path.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::FilePath> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::FilePath& val) {
-    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::FilePath* out) {
-    if (val->IsNull())
-      return true;
-
-    base::FilePath::StringType path;
-    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {
-      *out = base::FilePath(path);
-      return true;
-    } else {
-      return false;
-    }
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
removed in remote
  base   100644 37e7aeb3a48becbecd7f5fd61934ac4d178539ca atom/common/native_mate_converters/gfx_converter.cc
  our    100644 7a7cfd39e061837f7772be91b43f5851d8278c00 atom/common/native_mate_converters/gfx_converter.cc
@@ -1,138 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/gfx_converter.h"
-
-#include "native_mate/dictionary.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/gfx/geometry/point.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/size.h"
-
-namespace mate {
-
-v8::Local<v8::Value> Converter<gfx::Point>::ToV8(v8::Isolate* isolate,
-                                                 const gfx::Point& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Point>::FromV8(v8::Isolate* isolate,
-                                   v8::Local<v8::Value> val,
-                                   gfx::Point* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int x, y;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  *out = gfx::Point(x, y);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::PointF>::ToV8(v8::Isolate* isolate,
-                                                  const gfx::PointF& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::PointF>::FromV8(v8::Isolate* isolate,
-                                    v8::Local<v8::Value> val,
-                                    gfx::PointF* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  float x, y;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  *out = gfx::PointF(x, y);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Size>::ToV8(v8::Isolate* isolate,
-                                                const gfx::Size& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("width", val.width());
-  dict.Set("height", val.height());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Size>::FromV8(v8::Isolate* isolate,
-                                  v8::Local<v8::Value> val,
-                                  gfx::Size* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int width, height;
-  if (!dict.Get("width", &width) || !dict.Get("height", &height))
-    return false;
-  *out = gfx::Size(width, height);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Rect>::ToV8(v8::Isolate* isolate,
-                                                const gfx::Rect& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  dict.Set("width", val.width());
-  dict.Set("height", val.height());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Rect>::FromV8(v8::Isolate* isolate,
-                                  v8::Local<v8::Value> val,
-                                  gfx::Rect* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int x, y, width, height;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y) || !dict.Get("width", &width) ||
-      !dict.Get("height", &height))
-    return false;
-  *out = gfx::Rect(x, y, width, height);
-  return true;
-}
-
-template <>
-struct Converter<display::Display::TouchSupport> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const display::Display::TouchSupport& val) {
-    switch (val) {
-      case display::Display::TouchSupport::AVAILABLE:
-        return StringToV8(isolate, "available");
-      case display::Display::TouchSupport::UNAVAILABLE:
-        return StringToV8(isolate, "unavailable");
-      default:
-        return StringToV8(isolate, "unknown");
-    }
-  }
-};
-
-v8::Local<v8::Value> Converter<display::Display>::ToV8(
-    v8::Isolate* isolate,
-    const display::Display& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("id", val.id());
-  dict.Set("bounds", val.bounds());
-  dict.Set("workArea", val.work_area());
-  dict.Set("size", val.size());
-  dict.Set("workAreaSize", val.work_area_size());
-  dict.Set("scaleFactor", val.device_scale_factor());
-  dict.Set("rotation", val.RotationAsDegree());
-  dict.Set("touchSupport", val.touch_support());
-  return dict.GetHandle();
-}
-
-}  // namespace mate
removed in remote
  base   100644 c6da76a2d0e72404c01e24cd3ac01c3bd0b42a38 atom/common/native_mate_converters/gfx_converter.h
  our    100644 745e6528093f084d36959c624e05d8aabb994c4a atom/common/native_mate_converters/gfx_converter.h
@@ -1,67 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
-
-#include "native_mate/converter.h"
-#include "ui/gfx/geometry/point_f.h"
-
-namespace display {
-class Display;
-}
-
-namespace gfx {
-class Point;
-class Size;
-class Rect;
-}  // namespace gfx
-
-namespace mate {
-
-template <>
-struct Converter<gfx::Point> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Point& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Point* out);
-};
-
-template <>
-struct Converter<gfx::PointF> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const gfx::PointF& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::PointF* out);
-};
-
-template <>
-struct Converter<gfx::Size> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Size& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Size* out);
-};
-
-template <>
-struct Converter<gfx::Rect> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Rect& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Rect* out);
-};
-
-template <>
-struct Converter<display::Display> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const display::Display& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     display::Display* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
removed in remote
  base   100644 34408913b789a9303cacc57a56fdb1d0254c112e atom/common/native_mate_converters/gurl_converter.h
  our    100644 110b97d5ef290de2b39dd5435a20d1685178a781 atom/common/native_mate_converters/gurl_converter.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
-
-#include <string>
-
-#include "native_mate/converter.h"
-#include "url/gurl.h"
-
-namespace mate {
-
-template <>
-struct Converter<GURL> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const GURL& val) {
-    return ConvertToV8(isolate, val.spec());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     GURL* out) {
-    std::string url;
-    if (Converter<std::string>::FromV8(isolate, val, &url)) {
-      *out = GURL(url);
-      return true;
-    } else {
-      return false;
-    }
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
removed in remote
  base   100644 550bb7b904a74b54883b11f879ee772bb4bcb3a1 atom/common/native_mate_converters/image_converter.cc
  our    100644 1198479926068c1aed59fc7f8d6f384e246b678d atom/common/native_mate_converters/image_converter.cc
@@ -1,43 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/image_converter.h"
-
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace mate {
-
-bool Converter<gfx::ImageSkia>::FromV8(v8::Isolate* isolate,
-                                       v8::Local<v8::Value> val,
-                                       gfx::ImageSkia* out) {
-  gfx::Image image;
-  if (!ConvertFromV8(isolate, val, &image))
-    return false;
-
-  *out = image.AsImageSkia();
-  return true;
-}
-
-bool Converter<gfx::Image>::FromV8(v8::Isolate* isolate,
-                                   v8::Local<v8::Value> val,
-                                   gfx::Image* out) {
-  if (val->IsNull())
-    return true;
-
-  Handle<atom::api::NativeImage> native_image;
-  if (!ConvertFromV8(isolate, val, &native_image))
-    return false;
-
-  *out = native_image->image();
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Image>::ToV8(v8::Isolate* isolate,
-                                                 const gfx::Image& val) {
-  return ConvertToV8(isolate, atom::api::NativeImage::Create(isolate, val));
-}
-
-}  // namespace mate
removed in remote
  base   100644 be52288eb0491d9d5284ba20927e3496b714e481 atom/common/native_mate_converters/image_converter.h
  our    100644 d8673145a7637e8e0d479492a85b1126ab822127 atom/common/native_mate_converters/image_converter.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace gfx {
-class Image;
-class ImageSkia;
-}  // namespace gfx
-
-namespace mate {
-
-template <>
-struct Converter<gfx::ImageSkia> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::ImageSkia* out);
-};
-
-template <>
-struct Converter<gfx::Image> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Image* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Image& val);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
removed in remote
  base   100644 5223709ae585f128ab9933e1d2c80c7b5aaa3eb5 atom/common/native_mate_converters/net_converter.cc
  our    100644 db54210e7c095da593c6f5b9f4ed1eafb91b945d atom/common/native_mate_converters/net_converter.cc
@@ -1,259 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/net_converter.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-#include "net/base/upload_bytes_element_reader.h"
-#include "net/base/upload_data_stream.h"
-#include "net/base/upload_element_reader.h"
-#include "net/base/upload_file_element_reader.h"
-#include "net/cert/x509_certificate.h"
-#include "net/cert/x509_util.h"
-#include "net/http/http_response_headers.h"
-#include "net/url_request/url_request.h"
-#include "storage/browser/blob/upload_blob_element_reader.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace {
-
-bool CertFromData(const std::string& data,
-                  scoped_refptr<net::X509Certificate>* out) {
-  auto cert_list = net::X509Certificate::CreateCertificateListFromBytes(
-      data.c_str(), data.length(),
-      net::X509Certificate::FORMAT_SINGLE_CERTIFICATE);
-  if (cert_list.empty())
-    return false;
-
-  auto leaf_cert = cert_list.front();
-  if (!leaf_cert)
-    return false;
-
-  *out = leaf_cert;
-
-  return true;
-}
-
-}  // namespace
-
-// static
-v8::Local<v8::Value> Converter<const net::AuthChallengeInfo*>::ToV8(
-    v8::Isolate* isolate,
-    const net::AuthChallengeInfo* val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("isProxy", val->is_proxy);
-  dict.Set("scheme", val->scheme);
-  dict.Set("host", val->challenger.host());
-  dict.Set("port", static_cast<uint32_t>(val->challenger.port()));
-  dict.Set("realm", val->realm);
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-v8::Local<v8::Value> Converter<scoped_refptr<net::X509Certificate>>::ToV8(
-    v8::Isolate* isolate,
-    const scoped_refptr<net::X509Certificate>& val) {
-  mate::Dictionary dict(isolate, v8::Object::New(isolate));
-  std::string encoded_data;
-  net::X509Certificate::GetPEMEncoded(val->cert_buffer(), &encoded_data);
-
-  dict.Set("data", encoded_data);
-  dict.Set("issuer", val->issuer());
-  dict.Set("issuerName", val->issuer().GetDisplayName());
-  dict.Set("subject", val->subject());
-  dict.Set("subjectName", val->subject().GetDisplayName());
-  dict.Set("serialNumber", base::HexEncode(val->serial_number().data(),
-                                           val->serial_number().size()));
-  dict.Set("validStart", val->valid_start().ToDoubleT());
-  dict.Set("validExpiry", val->valid_expiry().ToDoubleT());
-  dict.Set("fingerprint",
-           net::HashValue(val->CalculateFingerprint256(val->cert_buffer()))
-               .ToString());
-
-  const auto& intermediate_buffers = val->intermediate_buffers();
-  if (!intermediate_buffers.empty()) {
-    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> issuer_intermediates;
-    issuer_intermediates.reserve(intermediate_buffers.size() - 1);
-    for (size_t i = 1; i < intermediate_buffers.size(); ++i) {
-      issuer_intermediates.push_back(
-          net::x509_util::DupCryptoBuffer(intermediate_buffers[i].get()));
-    }
-    const scoped_refptr<net::X509Certificate>& issuer_cert =
-        net::X509Certificate::CreateFromBuffer(
-            net::x509_util::DupCryptoBuffer(intermediate_buffers[0].get()),
-            std::move(issuer_intermediates));
-    dict.Set("issuerCert", issuer_cert);
-  }
-
-  return dict.GetHandle();
-}
-
-bool Converter<scoped_refptr<net::X509Certificate>>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    scoped_refptr<net::X509Certificate>* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  std::string data;
-  dict.Get("data", &data);
-  scoped_refptr<net::X509Certificate> leaf_cert;
-  if (!CertFromData(data, &leaf_cert))
-    return false;
-
-  scoped_refptr<net::X509Certificate> issuer_cert;
-  if (dict.Get("issuerCert", &issuer_cert)) {
-    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
-    intermediates.push_back(
-        net::x509_util::DupCryptoBuffer(issuer_cert->cert_buffer()));
-    auto cert = net::X509Certificate::CreateFromBuffer(
-        net::x509_util::DupCryptoBuffer(leaf_cert->cert_buffer()),
-        std::move(intermediates));
-    if (!cert)
-      return false;
-
-    *out = cert;
-  } else {
-    *out = leaf_cert;
-  }
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<net::CertPrincipal>::ToV8(
-    v8::Isolate* isolate,
-    const net::CertPrincipal& val) {
-  mate::Dictionary dict(isolate, v8::Object::New(isolate));
-
-  dict.Set("commonName", val.common_name);
-  dict.Set("organizations", val.organization_names);
-  dict.Set("organizationUnits", val.organization_unit_names);
-  dict.Set("locality", val.locality_name);
-  dict.Set("state", val.state_or_province_name);
-  dict.Set("country", val.country_name);
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> Converter<net::HttpResponseHeaders*>::ToV8(
-    v8::Isolate* isolate,
-    net::HttpResponseHeaders* headers) {
-  base::DictionaryValue response_headers;
-  if (headers) {
-    size_t iter = 0;
-    std::string key;
-    std::string value;
-    while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
-      key = base::ToLowerASCII(key);
-      if (response_headers.FindKey(key)) {
-        base::ListValue* values = nullptr;
-        if (response_headers.GetList(key, &values))
-          values->AppendString(value);
-      } else {
-        auto values = std::make_unique<base::ListValue>();
-        values->AppendString(value);
-        response_headers.Set(key, std::move(values));
-      }
-    }
-  }
-  return ConvertToV8(isolate, response_headers);
-}
-
-bool Converter<net::HttpResponseHeaders*>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    net::HttpResponseHeaders* out) {
-  if (!val->IsObject()) {
-    return false;
-  }
-  auto context = isolate->GetCurrentContext();
-  auto headers = v8::Local<v8::Object>::Cast(val);
-  auto keys = headers->GetOwnPropertyNames();
-  for (uint32_t i = 0; i < keys->Length(); i++) {
-    v8::Local<v8::String> key, value;
-    if (!keys->Get(i)->ToString(context).ToLocal(&key)) {
-      return false;
-    }
-    if (!headers->Get(key)->ToString(context).ToLocal(&value)) {
-      return false;
-    }
-    v8::String::Utf8Value key_utf8(key);
-    v8::String::Utf8Value value_utf8(value);
-    std::string k(*key_utf8, key_utf8.length());
-    std::string v(*value_utf8, value_utf8.length());
-    std::ostringstream tmp;
-    tmp << k << ": " << v;
-    out->AddHeader(tmp.str());
-  }
-  return true;
-}
-
-}  // namespace mate
-
-namespace atom {
-
-void FillRequestDetails(base::DictionaryValue* details,
-                        const net::URLRequest* request) {
-  details->SetString("method", request->method());
-  std::string url;
-  if (!request->url_chain().empty())
-    url = request->url().spec();
-  details->SetKey("url", base::Value(url));
-  details->SetString("referrer", request->referrer());
-  auto list = std::make_unique<base::ListValue>();
-  GetUploadData(list.get(), request);
-  if (!list->empty())
-    details->Set("uploadData", std::move(list));
-  auto headers_value = std::make_unique<base::DictionaryValue>();
-  for (net::HttpRequestHeaders::Iterator it(request->extra_request_headers());
-       it.GetNext();) {
-    headers_value->SetString(it.name(), it.value());
-  }
-  details->Set("headers", std::move(headers_value));
-}
-
-void GetUploadData(base::ListValue* upload_data_list,
-                   const net::URLRequest* request) {
-  const net::UploadDataStream* upload_data = request->get_upload();
-  if (!upload_data)
-    return;
-  const std::vector<std::unique_ptr<net::UploadElementReader>>* readers =
-      upload_data->GetElementReaders();
-  for (const auto& reader : *readers) {
-    auto upload_data_dict = std::make_unique<base::DictionaryValue>();
-    if (reader->AsBytesReader()) {
-      const net::UploadBytesElementReader* bytes_reader =
-          reader->AsBytesReader();
-      auto bytes = std::make_unique<base::Value>(
-          std::vector<char>(bytes_reader->bytes(),
-                            bytes_reader->bytes() + bytes_reader->length()));
-      upload_data_dict->Set("bytes", std::move(bytes));
-    } else if (reader->AsFileReader()) {
-      const net::UploadFileElementReader* file_reader = reader->AsFileReader();
-      auto file_path = file_reader->path().AsUTF8Unsafe();
-      upload_data_dict->SetKey("file", base::Value(file_path));
-    } else {
-      const storage::UploadBlobElementReader* blob_reader =
-          static_cast<storage::UploadBlobElementReader*>(reader.get());
-      upload_data_dict->SetString("blobUUID", blob_reader->uuid());
-    }
-    upload_data_list->Append(std::move(upload_data_dict));
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 b7fd9481a2070480d8cf26b40b7f8a70f4c1692e atom/common/native_mate_converters/net_converter.h
  our    100644 7182102cebaaf4debae09d26f6bd5654b3dcc627 atom/common/native_mate_converters/net_converter.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
-
-#include "base/memory/ref_counted.h"
-#include "native_mate/converter.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-}  // namespace base
-
-namespace net {
-class AuthChallengeInfo;
-class URLRequest;
-class X509Certificate;
-class HttpResponseHeaders;
-struct CertPrincipal;
-}  // namespace net
-
-namespace mate {
-
-template <>
-struct Converter<const net::AuthChallengeInfo*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::AuthChallengeInfo* val);
-};
-
-template <>
-struct Converter<scoped_refptr<net::X509Certificate>> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const scoped_refptr<net::X509Certificate>& val);
-
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     scoped_refptr<net::X509Certificate>* out);
-};
-
-template <>
-struct Converter<net::CertPrincipal> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CertPrincipal& val);
-};
-
-template <>
-struct Converter<net::HttpResponseHeaders*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   net::HttpResponseHeaders* headers);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     net::HttpResponseHeaders* out);
-};
-
-}  // namespace mate
-
-namespace atom {
-
-void FillRequestDetails(base::DictionaryValue* details,
-                        const net::URLRequest* request);
-
-void GetUploadData(base::ListValue* upload_data_list,
-                   const net::URLRequest* request);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
removed in remote
  base   100644 e2a5b8ca489eb40daf1830a98a034370f929316e atom/common/native_mate_converters/string16_converter.h
  our    100644 38dd7001fa23338a4be066f66c18960cb4962057 atom/common/native_mate_converters/string16_converter.h
@@ -1,40 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
-
-#include "base/strings/string16.h"
-#include "native_mate/converter.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::string16> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::string16& val) {
-    return v8::String::NewFromTwoByte(
-        isolate, reinterpret_cast<const uint16_t*>(val.data()),
-        v8::String::kNormalString, val.size());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::string16* out) {
-    if (!val->IsString())
-      return false;
-
-    v8::String::Value s(val);
-    out->assign(reinterpret_cast<const base::char16*>(*s), s.length());
-    return true;
-  }
-};
-
-inline v8::Local<v8::String> StringToV8(v8::Isolate* isolate,
-                                        const base::string16& input) {
-  return ConvertToV8(isolate, input).As<v8::String>();
-}
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
removed in remote
  base   100644 99873cd1c4f08e497d30d9ebef5a9534152f00d4 atom/common/native_mate_converters/v8_value_converter.cc
  our    100644 3fa070771d6843e9428e560c746965b095961e2a atom/common/native_mate_converters/v8_value_converter.cc
@@ -1,500 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-
-#include <map>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/logging.h"
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_bindings.h"
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace {
-
-const int kMaxRecursionDepth = 100;
-
-}  // namespace
-
-// The state of a call to FromV8Value.
-class V8ValueConverter::FromV8ValueState {
- public:
-  // Level scope which updates the current depth of some FromV8ValueState.
-  class Level {
-   public:
-    explicit Level(FromV8ValueState* state) : state_(state) {
-      state_->max_recursion_depth_--;
-    }
-    ~Level() { state_->max_recursion_depth_++; }
-
-   private:
-    FromV8ValueState* state_;
-  };
-
-  FromV8ValueState() : max_recursion_depth_(kMaxRecursionDepth) {}
-
-  // If |handle| is not in |unique_map_|, then add it to |unique_map_| and
-  // return true.
-  //
-  // Otherwise do nothing and return false. Here "A is unique" means that no
-  // other handle B in the map points to the same object as A. Note that A can
-  // be unique even if there already is another handle with the same identity
-  // hash (key) in the map, because two objects can have the same hash.
-  bool AddToUniquenessCheck(v8::Local<v8::Object> handle) {
-    int hash;
-    auto iter = GetIteratorInMap(handle, &hash);
-    if (iter != unique_map_.end())
-      return false;
-
-    unique_map_.insert(std::make_pair(hash, handle));
-    return true;
-  }
-
-  bool RemoveFromUniquenessCheck(v8::Local<v8::Object> handle) {
-    int unused_hash;
-    auto iter = GetIteratorInMap(handle, &unused_hash);
-    if (iter == unique_map_.end())
-      return false;
-    unique_map_.erase(iter);
-    return true;
-  }
-
-  bool HasReachedMaxRecursionDepth() { return max_recursion_depth_ < 0; }
-
- private:
-  using HashToHandleMap = std::multimap<int, v8::Local<v8::Object>>;
-  using Iterator = HashToHandleMap::const_iterator;
-
-  Iterator GetIteratorInMap(v8::Local<v8::Object> handle, int* hash) {
-    *hash = handle->GetIdentityHash();
-    // We only compare using == with handles to objects with the same identity
-    // hash. Different hash obviously means different objects, but two objects
-    // in a couple of thousands could have the same identity hash.
-    std::pair<Iterator, Iterator> range = unique_map_.equal_range(*hash);
-    for (auto it = range.first; it != range.second; ++it) {
-      // Operator == for handles actually compares the underlying objects.
-      if (it->second == handle)
-        return it;
-    }
-    // Not found.
-    return unique_map_.end();
-  }
-
-  HashToHandleMap unique_map_;
-
-  int max_recursion_depth_;
-};
-
-// A class to ensure that objects/arrays that are being converted by
-// this V8ValueConverterImpl do not have cycles.
-//
-// An example of cycle: var v = {}; v = {key: v};
-// Not an example of cycle: var v = {}; a = [v, v]; or w = {a: v, b: v};
-class V8ValueConverter::ScopedUniquenessGuard {
- public:
-  ScopedUniquenessGuard(V8ValueConverter::FromV8ValueState* state,
-                        v8::Local<v8::Object> value)
-      : state_(state),
-        value_(value),
-        is_valid_(state_->AddToUniquenessCheck(value_)) {}
-  ~ScopedUniquenessGuard() {
-    if (is_valid_) {
-      bool removed = state_->RemoveFromUniquenessCheck(value_);
-      DCHECK(removed);
-    }
-  }
-
-  bool is_valid() const { return is_valid_; }
-
- private:
-  typedef std::multimap<int, v8::Local<v8::Object>> HashToHandleMap;
-  V8ValueConverter::FromV8ValueState* state_;
-  v8::Local<v8::Object> value_;
-  bool is_valid_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedUniquenessGuard);
-};
-
-V8ValueConverter::V8ValueConverter() {}
-
-void V8ValueConverter::SetRegExpAllowed(bool val) {
-  reg_exp_allowed_ = val;
-}
-
-void V8ValueConverter::SetFunctionAllowed(bool val) {
-  function_allowed_ = val;
-}
-
-void V8ValueConverter::SetStripNullFromObjects(bool val) {
-  strip_null_from_objects_ = val;
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Value(
-    const base::Value* value,
-    v8::Local<v8::Context> context) const {
-  v8::Context::Scope context_scope(context);
-  v8::EscapableHandleScope handle_scope(context->GetIsolate());
-  return handle_scope.Escape(ToV8ValueImpl(context->GetIsolate(), value));
-}
-
-base::Value* V8ValueConverter::FromV8Value(
-    v8::Local<v8::Value> val,
-    v8::Local<v8::Context> context) const {
-  v8::Context::Scope context_scope(context);
-  v8::HandleScope handle_scope(context->GetIsolate());
-  FromV8ValueState state;
-  return FromV8ValueImpl(&state, val, context->GetIsolate());
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8ValueImpl(
-    v8::Isolate* isolate,
-    const base::Value* value) const {
-  switch (value->type()) {
-    case base::Value::Type::NONE:
-      return v8::Null(isolate);
-
-    case base::Value::Type::BOOLEAN: {
-      bool val = value->GetBool();
-      return v8::Boolean::New(isolate, val);
-    }
-
-    case base::Value::Type::INTEGER: {
-      int val = value->GetInt();
-      return v8::Integer::New(isolate, val);
-    }
-
-    case base::Value::Type::DOUBLE: {
-      double val = value->GetDouble();
-      return v8::Number::New(isolate, val);
-    }
-
-    case base::Value::Type::STRING: {
-      std::string val = value->GetString();
-      return v8::String::NewFromUtf8(isolate, val.c_str(),
-                                     v8::String::kNormalString, val.length());
-    }
-
-    case base::Value::Type::LIST:
-      return ToV8Array(isolate, static_cast<const base::ListValue*>(value));
-
-    case base::Value::Type::DICTIONARY:
-      return ToV8Object(isolate,
-                        static_cast<const base::DictionaryValue*>(value));
-
-    case base::Value::Type::BINARY:
-      return ToArrayBuffer(isolate, static_cast<const base::Value*>(value));
-
-    default:
-      LOG(ERROR) << "Unexpected value type: " << value->type();
-      return v8::Null(isolate);
-  }
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Array(
-    v8::Isolate* isolate,
-    const base::ListValue* val) const {
-  v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
-
-  for (size_t i = 0; i < val->GetSize(); ++i) {
-    const base::Value* child = nullptr;
-    val->Get(i, &child);
-
-    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, child);
-
-    v8::TryCatch try_catch(isolate);
-    result->Set(static_cast<uint32_t>(i), child_v8);
-    if (try_catch.HasCaught())
-      LOG(ERROR) << "Setter for index " << i << " threw an exception.";
-  }
-
-  return result;
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Object(
-    v8::Isolate* isolate,
-    const base::DictionaryValue* val) const {
-  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate);
-  result.SetHidden("simple", true);
-
-  for (base::DictionaryValue::Iterator iter(*val); !iter.IsAtEnd();
-       iter.Advance()) {
-    const std::string& key = iter.key();
-    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, &iter.value());
-
-    v8::TryCatch try_catch(isolate);
-    result.Set(key, child_v8);
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Setter for property " << key.c_str() << " threw an "
-                 << "exception.";
-    }
-  }
-
-  return result.GetHandle();
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToArrayBuffer(
-    v8::Isolate* isolate,
-    const base::Value* value) const {
-  const char* data = value->GetBlob().data();
-  size_t length = value->GetBlob().size();
-
-  if (NodeBindings::IsInitialized()) {
-    return node::Buffer::Copy(isolate, data, length).ToLocalChecked();
-  }
-
-  if (length > node::Buffer::kMaxLength) {
-    return v8::Local<v8::Object>();
-  }
-  auto context = isolate->GetCurrentContext();
-  auto array_buffer = v8::ArrayBuffer::New(isolate, length);
-  memcpy(array_buffer->GetContents().Data(), data, length);
-  // From this point, if something goes wrong(can't find Buffer class for
-  // example) we'll simply return a Uint8Array based on the created ArrayBuffer.
-  // This can happen if no preload script was specified to the renderer.
-  mate::Dictionary global(isolate, context->Global());
-  v8::Local<v8::Value> buffer_value;
-
-  // Get the Buffer class stored as a hidden value in the global object. We'll
-  // use it return a browserified Buffer.
-  if (!global.GetHidden("Buffer", &buffer_value) ||
-      !buffer_value->IsFunction()) {
-    return v8::Uint8Array::New(array_buffer, 0, length);
-  }
-
-  mate::Dictionary buffer_class(
-      isolate,
-      buffer_value->ToObject(isolate->GetCurrentContext()).ToLocalChecked());
-  v8::Local<v8::Value> from_value;
-  if (!buffer_class.Get("from", &from_value) || !from_value->IsFunction()) {
-    return v8::Uint8Array::New(array_buffer, 0, length);
-  }
-
-  v8::Local<v8::Value> args[] = {array_buffer};
-  auto func = v8::Local<v8::Function>::Cast(from_value);
-  auto result = func->Call(context, v8::Null(isolate), 1, args);
-  if (!result.IsEmpty()) {
-    return result.ToLocalChecked();
-  }
-
-  return v8::Uint8Array::New(array_buffer, 0, length);
-}
-
-base::Value* V8ValueConverter::FromV8ValueImpl(FromV8ValueState* state,
-                                               v8::Local<v8::Value> val,
-                                               v8::Isolate* isolate) const {
-  FromV8ValueState::Level state_level(state);
-  if (state->HasReachedMaxRecursionDepth())
-    return nullptr;
-
-  if (val->IsExternal())
-    return std::make_unique<base::Value>().release();
-
-  if (val->IsNull())
-    return std::make_unique<base::Value>().release();
-
-  auto context = isolate->GetCurrentContext();
-
-  if (val->IsBoolean())
-    return new base::Value(val->ToBoolean(context).ToLocalChecked()->Value());
-
-  if (val->IsInt32())
-    return new base::Value(val->ToInt32(context).ToLocalChecked()->Value());
-
-  if (val->IsNumber()) {
-    double val_as_double = val->ToNumber(context).ToLocalChecked()->Value();
-    if (!std::isfinite(val_as_double))
-      return nullptr;
-    return new base::Value(val_as_double);
-  }
-
-  if (val->IsString()) {
-    v8::String::Utf8Value utf8(val->ToString(context).ToLocalChecked());
-    return new base::Value(std::string(*utf8, utf8.length()));
-  }
-
-  if (val->IsUndefined())
-    // JSON.stringify ignores undefined.
-    return nullptr;
-
-  if (val->IsDate()) {
-    v8::Date* date = v8::Date::Cast(*val);
-    v8::Local<v8::Value> toISOString =
-        date->Get(v8::String::NewFromUtf8(isolate, "toISOString"));
-    if (toISOString->IsFunction()) {
-      v8::Local<v8::Value> result =
-          toISOString.As<v8::Function>()->Call(val, 0, nullptr);
-      if (!result.IsEmpty()) {
-        v8::String::Utf8Value utf8(result->ToString(context).ToLocalChecked());
-        return new base::Value(std::string(*utf8, utf8.length()));
-      }
-    }
-  }
-
-  if (val->IsRegExp()) {
-    if (!reg_exp_allowed_)
-      // JSON.stringify converts to an object.
-      return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                          isolate);
-    return new base::Value(
-        *v8::String::Utf8Value(val->ToString(context).ToLocalChecked()));
-  }
-
-  // v8::Value doesn't have a ToArray() method for some reason.
-  if (val->IsArray())
-    return FromV8Array(val.As<v8::Array>(), state, isolate);
-
-  if (val->IsFunction()) {
-    if (!function_allowed_)
-      // JSON.stringify refuses to convert function(){}.
-      return nullptr;
-    return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                        isolate);
-  }
-
-  if (node::Buffer::HasInstance(val)) {
-    return FromNodeBuffer(val, state, isolate);
-  }
-
-  if (val->IsObject()) {
-    return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                        isolate);
-  }
-
-  LOG(ERROR) << "Unexpected v8 value type encountered.";
-  return nullptr;
-}
-
-base::Value* V8ValueConverter::FromV8Array(v8::Local<v8::Array> val,
-                                           FromV8ValueState* state,
-                                           v8::Isolate* isolate) const {
-  ScopedUniquenessGuard uniqueness_guard(state, val);
-  if (!uniqueness_guard.is_valid())
-    return std::make_unique<base::Value>().release();
-
-  std::unique_ptr<v8::Context::Scope> scope;
-  // If val was created in a different context than our current one, change to
-  // that context, but change back after val is converted.
-  if (!val->CreationContext().IsEmpty() &&
-      val->CreationContext() != isolate->GetCurrentContext())
-    scope.reset(new v8::Context::Scope(val->CreationContext()));
-
-  auto* result = new base::ListValue();
-
-  // Only fields with integer keys are carried over to the ListValue.
-  for (uint32_t i = 0; i < val->Length(); ++i) {
-    v8::TryCatch try_catch(isolate);
-    v8::Local<v8::Value> child_v8 = val->Get(i);
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Getter for index " << i << " threw an exception.";
-      child_v8 = v8::Null(isolate);
-    }
-
-    if (!val->HasRealIndexedProperty(i))
-      continue;
-
-    base::Value* child = FromV8ValueImpl(state, child_v8, isolate);
-    if (child)
-      result->Append(std::unique_ptr<base::Value>(child));
-    else
-      // JSON.stringify puts null in places where values don't serialize, for
-      // example undefined and functions. Emulate that behavior.
-      result->Append(std::make_unique<base::Value>());
-  }
-  return result;
-}
-
-base::Value* V8ValueConverter::FromNodeBuffer(v8::Local<v8::Value> value,
-                                              FromV8ValueState* state,
-                                              v8::Isolate* isolate) const {
-  return new base::Value(std::vector<char>(
-      node::Buffer::Data(value),
-      node::Buffer::Data(value) + node::Buffer::Length(value)));
-}
-
-base::Value* V8ValueConverter::FromV8Object(v8::Local<v8::Object> val,
-                                            FromV8ValueState* state,
-                                            v8::Isolate* isolate) const {
-  ScopedUniquenessGuard uniqueness_guard(state, val);
-  if (!uniqueness_guard.is_valid())
-    return std::make_unique<base::Value>().release();
-
-  std::unique_ptr<v8::Context::Scope> scope;
-  // If val was created in a different context than our current one, change to
-  // that context, but change back after val is converted.
-  if (!val->CreationContext().IsEmpty() &&
-      val->CreationContext() != isolate->GetCurrentContext())
-    scope.reset(new v8::Context::Scope(val->CreationContext()));
-
-  auto result = std::make_unique<base::DictionaryValue>();
-  v8::Local<v8::Array> property_names(val->GetOwnPropertyNames());
-
-  for (uint32_t i = 0; i < property_names->Length(); ++i) {
-    v8::Local<v8::Value> key(property_names->Get(i));
-
-    // Extend this test to cover more types as necessary and if sensible.
-    if (!key->IsString() && !key->IsNumber()) {
-      NOTREACHED() << "Key \"" << *v8::String::Utf8Value(key)
-                   << "\" "
-                      "is neither a string nor a number";
-      continue;
-    }
-
-    v8::String::Utf8Value name_utf8(
-        key->ToString(isolate->GetCurrentContext()).ToLocalChecked());
-
-    v8::TryCatch try_catch(isolate);
-    v8::Local<v8::Value> child_v8 = val->Get(key);
-
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Getter for property " << *name_utf8
-                 << " threw an exception.";
-      child_v8 = v8::Null(isolate);
-    }
-
-    std::unique_ptr<base::Value> child(
-        FromV8ValueImpl(state, child_v8, isolate));
-    if (!child.get())
-      // JSON.stringify skips properties whose values don't serialize, for
-      // example undefined and functions. Emulate that behavior.
-      continue;
-
-    // Strip null if asked (and since undefined is turned into null, undefined
-    // too). The use case for supporting this is JSON-schema support,
-    // specifically for extensions, where "optional" JSON properties may be
-    // represented as null, yet due to buggy legacy code elsewhere isn't
-    // treated as such (potentially causing crashes). For example, the
-    // "tabs.create" function takes an object as its first argument with an
-    // optional "windowId" property.
-    //
-    // Given just
-    //
-    //   tabs.create({})
-    //
-    // this will work as expected on code that only checks for the existence of
-    // a "windowId" property (such as that legacy code). However given
-    //
-    //   tabs.create({windowId: null})
-    //
-    // there *is* a "windowId" property, but since it should be an int, code
-    // on the browser which doesn't additionally check for null will fail.
-    // We can avoid all bugs related to this by stripping null.
-    if (strip_null_from_objects_ && child->is_none())
-      continue;
-
-    result->SetWithoutPathExpansion(std::string(*name_utf8, name_utf8.length()),
-                                    std::move(child));
-  }
-
-  return result.release();
-}
-
-}  // namespace atom
removed in remote
  base   100644 632587022d14424fac08b0afde870f0ece298284 atom/common/native_mate_converters/v8_value_converter.h
  our    100644 353f5d13597fa0cefee8d99a0b8bcfa007498aa1 atom/common/native_mate_converters/v8_value_converter.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
-
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "v8/include/v8.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-class Value;
-}  // namespace base
-
-namespace atom {
-
-class V8ValueConverter {
- public:
-  V8ValueConverter();
-
-  void SetRegExpAllowed(bool val);
-  void SetFunctionAllowed(bool val);
-  void SetStripNullFromObjects(bool val);
-  v8::Local<v8::Value> ToV8Value(const base::Value* value,
-                                 v8::Local<v8::Context> context) const;
-  base::Value* FromV8Value(v8::Local<v8::Value> value,
-                           v8::Local<v8::Context> context) const;
-
- private:
-  class FromV8ValueState;
-  class ScopedUniquenessGuard;
-
-  v8::Local<v8::Value> ToV8ValueImpl(v8::Isolate* isolate,
-                                     const base::Value* value) const;
-  v8::Local<v8::Value> ToV8Array(v8::Isolate* isolate,
-                                 const base::ListValue* list) const;
-  v8::Local<v8::Value> ToV8Object(
-      v8::Isolate* isolate,
-      const base::DictionaryValue* dictionary) const;
-  v8::Local<v8::Value> ToArrayBuffer(v8::Isolate* isolate,
-                                     const base::Value* value) const;
-
-  base::Value* FromV8ValueImpl(FromV8ValueState* state,
-                               v8::Local<v8::Value> value,
-                               v8::Isolate* isolate) const;
-  base::Value* FromV8Array(v8::Local<v8::Array> array,
-                           FromV8ValueState* state,
-                           v8::Isolate* isolate) const;
-  base::Value* FromNodeBuffer(v8::Local<v8::Value> value,
-                              FromV8ValueState* state,
-                              v8::Isolate* isolate) const;
-  base::Value* FromV8Object(v8::Local<v8::Object> object,
-                            FromV8ValueState* state,
-                            v8::Isolate* isolate) const;
-
-  // If true, we will convert RegExp JavaScript objects to string.
-  bool reg_exp_allowed_ = false;
-
-  // If true, we will convert Function JavaScript objects to dictionaries.
-  bool function_allowed_ = false;
-
-  // If true, undefined and null values are ignored when converting v8 objects
-  // into Values.
-  bool strip_null_from_objects_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(V8ValueConverter);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
removed in remote
  base   100644 c9c1a861ba26d9cfdc68292427ca2f86fba7685e atom/common/native_mate_converters/value_converter.cc
  our    100644 a71cc70f83d2526596a75d8daf036f905ca099be atom/common/native_mate_converters/value_converter.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/value_converter.h"
-
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-#include "base/values.h"
-
-namespace mate {
-
-bool Converter<base::DictionaryValue>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              base::DictionaryValue* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value && value->is_dict()) {
-    out->Swap(static_cast<base::DictionaryValue*>(value.get()));
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::DictionaryValue>::ToV8(
-    v8::Isolate* isolate,
-    const base::DictionaryValue& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-bool Converter<base::Value>::FromV8(v8::Isolate* isolate,
-                                    v8::Local<v8::Value> val,
-                                    base::Value* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value) {
-    *out = value->Clone();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::Value>::ToV8(v8::Isolate* isolate,
-                                                  const base::Value& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-bool Converter<base::ListValue>::FromV8(v8::Isolate* isolate,
-                                        v8::Local<v8::Value> val,
-                                        base::ListValue* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value->is_list()) {
-    out->Swap(static_cast<base::ListValue*>(value.get()));
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::ListValue>::ToV8(
-    v8::Isolate* isolate,
-    const base::ListValue& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-}  // namespace mate
removed in remote
  base   100644 013dd99cc7980a2636b04c6b700dc55fa53385cb atom/common/native_mate_converters/value_converter.h
  our    100644 b2ea5def0aa9646791c635c15e0ed504dc0af465 atom/common/native_mate_converters/value_converter.h
@@ -1,47 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-class Value;
-}  // namespace base
-
-namespace mate {
-
-template <>
-struct Converter<base::DictionaryValue> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::DictionaryValue* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::DictionaryValue& val);
-};
-
-template <>
-struct Converter<base::Value> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::Value* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::Value& val);
-};
-
-template <>
-struct Converter<base::ListValue> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::ListValue* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::ListValue& val);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
removed in remote
  base   100644 b0b4148c7baf2f4970d7211bb368591a695ca727 atom/common/node_bindings.cc
  our    100644 e6aded2e661af919c2d89c2f9bd46b4921d4aec4 atom/common/node_bindings.cc
@@ -1,384 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/api/locker.h"
-#include "atom/common/atom_command_line.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/base_paths.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/path_service.h"
-#include "base/run_loop.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/trace_event/trace_event.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/common/content_paths.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-#define ELECTRON_BUILTIN_MODULES(V)          \
-  V(atom_browser_app)                        \
-  V(atom_browser_auto_updater)               \
-  V(atom_browser_browser_view)               \
-  V(atom_browser_content_tracing)            \
-  V(atom_browser_debugger)                   \
-  V(atom_browser_dialog)                     \
-  V(atom_browser_download_item)              \
-  V(atom_browser_global_shortcut)            \
-  V(atom_browser_in_app_purchase)            \
-  V(atom_browser_menu)                       \
-  V(atom_browser_net)                        \
-  V(atom_browser_net_log)                    \
-  V(atom_browser_power_monitor)              \
-  V(atom_browser_power_save_blocker)         \
-  V(atom_browser_protocol)                   \
-  V(atom_browser_render_process_preferences) \
-  V(atom_browser_session)                    \
-  V(atom_browser_system_preferences)         \
-  V(atom_browser_top_level_window)           \
-  V(atom_browser_tray)                       \
-  V(atom_browser_web_contents)               \
-  V(atom_browser_web_contents_view)          \
-  V(atom_browser_view)                       \
-  V(atom_browser_web_view_manager)           \
-  V(atom_browser_window)                     \
-  V(atom_common_asar)                        \
-  V(atom_common_clipboard)                   \
-  V(atom_common_crash_reporter)              \
-  V(atom_common_features)                    \
-  V(atom_common_native_image)                \
-  V(atom_common_notification)                \
-  V(atom_common_screen)                      \
-  V(atom_common_shell)                       \
-  V(atom_common_v8_util)                     \
-  V(atom_renderer_ipc)                       \
-  V(atom_renderer_web_frame)
-
-#define ELECTRON_VIEW_MODULES(V) \
-  V(atom_browser_box_layout)     \
-  V(atom_browser_button)         \
-  V(atom_browser_label_button)   \
-  V(atom_browser_layout_manager) \
-  V(atom_browser_text_field)
-
-#define ELECTRON_DESKTOP_CAPTURER_MODULE(V) V(atom_browser_desktop_capturer)
-
-// This is used to load built-in modules. Instead of using
-// __attribute__((constructor)), we call the _register_<modname>
-// function for each built-in modules explicitly. This is only
-// forward declaration. The definitions are in each module's
-// implementation when calling the NODE_BUILTIN_MODULE_CONTEXT_AWARE.
-#define V(modname) void _register_##modname();
-ELECTRON_BUILTIN_MODULES(V)
-#if defined(ENABLE_VIEW_API)
-ELECTRON_VIEW_MODULES(V)
-#endif
-#if defined(ENABLE_DESKTOP_CAPTURER)
-ELECTRON_DESKTOP_CAPTURER_MODULE(V)
-#endif
-#undef V
-
-namespace {
-
-void stop_and_close_uv_loop(uv_loop_t* loop) {
-  // Close any active handles
-  uv_stop(loop);
-  uv_walk(loop,
-          [](uv_handle_t* handle, void*) {
-            if (!uv_is_closing(handle)) {
-              uv_close(handle, nullptr);
-            }
-          },
-          nullptr);
-
-  // Run the loop to let it finish all the closing handles
-  // NB: after uv_stop(), uv_run(UV_RUN_DEFAULT) returns 0 when that's done
-  for (;;)
-    if (!uv_run(loop, UV_RUN_DEFAULT))
-      break;
-
-  DCHECK(!uv_loop_alive(loop));
-  uv_loop_close(loop);
-}
-
-bool g_is_initialized = false;
-
-}  // namespace
-
-namespace atom {
-
-namespace {
-
-// Convert the given vector to an array of C-strings. The strings in the
-// returned vector are only guaranteed valid so long as the vector of strings
-// is not modified.
-std::unique_ptr<const char* []> StringVectorToArgArray(
-    const std::vector<std::string>& vector) {
-  std::unique_ptr<const char* []> array(new const char*[vector.size()]);
-  for (size_t i = 0; i < vector.size(); ++i) {
-    array[i] = vector[i].c_str();
-  }
-  return array;
-}
-
-base::FilePath GetResourcesPath(bool is_browser) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath exec_path(command_line->GetProgram());
-  PathService::Get(base::FILE_EXE, &exec_path);
-
-  base::FilePath resources_path =
-#if defined(OS_MACOSX)
-      is_browser
-          ? exec_path.DirName().DirName().Append("Resources")
-          : exec_path.DirName().DirName().DirName().DirName().DirName().Append(
-                "Resources");
-#else
-      exec_path.DirName().Append(FILE_PATH_LITERAL("resources"));
-#endif
-  return resources_path;
-}
-
-}  // namespace
-
-NodeBindings::NodeBindings(BrowserEnvironment browser_env)
-    : browser_env_(browser_env), weak_factory_(this) {
-  if (browser_env == WORKER) {
-    uv_loop_init(&worker_loop_);
-    uv_loop_ = &worker_loop_;
-  } else {
-    uv_loop_ = uv_default_loop();
-  }
-}
-
-NodeBindings::~NodeBindings() {
-  // Quit the embed thread.
-  embed_closed_ = true;
-  uv_sem_post(&embed_sem_);
-  WakeupEmbedThread();
-
-  // Wait for everything to be done.
-  uv_thread_join(&embed_thread_);
-
-  // Clear uv.
-  uv_sem_destroy(&embed_sem_);
-  uv_close(reinterpret_cast<uv_handle_t*>(&dummy_uv_handle_), nullptr);
-
-  // Clean up worker loop
-  if (uv_loop_ == &worker_loop_)
-    stop_and_close_uv_loop(uv_loop_);
-}
-
-void NodeBindings::RegisterBuiltinModules() {
-#define V(modname) _register_##modname();
-  ELECTRON_BUILTIN_MODULES(V)
-#if defined(ENABLE_VIEW_API)
-  ELECTRON_VIEW_MODULES(V)
-#endif
-#if defined(ENABLE_DESKTOP_CAPTURER)
-  ELECTRON_DESKTOP_CAPTURER_MODULE(V)
-#endif
-#undef V
-}
-
-bool NodeBindings::IsInitialized() {
-  return g_is_initialized;
-}
-
-base::FilePath::StringType NodeBindings::GetHelperResourcesPath() {
-  return GetResourcesPath(false).value();
-}
-
-void NodeBindings::Initialize() {
-  // Open node's error reporting system for browser process.
-  node::g_standalone_mode = browser_env_ == BROWSER;
-  node::g_upstream_node_mode = false;
-
-#if defined(OS_LINUX)
-  // Get real command line in renderer process forked by zygote.
-  if (browser_env_ != BROWSER)
-    AtomCommandLine::InitializeFromCommandLine();
-#endif
-
-  // Explicitly register electron's builtin modules.
-  RegisterBuiltinModules();
-
-  // Init node.
-  // (we assume node::Init would not modify the parameters under embedded mode).
-  node::Init(nullptr, nullptr, nullptr, nullptr);
-
-#if defined(OS_WIN)
-  // uv_init overrides error mode to suppress the default crash dialog, bring
-  // it back if user wants to show it.
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  if (browser_env_ == BROWSER || env->HasVar("ELECTRON_DEFAULT_ERROR_MODE"))
-    SetErrorMode(GetErrorMode() & ~SEM_NOGPFAULTERRORBOX);
-#endif
-
-  g_is_initialized = true;
-}
-
-node::Environment* NodeBindings::CreateEnvironment(
-    v8::Handle<v8::Context> context,
-    node::MultiIsolatePlatform* platform) {
-#if defined(OS_WIN)
-  auto& atom_args = AtomCommandLine::argv();
-  std::vector<std::string> args(atom_args.size());
-  std::transform(atom_args.cbegin(), atom_args.cend(), args.begin(),
-                 [](auto& a) { return base::WideToUTF8(a); });
-#else
-  auto args = AtomCommandLine::argv();
-#endif
-
-  // Feed node the path to initialization script.
-  base::FilePath::StringType process_type;
-  switch (browser_env_) {
-    case BROWSER:
-      process_type = FILE_PATH_LITERAL("browser");
-      break;
-    case RENDERER:
-      process_type = FILE_PATH_LITERAL("renderer");
-      break;
-    case WORKER:
-      process_type = FILE_PATH_LITERAL("worker");
-      break;
-  }
-  base::FilePath resources_path = GetResourcesPath(browser_env_ == BROWSER);
-  base::FilePath script_path =
-      resources_path.Append(FILE_PATH_LITERAL("electron.asar"))
-          .Append(process_type)
-          .Append(FILE_PATH_LITERAL("init.js"));
-  args.insert(args.begin() + 1, script_path.AsUTF8Unsafe());
-
-  std::unique_ptr<const char* []> c_argv = StringVectorToArgArray(args);
-  node::Environment* env = node::CreateEnvironment(
-      node::CreateIsolateData(context->GetIsolate(), uv_loop_, platform),
-      context, args.size(), c_argv.get(), 0, nullptr);
-
-  if (browser_env_ == BROWSER) {
-    // SetAutorunMicrotasks is no longer called in node::CreateEnvironment
-    // so instead call it here to match expected node behavior
-    context->GetIsolate()->SetMicrotasksPolicy(v8::MicrotasksPolicy::kExplicit);
-  } else {
-    // Node uses the deprecated SetAutorunMicrotasks(false) mode, we should
-    // switch to use the scoped policy to match blink's behavior.
-    context->GetIsolate()->SetMicrotasksPolicy(v8::MicrotasksPolicy::kScoped);
-  }
-
-  mate::Dictionary process(context->GetIsolate(), env->process_object());
-  process.Set("type", process_type);
-  process.Set("resourcesPath", resources_path);
-  // Do not set DOM globals for renderer process.
-  if (browser_env_ != BROWSER)
-    process.Set("_noBrowserGlobals", resources_path);
-  // The path to helper app.
-  base::FilePath helper_exec_path;
-  PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);
-  process.Set("helperExecPath", helper_exec_path);
-
-  return env;
-}
-
-void NodeBindings::LoadEnvironment(node::Environment* env) {
-  node::LoadEnvironment(env);
-  mate::EmitEvent(env->isolate(), env->process_object(), "loaded");
-}
-
-void NodeBindings::PrepareMessageLoop() {
-  // Add dummy handle for libuv, otherwise libuv would quit when there is
-  // nothing to do.
-  uv_async_init(uv_loop_, &dummy_uv_handle_, nullptr);
-
-  // Start worker that will interrupt main loop when having uv events.
-  uv_sem_init(&embed_sem_, 0);
-  uv_thread_create(&embed_thread_, EmbedThreadRunner, this);
-}
-
-void NodeBindings::RunMessageLoop() {
-  // The MessageLoop should have been created, remember the one in main thread.
-  task_runner_ = base::ThreadTaskRunnerHandle::Get();
-
-  // Run uv loop for once to give the uv__io_poll a chance to add all events.
-  UvRunOnce();
-}
-
-void NodeBindings::UvRunOnce() {
-  node::Environment* env = uv_env();
-
-  // When doing navigation without restarting renderer process, it may happen
-  // that the node environment is destroyed but the message loop is still there.
-  // In this case we should not run uv loop.
-  if (!env)
-    return;
-
-  // Use Locker in browser process.
-  mate::Locker locker(env->isolate());
-  v8::HandleScope handle_scope(env->isolate());
-
-  // Enter node context while dealing with uv events.
-  v8::Context::Scope context_scope(env->context());
-
-  // Perform microtask checkpoint after running JavaScript.
-  v8::MicrotasksScope script_scope(env->isolate(),
-                                   v8::MicrotasksScope::kRunMicrotasks);
-
-  if (browser_env_ != BROWSER)
-    TRACE_EVENT_BEGIN0("devtools.timeline", "FunctionCall");
-
-  // Deal with uv events.
-  int r = uv_run(uv_loop_, UV_RUN_NOWAIT);
-
-  if (browser_env_ != BROWSER)
-    TRACE_EVENT_END0("devtools.timeline", "FunctionCall");
-
-  if (r == 0)
-    base::RunLoop().QuitWhenIdle();  // Quit from uv.
-
-  // Tell the worker thread to continue polling.
-  uv_sem_post(&embed_sem_);
-}
-
-void NodeBindings::WakeupMainThread() {
-  DCHECK(task_runner_);
-  task_runner_->PostTask(FROM_HERE, base::BindOnce(&NodeBindings::UvRunOnce,
-                                                   weak_factory_.GetWeakPtr()));
-}
-
-void NodeBindings::WakeupEmbedThread() {
-  uv_async_send(&dummy_uv_handle_);
-}
-
-// static
-void NodeBindings::EmbedThreadRunner(void* arg) {
-  NodeBindings* self = static_cast<NodeBindings*>(arg);
-
-  while (true) {
-    // Wait for the main loop to deal with events.
-    uv_sem_wait(&self->embed_sem_);
-    if (self->embed_closed_)
-      break;
-
-    // Wait for something to happen in uv loop.
-    // Note that the PollEvents() is implemented by derived classes, so when
-    // this class is being destructed the PollEvents() would not be available
-    // anymore. Because of it we must make sure we only invoke PollEvents()
-    // when this class is alive.
-    self->PollEvents();
-    if (self->embed_closed_)
-      break;
-
-    // Deal with event in main thread.
-    self->WakeupMainThread();
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 16d512d3bed038c08d9d3c25da727ea9640f4f49 atom/common/node_bindings.h
  our    100644 5e5ec8e5300ba2c1917e3e9d7e2e8ea1ee341e3b atom/common/node_bindings.h
@@ -1,117 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_H_
-#define ATOM_COMMON_NODE_BINDINGS_H_
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/single_thread_task_runner.h"
-#include "uv.h"  // NOLINT(build/include)
-#include "v8/include/v8.h"
-
-namespace base {
-class MessageLoop;
-}
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-class NodeBindings {
- public:
-  enum BrowserEnvironment {
-    BROWSER,
-    RENDERER,
-    WORKER,
-  };
-
-  static NodeBindings* Create(BrowserEnvironment browser_env);
-  static void RegisterBuiltinModules();
-  static bool IsInitialized();
-  static base::FilePath::StringType GetHelperResourcesPath();
-
-  virtual ~NodeBindings();
-
-  // Setup V8, libuv.
-  void Initialize();
-
-  // Create the environment and load node.js.
-  node::Environment* CreateEnvironment(
-      v8::Handle<v8::Context> context,
-      node::MultiIsolatePlatform* platform = nullptr);
-
-  // Load node.js in the environment.
-  void LoadEnvironment(node::Environment* env);
-
-  // Prepare for message loop integration.
-  void PrepareMessageLoop();
-
-  // Do message loop integration.
-  virtual void RunMessageLoop();
-
-  // Gets/sets the environment to wrap uv loop.
-  void set_uv_env(node::Environment* env) { uv_env_ = env; }
-  node::Environment* uv_env() const { return uv_env_; }
-
-  uv_loop_t* uv_loop() const { return uv_loop_; }
-
- protected:
-  explicit NodeBindings(BrowserEnvironment browser_env);
-
-  // Called to poll events in new thread.
-  virtual void PollEvents() = 0;
-
-  // Run the libuv loop for once.
-  void UvRunOnce();
-
-  // Make the main thread run libuv loop.
-  void WakeupMainThread();
-
-  // Interrupt the PollEvents.
-  void WakeupEmbedThread();
-
-  // Which environment we are running.
-  BrowserEnvironment browser_env_;
-
-  // Current thread's MessageLoop.
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-
-  // Current thread's libuv loop.
-  uv_loop_t* uv_loop_;
-
- private:
-  // Thread to poll uv events.
-  static void EmbedThreadRunner(void* arg);
-
-  // Whether the libuv loop has ended.
-  bool embed_closed_ = false;
-
-  // Loop used when constructed in WORKER mode
-  uv_loop_t worker_loop_;
-
-  // Dummy handle to make uv's loop not quit.
-  uv_async_t dummy_uv_handle_;
-
-  // Thread for polling events.
-  uv_thread_t embed_thread_;
-
-  // Semaphore to wait for main loop in the embed thread.
-  uv_sem_t embed_sem_;
-
-  // Environment that to wrap the uv loop.
-  node::Environment* uv_env_ = nullptr;
-
-  base::WeakPtrFactory<NodeBindings> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindings);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_H_
removed in remote
  base   100644 34b9ea952365eb5875ac9e9faea1641f3f5a225e atom/common/node_bindings_linux.cc
  our    100644 3c58cb67a072387c4b203697ece022c19d45f7ed atom/common/node_bindings_linux.cc
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_linux.h"
-
-#include <sys/epoll.h>
-
-namespace atom {
-
-NodeBindingsLinux::NodeBindingsLinux(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env), epoll_(epoll_create(1)) {
-  int backend_fd = uv_backend_fd(uv_loop_);
-  struct epoll_event ev = {0};
-  ev.events = EPOLLIN;
-  ev.data.fd = backend_fd;
-  epoll_ctl(epoll_, EPOLL_CTL_ADD, backend_fd, &ev);
-}
-
-NodeBindingsLinux::~NodeBindingsLinux() {}
-
-void NodeBindingsLinux::RunMessageLoop() {
-  // Get notified when libuv's watcher queue changes.
-  uv_loop_->data = this;
-  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
-
-  NodeBindings::RunMessageLoop();
-}
-
-// static
-void NodeBindingsLinux::OnWatcherQueueChanged(uv_loop_t* loop) {
-  NodeBindingsLinux* self = static_cast<NodeBindingsLinux*>(loop->data);
-
-  // We need to break the io polling in the epoll thread when loop's watcher
-  // queue changes, otherwise new events cannot be notified.
-  self->WakeupEmbedThread();
-}
-
-void NodeBindingsLinux::PollEvents() {
-  int timeout = uv_backend_timeout(uv_loop_);
-
-  // Wait for new libuv events.
-  int r;
-  do {
-    struct epoll_event ev;
-    r = epoll_wait(epoll_, &ev, 1, timeout);
-  } while (r == -1 && errno == EINTR);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsLinux(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3bbea9f9dd0a315a32880f87da5e3d5c7c5a1cbc atom/common/node_bindings_linux.h
  our    100644 15d9b33eb047bfd9fc92bb1458989c4238e0d9d2 atom/common/node_bindings_linux.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_LINUX_H_
-#define ATOM_COMMON_NODE_BINDINGS_LINUX_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsLinux : public NodeBindings {
- public:
-  explicit NodeBindingsLinux(BrowserEnvironment browser_env);
-  ~NodeBindingsLinux() override;
-
-  void RunMessageLoop() override;
-
- private:
-  // Called when uv's watcher queue changes.
-  static void OnWatcherQueueChanged(uv_loop_t* loop);
-
-  void PollEvents() override;
-
-  // Epoll to poll for uv's backend fd.
-  int epoll_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsLinux);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_LINUX_H_
removed in remote
  base   100644 877497d5a1e2b0748072fc539596a5d7b3b1f417 atom/common/node_bindings_mac.cc
  our    100644 856b9cc868a51e1ca754da2a24682780ed9100b4 atom/common/node_bindings_mac.cc
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_mac.h"
-
-#include <errno.h>
-#include <sys/select.h>
-#include <sys/sysctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-NodeBindingsMac::NodeBindingsMac(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env) {}
-
-NodeBindingsMac::~NodeBindingsMac() {}
-
-void NodeBindingsMac::RunMessageLoop() {
-  // Get notified when libuv's watcher queue changes.
-  uv_loop_->data = this;
-  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
-
-  NodeBindings::RunMessageLoop();
-}
-
-// static
-void NodeBindingsMac::OnWatcherQueueChanged(uv_loop_t* loop) {
-  NodeBindingsMac* self = static_cast<NodeBindingsMac*>(loop->data);
-
-  // We need to break the io polling in the kqueue thread when loop's watcher
-  // queue changes, otherwise new events cannot be notified.
-  self->WakeupEmbedThread();
-}
-
-void NodeBindingsMac::PollEvents() {
-  struct timeval tv;
-  int timeout = uv_backend_timeout(uv_loop_);
-  if (timeout != -1) {
-    tv.tv_sec = timeout / 1000;
-    tv.tv_usec = (timeout % 1000) * 1000;
-  }
-
-  fd_set readset;
-  int fd = uv_backend_fd(uv_loop_);
-  FD_ZERO(&readset);
-  FD_SET(fd, &readset);
-
-  // Wait for new libuv events.
-  int r;
-  do {
-    r = select(fd + 1, &readset, nullptr, nullptr,
-               timeout == -1 ? nullptr : &tv);
-  } while (r == -1 && errno == EINTR);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsMac(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 03152ada3ea698af3c9d6297f219cdd9127ecbe9 atom/common/node_bindings_mac.h
  our    100644 a0f93d8755eda701d12833e425bf1bb580790c5b atom/common/node_bindings_mac.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_MAC_H_
-#define ATOM_COMMON_NODE_BINDINGS_MAC_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsMac : public NodeBindings {
- public:
-  explicit NodeBindingsMac(BrowserEnvironment browser_env);
-  ~NodeBindingsMac() override;
-
-  void RunMessageLoop() override;
-
- private:
-  // Called when uv's watcher queue changes.
-  static void OnWatcherQueueChanged(uv_loop_t* loop);
-
-  void PollEvents() override;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsMac);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_MAC_H_
removed in remote
  base   100644 b8de4f59da3b79d62e880dee7ee35707533c3536 atom/common/node_bindings_win.cc
  our    100644 e41fb585f57114de00376f52e0d97277e6eca94b atom/common/node_bindings_win.cc
@@ -1,39 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_win.h"
-
-#include <windows.h>
-
-#include "base/logging.h"
-
-namespace atom {
-
-NodeBindingsWin::NodeBindingsWin(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env) {}
-
-NodeBindingsWin::~NodeBindingsWin() {}
-
-void NodeBindingsWin::PollEvents() {
-  // If there are other kinds of events pending, uv_backend_timeout will
-  // instruct us not to wait.
-  DWORD bytes, timeout;
-  ULONG_PTR key;
-  OVERLAPPED* overlapped;
-
-  timeout = uv_backend_timeout(uv_loop_);
-
-  GetQueuedCompletionStatus(uv_loop_->iocp, &bytes, &key, &overlapped, timeout);
-
-  // Give the event back so libuv can deal with it.
-  if (overlapped != NULL)
-    PostQueuedCompletionStatus(uv_loop_->iocp, bytes, key, overlapped);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsWin(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3950098e5ebfba8c2a19618f366a24ef37455a86 atom/common/node_bindings_win.h
  our    100644 77fe5f43b54c8d53bfc5a4a29c9c0a6f62bea423 atom/common/node_bindings_win.h
@@ -1,26 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_WIN_H_
-#define ATOM_COMMON_NODE_BINDINGS_WIN_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsWin : public NodeBindings {
- public:
-  explicit NodeBindingsWin(BrowserEnvironment browser_env);
-  ~NodeBindingsWin() override;
-
- private:
-  void PollEvents() override;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsWin);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_WIN_H_
removed in remote
  base   100644 bb76afb54db9e806a68cfe797f7af79c6b3ef199 atom/common/node_includes.h
  our    100644 fa1a7499a8b082fe9007f04041b46e58502b3ad9 atom/common/node_includes.h
@@ -1,54 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_INCLUDES_H_
-#define ATOM_COMMON_NODE_INCLUDES_H_
-
-#include "base/logging.h"
-
-// Include common headers for using node APIs.
-
-#ifdef NODE_SHARED_MODE
-#define BUILDING_NODE_EXTENSION
-#endif
-
-// The following define makes sure that we do not include the macros
-// again. But we still need the tracing functions, so declaring them.
-#define SRC_TRACING_TRACE_EVENT_H_
-
-#undef ASSERT
-#undef CHECK
-#undef CHECK_EQ
-#undef CHECK_NE
-#undef CHECK_GE
-#undef CHECK_GT
-#undef CHECK_LE
-#undef CHECK_LT
-#undef UNLIKELY
-#undef DISALLOW_COPY_AND_ASSIGN
-#undef NO_RETURN
-#undef LIKELY
-#undef arraysize
-#undef debug_string  // This is defined in macOS 10.9 SDK in AssertMacros.h.
-#include "env-inl.h"
-#include "env.h"
-#include "node.h"
-#include "node_buffer.h"
-#include "node_debug_options.h"
-#include "node_internals.h"
-#include "node_platform.h"
-
-namespace node {
-namespace tracing {
-
-class TraceEventHelper {
- public:
-  static v8::TracingController* GetTracingController();
-  static void SetTracingController(v8::TracingController* controller);
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // ATOM_COMMON_NODE_INCLUDES_H_
removed in remote
  base   100644 ac63ea1b7276fc93f5d47ffaa624e080d95d6939 atom/common/options_switches.cc
  our    100644 8b1836f80c583e4db68971ff1b00ca4f86356b45 atom/common/options_switches.cc
@@ -1,221 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/options_switches.h"
-
-namespace atom {
-
-namespace options {
-
-const char kTitle[] = "title";
-const char kIcon[] = "icon";
-const char kFrame[] = "frame";
-const char kShow[] = "show";
-const char kCenter[] = "center";
-const char kX[] = "x";
-const char kY[] = "y";
-const char kWidth[] = "width";
-const char kHeight[] = "height";
-const char kMinWidth[] = "minWidth";
-const char kMinHeight[] = "minHeight";
-const char kMaxWidth[] = "maxWidth";
-const char kMaxHeight[] = "maxHeight";
-const char kResizable[] = "resizable";
-const char kMovable[] = "movable";
-const char kMinimizable[] = "minimizable";
-const char kMaximizable[] = "maximizable";
-const char kFullScreenable[] = "fullscreenable";
-const char kClosable[] = "closable";
-const char kFullscreen[] = "fullscreen";
-
-// Whether the window should show in taskbar.
-const char kSkipTaskbar[] = "skipTaskbar";
-
-// Start with the kiosk mode, see Opera's page for description:
-// http://www.opera.com/support/mastering/kiosk/
-const char kKiosk[] = "kiosk";
-
-const char kSimpleFullScreen[] = "simpleFullscreen";
-
-// Make windows stays on the top of all other windows.
-const char kAlwaysOnTop[] = "alwaysOnTop";
-
-// Enable the NSView to accept first mouse event.
-const char kAcceptFirstMouse[] = "acceptFirstMouse";
-
-// Whether window size should include window frame.
-const char kUseContentSize[] = "useContentSize";
-
-// Whether window zoom should be to page width.
-const char kZoomToPageWidth[] = "zoomToPageWidth";
-
-// Whether always show title text in full screen is enabled.
-const char kFullscreenWindowTitle[] = "fullscreenWindowTitle";
-
-// The requested title bar style for the window
-const char kTitleBarStyle[] = "titleBarStyle";
-
-// Tabbing identifier for the window if native tabs are enabled on macOS.
-const char kTabbingIdentifier[] = "tabbingIdentifier";
-
-// The menu bar is hidden unless "Alt" is pressed.
-const char kAutoHideMenuBar[] = "autoHideMenuBar";
-
-// Enable window to be resized larger than screen.
-const char kEnableLargerThanScreen[] = "enableLargerThanScreen";
-
-// Forces to use dark theme on Linux.
-const char kDarkTheme[] = "darkTheme";
-
-// Whether the window should be transparent.
-const char kTransparent[] = "transparent";
-
-// Window type hint.
-const char kType[] = "type";
-
-// Disable auto-hiding cursor.
-const char kDisableAutoHideCursor[] = "disableAutoHideCursor";
-
-// Use the macOS' standard window instead of the textured window.
-const char kStandardWindow[] = "standardWindow";
-
-// Default browser window background color.
-const char kBackgroundColor[] = "backgroundColor";
-
-// Whether the window should have a shadow.
-const char kHasShadow[] = "hasShadow";
-
-// Browser window opacity
-const char kOpacity[] = "opacity";
-
-// Whether the window can be activated.
-const char kFocusable[] = "focusable";
-
-// The WebPreferences.
-const char kWebPreferences[] = "webPreferences";
-
-// Add a vibrancy effect to the browser window
-const char kVibrancyType[] = "vibrancy";
-
-// The factor of which page should be zoomed.
-const char kZoomFactor[] = "zoomFactor";
-
-// Script that will be loaded by guest WebContents before other scripts.
-const char kPreloadScript[] = "preload";
-
-// Like --preload, but the passed argument is an URL.
-const char kPreloadURL[] = "preloadURL";
-
-// Enable the node integration.
-const char kNodeIntegration[] = "nodeIntegration";
-
-// Enable context isolation of Electron APIs and preload script
-const char kContextIsolation[] = "contextIsolation";
-
-// Instance ID of guest WebContents.
-const char kGuestInstanceID[] = "guestInstanceId";
-
-// Web runtime features.
-const char kExperimentalFeatures[] = "experimentalFeatures";
-
-// Opener window's ID.
-const char kOpenerID[] = "openerId";
-
-// Enable the rubber banding effect.
-const char kScrollBounce[] = "scrollBounce";
-
-// Enable blink features.
-const char kEnableBlinkFeatures[] = "enableBlinkFeatures";
-
-// Disable blink features.
-const char kDisableBlinkFeatures[] = "disableBlinkFeatures";
-
-// Enable the node integration in WebWorker.
-const char kNodeIntegrationInWorker[] = "nodeIntegrationInWorker";
-
-// Enable the web view tag.
-const char kWebviewTag[] = "webviewTag";
-
-const char kNativeWindowOpen[] = "nativeWindowOpen";
-
-const char kCustomArgs[] = "additionalArguments";
-
-const char kPlugins[] = "plugins";
-
-const char kSandbox[] = "sandbox";
-
-const char kWebSecurity[] = "webSecurity";
-
-const char kAllowRunningInsecureContent[] = "allowRunningInsecureContent";
-
-const char kOffscreen[] = "offscreen";
-
-}  // namespace options
-
-namespace switches {
-
-// Enable chromium sandbox.
-const char kEnableSandbox[] = "enable-sandbox";
-
-// Enable sandbox in only remote content windows.
-const char kEnableMixedSandbox[] = "enable-mixed-sandbox";
-
-// Enable plugins.
-const char kEnablePlugins[] = "enable-plugins";
-
-// Ppapi Flash path.
-const char kPpapiFlashPath[] = "ppapi-flash-path";
-
-// Ppapi Flash version.
-const char kPpapiFlashVersion[] = "ppapi-flash-version";
-
-// Disable HTTP cache.
-const char kDisableHttpCache[] = "disable-http-cache";
-
-// The list of standard schemes.
-const char kStandardSchemes[] = "standard-schemes";
-
-// Register schemes to handle service worker.
-const char kRegisterServiceWorkerSchemes[] = "register-service-worker-schemes";
-
-// Register schemes as secure.
-const char kSecureSchemes[] = "secure-schemes";
-
-// The browser process app model ID
-const char kAppUserModelId[] = "app-user-model-id";
-
-// The application path
-const char kAppPath[] = "app-path";
-
-// The command line switch versions of the options.
-const char kBackgroundColor[] = "background-color";
-const char kPreloadScript[] = "preload";
-const char kPreloadScripts[] = "preload-scripts";
-const char kNodeIntegration[] = "node-integration";
-const char kContextIsolation[] = "context-isolation";
-const char kGuestInstanceID[] = "guest-instance-id";
-const char kOpenerID[] = "opener-id";
-const char kScrollBounce[] = "scroll-bounce";
-const char kHiddenPage[] = "hidden-page";
-const char kNativeWindowOpen[] = "native-window-open";
-const char kWebviewTag[] = "webview-tag";
-
-// Command switch passed to renderer process to control nodeIntegration.
-const char kNodeIntegrationInWorker[] = "node-integration-in-worker";
-
-// Widevine options
-// Path to Widevine CDM binaries.
-const char kWidevineCdmPath[] = "widevine-cdm-path";
-// Widevine CDM version.
-const char kWidevineCdmVersion[] = "widevine-cdm-version";
-
-// Forces the maximum disk space to be used by the disk cache, in bytes.
-const char kDiskCacheSize[] = "disk-cache-size";
-
-// Ignore the limit of 6 connections per host.
-const char kIgnoreConnectionsLimit[] = "ignore-connections-limit";
-
-}  // namespace switches
-
-}  // namespace atom
removed in remote
  base   100644 3c198555a5c380e81dbdfcd4f26b5c03a2a5c6a5 atom/common/options_switches.h
  our    100644 5f6d7e9d38120668ed06922ced2f8d6a6e27a52b atom/common/options_switches.h
@@ -1,119 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_OPTIONS_SWITCHES_H_
-#define ATOM_COMMON_OPTIONS_SWITCHES_H_
-
-namespace atom {
-
-namespace options {
-
-extern const char kTitle[];
-extern const char kIcon[];
-extern const char kFrame[];
-extern const char kShow[];
-extern const char kCenter[];
-extern const char kX[];
-extern const char kY[];
-extern const char kWidth[];
-extern const char kHeight[];
-extern const char kMinWidth[];
-extern const char kMinHeight[];
-extern const char kMaxWidth[];
-extern const char kMaxHeight[];
-extern const char kResizable[];
-extern const char kMovable[];
-extern const char kMinimizable[];
-extern const char kMaximizable[];
-extern const char kFullScreenable[];
-extern const char kClosable[];
-extern const char kFullscreen[];
-extern const char kSkipTaskbar[];
-extern const char kKiosk[];
-extern const char kSimpleFullScreen[];
-extern const char kAlwaysOnTop[];
-extern const char kAcceptFirstMouse[];
-extern const char kUseContentSize[];
-extern const char kZoomToPageWidth[];
-extern const char kFullscreenWindowTitle[];
-extern const char kTitleBarStyle[];
-extern const char kTabbingIdentifier[];
-extern const char kAutoHideMenuBar[];
-extern const char kEnableLargerThanScreen[];
-extern const char kDarkTheme[];
-extern const char kTransparent[];
-extern const char kType[];
-extern const char kDisableAutoHideCursor[];
-extern const char kStandardWindow[];
-extern const char kBackgroundColor[];
-extern const char kHasShadow[];
-extern const char kOpacity[];
-extern const char kFocusable[];
-extern const char kWebPreferences[];
-extern const char kVibrancyType[];
-
-// WebPreferences.
-extern const char kZoomFactor[];
-extern const char kPreloadScript[];
-extern const char kPreloadURL[];
-extern const char kNodeIntegration[];
-extern const char kContextIsolation[];
-extern const char kGuestInstanceID[];
-extern const char kExperimentalFeatures[];
-extern const char kOpenerID[];
-extern const char kScrollBounce[];
-extern const char kEnableBlinkFeatures[];
-extern const char kDisableBlinkFeatures[];
-extern const char kNodeIntegrationInWorker[];
-extern const char kWebviewTag[];
-extern const char kNativeWindowOpen[];
-extern const char kCustomArgs[];
-extern const char kPlugins[];
-extern const char kSandbox[];
-extern const char kWebSecurity[];
-extern const char kAllowRunningInsecureContent[];
-extern const char kOffscreen[];
-
-}  // namespace options
-
-// Following are actually command line switches, should be moved to other files.
-
-namespace switches {
-
-extern const char kEnableSandbox[];
-extern const char kEnableMixedSandbox[];
-extern const char kEnablePlugins[];
-extern const char kPpapiFlashPath[];
-extern const char kPpapiFlashVersion[];
-extern const char kDisableHttpCache[];
-extern const char kStandardSchemes[];
-extern const char kRegisterServiceWorkerSchemes[];
-extern const char kSecureSchemes[];
-extern const char kAppUserModelId[];
-extern const char kAppPath[];
-
-extern const char kBackgroundColor[];
-extern const char kPreloadScript[];
-extern const char kPreloadScripts[];
-extern const char kNodeIntegration[];
-extern const char kContextIsolation[];
-extern const char kGuestInstanceID[];
-extern const char kOpenerID[];
-extern const char kScrollBounce[];
-extern const char kHiddenPage[];
-extern const char kNativeWindowOpen[];
-extern const char kNodeIntegrationInWorker[];
-extern const char kWebviewTag[];
-
-extern const char kWidevineCdmPath[];
-extern const char kWidevineCdmVersion[];
-
-extern const char kDiskCacheSize[];
-extern const char kIgnoreConnectionsLimit[];
-
-}  // namespace switches
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_OPTIONS_SWITCHES_H_
removed in remote
  base   100644 4565221e9d8455b42edceb04e3c4ae17d1680755 atom/common/platform_util.h
  our    100644 6fd84056a06a3163547b254777d78161538b7069 atom/common/platform_util.h
@@ -1,67 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_PLATFORM_UTIL_H_
-#define ATOM_COMMON_PLATFORM_UTIL_H_
-
-#include <string>
-
-#include "base/callback_forward.h"
-#include "build/build_config.h"
-
-#if defined(OS_WIN)
-#include "base/strings/string16.h"
-#endif
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace platform_util {
-
-typedef base::Callback<void(const std::string&)> OpenExternalCallback;
-
-// Show the given file in a file manager. If possible, select the file.
-// Must be called from the UI thread.
-bool ShowItemInFolder(const base::FilePath& full_path);
-
-// Open the given file in the desktop's default manner.
-// Must be called from the UI thread.
-bool OpenItem(const base::FilePath& full_path);
-
-// Open the given external protocol URL in the desktop's default manner.
-// (For example, mailto: URLs in the default mail user agent.)
-bool OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    bool activate);
-
-// The asynchronous version of OpenExternal.
-void OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    bool activate,
-    const OpenExternalCallback& callback);
-
-// Move a file to trash.
-bool MoveItemToTrash(const base::FilePath& full_path);
-
-void Beep();
-
-#if defined(OS_MACOSX)
-bool GetLoginItemEnabled();
-void SetLoginItemEnabled(bool enabled);
-#endif
-
-}  // namespace platform_util
-
-#endif  // ATOM_COMMON_PLATFORM_UTIL_H_
removed in remote
  base   100644 1e437b866cc019078915ef0f9edbb62a20a483cc atom/common/platform_util_linux.cc
  our    100644 8fad8609342a81f46ea2608b3923f85af2d4308b atom/common/platform_util_linux.cc
@@ -1,149 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#include <stdio.h>
-
-#include "base/cancelable_callback.h"
-#include "base/environment.h"
-#include "base/files/file_util.h"
-#include "base/nix/xdg_util.h"
-#include "base/process/kill.h"
-#include "base/process/launch.h"
-#include "url/gurl.h"
-
-#define ELECTRON_TRASH "ELECTRON_TRASH"
-#define ELECTRON_DEFAULT_TRASH "gvfs-trash"
-
-namespace {
-
-bool XDGUtilV(const std::vector<std::string>& argv, const bool wait_for_exit) {
-  base::LaunchOptions options;
-  options.allow_new_privs = true;
-  // xdg-open can fall back on mailcap which eventually might plumb through
-  // to a command that needs a terminal.  Set the environment variable telling
-  // it that we definitely don't have a terminal available and that it should
-  // bring up a new terminal if necessary.  See "man mailcap".
-  options.environ["MM_NOTTTY"] = "1";
-
-  base::Process process = base::LaunchProcess(argv, options);
-  if (!process.IsValid())
-    return false;
-
-  if (!wait_for_exit) {
-    base::EnsureProcessGetsReaped(process.Pid());
-    return true;
-  }
-
-  int exit_code = -1;
-  if (!process.WaitForExit(&exit_code))
-    return false;
-
-  return (exit_code == 0);
-}
-
-bool XDGUtil(const std::string& util,
-             const std::string& arg,
-             const bool wait_for_exit) {
-  std::vector<std::string> argv;
-  argv.push_back(util);
-  argv.push_back(arg);
-
-  return XDGUtilV(argv, wait_for_exit);
-}
-
-bool XDGOpen(const std::string& path, const bool wait_for_exit) {
-  return XDGUtil("xdg-open", path, wait_for_exit);
-}
-
-bool XDGEmail(const std::string& email, const bool wait_for_exit) {
-  return XDGUtil("xdg-email", email, wait_for_exit);
-}
-
-}  // namespace
-
-namespace platform_util {
-
-// TODO(estade): It would be nice to be able to select the file in the file
-// manager, but that probably requires extending xdg-open. For now just
-// show the folder.
-bool ShowItemInFolder(const base::FilePath& full_path) {
-  base::FilePath dir = full_path.DirName();
-  if (!base::DirectoryExists(dir))
-    return false;
-
-  return XDGOpen(dir.value(), false);
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  return XDGOpen(full_path.value(), false);
-}
-
-bool OpenExternal(const GURL& url, bool activate) {
-  // Don't wait for exit, since we don't want to wait for the browser/email
-  // client window to close before returning
-  if (url.SchemeIs("mailto"))
-    return XDGEmail(url.spec(), false);
-  else
-    return XDGOpen(url.spec(), false);
-}
-
-void OpenExternal(const GURL& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  // TODO(gabriel): Implement async open if callback is specified
-  callback.Run(OpenExternal(url, activate) ? "" : "Failed to open");
-}
-
-bool MoveItemToTrash(const base::FilePath& full_path) {
-  std::string trash;
-  if (getenv(ELECTRON_TRASH) != NULL) {
-    trash = getenv(ELECTRON_TRASH);
-  } else {
-    // Determine desktop environment and set accordingly.
-    std::unique_ptr<base::Environment> env(base::Environment::Create());
-    base::nix::DesktopEnvironment desktop_env(
-        base::nix::GetDesktopEnvironment(env.get()));
-    if (desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE4 ||
-        desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE5) {
-      trash = "kioclient5";
-    } else if (desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE3) {
-      trash = "kioclient";
-    } else {
-      trash = ELECTRON_DEFAULT_TRASH;
-    }
-  }
-
-  std::vector<std::string> argv;
-
-  if (trash.compare("kioclient5") == 0 || trash.compare("kioclient") == 0) {
-    argv.push_back(trash);
-    argv.push_back("move");
-    argv.push_back(full_path.value());
-    argv.push_back("trash:/");
-  } else if (trash.compare("trash-cli") == 0) {
-    argv.push_back("trash-put");
-    argv.push_back(full_path.value());
-  } else if (trash.compare("gio") == 0) {
-    argv.push_back("gio");
-    argv.push_back("trash");
-    argv.push_back(full_path.value());
-  } else {
-    argv.push_back(ELECTRON_DEFAULT_TRASH);
-    argv.push_back(full_path.value());
-  }
-  return XDGUtilV(argv, true);
-}
-
-void Beep() {
-  // echo '\a' > /dev/console
-  FILE* console = fopen("/dev/console", "r");
-  if (console == NULL)
-    return;
-  fprintf(console, "\a");
-  fclose(console);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 98bc4e537d89162236689586e930e818098d758d atom/common/platform_util_mac.mm
  our    100644 b83b1e11d891ed8a70e488460fcdc7402dc6281e atom/common/platform_util_mac.mm
@@ -1,207 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#import <Carbon/Carbon.h>
-#import <Cocoa/Cocoa.h>
-#import <ServiceManagement/ServiceManagement.h>
-
-#include "base/callback.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_logging.h"
-#include "base/mac/scoped_aedesc.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/sys_string_conversions.h"
-#include "net/base/mac/url_conversions.h"
-#include "url/gurl.h"
-
-namespace {
-
-std::string MessageForOSStatus(OSStatus status, const char* default_message) {
-  switch (status) {
-    case kLSAppInTrashErr:
-      return "The application cannot be run because it is inside a Trash "
-             "folder.";
-    case kLSUnknownErr:
-      return "An unknown error has occurred.";
-    case kLSNotAnApplicationErr:
-      return "The item to be registered is not an application.";
-    case kLSNotInitializedErr:
-      return "Formerly returned by LSInit on initialization failure; "
-             "no longer used.";
-    case kLSDataUnavailableErr:
-      return "Data of the desired type is not available (for example, there is "
-             "no kind string).";
-    case kLSApplicationNotFoundErr:
-      return "No application in the Launch Services database matches the input "
-             "criteria.";
-    case kLSDataErr:
-      return "Data is structured improperly (for example, an items "
-             "information property list is malformed). Not used in macOS 10.4.";
-    case kLSLaunchInProgressErr:
-      return "A launch of the application is already in progress.";
-    case kLSServerCommunicationErr:
-      return "There is a problem communicating with the server process that "
-             "maintains the Launch Services database.";
-    case kLSCannotSetInfoErr:
-      return "The filename extension to be hidden cannot be hidden.";
-    case kLSIncompatibleSystemVersionErr:
-      return "The application to be launched cannot run on the current Mac OS "
-             "version.";
-    case kLSNoLaunchPermissionErr:
-      return "The user does not have permission to launch the application (on a"
-             "managed network).";
-    case kLSNoExecutableErr:
-      return "The executable file is missing or has an unusable format.";
-    case kLSNoClassicEnvironmentErr:
-      return "The Classic emulation environment was required but is not "
-             "available.";
-    case kLSMultipleSessionsNotSupportedErr:
-      return "The application to be launched cannot run simultaneously in two "
-             "different user sessions.";
-    default:
-      return base::StringPrintf("%s (%d)", default_message, status);
-  }
-}
-
-// This may be called from a global dispatch queue, the methods used here are
-// thread safe, including LSGetApplicationForURL (> 10.2) and
-// NSWorkspace#openURLs.
-std::string OpenURL(NSURL* ns_url, bool activate) {
-  CFURLRef openingApp = nullptr;
-  OSStatus status = LSGetApplicationForURL(base::mac::NSToCFCast(ns_url),
-                                           kLSRolesAll, nullptr, &openingApp);
-  if (status != noErr)
-    return MessageForOSStatus(status, "Failed to open");
-
-  CFRelease(openingApp);  // NOT A BUG; LSGetApplicationForURL retains for us
-
-  NSUInteger launchOptions = NSWorkspaceLaunchDefault;
-  if (!activate)
-    launchOptions |= NSWorkspaceLaunchWithoutActivation;
-
-  bool opened = [[NSWorkspace sharedWorkspace] openURLs:@[ ns_url ]
-                                withAppBundleIdentifier:nil
-                                                options:launchOptions
-                         additionalEventParamDescriptor:nil
-                                      launchIdentifiers:nil];
-  if (!opened)
-    return "Failed to open URL";
-
-  return "";
-}
-
-NSString* GetLoginHelperBundleIdentifier() {
-  return [[[NSBundle mainBundle] bundleIdentifier]
-      stringByAppendingString:@".loginhelper"];
-}
-
-}  // namespace
-
-namespace platform_util {
-
-bool ShowItemInFolder(const base::FilePath& path) {
-  // The API only takes absolute path.
-  base::FilePath full_path =
-      path.IsAbsolute() ? path : base::MakeAbsoluteFilePath(path);
-
-  DCHECK([NSThread isMainThread]);
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  if (!path_string || ![[NSWorkspace sharedWorkspace] selectFile:path_string
-                                        inFileViewerRootedAtPath:@""]) {
-    LOG(WARNING) << "NSWorkspace failed to select file " << full_path.value();
-    return false;
-  }
-  return true;
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  DCHECK([NSThread isMainThread]);
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  if (!path_string)
-    return false;
-
-  NSURL* url = [NSURL fileURLWithPath:path_string];
-  if (!url)
-    return false;
-
-  const NSWorkspaceLaunchOptions launch_options =
-      NSWorkspaceLaunchAsync | NSWorkspaceLaunchWithErrorPresentation;
-  return [[NSWorkspace sharedWorkspace] openURLs:@[ url ]
-                         withAppBundleIdentifier:nil
-                                         options:launch_options
-                  additionalEventParamDescriptor:nil
-                               launchIdentifiers:NULL];
-}
-
-bool OpenExternal(const GURL& url, bool activate) {
-  DCHECK([NSThread isMainThread]);
-  NSURL* ns_url = net::NSURLWithGURL(url);
-  if (ns_url)
-    return OpenURL(ns_url, activate).empty();
-  return false;
-}
-
-void OpenExternal(const GURL& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  NSURL* ns_url = net::NSURLWithGURL(url);
-  if (!ns_url) {
-    callback.Run("Invalid URL");
-    return;
-  }
-
-  __block OpenExternalCallback c = callback;
-  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
-                 ^{
-                   __block std::string error = OpenURL(ns_url, activate);
-                   dispatch_async(dispatch_get_main_queue(), ^{
-                     c.Run(error);
-                   });
-                 });
-}
-
-bool MoveItemToTrash(const base::FilePath& full_path) {
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  BOOL status = [[NSFileManager defaultManager]
-        trashItemAtURL:[NSURL fileURLWithPath:path_string]
-      resultingItemURL:nil
-                 error:nil];
-  if (!path_string || !status)
-    LOG(WARNING) << "NSWorkspace failed to move file " << full_path.value()
-                 << " to trash";
-  return status;
-}
-
-void Beep() {
-  NSBeep();
-}
-
-bool GetLoginItemEnabled() {
-  BOOL enabled = NO;
-  // SMJobCopyDictionary does not work in sandbox (see rdar://13626319)
-  CFArrayRef jobs = SMCopyAllJobDictionaries(kSMDomainUserLaunchd);
-  NSArray* jobs_ = CFBridgingRelease(jobs);
-  NSString* identifier = GetLoginHelperBundleIdentifier();
-  if (jobs_ && [jobs_ count] > 0) {
-    for (NSDictionary* job in jobs_) {
-      if ([identifier isEqualToString:[job objectForKey:@"Label"]]) {
-        enabled = [[job objectForKey:@"OnDemand"] boolValue];
-        break;
-      }
-    }
-  }
-  return enabled;
-}
-
-void SetLoginItemEnabled(bool enabled) {
-  NSString* identifier = GetLoginHelperBundleIdentifier();
-  SMLoginItemSetEnabled((__bridge CFStringRef)identifier, enabled);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 12591a94d5691c8944ff96596af755779941261c atom/common/platform_util_win.cc
  our    100644 34576be95f2552aaa985dacb3f36406dfc29d54c atom/common/platform_util_win.cc
@@ -1,371 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>
-#include <comdef.h>
-#include <commdlg.h>
-#include <dwmapi.h>
-#include <objbase.h>
-#include <shellapi.h>
-#include <shlobj.h>
-#include <wrl/client.h>
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/registry.h"
-#include "base/win/scoped_co_mem.h"
-#include "base/win/scoped_com_initializer.h"
-#include "base/win/windows_version.h"
-#include "ui/base/win/shell.h"
-#include "url/gurl.h"
-
-namespace {
-
-// Required COM implementation of IFileOperationProgressSink so we can
-// precheck files before deletion to make sure they can be move to the
-// Recycle Bin.
-class DeleteFileProgressSink : public IFileOperationProgressSink {
- public:
-  DeleteFileProgressSink();
-  virtual ~DeleteFileProgressSink() = default;
-
- private:
-  ULONG STDMETHODCALLTYPE AddRef(void) override;
-  ULONG STDMETHODCALLTYPE Release(void) override;
-  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
-                                           LPVOID* ppvObj) override;
-  HRESULT STDMETHODCALLTYPE StartOperations(void) override;
-  HRESULT STDMETHODCALLTYPE FinishOperations(HRESULT) override;
-  HRESULT STDMETHODCALLTYPE PreRenameItem(DWORD, IShellItem*, LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE
-  PostRenameItem(DWORD, IShellItem*, LPCWSTR, HRESULT, IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreMoveItem(DWORD,
-                                        IShellItem*,
-                                        IShellItem*,
-                                        LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostMoveItem(DWORD,
-                                         IShellItem*,
-                                         IShellItem*,
-                                         LPCWSTR,
-                                         HRESULT,
-                                         IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreCopyItem(DWORD,
-                                        IShellItem*,
-                                        IShellItem*,
-                                        LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostCopyItem(DWORD,
-                                         IShellItem*,
-                                         IShellItem*,
-                                         LPCWSTR,
-                                         HRESULT,
-                                         IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreDeleteItem(DWORD, IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PostDeleteItem(DWORD,
-                                           IShellItem*,
-                                           HRESULT,
-                                           IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreNewItem(DWORD, IShellItem*, LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostNewItem(DWORD,
-                                        IShellItem*,
-                                        LPCWSTR,
-                                        LPCWSTR,
-                                        DWORD,
-                                        HRESULT,
-                                        IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE UpdateProgress(UINT, UINT) override;
-  HRESULT STDMETHODCALLTYPE ResetTimer(void) override;
-  HRESULT STDMETHODCALLTYPE PauseTimer(void) override;
-  HRESULT STDMETHODCALLTYPE ResumeTimer(void) override;
-
-  ULONG m_cRef;
-};
-
-DeleteFileProgressSink::DeleteFileProgressSink() {
-  m_cRef = 0;
-}
-
-HRESULT DeleteFileProgressSink::PreDeleteItem(DWORD dwFlags, IShellItem*) {
-  if (!(dwFlags & TSF_DELETE_RECYCLE_IF_POSSIBLE)) {
-    // TSF_DELETE_RECYCLE_IF_POSSIBLE will not be set for items that cannot be
-    // recycled.  In this case, we abort the delete operation.  This bubbles
-    // up and stops the Delete in IFileOperation.
-    return E_ABORT;
-  }
-  // Returns S_OK if successful, or an error value otherwise. In the case of an
-  // error value, the delete operation and all subsequent operations pending
-  // from the call to IFileOperation are canceled.
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::QueryInterface(REFIID riid, LPVOID* ppvObj) {
-  // Always set out parameter to NULL, validating it first.
-  if (!ppvObj)
-    return E_INVALIDARG;
-  *ppvObj = nullptr;
-  if (riid == IID_IUnknown || riid == IID_IFileOperationProgressSink) {
-    // Increment the reference count and return the pointer.
-    *ppvObj = reinterpret_cast<IUnknown*>(this);
-    AddRef();
-    return NOERROR;
-  }
-  return E_NOINTERFACE;
-}
-
-ULONG DeleteFileProgressSink::AddRef() {
-  InterlockedIncrement(&m_cRef);
-  return m_cRef;
-}
-
-ULONG DeleteFileProgressSink::Release() {
-  // Decrement the object's internal counter.
-  ULONG ulRefCount = InterlockedDecrement(&m_cRef);
-  if (0 == m_cRef) {
-    delete this;
-  }
-  return ulRefCount;
-}
-
-HRESULT DeleteFileProgressSink::StartOperations() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::FinishOperations(HRESULT) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PreRenameItem(DWORD, IShellItem*, LPCWSTR) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PostRenameItem(DWORD,
-                                               IShellItem*,
-                                               __RPC__in_string LPCWSTR,
-                                               HRESULT,
-                                               IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PreMoveItem(DWORD,
-                                            IShellItem*,
-                                            IShellItem*,
-                                            LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostMoveItem(DWORD,
-                                             IShellItem*,
-                                             IShellItem*,
-                                             LPCWSTR,
-                                             HRESULT,
-                                             IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PreCopyItem(DWORD,
-                                            IShellItem*,
-                                            IShellItem*,
-                                            LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostCopyItem(DWORD,
-                                             IShellItem*,
-                                             IShellItem*,
-                                             LPCWSTR,
-                                             HRESULT,
-                                             IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostDeleteItem(DWORD,
-                                               IShellItem*,
-                                               HRESULT,
-                                               IShellItem*) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PreNewItem(DWORD dwFlags,
-                                           IShellItem*,
-                                           LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostNewItem(DWORD,
-                                            IShellItem*,
-                                            LPCWSTR,
-                                            LPCWSTR,
-                                            DWORD,
-                                            HRESULT,
-                                            IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::UpdateProgress(UINT, UINT) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::ResetTimer() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PauseTimer() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::ResumeTimer() {
-  return S_OK;
-}
-
-}  // namespace
-
-namespace platform_util {
-
-bool ShowItemInFolder(const base::FilePath& full_path) {
-  base::win::ScopedCOMInitializer com_initializer;
-  if (!com_initializer.Succeeded())
-    return false;
-
-  base::FilePath dir = full_path.DirName().AsEndingWithSeparator();
-  // ParseDisplayName will fail if the directory is "C:", it must be "C:\\".
-  if (dir.empty())
-    return false;
-
-  Microsoft::WRL::ComPtr<IShellFolder> desktop;
-  HRESULT hr = SHGetDesktopFolder(desktop.GetAddressOf());
-  if (FAILED(hr))
-    return false;
-
-  base::win::ScopedCoMem<ITEMIDLIST> dir_item;
-  hr = desktop->ParseDisplayName(NULL, NULL,
-                                 const_cast<wchar_t*>(dir.value().c_str()),
-                                 NULL, &dir_item, NULL);
-  if (FAILED(hr)) {
-    return ui::win::OpenFolderViaShell(dir);
-  }
-
-  base::win::ScopedCoMem<ITEMIDLIST> file_item;
-  hr = desktop->ParseDisplayName(
-      NULL, NULL, const_cast<wchar_t*>(full_path.value().c_str()), NULL,
-      &file_item, NULL);
-  if (FAILED(hr)) {
-    return ui::win::OpenFolderViaShell(dir);
-  }
-
-  const ITEMIDLIST* highlight[] = {file_item};
-
-  hr = SHOpenFolderAndSelectItems(dir_item, arraysize(highlight), highlight,
-                                  NULL);
-  if (!FAILED(hr))
-    return true;
-
-  // On some systems, the above call mysteriously fails with "file not
-  // found" even though the file is there.  In these cases, ShellExecute()
-  // seems to work as a fallback (although it won't select the file).
-  if (hr == ERROR_FILE_NOT_FOUND) {
-    return ui::win::OpenFolderViaShell(dir);
-  } else {
-    LPTSTR message = NULL;
-    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
-                  0, hr, 0, reinterpret_cast<LPTSTR>(&message), 0, NULL);
-    LOG(WARNING) << " " << __FUNCTION__ << "(): Can't open full_path = \""
-                 << full_path.value() << "\""
-                 << " hr = " << hr << " " << reinterpret_cast<LPTSTR>(&message);
-    if (message)
-      LocalFree(message);
-
-    return ui::win::OpenFolderViaShell(dir);
-  }
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  if (base::DirectoryExists(full_path))
-    return ui::win::OpenFolderViaShell(full_path);
-  else
-    return ui::win::OpenFileViaShell(full_path);
-}
-
-bool OpenExternal(const base::string16& url, bool activate) {
-  // Quote the input scheme to be sure that the command does not have
-  // parameters unexpected by the external program. This url should already
-  // have been escaped.
-  base::string16 escaped_url = L"\"" + url + L"\"";
-
-  if (reinterpret_cast<ULONG_PTR>(ShellExecuteW(
-          NULL, L"open", escaped_url.c_str(), NULL, NULL, SW_SHOWNORMAL)) <=
-      32) {
-    // We fail to execute the call. We could display a message to the user.
-    // TODO(nsylvain): we should also add a dialog to warn on errors. See
-    // bug 1136923.
-    return false;
-  }
-  return true;
-}
-
-void OpenExternal(const base::string16& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  // TODO(gabriel): Implement async open if callback is specified
-  callback.Run(OpenExternal(url, activate) ? "" : "Failed to open");
-}
-
-bool MoveItemToTrash(const base::FilePath& path) {
-  base::win::ScopedCOMInitializer com_initializer;
-  if (!com_initializer.Succeeded())
-    return false;
-
-  Microsoft::WRL::ComPtr<IFileOperation> pfo;
-  if (FAILED(::CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL,
-                                IID_PPV_ARGS(&pfo))))
-    return false;
-
-  // Elevation prompt enabled for UAC protected files.  This overrides the
-  // SILENT, NO_UI and NOERRORUI flags.
-
-  if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
-    // Windows 8 introduces the flag RECYCLEONDELETE and deprecates the
-    // ALLOWUNDO in favor of ADDUNDORECORD.
-    if (FAILED(pfo->SetOperationFlags(
-            FOF_NO_UI | FOFX_ADDUNDORECORD | FOF_NOERRORUI | FOF_SILENT |
-            FOFX_SHOWELEVATIONPROMPT | FOFX_RECYCLEONDELETE)))
-      return false;
-  } else {
-    // For Windows 7 and Vista, RecycleOnDelete is the default behavior.
-    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI | FOF_ALLOWUNDO |
-                                      FOF_NOERRORUI | FOF_SILENT |
-                                      FOFX_SHOWELEVATIONPROMPT)))
-      return false;
-  }
-
-  // Create an IShellItem from the supplied source path.
-  Microsoft::WRL::ComPtr<IShellItem> delete_item;
-  if (FAILED(SHCreateItemFromParsingName(
-          path.value().c_str(), NULL,
-          IID_PPV_ARGS(delete_item.GetAddressOf()))))
-    return false;
-
-  Microsoft::WRL::ComPtr<IFileOperationProgressSink> delete_sink(
-      new DeleteFileProgressSink);
-  if (!delete_sink)
-    return false;
-
-  // Processes the queued command DeleteItem. This will trigger
-  // the DeleteFileProgressSink to check for Recycle Bin.
-  return SUCCEEDED(pfo->DeleteItem(delete_item.Get(), delete_sink.Get())) &&
-         SUCCEEDED(pfo->PerformOperations());
-}
-
-void Beep() {
-  MessageBeep(MB_OK);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 7b56a46470ea071c861f28c879cb20b8ced1d34d atom/common/resources/mac/Info.plist
  our    100644 7b56a46470ea071c861f28c879cb20b8ced1d34d atom/common/resources/mac/Info.plist
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleIdentifier</key>
-	<string>${ATOM_BUNDLE_ID}</string>
-	<key>CFBundleName</key>
-	<string>${PRODUCT_NAME}</string>
-	<key>CFBundleExecutable</key>
-	<string>${PRODUCT_NAME}</string>
-	<key>CFBundlePackageType</key>
-	<string>FMWK</string>
-	<key>NSSupportsAutomaticGraphicsSwitching</key>
-	<true/>
-</dict>
-</plist>
removed in remote
  base   100644 fb4656cac6184e1c0eaafccc45eee95eb539df92 atom/common/resources/mac/MainMenu.xib
  our    100644 5427dde7f9290006bfed808788c2cc8374a05598 atom/common/resources/mac/MainMenu.xib
@@ -1,219 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="8.00">
-	<data>
-		<int key="IBDocument.SystemTarget">101000</int>
-		<string key="IBDocument.SystemVersion">14D136</string>
-		<string key="IBDocument.InterfaceBuilderVersion">7531</string>
-		<string key="IBDocument.AppKitVersion">1347.57</string>
-		<string key="IBDocument.HIToolboxVersion">758.70</string>
-		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
-			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin</string>
-			<string key="NS.object.0">7531</string>
-		</object>
-		<array key="IBDocument.IntegratedClassDependencies">
-			<string>NSCustomObject</string>
-			<string>NSMenu</string>
-			<string>NSMenuItem</string>
-		</array>
-		<array key="IBDocument.PluginDependencies">
-			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-		</array>
-		<object class="NSMutableDictionary" key="IBDocument.Metadata">
-			<string key="NS.key.0">PluginDependencyRecalculationVersion</string>
-			<integer value="1" key="NS.object.0"/>
-		</object>
-		<array class="NSMutableArray" key="IBDocument.RootObjects" id="1048">
-			<object class="NSCustomObject" id="1021">
-				<string key="NSClassName">AtomApplication</string>
-			</object>
-			<object class="NSCustomObject" id="1014">
-				<string key="NSClassName">FirstResponder</string>
-			</object>
-			<object class="NSCustomObject" id="1050">
-				<string key="NSClassName">NSApplication</string>
-			</object>
-			<object class="NSCustomObject" id="903638069">
-				<string key="NSClassName">NSFontManager</string>
-			</object>
-			<object class="NSMenu" id="649796088">
-				<string key="NSTitle">Main Menu</string>
-				<array class="NSMutableArray" key="NSMenuItems">
-					<object class="NSMenuItem" id="694149608">
-						<reference key="NSMenu" ref="649796088"/>
-						<string key="NSTitle">Electron</string>
-						<string key="NSKeyEquiv"/>
-						<int key="NSMnemonicLoc">2147483647</int>
-						<object class="NSCustomResource" key="NSOnImage" id="229763992">
-							<string key="NSClassName">NSImage</string>
-							<string key="NSResourceName">NSMenuCheckmark</string>
-						</object>
-						<object class="NSCustomResource" key="NSMixedImage" id="909111550">
-							<string key="NSClassName">NSImage</string>
-							<string key="NSResourceName">NSMenuMixedState</string>
-						</object>
-						<string key="NSAction">submenuAction:</string>
-						<reference key="NSTarget" ref="110575045"/>
-						<object class="NSMenu" key="NSSubmenu" id="110575045">
-							<string key="NSTitle">Electron</string>
-							<array class="NSMutableArray" key="NSMenuItems">
-								<object class="NSMenuItem" id="632727374">
-									<reference key="NSMenu" ref="110575045"/>
-									<string key="NSTitle">Quit</string>
-									<string key="NSKeyEquiv">q</string>
-									<int key="NSKeyEquivModMask">1048576</int>
-									<int key="NSMnemonicLoc">2147483647</int>
-									<reference key="NSOnImage" ref="229763992"/>
-									<reference key="NSMixedImage" ref="909111550"/>
-								</object>
-								<object class="NSMenuItem" id="1025936716">
-									<reference key="NSMenu" ref="110575045"/>
-									<string key="NSTitle">Open Recent</string>
-									<string key="NSKeyEquiv"/>
-									<int key="NSKeyEquivModMask">1048576</int>
-									<int key="NSMnemonicLoc">2147483647</int>
-									<bool key="NSIsHidden">YES</bool>
-									<reference key="NSOnImage" ref="229763992"/>
-									<reference key="NSMixedImage" ref="909111550"/>
-									<string key="NSAction">submenuAction:</string>
-									<object class="NSMenu" key="NSSubmenu" id="1065607017">
-										<string key="NSTitle">Open Recent</string>
-										<array class="NSMutableArray" key="NSMenuItems"></array>
-										<string key="NSName">_NSRecentDocumentsMenu</string>
-									</object>
-								</object>
-							</array>
-							<string key="NSName">_NSAppleMenu</string>
-						</object>
-					</object>
-				</array>
-				<string key="NSName">_NSMainMenu</string>
-			</object>
-		</array>
-		<object class="IBObjectContainer" key="IBDocument.Objects">
-			<array key="connectionRecords">
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">terminate:</string>
-						<reference key="source" ref="1014"/>
-						<reference key="destination" ref="632727374"/>
-					</object>
-					<int key="connectionID">807</int>
-				</object>
-			</array>
-			<object class="IBMutableOrderedSet" key="objectRecords">
-				<array key="orderedObjects">
-					<object class="IBObjectRecord">
-						<int key="objectID">0</int>
-						<array key="object" id="0"/>
-						<reference key="children" ref="1048"/>
-						<nil key="parent"/>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-2</int>
-						<reference key="object" ref="1021"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">File's Owner</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-1</int>
-						<reference key="object" ref="1014"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">First Responder</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-3</int>
-						<reference key="object" ref="1050"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">Application</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">371</int>
-						<reference key="object" ref="903638069"/>
-						<reference key="parent" ref="0"/>
-					</object>
-					<!-- NSMenu Main Menu -->
-					<object class="IBObjectRecord">
-						<int key="objectID">29</int>
-						<reference key="object" ref="649796088"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="694149608"/>
-						</array>
-						<reference key="parent" ref="0"/>
-					</object>
-					<!-- NSMenuItem Electron -->
-					<object class="IBObjectRecord">
-						<int key="objectID">56</int>
-						<reference key="object" ref="694149608"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="110575045"/>
-						</array>
-						<reference key="parent" ref="649796088"/>
-					</object>
-					<!-- NSMenu Electron -->
-					<object class="IBObjectRecord">
-						<int key="objectID">57</int>
-						<reference key="object" ref="110575045"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="632727374"/>
-							<reference ref="1025936716"/>
-						</array>
-						<reference key="parent" ref="694149608"/>
-					</object>
-					<!-- NSMenuItem Quit -->
-					<object class="IBObjectRecord">
-						<int key="objectID">136</int>
-						<reference key="object" ref="632727374"/>
-						<reference key="parent" ref="110575045"/>
-					</object>
-					<!-- NSMenuItem Open Recent -->
-					<object class="IBObjectRecord">
-						<int key="objectID">124</int>
-						<reference key="object" ref="1025936716"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="1065607017"/>
-						</array>
-						<reference key="parent" ref="110575045"/>
-					</object>
-					<!-- NSMenu Open Recent -->
-					<object class="IBObjectRecord">
-						<int key="objectID">125</int>
-						<reference key="object" ref="1065607017"/>
-						<array class="NSMutableArray" key="children"></array>
-						<reference key="parent" ref="1025936716"/>
-					</object>
-				</array>
-			</object>
-			<dictionary class="NSMutableDictionary" key="flattenedProperties">
-				<string key="-1.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="-2.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="-3.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="29.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="371.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="56.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="57.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="136.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="124.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="125.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-			</dictionary>
-			<dictionary class="NSMutableDictionary" key="unlocalizedProperties"/>
-			<nil key="activeLocalization"/>
-			<dictionary class="NSMutableDictionary" key="localizations"/>
-			<nil key="sourceID"/>
-			<int key="maxID">807</int>
-		</object>
-		<int key="IBDocument.localizationMode">0</int>
-		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaFramework</string>
-		<bool key="IBDocument.previouslyAttemptedUpgradeToXcode5">NO</bool>
-		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
-			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.InterfaceBuilder3</string>
-			<integer value="4600" key="NS.object.0"/>
-		</object>
-		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
-		<int key="IBDocument.defaultPropertyAccessControl">3</int>
-		<dictionary class="NSMutableDictionary" key="IBDocument.LastKnownImageSizes">
-			<string key="NSMenuCheckmark">{12, 12}</string>
-			<string key="NSMenuMixedState">{10, 2}</string>
-		</dictionary>
-		<bool key="IBDocument.UseAutolayout">YES</bool>
-	</data>
-</archive>
removed in remote
  base   100644 a82562f93614194343442d52921cc757fb400824 atom/renderer/api/atom_api_renderer_ipc.cc
  our    100644 3e48a4f7d0c11f40e6360b0acc2c83c38e671319 atom/renderer/api/atom_api_renderer_ipc.cc
@@ -1,76 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_renderer_ipc.h"
-#include "atom/common/api/api_messages.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_bindings.h"
-#include "atom/common/node_includes.h"
-#include "content/public/renderer/render_frame.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-
-using blink::WebLocalFrame;
-using content::RenderFrame;
-
-namespace atom {
-
-namespace api {
-
-RenderFrame* GetCurrentRenderFrame() {
-  WebLocalFrame* frame = WebLocalFrame::FrameForCurrentContext();
-  if (!frame)
-    return nullptr;
-
-  return RenderFrame::FromWebFrame(frame);
-}
-
-void Send(mate::Arguments* args,
-          const base::string16& channel,
-          const base::ListValue& arguments) {
-  RenderFrame* render_frame = GetCurrentRenderFrame();
-  if (render_frame == nullptr)
-    return;
-
-  bool success = render_frame->Send(new AtomFrameHostMsg_Message(
-      render_frame->GetRoutingID(), channel, arguments));
-
-  if (!success)
-    args->ThrowError("Unable to send AtomFrameHostMsg_Message");
-}
-
-base::ListValue SendSync(mate::Arguments* args,
-                         const base::string16& channel,
-                         const base::ListValue& arguments) {
-  base::ListValue result;
-
-  RenderFrame* render_frame = GetCurrentRenderFrame();
-  if (render_frame == nullptr)
-    return result;
-
-  IPC::SyncMessage* message = new AtomFrameHostMsg_Message_Sync(
-      render_frame->GetRoutingID(), channel, arguments, &result);
-  bool success = render_frame->Send(message);
-
-  if (!success)
-    args->ThrowError("Unable to send AtomFrameHostMsg_Message_Sync");
-
-  return result;
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("send", &Send);
-  dict.SetMethod("sendSync", &SendSync);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_renderer_ipc, atom::api::Initialize)
removed in remote
  base   100644 08f36efce5819903e97a9895afc5a08976ad8c7c atom/renderer/api/atom_api_spell_check_client.cc
  our    100644 5f7985be2f820fdb0a9b7a26032e7fc83ed34952 atom/renderer/api/atom_api_spell_check_client.cc
@@ -1,248 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_spell_check_client.h"
-
-#include <algorithm>
-#include <vector>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/logging.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebTextCheckingCompletion.h"
-#include "third_party/WebKit/public/web/WebTextCheckingResult.h"
-#include "third_party/icu/source/common/unicode/uscript.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-bool HasWordCharacters(const base::string16& text, int index) {
-  const base::char16* data = text.data();
-  int length = text.length();
-  while (index < length) {
-    uint32_t code = 0;
-    U16_NEXT(data, index, length, code);
-    UErrorCode error = U_ZERO_ERROR;
-    if (uscript_getScript(code, &error) != USCRIPT_COMMON)
-      return true;
-  }
-  return false;
-}
-
-}  // namespace
-
-class SpellCheckClient::SpellcheckRequest {
- public:
-  SpellcheckRequest(const base::string16& text,
-                    blink::WebTextCheckingCompletion* completion)
-      : text_(text), completion_(completion) {
-    DCHECK(completion);
-  }
-  ~SpellcheckRequest() {}
-
-  base::string16 text() { return text_; }
-  blink::WebTextCheckingCompletion* completion() { return completion_; }
-
- private:
-  base::string16 text_;  // Text to be checked in this task.
-
-  // The interface to send the misspelled ranges to WebKit.
-  blink::WebTextCheckingCompletion* completion_;
-
-  DISALLOW_COPY_AND_ASSIGN(SpellcheckRequest);
-};
-
-SpellCheckClient::SpellCheckClient(const std::string& language,
-                                   bool auto_spell_correct_turned_on,
-                                   v8::Isolate* isolate,
-                                   v8::Local<v8::Object> provider)
-    : isolate_(isolate),
-      context_(isolate, isolate->GetCurrentContext()),
-      provider_(isolate, provider) {
-  DCHECK(!context_.IsEmpty());
-
-  character_attributes_.SetDefaultLanguage(language);
-
-  // Persistent the method.
-  mate::Dictionary dict(isolate, provider);
-  dict.Get("spellCheck", &spell_check_);
-}
-
-SpellCheckClient::~SpellCheckClient() {
-  context_.Reset();
-}
-
-void SpellCheckClient::CheckSpelling(
-    const blink::WebString& text,
-    int& misspelling_start,
-    int& misspelling_len,
-    blink::WebVector<blink::WebString>* optional_suggestions) {
-  std::vector<blink::WebTextCheckingResult> results;
-  SpellCheckText(text.Utf16(), true, &results);
-  if (results.size() == 1) {
-    misspelling_start = results[0].location;
-    misspelling_len = results[0].length;
-  }
-}
-
-void SpellCheckClient::RequestCheckingOfText(
-    const blink::WebString& textToCheck,
-    blink::WebTextCheckingCompletion* completionCallback) {
-  base::string16 text(textToCheck.Utf16());
-  // Ignore invalid requests.
-  if (text.empty() || !HasWordCharacters(text, 0)) {
-    completionCallback->DidCancelCheckingText();
-    return;
-  }
-
-  // Clean up the previous request before starting a new request.
-  if (pending_request_param_.get()) {
-    pending_request_param_->completion()->DidCancelCheckingText();
-  }
-
-  pending_request_param_.reset(new SpellcheckRequest(text, completionCallback));
-
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&SpellCheckClient::PerformSpellCheck, AsWeakPtr(),
-                     base::Owned(pending_request_param_.release())));
-}
-
-bool SpellCheckClient::IsSpellCheckingEnabled() const {
-  return true;
-}
-
-void SpellCheckClient::ShowSpellingUI(bool show) {}
-
-bool SpellCheckClient::IsShowingSpellingUI() {
-  return false;
-}
-
-void SpellCheckClient::UpdateSpellingUIWithMisspelledWord(
-    const blink::WebString& word) {}
-
-void SpellCheckClient::SpellCheckText(
-    const base::string16& text,
-    bool stop_at_first_result,
-    std::vector<blink::WebTextCheckingResult>* results) {
-  if (text.empty() || spell_check_.IsEmpty())
-    return;
-
-  if (!text_iterator_.IsInitialized() &&
-      !text_iterator_.Initialize(&character_attributes_, true)) {
-    // We failed to initialize text_iterator_, return as spelled correctly.
-    VLOG(1) << "Failed to initialize SpellcheckWordIterator";
-    return;
-  }
-
-  if (!contraction_iterator_.IsInitialized() &&
-      !contraction_iterator_.Initialize(&character_attributes_, false)) {
-    // We failed to initialize the word iterator, return as spelled correctly.
-    VLOG(1) << "Failed to initialize contraction_iterator_";
-    return;
-  }
-
-  text_iterator_.SetText(text.c_str(), text.size());
-
-  SpellCheckScope scope(*this);
-  base::string16 word;
-  int word_start;
-  int word_length;
-  for (auto status =
-           text_iterator_.GetNextWord(&word, &word_start, &word_length);
-       status != SpellcheckWordIterator::IS_END_OF_TEXT;
-       status = text_iterator_.GetNextWord(&word, &word_start, &word_length)) {
-    if (status == SpellcheckWordIterator::IS_SKIPPABLE)
-      continue;
-
-    // Found a word (or a contraction) that the spellchecker can check the
-    // spelling of.
-    if (SpellCheckWord(scope, word))
-      continue;
-
-    // If the given word is a concatenated word of two or more valid words
-    // (e.g. "hello:hello"), we should treat it as a valid word.
-    if (IsValidContraction(scope, word))
-      continue;
-
-    blink::WebTextCheckingResult result;
-    result.location = word_start;
-    result.length = word_length;
-    results->push_back(result);
-
-    if (stop_at_first_result)
-      return;
-  }
-}
-
-bool SpellCheckClient::SpellCheckWord(
-    const SpellCheckScope& scope,
-    const base::string16& word_to_check) const {
-  DCHECK(!scope.spell_check_.IsEmpty());
-
-  v8::Local<v8::Value> word = mate::ConvertToV8(isolate_, word_to_check);
-  v8::Local<v8::Value> result =
-      scope.spell_check_->Call(scope.provider_, 1, &word);
-
-  if (!result.IsEmpty() && result->IsBoolean())
-    return result->BooleanValue();
-  else
-    return true;
-}
-
-// Returns whether or not the given string is a valid contraction.
-// This function is a fall-back when the SpellcheckWordIterator class
-// returns a concatenated word which is not in the selected dictionary
-// (e.g. "in'n'out") but each word is valid.
-bool SpellCheckClient::IsValidContraction(const SpellCheckScope& scope,
-                                          const base::string16& contraction) {
-  DCHECK(contraction_iterator_.IsInitialized());
-
-  contraction_iterator_.SetText(contraction.c_str(), contraction.length());
-
-  base::string16 word;
-  int word_start;
-  int word_length;
-
-  for (auto status =
-           contraction_iterator_.GetNextWord(&word, &word_start, &word_length);
-       status != SpellcheckWordIterator::IS_END_OF_TEXT;
-       status = contraction_iterator_.GetNextWord(&word, &word_start,
-                                                  &word_length)) {
-    if (status == SpellcheckWordIterator::IS_SKIPPABLE)
-      continue;
-
-    if (!SpellCheckWord(scope, word))
-      return false;
-  }
-  return true;
-}
-
-void SpellCheckClient::PerformSpellCheck(SpellcheckRequest* param) {
-  DCHECK(param);
-
-  std::vector<blink::WebTextCheckingResult> results;
-  SpellCheckText(param->text(), false, &results);
-  param->completion()->DidFinishCheckingText(results);
-}
-
-SpellCheckClient::SpellCheckScope::SpellCheckScope(
-    const SpellCheckClient& client)
-    : handle_scope_(client.isolate_),
-      context_scope_(
-          v8::Local<v8::Context>::New(client.isolate_, client.context_)),
-      provider_(client.provider_.NewHandle()),
-      spell_check_(client.spell_check_.NewHandle()) {}
-
-SpellCheckClient::SpellCheckScope::~SpellCheckScope() = default;
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 af72756e2ec13911ae5159944cbcca51d8365e77 atom/renderer/api/atom_api_spell_check_client.h
  our    100644 c8b5f7f4ab164307f735cc0bc0651435a42c3034 atom/renderer/api/atom_api_spell_check_client.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
-#define ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
-
-#include <string>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
-#include "native_mate/scoped_persistent.h"
-#include "third_party/WebKit/public/platform/WebSpellCheckPanelHostClient.h"
-#include "third_party/WebKit/public/platform/WebVector.h"
-#include "third_party/WebKit/public/web/WebTextCheckClient.h"
-
-namespace blink {
-struct WebTextCheckingResult;
-class WebTextCheckingCompletion;
-}  // namespace blink
-
-namespace atom {
-
-namespace api {
-
-class SpellCheckClient : public blink::WebSpellCheckPanelHostClient,
-                         public blink::WebTextCheckClient,
-                         public base::SupportsWeakPtr<SpellCheckClient> {
- public:
-  SpellCheckClient(const std::string& language,
-                   bool auto_spell_correct_turned_on,
-                   v8::Isolate* isolate,
-                   v8::Local<v8::Object> provider);
-  ~SpellCheckClient() override;
-
- private:
-  class SpellcheckRequest;
-  // blink::WebTextCheckClient:
-  void CheckSpelling(
-      const blink::WebString& text,
-      int& misspelledOffset,
-      int& misspelledLength,
-      blink::WebVector<blink::WebString>* optionalSuggestions) override;
-  void RequestCheckingOfText(
-      const blink::WebString& textToCheck,
-      blink::WebTextCheckingCompletion* completionCallback) override;
-  bool IsSpellCheckingEnabled() const override;
-
-  // blink::WebSpellCheckPanelHostClient:
-  void ShowSpellingUI(bool show) override;
-  bool IsShowingSpellingUI() override;
-  void UpdateSpellingUIWithMisspelledWord(
-      const blink::WebString& word) override;
-
-  struct SpellCheckScope {
-    v8::HandleScope handle_scope_;
-    v8::Context::Scope context_scope_;
-    v8::Local<v8::Object> provider_;
-    v8::Local<v8::Function> spell_check_;
-
-    explicit SpellCheckScope(const SpellCheckClient& client);
-    ~SpellCheckScope();
-  };
-
-  // Check the spelling of text.
-  void SpellCheckText(const base::string16& text,
-                      bool stop_at_first_result,
-                      std::vector<blink::WebTextCheckingResult>* results);
-
-  // Call JavaScript to check spelling a word.
-  bool SpellCheckWord(const SpellCheckScope& scope,
-                      const base::string16& word_to_check) const;
-
-  // Returns whether or not the given word is a contraction of valid words
-  // (e.g. "word:word").
-  bool IsValidContraction(const SpellCheckScope& scope,
-                          const base::string16& word);
-
-  // Performs spell checking from the request queue.
-  void PerformSpellCheck(SpellcheckRequest* param);
-
-  // Represents character attributes used for filtering out characters which
-  // are not supported by this SpellCheck object.
-  SpellcheckCharAttribute character_attributes_;
-
-  // Represents word iterators used in this spellchecker. The |text_iterator_|
-  // splits text provided by WebKit into words, contractions, or concatenated
-  // words. The |contraction_iterator_| splits a concatenated word extracted by
-  // |text_iterator_| into word components so we can treat a concatenated word
-  // consisting only of correct words as a correct word.
-  SpellcheckWordIterator text_iterator_;
-  SpellcheckWordIterator contraction_iterator_;
-
-  // The parameters of a pending background-spellchecking request.
-  // (When WebKit sends two or more requests, we cancel the previous
-  // requests so we do not have to use vectors.)
-  std::unique_ptr<SpellcheckRequest> pending_request_param_;
-
-  v8::Isolate* isolate_;
-  v8::Persistent<v8::Context> context_;
-  mate::ScopedPersistent<v8::Object> provider_;
-  mate::ScopedPersistent<v8::Function> spell_check_;
-
-  DISALLOW_COPY_AND_ASSIGN(SpellCheckClient);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
removed in remote
  base   100644 e00b901bfff60e8223fd11194bfd209efee72fea atom/renderer/api/atom_api_web_frame.cc
  our    100644 f0f7ef249d73876f7107d3d3865e8fc71ee33945 atom/renderer/api/atom_api_web_frame.cc
@@ -1,544 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_web_frame.h"
-
-#include "atom/common/api/api_messages.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/renderer/api/atom_api_spell_check_client.h"
-#include "base/memory/memory_pressure_listener.h"
-#include "content/public/renderer/render_frame.h"
-#include "content/public/renderer/render_frame_observer.h"
-#include "content/public/renderer/render_frame_visitor.h"
-#include "content/public/renderer/render_view.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "third_party/WebKit/Source/platform/weborigin/SchemeRegistry.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-#include "third_party/WebKit/public/web/WebDocument.h"
-#include "third_party/WebKit/public/web/WebElement.h"
-#include "third_party/WebKit/public/web/WebFrameWidget.h"
-#include "third_party/WebKit/public/web/WebImeTextSpan.h"
-#include "third_party/WebKit/public/web/WebInputMethodController.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-#include "third_party/WebKit/public/web/WebScriptExecutionCallback.h"
-#include "third_party/WebKit/public/web/WebScriptSource.h"
-#include "third_party/WebKit/public/web/WebView.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<blink::WebLocalFrame::ScriptExecutionType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebLocalFrame::ScriptExecutionType* out) {
-    std::string execution_type;
-    if (!ConvertFromV8(isolate, val, &execution_type))
-      return false;
-    if (execution_type == "asynchronous") {
-      *out = blink::WebLocalFrame::kAsynchronous;
-    } else if (execution_type == "asynchronousBlockingOnload") {
-      *out = blink::WebLocalFrame::kAsynchronousBlockingOnload;
-    } else if (execution_type == "synchronous") {
-      *out = blink::WebLocalFrame::kSynchronous;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-content::RenderFrame* GetRenderFrame(v8::Local<v8::Value> value) {
-  v8::Local<v8::Context> context =
-      v8::Local<v8::Object>::Cast(value)->CreationContext();
-  if (context.IsEmpty())
-    return nullptr;
-  blink::WebLocalFrame* frame = blink::WebLocalFrame::FrameForContext(context);
-  if (!frame)
-    return nullptr;
-  return content::RenderFrame::FromWebFrame(frame);
-}
-
-class RenderFrameStatus : public content::RenderFrameObserver {
- public:
-  explicit RenderFrameStatus(content::RenderFrame* render_frame)
-      : content::RenderFrameObserver(render_frame) {}
-  ~RenderFrameStatus() final {}
-
-  bool is_ok() { return render_frame() != nullptr; }
-
-  // RenderFrameObserver implementation.
-  void OnDestruct() final {}
-};
-
-class ScriptExecutionCallback : public blink::WebScriptExecutionCallback {
- public:
-  using CompletionCallback =
-      base::Callback<void(const v8::Local<v8::Value>& result)>;
-
-  explicit ScriptExecutionCallback(const CompletionCallback& callback)
-      : callback_(callback) {}
-  ~ScriptExecutionCallback() override {}
-
-  void Completed(
-      const blink::WebVector<v8::Local<v8::Value>>& result) override {
-    if (!callback_.is_null() && !result.IsEmpty() && !result[0].IsEmpty())
-      // Right now only single results per frame is supported.
-      callback_.Run(result[0]);
-    delete this;
-  }
-
- private:
-  CompletionCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScriptExecutionCallback);
-};
-
-class FrameSpellChecker : public content::RenderFrameVisitor {
- public:
-  explicit FrameSpellChecker(SpellCheckClient* spell_check_client,
-                             content::RenderFrame* main_frame)
-      : spell_check_client_(spell_check_client), main_frame_(main_frame) {}
-  ~FrameSpellChecker() override {
-    spell_check_client_ = nullptr;
-    main_frame_ = nullptr;
-  }
-  bool Visit(content::RenderFrame* render_frame) override {
-    auto* view = render_frame->GetRenderView();
-    if (view->GetMainRenderFrame() == main_frame_ ||
-        (render_frame->IsMainFrame() && render_frame == main_frame_)) {
-      render_frame->GetWebFrame()->SetTextCheckClient(spell_check_client_);
-    }
-    return true;
-  }
-
- private:
-  SpellCheckClient* spell_check_client_;
-  content::RenderFrame* main_frame_;
-  DISALLOW_COPY_AND_ASSIGN(FrameSpellChecker);
-};
-
-}  // namespace
-
-WebFrame::WebFrame(v8::Isolate* isolate)
-    : web_frame_(blink::WebLocalFrame::FrameForCurrentContext()) {
-  Init(isolate);
-}
-
-WebFrame::WebFrame(v8::Isolate* isolate, blink::WebLocalFrame* blink_frame)
-    : web_frame_(blink_frame) {
-  Init(isolate);
-}
-
-WebFrame::~WebFrame() {}
-
-void WebFrame::SetName(const std::string& name) {
-  web_frame_->SetName(blink::WebString::FromUTF8(name));
-}
-
-double WebFrame::SetZoomLevel(double level) {
-  double result = 0.0;
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromWebFrame(web_frame_);
-  render_frame->Send(new AtomFrameHostMsg_SetTemporaryZoomLevel(
-      render_frame->GetRoutingID(), level, &result));
-  return result;
-}
-
-double WebFrame::GetZoomLevel() const {
-  double result = 0.0;
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromWebFrame(web_frame_);
-  render_frame->Send(
-      new AtomFrameHostMsg_GetZoomLevel(render_frame->GetRoutingID(), &result));
-  return result;
-}
-
-double WebFrame::SetZoomFactor(double factor) {
-  return blink::WebView::ZoomLevelToZoomFactor(
-      SetZoomLevel(blink::WebView::ZoomFactorToZoomLevel(factor)));
-}
-
-double WebFrame::GetZoomFactor() const {
-  return blink::WebView::ZoomLevelToZoomFactor(GetZoomLevel());
-}
-
-void WebFrame::SetVisualZoomLevelLimits(double min_level, double max_level) {
-  web_frame_->View()->SetDefaultPageScaleLimits(min_level, max_level);
-  web_frame_->View()->SetIgnoreViewportTagScaleLimits(true);
-}
-
-void WebFrame::SetLayoutZoomLevelLimits(double min_level, double max_level) {
-  web_frame_->View()->ZoomLimitsChanged(min_level, max_level);
-}
-
-v8::Local<v8::Value> WebFrame::RegisterEmbedderCustomElement(
-    const base::string16& name,
-    v8::Local<v8::Object> options) {
-  return web_frame_->GetDocument().RegisterEmbedderCustomElement(
-      blink::WebString::FromUTF16(name), options);
-}
-
-int WebFrame::GetWebFrameId(v8::Local<v8::Value> content_window) {
-  // Get the WebLocalFrame before (possibly) executing any user-space JS while
-  // getting the |params|. We track the status of the RenderFrame via an
-  // observer in case it is deleted during user code execution.
-  content::RenderFrame* render_frame = GetRenderFrame(content_window);
-  RenderFrameStatus render_frame_status(render_frame);
-
-  if (!render_frame_status.is_ok())
-    return -1;
-
-  blink::WebLocalFrame* frame = render_frame->GetWebFrame();
-  // Parent must exist.
-  blink::WebFrame* parent_frame = frame->Parent();
-  DCHECK(parent_frame);
-  DCHECK(parent_frame->IsWebLocalFrame());
-
-  return render_frame->GetRoutingID();
-}
-
-void WebFrame::SetSpellCheckProvider(mate::Arguments* args,
-                                     const std::string& language,
-                                     bool auto_spell_correct_turned_on,
-                                     v8::Local<v8::Object> provider) {
-  if (!provider->Has(mate::StringToV8(args->isolate(), "spellCheck"))) {
-    args->ThrowError("\"spellCheck\" has to be defined");
-    return;
-  }
-
-  auto client = std::make_unique<SpellCheckClient>(
-      language, auto_spell_correct_turned_on, args->isolate(), provider);
-  // Set spellchecker for all live frames in the same process or
-  // in the sandbox mode for all live sub frames to this WebFrame.
-  FrameSpellChecker spell_checker(
-      client.get(), content::RenderFrame::FromWebFrame(web_frame_));
-  content::RenderFrame::ForEach(&spell_checker);
-  spell_check_client_.swap(client);
-  web_frame_->SetSpellCheckPanelHostClient(spell_check_client_.get());
-}
-
-void WebFrame::RegisterURLSchemeAsBypassingCSP(const std::string& scheme) {
-  // Register scheme to bypass pages's Content Security Policy.
-  blink::SchemeRegistry::RegisterURLSchemeAsBypassingContentSecurityPolicy(
-      WTF::String::FromUTF8(scheme.data(), scheme.length()));
-}
-
-void WebFrame::RegisterURLSchemeAsPrivileged(const std::string& scheme,
-                                             mate::Arguments* args) {
-  // TODO(deepak1556): blink::SchemeRegistry methods should be called
-  // before any renderer threads are created. Fixing this would break
-  // current api. Change it with 2.0.
-
-  // Read optional flags
-  bool secure = true;
-  bool bypassCSP = true;
-  bool allowServiceWorkers = true;
-  bool supportFetchAPI = true;
-  bool corsEnabled = true;
-  if (args->Length() == 2) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("secure", &secure);
-      options.Get("bypassCSP", &bypassCSP);
-      options.Get("allowServiceWorkers", &allowServiceWorkers);
-      options.Get("supportFetchAPI", &supportFetchAPI);
-      options.Get("corsEnabled", &corsEnabled);
-    }
-  }
-  // Register scheme to privileged list (https, wss, data, chrome-extension)
-  WTF::String privileged_scheme(
-      WTF::String::FromUTF8(scheme.data(), scheme.length()));
-  if (bypassCSP) {
-    blink::SchemeRegistry::RegisterURLSchemeAsBypassingContentSecurityPolicy(
-        privileged_scheme);
-  }
-  if (allowServiceWorkers) {
-    blink::SchemeRegistry::RegisterURLSchemeAsAllowingServiceWorkers(
-        privileged_scheme);
-  }
-  if (supportFetchAPI) {
-    blink::SchemeRegistry::RegisterURLSchemeAsSupportingFetchAPI(
-        privileged_scheme);
-  }
-  if (corsEnabled) {
-    blink::SchemeRegistry::RegisterURLSchemeAsCORSEnabled(privileged_scheme);
-  }
-}
-
-void WebFrame::InsertText(const std::string& text) {
-  web_frame_->FrameWidget()->GetActiveWebInputMethodController()->CommitText(
-      blink::WebString::FromUTF8(text),
-      blink::WebVector<blink::WebImeTextSpan>(), blink::WebRange(), 0);
-}
-
-void WebFrame::InsertCSS(const std::string& css) {
-  web_frame_->GetDocument().InsertStyleSheet(blink::WebString::FromUTF8(css));
-}
-
-void WebFrame::ExecuteJavaScript(const base::string16& code,
-                                 mate::Arguments* args) {
-  bool has_user_gesture = false;
-  args->GetNext(&has_user_gesture);
-  ScriptExecutionCallback::CompletionCallback completion_callback;
-  args->GetNext(&completion_callback);
-  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
-      new ScriptExecutionCallback(completion_callback));
-  web_frame_->RequestExecuteScriptAndReturnValue(
-      blink::WebScriptSource(blink::WebString::FromUTF16(code)),
-      has_user_gesture, callback.release());
-}
-
-void WebFrame::ExecuteJavaScriptInIsolatedWorld(
-    int world_id,
-    const std::vector<mate::Dictionary>& scripts,
-    mate::Arguments* args) {
-  std::vector<blink::WebScriptSource> sources;
-
-  for (const auto& script : scripts) {
-    base::string16 code;
-    base::string16 url;
-    int start_line = 1;
-    script.Get("url", &url);
-    script.Get("startLine", &start_line);
-
-    if (!script.Get("code", &code)) {
-      args->ThrowError("Invalid 'code'");
-      return;
-    }
-
-    sources.emplace_back(
-        blink::WebScriptSource(blink::WebString::FromUTF16(code),
-                               blink::WebURL(GURL(url)), start_line));
-  }
-
-  bool has_user_gesture = false;
-  args->GetNext(&has_user_gesture);
-
-  blink::WebLocalFrame::ScriptExecutionType scriptExecutionType =
-      blink::WebLocalFrame::kSynchronous;
-  args->GetNext(&scriptExecutionType);
-
-  ScriptExecutionCallback::CompletionCallback completion_callback;
-  args->GetNext(&completion_callback);
-  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
-      new ScriptExecutionCallback(completion_callback));
-
-  web_frame_->RequestExecuteScriptInIsolatedWorld(
-      world_id, &sources.front(), sources.size(), has_user_gesture,
-      scriptExecutionType, callback.release());
-}
-
-void WebFrame::SetIsolatedWorldSecurityOrigin(int world_id,
-                                              const std::string& origin_url) {
-  web_frame_->SetIsolatedWorldSecurityOrigin(
-      world_id, blink::WebSecurityOrigin::CreateFromString(
-                    blink::WebString::FromUTF8(origin_url)));
-}
-
-void WebFrame::SetIsolatedWorldContentSecurityPolicy(
-    int world_id,
-    const std::string& security_policy) {
-  web_frame_->SetIsolatedWorldContentSecurityPolicy(
-      world_id, blink::WebString::FromUTF8(security_policy));
-}
-
-void WebFrame::SetIsolatedWorldHumanReadableName(int world_id,
-                                                 const std::string& name) {
-  web_frame_->SetIsolatedWorldHumanReadableName(
-      world_id, blink::WebString::FromUTF8(name));
-}
-
-// static
-mate::Handle<WebFrame> WebFrame::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new WebFrame(isolate));
-}
-
-blink::WebCache::ResourceTypeStats WebFrame::GetResourceUsage(
-    v8::Isolate* isolate) {
-  blink::WebCache::ResourceTypeStats stats;
-  blink::WebCache::GetResourceTypeStats(&stats);
-  return stats;
-}
-
-void WebFrame::ClearCache(v8::Isolate* isolate) {
-  isolate->IdleNotificationDeadline(0.5);
-  blink::WebCache::Clear();
-  base::MemoryPressureListener::NotifyMemoryPressure(
-      base::MemoryPressureListener::MEMORY_PRESSURE_LEVEL_CRITICAL);
-}
-
-v8::Local<v8::Value> WebFrame::Opener() const {
-  blink::WebFrame* frame = web_frame_->Opener();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::Parent() const {
-  blink::WebFrame* frame = web_frame_->Parent();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::Top() const {
-  blink::WebFrame* frame = web_frame_->Top();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FirstChild() const {
-  blink::WebFrame* frame = web_frame_->FirstChild();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::NextSibling() const {
-  blink::WebFrame* frame = web_frame_->NextSibling();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::GetFrameForSelector(
-    const std::string& selector) const {
-  blink::WebElement element = web_frame_->GetDocument().QuerySelector(
-      blink::WebString::FromUTF8(selector));
-  blink::WebLocalFrame* element_frame =
-      blink::WebLocalFrame::FromFrameOwnerElement(element);
-  if (element_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), element_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FindFrameByName(const std::string& name) const {
-  blink::WebLocalFrame* local_frame =
-      web_frame_->FindFrameByName(blink::WebString::FromUTF8(name))
-          ->ToWebLocalFrame();
-  if (local_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), local_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FindFrameByRoutingId(int routing_id) const {
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromRoutingID(routing_id);
-  blink::WebLocalFrame* local_frame = nullptr;
-  if (render_frame)
-    local_frame = render_frame->GetWebFrame();
-  if (local_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), local_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::RoutingId() const {
-  int routing_id = content::RenderFrame::GetRoutingIdForWebFrame(web_frame_);
-  return v8::Number::New(isolate(), routing_id);
-}
-
-// static
-void WebFrame::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebFrame"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("setName", &WebFrame::SetName)
-      .SetMethod("setZoomLevel", &WebFrame::SetZoomLevel)
-      .SetMethod("getZoomLevel", &WebFrame::GetZoomLevel)
-      .SetMethod("setZoomFactor", &WebFrame::SetZoomFactor)
-      .SetMethod("getZoomFactor", &WebFrame::GetZoomFactor)
-      .SetMethod("setVisualZoomLevelLimits",
-                 &WebFrame::SetVisualZoomLevelLimits)
-      .SetMethod("setLayoutZoomLevelLimits",
-                 &WebFrame::SetLayoutZoomLevelLimits)
-      .SetMethod("registerEmbedderCustomElement",
-                 &WebFrame::RegisterEmbedderCustomElement)
-      .SetMethod("getWebFrameId", &WebFrame::GetWebFrameId)
-      .SetMethod("setSpellCheckProvider", &WebFrame::SetSpellCheckProvider)
-      .SetMethod("registerURLSchemeAsBypassingCSP",
-                 &WebFrame::RegisterURLSchemeAsBypassingCSP)
-      .SetMethod("registerURLSchemeAsPrivileged",
-                 &WebFrame::RegisterURLSchemeAsPrivileged)
-      .SetMethod("insertText", &WebFrame::InsertText)
-      .SetMethod("insertCSS", &WebFrame::InsertCSS)
-      .SetMethod("executeJavaScript", &WebFrame::ExecuteJavaScript)
-      .SetMethod("executeJavaScriptInIsolatedWorld",
-                 &WebFrame::ExecuteJavaScriptInIsolatedWorld)
-      .SetMethod("setIsolatedWorldSecurityOrigin",
-                 &WebFrame::SetIsolatedWorldSecurityOrigin)
-      .SetMethod("setIsolatedWorldContentSecurityPolicy",
-                 &WebFrame::SetIsolatedWorldContentSecurityPolicy)
-      .SetMethod("setIsolatedWorldHumanReadableName",
-                 &WebFrame::SetIsolatedWorldHumanReadableName)
-      .SetMethod("getResourceUsage", &WebFrame::GetResourceUsage)
-      .SetMethod("clearCache", &WebFrame::ClearCache)
-      .SetMethod("getFrameForSelector", &WebFrame::GetFrameForSelector)
-      .SetMethod("findFrameByName", &WebFrame::FindFrameByName)
-      .SetProperty("opener", &WebFrame::Opener)
-      .SetProperty("parent", &WebFrame::Parent)
-      .SetProperty("top", &WebFrame::Top)
-      .SetProperty("firstChild", &WebFrame::FirstChild)
-      .SetProperty("nextSibling", &WebFrame::NextSibling)
-      .SetProperty("routingId", &WebFrame::RoutingId)
-      .SetMethod("findFrameByRoutingId", &WebFrame::FindFrameByRoutingId);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::WebFrame;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("webFrame", WebFrame::Create(isolate));
-  dict.Set("WebFrame", WebFrame::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_renderer_web_frame, Initialize)
removed in remote
  base   100644 d55b24fd25ea474104ccf32f48103c39a79c8f56 atom/renderer/api/atom_api_web_frame.h
  our    100644 4cc6386abcb41cfa29fdc002f6fb267329bb112d atom/renderer/api/atom_api_web_frame.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
-#define ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-
-namespace blink {
-class WebLocalFrame;
-}
-
-namespace mate {
-class Dictionary;
-class Arguments;
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-class SpellCheckClient;
-
-class WebFrame : public mate::Wrappable<WebFrame> {
- public:
-  static mate::Handle<WebFrame> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- private:
-  explicit WebFrame(v8::Isolate* isolate);
-  explicit WebFrame(v8::Isolate* isolate, blink::WebLocalFrame* blink_frame);
-  ~WebFrame() override;
-
-  void SetName(const std::string& name);
-
-  double SetZoomLevel(double level);
-  double GetZoomLevel() const;
-  double SetZoomFactor(double factor);
-  double GetZoomFactor() const;
-
-  void SetVisualZoomLevelLimits(double min_level, double max_level);
-  void SetLayoutZoomLevelLimits(double min_level, double max_level);
-
-  v8::Local<v8::Value> RegisterEmbedderCustomElement(
-      const base::string16& name,
-      v8::Local<v8::Object> options);
-  int GetWebFrameId(v8::Local<v8::Value> content_window);
-
-  // Set the provider that will be used by SpellCheckClient for spell check.
-  void SetSpellCheckProvider(mate::Arguments* args,
-                             const std::string& language,
-                             bool auto_spell_correct_turned_on,
-                             v8::Local<v8::Object> provider);
-
-  void RegisterURLSchemeAsBypassingCSP(const std::string& scheme);
-  void RegisterURLSchemeAsPrivileged(const std::string& scheme,
-                                     mate::Arguments* args);
-
-  // Editing.
-  void InsertText(const std::string& text);
-  void InsertCSS(const std::string& css);
-
-  // Executing scripts.
-  void ExecuteJavaScript(const base::string16& code, mate::Arguments* args);
-  void ExecuteJavaScriptInIsolatedWorld(
-      int world_id,
-      const std::vector<mate::Dictionary>& scripts,
-      mate::Arguments* args);
-
-  // Isolated world related methods
-  void SetIsolatedWorldSecurityOrigin(int world_id,
-                                      const std::string& origin_url);
-  void SetIsolatedWorldContentSecurityPolicy(
-      int world_id,
-      const std::string& security_policy);
-  void SetIsolatedWorldHumanReadableName(int world_id, const std::string& name);
-
-  // Resource related methods
-  blink::WebCache::ResourceTypeStats GetResourceUsage(v8::Isolate* isolate);
-  void ClearCache(v8::Isolate* isolate);
-
-  // Frame navigation
-  v8::Local<v8::Value> Opener() const;
-  v8::Local<v8::Value> Parent() const;
-  v8::Local<v8::Value> Top() const;
-  v8::Local<v8::Value> FirstChild() const;
-  v8::Local<v8::Value> NextSibling() const;
-  v8::Local<v8::Value> GetFrameForSelector(const std::string& selector) const;
-  v8::Local<v8::Value> FindFrameByName(const std::string& name) const;
-  v8::Local<v8::Value> FindFrameByRoutingId(int routing_id) const;
-  v8::Local<v8::Value> RoutingId() const;
-
-  std::unique_ptr<SpellCheckClient> spell_check_client_;
-
-  blink::WebLocalFrame* web_frame_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebFrame);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
removed in remote
  base   100644 bbaea351378bf2c9115b87b762a8b2af7e15b844 atom/renderer/atom_render_view_observer.cc
  our    100644 1a425dfa1d40953efb192c3405baff61e96cb734 atom/renderer/atom_render_view_observer.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/atom_render_view_observer.h"
-
-#include "atom/common/api/api_messages.h"
-#include "content/public/renderer/render_view.h"
-#include "ipc/ipc_message_macros.h"
-#include "third_party/WebKit/public/web/WebView.h"
-
-namespace atom {
-
-AtomRenderViewObserver::AtomRenderViewObserver(content::RenderView* render_view)
-    : content::RenderViewObserver(render_view) {}
-
-AtomRenderViewObserver::~AtomRenderViewObserver() {}
-
-bool AtomRenderViewObserver::OnMessageReceived(const IPC::Message& message) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(AtomRenderViewObserver, message)
-    IPC_MESSAGE_HANDLER(AtomViewMsg_Offscreen, OnOffscreen)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-void AtomRenderViewObserver::OnDestruct() {
-  delete this;
-}
-
-void AtomRenderViewObserver::OnOffscreen() {
-  blink::WebView::SetUseExternalPopupMenus(false);
-}
-
-}  // namespace atom
removed in remote
  base   100644 4b9d59f3fa08720ab25170a4c0cc785ba1c170de atom/renderer/atom_render_view_observer.h
  our    100644 097616e12369662473c12645a93e27cffcb55e3b atom/renderer/atom_render_view_observer.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
-#define ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
-
-#include "content/public/renderer/render_view_observer.h"
-
-namespace atom {
-
-class AtomRenderViewObserver : public content::RenderViewObserver {
- public:
-  explicit AtomRenderViewObserver(content::RenderView* render_view);
-
- protected:
-  ~AtomRenderViewObserver() override;
-
- private:
-  // content::RenderViewObserver implementation.
-  bool OnMessageReceived(const IPC::Message& message) override;
-  void OnDestruct() override;
-
-  void OnOffscreen();
-
-  DISALLOW_COPY_AND_ASSIGN(AtomRenderViewObserver);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
removed in remote
  base   100644 7746ce123e4ffdec46196aae5b69295672ccdcc8 atom/renderer/atom_renderer_client.cc
  our    100644 204f17c2cf0d2d4ec4a71bdbecfcd1cbdc5fc8be atom/renderer/atom_renderer_client.cc
@@ -1,230 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/atom_renderer_client.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/node_bindings.h"
-#include "atom/common/options_switches.h"
-#include "atom/renderer/api/atom_api_renderer_ipc.h"
-#include "atom/renderer/atom_render_frame_observer.h"
-#include "atom/renderer/web_worker_observer.h"
-#include "base/command_line.h"
-#include "content/public/renderer/render_frame.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebDocument.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-
-#include "atom/common/node_includes.h"
-#include "atom_natives.h"  // NOLINT: This file is generated with js2c
-#include "tracing/trace_event.h"
-
-namespace atom {
-
-namespace {
-
-bool IsDevToolsExtension(content::RenderFrame* render_frame) {
-  return static_cast<GURL>(render_frame->GetWebFrame()->GetDocument().Url())
-      .SchemeIs("chrome-extension");
-}
-
-}  // namespace
-
-AtomRendererClient::AtomRendererClient()
-    : node_bindings_(NodeBindings::Create(NodeBindings::RENDERER)),
-      atom_bindings_(new AtomBindings(uv_default_loop())) {}
-
-AtomRendererClient::~AtomRendererClient() {
-  asar::ClearArchives();
-}
-
-void AtomRendererClient::RenderThreadStarted() {
-  RendererClientBase::RenderThreadStarted();
-}
-
-void AtomRendererClient::RenderFrameCreated(
-    content::RenderFrame* render_frame) {
-  new AtomRenderFrameObserver(render_frame, this);
-  RendererClientBase::RenderFrameCreated(render_frame);
-}
-
-void AtomRendererClient::RenderViewCreated(content::RenderView* render_view) {
-  RendererClientBase::RenderViewCreated(render_view);
-}
-
-void AtomRendererClient::RunScriptsAtDocumentStart(
-    content::RenderFrame* render_frame) {
-  // Inform the document start pharse.
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  node::Environment* env = GetEnvironment(render_frame);
-  if (env)
-    mate::EmitEvent(env->isolate(), env->process_object(), "document-start");
-}
-
-void AtomRendererClient::RunScriptsAtDocumentEnd(
-    content::RenderFrame* render_frame) {
-  // Inform the document end pharse.
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  node::Environment* env = GetEnvironment(render_frame);
-  if (env)
-    mate::EmitEvent(env->isolate(), env->process_object(), "document-end");
-}
-
-void AtomRendererClient::DidCreateScriptContext(
-    v8::Handle<v8::Context> context,
-    content::RenderFrame* render_frame) {
-  RendererClientBase::DidCreateScriptContext(context, render_frame);
-
-  // Only allow node integration for the main frame, unless it is a devtools
-  // extension page.
-  if (!render_frame->IsMainFrame() && !IsDevToolsExtension(render_frame))
-    return;
-
-  injected_frames_.insert(render_frame);
-
-  // Prepare the node bindings.
-  if (!node_integration_initialized_) {
-    node_integration_initialized_ = true;
-    node_bindings_->Initialize();
-    node_bindings_->PrepareMessageLoop();
-  }
-
-  // Setup node tracing controller.
-  if (!node::tracing::TraceEventHelper::GetTracingController())
-    node::tracing::TraceEventHelper::SetTracingController(
-        new v8::TracingController());
-
-  // Setup node environment for each window.
-  node::Environment* env = node_bindings_->CreateEnvironment(context);
-  environments_.insert(env);
-
-  // Add Electron extended APIs.
-  atom_bindings_->BindTo(env->isolate(), env->process_object());
-  AddRenderBindings(env->isolate(), env->process_object());
-
-  // Load everything.
-  node_bindings_->LoadEnvironment(env);
-
-  if (node_bindings_->uv_env() == nullptr) {
-    // Make uv loop being wrapped by window context.
-    node_bindings_->set_uv_env(env);
-
-    // Give the node loop a run to make sure everything is ready.
-    node_bindings_->RunMessageLoop();
-  }
-}
-
-void AtomRendererClient::WillReleaseScriptContext(
-    v8::Handle<v8::Context> context,
-    content::RenderFrame* render_frame) {
-  if (injected_frames_.find(render_frame) == injected_frames_.end())
-    return;
-  injected_frames_.erase(render_frame);
-
-  node::Environment* env = node::Environment::GetCurrent(context);
-  if (environments_.find(env) == environments_.end())
-    return;
-  environments_.erase(env);
-
-  mate::EmitEvent(env->isolate(), env->process_object(), "exit");
-
-  // The main frame may be replaced.
-  if (env == node_bindings_->uv_env())
-    node_bindings_->set_uv_env(nullptr);
-
-  // Destroy the node environment.
-  // This is disabled because pending async tasks may still use the environment
-  // and would cause crashes later. Node does not seem to clear all async tasks
-  // when the environment is destroyed.
-  // node::FreeEnvironment(env);
-
-  // AtomBindings is tracking node environments.
-  atom_bindings_->EnvironmentDestroyed(env);
-}
-
-bool AtomRendererClient::ShouldFork(blink::WebLocalFrame* frame,
-                                    const GURL& url,
-                                    const std::string& http_method,
-                                    bool is_initial_navigation,
-                                    bool is_server_redirect,
-                                    bool* send_referrer) {
-  // Handle all the navigations and reloads in browser.
-  // FIXME We only support GET here because http method will be ignored when
-  // the OpenURLFromTab is triggered, which means form posting would not work,
-  // we should solve this by patching Chromium in future.
-  *send_referrer = true;
-  return http_method == "GET";
-}
-
-void AtomRendererClient::DidInitializeWorkerContextOnWorkerThread(
-    v8::Local<v8::Context> context) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kNodeIntegrationInWorker)) {
-    WebWorkerObserver::GetCurrent()->ContextCreated(context);
-  }
-}
-
-void AtomRendererClient::WillDestroyWorkerContextOnWorkerThread(
-    v8::Local<v8::Context> context) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kNodeIntegrationInWorker)) {
-    WebWorkerObserver::GetCurrent()->ContextWillDestroy(context);
-  }
-}
-
-void AtomRendererClient::SetupMainWorldOverrides(
-    v8::Handle<v8::Context> context) {
-  // Setup window overrides in the main world context
-  v8::Isolate* isolate = context->GetIsolate();
-
-  // Wrap the bundle into a function that receives the binding object as
-  // an argument.
-  std::string left = "(function (binding, require) {\n";
-  std::string right = "\n})";
-  auto script = v8::Script::Compile(v8::String::Concat(
-      mate::ConvertToV8(isolate, left)->ToString(),
-      v8::String::Concat(node::isolated_bundle_value.ToStringChecked(isolate),
-                         mate::ConvertToV8(isolate, right)->ToString())));
-  auto func =
-      v8::Handle<v8::Function>::Cast(script->Run(context).ToLocalChecked());
-
-  auto binding = v8::Object::New(isolate);
-  api::Initialize(binding, v8::Null(isolate), context, nullptr);
-
-  // Pass in CLI flags needed to setup window
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-  mate::Dictionary dict(isolate, binding);
-  if (command_line->HasSwitch(switches::kGuestInstanceID))
-    dict.Set(options::kGuestInstanceID,
-             command_line->GetSwitchValueASCII(switches::kGuestInstanceID));
-  if (command_line->HasSwitch(switches::kOpenerID))
-    dict.Set(options::kOpenerID,
-             command_line->GetSwitchValueASCII(switches::kOpenerID));
-  dict.Set("hiddenPage", command_line->HasSwitch(switches::kHiddenPage));
-  dict.Set(options::kNativeWindowOpen,
-           command_line->HasSwitch(switches::kNativeWindowOpen));
-
-  v8::Local<v8::Value> args[] = {binding};
-  ignore_result(func->Call(context, v8::Null(isolate), 1, args));
-}
-
-node::Environment* AtomRendererClient::GetEnvironment(
-    content::RenderFrame* render_frame) const {
-  if (injected_frames_.find(render_frame) == injected_frames_.end())
-    return nullptr;
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  auto context =
-      GetContext(render_frame->GetWebFrame(), v8::Isolate::GetCurrent());
-  node::Environment* env = node::Environment::GetCurrent(context);
-  if (environments_.find(env) == environments_.end())
-    return nullptr;
-  return env;
-}
-
-}  // namespace atom
removed in remote
  base   100644 59b407ba1efb230a001043f7fb25b1c4cb1d0b53 atom/renderer/atom_renderer_client.h
  our    100644 3e81cd4c647b8fddc01da868d0e8a53bcb59b5b4 atom/renderer/atom_renderer_client.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
-#define ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "atom/renderer/renderer_client_base.h"
-
-namespace node {
-class Environment;
-}
-
-namespace atom {
-
-class AtomBindings;
-class NodeBindings;
-
-class AtomRendererClient : public RendererClientBase {
- public:
-  AtomRendererClient();
-  ~AtomRendererClient() override;
-
-  // atom::RendererClientBase:
-  void DidCreateScriptContext(v8::Handle<v8::Context> context,
-                              content::RenderFrame* render_frame) override;
-  void WillReleaseScriptContext(v8::Handle<v8::Context> context,
-                                content::RenderFrame* render_frame) override;
-  void SetupMainWorldOverrides(v8::Handle<v8::Context> context) override;
-
- private:
-  enum NodeIntegration {
-    ALL,
-    EXCEPT_IFRAME,
-    MANUAL_ENABLE_IFRAME,
-    DISABLE,
-  };
-
-  // content::ContentRendererClient:
-  void RenderThreadStarted() override;
-  void RenderFrameCreated(content::RenderFrame*) override;
-  void RenderViewCreated(content::RenderView*) override;
-  void RunScriptsAtDocumentStart(content::RenderFrame* render_frame) override;
-  void RunScriptsAtDocumentEnd(content::RenderFrame* render_frame) override;
-  bool ShouldFork(blink::WebLocalFrame* frame,
-                  const GURL& url,
-                  const std::string& http_method,
-                  bool is_initial_navigation,
-                  bool is_server_redirect,
-                  bool* send_referrer) override;
-  void DidInitializeWorkerContextOnWorkerThread(
-      v8::Local<v8::Context> context) override;
-  void WillDestroyWorkerContextOnWorkerThread(
-      v8::Local<v8::Context> context) override;
-
-  node::Environment* GetEnvironment(content::RenderFrame* frame) const;
-
-  // Whether the node integration has been initialized.
-  bool node_integration_initialized_ = false;
-
-  std::unique_ptr<NodeBindings> node_bindings_;
-  std::unique_ptr<AtomBindings> atom_bindings_;
-
-  // The node::Environment::GetCurrent API does not return nullptr when it
-  // is called for a context without node::Environment, so we have to keep
-  // a book of the environments created.
-  std::set<node::Environment*> environments_;
-
-  // Getting main script context from web frame would lazily initializes
-  // its script context. Doing so in a web page without scripts would trigger
-  // assertion, so we have to keep a book of injected web frames.
-  std::set<content::RenderFrame*> injected_frames_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomRendererClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
removed in remote
  base   100644 f50c3f78685c0886b44f82cad7e48e2ed90ae385 atom/renderer/guest_view_container.cc
  our    100644 6ad5cd0703f50481749b467d7fe99575dc0731c7 atom/renderer/guest_view_container.cc
@@ -1,63 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/guest_view_container.h"
-
-#include <map>
-
-#include "base/bind.h"
-#include "base/lazy_instance.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "ui/gfx/geometry/size.h"
-
-namespace atom {
-
-namespace {
-
-using GuestViewContainerMap = std::map<int, GuestViewContainer*>;
-static base::LazyInstance<GuestViewContainerMap>::DestructorAtExit
-    g_guest_view_container_map = LAZY_INSTANCE_INITIALIZER;
-
-}  // namespace
-
-GuestViewContainer::GuestViewContainer(content::RenderFrame* render_frame)
-    : weak_ptr_factory_(this) {}
-
-GuestViewContainer::~GuestViewContainer() {
-  if (element_instance_id_ > 0)
-    g_guest_view_container_map.Get().erase(element_instance_id_);
-}
-
-// static
-GuestViewContainer* GuestViewContainer::FromID(int element_instance_id) {
-  GuestViewContainerMap* guest_view_containers =
-      g_guest_view_container_map.Pointer();
-  auto it = guest_view_containers->find(element_instance_id);
-  return it == guest_view_containers->end() ? nullptr : it->second;
-}
-
-void GuestViewContainer::RegisterElementResizeCallback(
-    const ResizeCallback& callback) {
-  element_resize_callback_ = callback;
-}
-
-void GuestViewContainer::SetElementInstanceID(int element_instance_id) {
-  element_instance_id_ = element_instance_id;
-  g_guest_view_container_map.Get().insert(
-      std::make_pair(element_instance_id, this));
-}
-
-void GuestViewContainer::DidResizeElement(const gfx::Size& new_size) {
-  if (element_resize_callback_.is_null())
-    return;
-
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(element_resize_callback_, new_size));
-}
-
-base::WeakPtr<content::BrowserPluginDelegate> GuestViewContainer::GetWeakPtr() {
-  return weak_ptr_factory_.GetWeakPtr();
-}
-
-}  // namespace atom
removed in remote
  base   100644 3771c7adc4e6c1dc31cdb0be4a5cf5025053733c atom/renderer/guest_view_container.h
  our    100644 81e6313358a9a64728a94f52a31a4f40e5547d7a atom/renderer/guest_view_container.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
-#define ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
-
-#include "base/callback.h"
-#include "content/public/renderer/browser_plugin_delegate.h"
-#include "content/public/renderer/render_frame.h"
-
-namespace gfx {
-class Size;
-}
-
-namespace atom {
-
-class GuestViewContainer : public content::BrowserPluginDelegate {
- public:
-  typedef base::Callback<void(const gfx::Size&)> ResizeCallback;
-
-  explicit GuestViewContainer(content::RenderFrame* render_frame);
-  ~GuestViewContainer() override;
-
-  static GuestViewContainer* FromID(int element_instance_id);
-
-  void RegisterElementResizeCallback(const ResizeCallback& callback);
-
-  // content::BrowserPluginDelegate:
-  void SetElementInstanceID(int element_instance_id) final;
-  void DidResizeElement(const gfx::Size& new_size) final;
-  base::WeakPtr<BrowserPluginDelegate> GetWeakPtr() final;
-
- private:
-  int element_instance_id_;
-
-  ResizeCallback element_resize_callback_;
-
-  base::WeakPtrFactory<GuestViewContainer> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(GuestViewContainer);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
removed in remote
  base   100644 1da2c29fd9ca2138134e5cf2db2da57aba31f35c atom/renderer/resources/mac/Info.plist
  our    100644 1da2c29fd9ca2138134e5cf2db2da57aba31f35c atom/renderer/resources/mac/Info.plist
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-  <key>CFBundleIdentifier</key>
-  <string>${ATOM_BUNDLE_ID}</string>
-  <key>CFBundleName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundlePackageType</key>
-  <string>APPL</string>
-  <key>LSUIElement</key>
-  <true/>
-  <key>NSSupportsAutomaticGraphicsSwitching</key>
-  <true/>
-</dict>
-</plist>
removed in remote
  base   100644 2e591f2c6a8dadb3bb624aa395276377e0d43a6b atom/utility/atom_content_utility_client.cc
  our    100644 e2a856d53ae243de988c43b0a3335b9391e54b4e atom/utility/atom_content_utility_client.cc
@@ -1,32 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/utility/atom_content_utility_client.h"
-
-#if defined(OS_WIN)
-#include "chrome/utility/printing_handler_win.h"
-#endif
-
-namespace atom {
-
-AtomContentUtilityClient::AtomContentUtilityClient() {
-#if defined(OS_WIN)
-  handlers_.push_back(std::make_unique<printing::PrintingHandlerWin>());
-#endif
-}
-
-AtomContentUtilityClient::~AtomContentUtilityClient() {}
-
-bool AtomContentUtilityClient::OnMessageReceived(const IPC::Message& message) {
-#if defined(OS_WIN)
-  for (const auto& handler : handlers_) {
-    if (handler->OnMessageReceived(message))
-      return true;
-  }
-#endif
-
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 229ae3f91765d36041f1360a635840524eb9febd atom/utility/atom_content_utility_client.h
  our    100644 7694970457b745a84ecab24a2f0ec8eaefa8a1ad atom/utility/atom_content_utility_client.h
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
-#define ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
-
-#include <memory>
-#include <vector>
-
-#include "base/compiler_specific.h"
-#include "content/public/utility/content_utility_client.h"
-
-class UtilityMessageHandler;
-
-namespace atom {
-
-class AtomContentUtilityClient : public content::ContentUtilityClient {
- public:
-  AtomContentUtilityClient();
-  ~AtomContentUtilityClient() override;
-
-  bool OnMessageReceived(const IPC::Message& message) override;
-
- private:
-#if defined(OS_WIN)
-  typedef std::vector<std::unique_ptr<UtilityMessageHandler>> Handlers;
-  Handlers handlers_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(AtomContentUtilityClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
changed in both
  base   100644 a195ad4c6adfc9726faaf297e037fa7c863a67a9 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
  our    100644 a346478c49fb355db5bfb163deafbb6f7a98ab20 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
  their  100644 d47c855f6b90654a08b7b32275fd46ec6e17eaf1 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
@@ -18,7 +18,7 @@
 #include "printing/pdf_metafile_skia.h"
 #include "printing/print_job_constants.h"
 
-#include "atom/common/node_includes.h"
+#include "electron/common/node_includes.h"
 
 using content::BrowserThread;
 using content::WebContents;
@@ -107,7 +107,7 @@
 
 void PrintPreviewMessageHandler::PrintToPDF(
     const base::DictionaryValue& options,
-    const atom::api::WebContents::PrintToPDFCallback& callback) {
+    const electron::api::WebContents::PrintToPDFCallback& callback) {
   int request_id;
   options.GetInteger(printing::kPreviewRequestID, &request_id);
   print_to_pdf_callback_map_[request_id] = callback;
changed in both
  base   100644 1aac74baa229923460ac3d8d230159f90f23fe5f chromium_src/chrome/browser/printing/print_preview_message_handler.h
  our    100644 465bbf598319551525ef629b46943c4d905577ce chromium_src/chrome/browser/printing/print_preview_message_handler.h
  their  100644 9ade37bb732798e65ff18e1c540624c6a6a297fe chromium_src/chrome/browser/printing/print_preview_message_handler.h
@@ -7,7 +7,7 @@
 
 #include <map>
 
-#include "atom/browser/api/atom_api_web_contents.h"
+#include "electron/browser/api/electron_api_web_contents.h"
 #include "base/compiler_specific.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
@@ -34,10 +34,10 @@
                          content::RenderFrameHost* render_frame_host) override;
 
   void PrintToPDF(const base::DictionaryValue& options,
-                  const atom::api::WebContents::PrintToPDFCallback& callback);
+                  const electron::api::WebContents::PrintToPDFCallback& callback);
 
  private:
-  typedef std::map<int, atom::api::WebContents::PrintToPDFCallback>
+  typedef std::map<int, electron::api::WebContents::PrintToPDFCallback>
       PrintToPDFCallbackMap;
 
   explicit PrintPreviewMessageHandler(content::WebContents* web_contents);
changed in both
  base   100644 7e54d9b5d37039ebc9adf3656c984e029328433d chromium_src/chrome/browser/process_singleton_posix.cc
  our    100644 4891743710d16673c6a72d76a303f6ac56a5ad32 chromium_src/chrome/browser/process_singleton_posix.cc
  their  100644 1d157cf625218de7b32ac2e29ffe581843ad1215 chromium_src/chrome/browser/process_singleton_posix.cc
@@ -53,11 +53,15 @@
 #include <set>
 #include <string>
 
+<<<<<<< .our
 #include <stddef.h>
 
 #include "atom/browser/browser.h"
 #include "atom/common/atom_command_line.h"
 
+=======
+#include "electron/common/electron_command_line.h"
+>>>>>>> .their
 #include "base/base_paths.h"
 #include "base/bind.h"
 #include "base/command_line.h"
@@ -824,7 +828,7 @@
     return PROCESS_NONE;
   to_send.append(current_dir.value());
 
-  const std::vector<std::string>& argv = atom::AtomCommandLine::argv();
+  const std::vector<std::string>& argv = electron::ElectronCommandLine::argv();
   for (std::vector<std::string>::const_iterator it = argv.begin();
        it != argv.end(); ++it) {
     to_send.push_back(kTokenDelimiter);
changed in both
  base   100644 fd4c22e7405c4c6185c37e86d9a9ed0f4cfbe176 chromium_src/chrome/browser/process_singleton_win.cc
  our    100644 6d0d102430ff700e703cef7e3189403c4a35218f chromium_src/chrome/browser/process_singleton_win.cc
  their  100644 88c6185f3bb51ac553b471c901e1bb0de0153205 chromium_src/chrome/browser/process_singleton_win.cc
@@ -263,7 +263,7 @@
 // isn't one, create a message window with its title set to the profile
 // directory path.
 bool ProcessSingleton::Create() {
-  static const wchar_t kMutexName[] = L"Local\\AtomProcessSingletonStartup!";
+  static const wchar_t kMutexName[] = L"Local\\ElectronProcessSingletonStartup!";
 
   remote_window_ = chrome::FindRunningChromeWindow(user_data_dir_);
   if (!remote_window_) {
changed in both
  base   100644 cead675a74d33ac990b1a77fe5f9c2c6416ac249 chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
  our    100644 54bf67e50330255c9b1e29d812fced8d2a73e52e chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
  their  100644 26c5b703aa76e1a991e6d7b7ac181c96726d4e96 chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
@@ -4,7 +4,7 @@
 
 #include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
 
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
 #include "base/bind.h"
 #include "base/debug/leak_annotations.h"
 #include "base/logging.h"
@@ -65,7 +65,7 @@
 
 void GlobalMenuBarRegistrarX11::RegisterXID(unsigned long xid) {
   DCHECK(registrar_proxy_);
-  std::string path = atom::GlobalMenuBarX11::GetPathForWindow(xid);
+  std::string path = electron::GlobalMenuBarX11::GetPathForWindow(xid);
 
   ANNOTATE_SCOPED_MEMORY_LEAK;  // http://crbug.com/314087
   // TODO(erg): The mozilla implementation goes to a lot of callback trouble
@@ -82,7 +82,7 @@
 
 void GlobalMenuBarRegistrarX11::UnregisterXID(unsigned long xid) {
   DCHECK(registrar_proxy_);
-  std::string path = atom::GlobalMenuBarX11::GetPathForWindow(xid);
+  std::string path = electron::GlobalMenuBarX11::GetPathForWindow(xid);
 
   ANNOTATE_SCOPED_MEMORY_LEAK;  // http://crbug.com/314087
   // TODO(erg): The mozilla implementation goes to a lot of callback trouble
merged
  result 100644 1fd4364a5fc24a34f23c578783ff9e4baab4b155 chromium_src/chrome/common/chrome_constants.cc
  our    100644 43a6ccdc7cb4a29fc1f53846e35a4b490d5899ff chromium_src/chrome/common/chrome_constants.cc
@@ -10,7 +10,7 @@
 
 #if defined(OS_MACOSX)
 const base::FilePath::CharType kFrameworkName[] =
-    FPL(ATOM_PRODUCT_NAME " Framework.framework");
+    FPL(ELECTRON_PRODUCT_NAME " Framework.framework");
 #endif  // OS_MACOSX
 
 // filenames
added in both
  our    100644 944ddab2a3fd879044e31677e4bac2843fffbdee electron.gyp
  their  100644 ff95786a4ec0a57f25cc494ee5965e88c1139b50 electron.gyp
@@ -4,6 +4,7 @@
     'product_name%': 'Electron',
     'company_name%': 'GitHub, Inc',
     'company_abbr%': 'github',
+<<<<<<< .our
     'version%': '4.0.0-nightly.20180821',
     'js2c_input_dir': '<(SHARED_INTERMEDIATE_DIR)/js2c',
   },
@@ -16,6 +17,18 @@
     'defines': [
       'ATOM_PRODUCT_NAME="<(product_name)"',
       'ATOM_PROJECT_NAME="<(project_name)"',
+=======
+    'version%': '0.37.3',
+  },
+  'includes': [
+    'filenames.gypi',
+    'vendor/native_mate/native_mate_files.gypi',
+  ],
+  'target_defaults': {
+    'defines': [
+      'ELECTRON_PRODUCT_NAME="<(product_name)"',
+      'ELECTRON_PROJECT_NAME="<(project_name)"',
+>>>>>>> .their
     ],
     'conditions': [
       ['OS=="mac"', {
@@ -23,6 +36,7 @@
           '<(source_root)/external_binaries',
         ],
       }],
+<<<<<<< .our
       ['enable_desktop_capturer==1', {
         'defines': [
           'ENABLE_DESKTOP_CAPTURER',
@@ -53,6 +67,8 @@
           'ENABLE_PEPPER_FLASH',
         ],
       }],  # enable_pepper_flash
+=======
+>>>>>>> .their
     ],
   },
   'targets': [
@@ -61,7 +77,10 @@
       'type': 'executable',
       'dependencies': [
         'js2asar',
+<<<<<<< .our
         'app2asar',
+=======
+>>>>>>> .their
         '<(project_name)_lib',
       ],
       'sources': [
@@ -82,8 +101,13 @@
             '<(project_name)_helper',
           ],
           'xcode_settings': {
+<<<<<<< .our
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name)',
             'INFOPLIST_FILE': 'atom/browser/resources/mac/Info.plist',
+=======
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name)',
+            'INFOPLIST_FILE': 'electron/browser/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_RUNPATH_SEARCH_PATHS': [
               '@executable_path/../Frameworks',
             ],
@@ -99,6 +123,15 @@
                 '<(PRODUCT_DIR)/<(product_name) Framework.framework',
               ],
             },
+<<<<<<< .our
+=======
+            {
+              'destination': '<(PRODUCT_DIR)/<(product_name).app/Contents/Resources',
+              'files': [
+                'default_app',
+              ],
+            },
+>>>>>>> .their
           ],
           'postbuilds': [
             {
@@ -112,7 +145,11 @@
               # is marked for no PIE (ASLR).
               'postbuild_name': 'Make More Helpers',
               'action': [
+<<<<<<< .our
                 'tools/mac/make_more_helpers.sh',
+=======
+                'vendor/brightray/tools/mac/make_more_helpers.sh',
+>>>>>>> .their
                 'Frameworks',
                 '<(product_name)',
               ],
@@ -147,6 +184,7 @@
                 },
               ],
             }],
+<<<<<<< .our
             ['mas_build==1', {
               'dependencies': [
                 '<(project_name)_login_helper',
@@ -181,6 +219,19 @@
                 'wtsapi32.lib',
               ],
             },
+=======
+          ],
+        }],  # OS!="mac"
+        ['OS=="win"', {
+          'include_dirs': [
+            '<(libchromiumcontent_dir)/gen/ui/resources',
+          ],
+          'msvs_settings': {
+            'VCManifestTool': {
+              'EmbedManifest': 'true',
+              'AdditionalManifestFiles': 'electron/browser/resources/win/electron.manifest',
+            }
+>>>>>>> .their
           },
           'copies': [
             {
@@ -205,6 +256,7 @@
                 '<(libchromiumcontent_dir)/libEGL.dll',
                 '<(libchromiumcontent_dir)/libGLESv2.dll',
                 '<(libchromiumcontent_dir)/icudtl.dat',
+<<<<<<< .our
                 '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_shell.pak',
@@ -215,6 +267,26 @@
                 'external_binaries/d3dcompiler_47.dll',
               ],
             },
+=======
+                '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
+                '<(libchromiumcontent_dir)/content_shell.pak',
+                '<(libchromiumcontent_dir)/ui_resources_200_percent.pak',
+                '<(libchromiumcontent_dir)/natives_blob.bin',
+                '<(libchromiumcontent_dir)/snapshot_blob.bin',
+                'external_binaries/d3dcompiler_47.dll',
+                'external_binaries/xinput1_3.dll',
+                'external_binaries/msvcp120.dll',
+                'external_binaries/msvcr120.dll',
+                'external_binaries/vccorlib120.dll',
+              ],
+            },
+            {
+              'destination': '<(PRODUCT_DIR)/resources',
+              'files': [
+                'default_app',
+              ]
+            },
+>>>>>>> .their
           ],
         }, {
           'dependencies': [
@@ -245,6 +317,7 @@
                 '<@(copied_libraries)',
                 '<(libchromiumcontent_dir)/locales',
                 '<(libchromiumcontent_dir)/icudtl.dat',
+<<<<<<< .our
                 '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_shell.pak',
@@ -254,6 +327,19 @@
                 '<(libchromiumcontent_dir)/v8_context_snapshot.bin',
               ],
             },
+=======
+                '<(libchromiumcontent_dir)/content_shell.pak',
+                '<(libchromiumcontent_dir)/natives_blob.bin',
+                '<(libchromiumcontent_dir)/snapshot_blob.bin',
+              ],
+            },
+            {
+              'destination': '<(PRODUCT_DIR)/resources',
+              'files': [
+                'default_app',
+              ]
+            },
+>>>>>>> .their
           ],
         }],  # OS=="linux"
       ],
@@ -262,6 +348,7 @@
       'target_name': '<(project_name)_lib',
       'type': 'static_library',
       'dependencies': [
+<<<<<<< .our
         'atom_js2c',
         'brightray/brightray.gyp:brightray',
         'vendor/node/node.gyp:node_lib',
@@ -272,10 +359,20 @@
         'NODE_SHARED_MODE',
         'HAVE_OPENSSL=1',
         'HAVE_INSPECTOR=1',
+=======
+        'electron_js2c',
+        'vendor/brightray/brightray.gyp:brightray',
+        'vendor/node/node.gyp:node',
+      ],
+      'defines': [
+        # This is defined in skia/skia_common.gypi.
+        'SK_SUPPORT_LEGACY_GETTOPDEVICE',
+>>>>>>> .their
         # Disable warnings for g_settings_list_schemas.
         'GLIB_DISABLE_DEPRECATION_WARNINGS',
         # Defined in Chromium but not exposed in its gyp file.
         'V8_USE_EXTERNAL_STARTUP_DATA',
+<<<<<<< .our
 
         # Import V8 symbols from shared library (node.dll / libnode.so)
         'USING_V8_SHARED',
@@ -285,6 +382,11 @@
         # See Chromium src/third_party/protobuf/BUILD.gn
         'GOOGLE_PROTOBUF_NO_RTTI',
         'GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER',
+=======
+        'ENABLE_PLUGINS',
+        'ENABLE_PEPPER_CDMS',
+        'USE_PROPRIETARY_CODECS',
+>>>>>>> .their
       ],
       'sources': [
         '<@(lib_sources)',
@@ -292,8 +394,14 @@
       'include_dirs': [
         '.',
         'chromium_src',
+<<<<<<< .our
         'native_mate',
         # Include atom_natives.h.
+=======
+        'vendor/brightray',
+        'vendor/native_mate',
+        # Include electron_natives.h.
+>>>>>>> .their
         '<(SHARED_INTERMEDIATE_DIR)',
         # Include directories for uv and node.
         'vendor/node/src',
@@ -311,6 +419,7 @@
         '<(libchromiumcontent_src_dir)/third_party/',
         '<(libchromiumcontent_src_dir)/components/cdm',
         '<(libchromiumcontent_src_dir)/third_party/widevine',
+<<<<<<< .our
         '<(libchromiumcontent_src_dir)/third_party/widevine/cdm/stub',
         '<(libchromiumcontent_src_dir)/third_party/protobuf/src',
         # The 'third_party/webrtc/modules/desktop_capture/desktop_capture_options.h' is using 'rtc_base/constructormagic.h'.
@@ -318,6 +427,8 @@
         # leveldb includes are required
         '<(libchromiumcontent_src_dir)/third_party/leveldatabase/src',
         '<(libchromiumcontent_src_dir)/third_party/leveldatabase/src/include',
+=======
+>>>>>>> .their
       ],
       'direct_dependent_settings': {
         'include_dirs': [
@@ -325,6 +436,7 @@
         ],
       },
       'export_dependent_settings': [
+<<<<<<< .our
         'brightray/brightray.gyp:brightray',
       ],
       'conditions': [
@@ -352,6 +464,11 @@
             ],
           },
         }],  # enable_pepper_flash
+=======
+        'vendor/brightray/brightray.gyp:brightray',
+      ],
+      'conditions': [
+>>>>>>> .their
         ['libchromiumcontent_component', {
           'link_settings': {
             'libraries': [ '<@(libchromiumcontent_v8_libraries)' ],
@@ -363,17 +480,24 @@
           ],
           'link_settings': {
             'libraries': [
+<<<<<<< .our
               '-ldwmapi.lib',
               '-limm32.lib',
               '-lgdi32.lib',
+=======
+              '-limm32.lib',
+>>>>>>> .their
               '-loleacc.lib',
               '-lcomctl32.lib',
               '-lcomdlg32.lib',
               '-lwininet.lib',
               '-lwinmm.lib',
+<<<<<<< .our
               '-lcrypt32.lib',
               '-luiautomationcore.lib',
               '-lPropsys.lib'
+=======
+>>>>>>> .their
             ],
           },
           'dependencies': [
@@ -399,6 +523,7 @@
               '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
+<<<<<<< .our
           'xcode_settings': {
             # ReactiveCocoa which is used by Squirrel requires using __weak.
             'CLANG_ENABLE_OBJC_WEAK': 'YES',
@@ -407,12 +532,15 @@
               '-Wobjc-missing-property-synthesis',
             ],
           },
+=======
+>>>>>>> .their
         }],  # OS=="mac" and mas_build==0
         ['OS=="mac" and mas_build==1', {
           'defines': [
             'MAS_BUILD',
           ],
           'sources!': [
+<<<<<<< .our
             'atom/browser/auto_updater_mac.mm',
             'atom/common/crash_reporter/crash_reporter_mac.h',
             'atom/common/crash_reporter/crash_reporter_mac.mm',
@@ -430,12 +558,24 @@
             '<@(lib_sources_linux)',
             '<@(lib_sources_nss)',
           ],
+=======
+            'electron/browser/auto_updater_mac.mm',
+            'electron/common/crash_reporter/crash_reporter_mac.h',
+            'electron/common/crash_reporter/crash_reporter_mac.mm',
+          ],
+        }],  # OS=="mac" and mas_build==1
+        ['OS=="linux"', {
+>>>>>>> .their
           'link_settings': {
             'ldflags': [
               # Make binary search for libraries under current directory, so we
               # don't have to manually set $LD_LIBRARY_PATH:
               # http://serverfault.com/questions/279068/cant-find-so-in-the-same-directory-as-the-executable
+<<<<<<< .our
               '-Wl,-rpath=\$$ORIGIN',
+=======
+              '-rpath \$$ORIGIN',
+>>>>>>> .their
               # Make native module dynamic loading work.
               '-rdynamic',
             ],
@@ -443,6 +583,10 @@
           # Required settings of using breakpad.
           'cflags_cc': [
             '-Wno-empty-body',
+<<<<<<< .our
+=======
+            '-Wno-reserved-user-defined-literal',
+>>>>>>> .their
           ],
           'include_dirs': [
             'vendor/breakpad/src',
@@ -451,12 +595,15 @@
             'vendor/breakpad/breakpad.gyp:breakpad_client',
           ],
         }],  # OS=="linux"
+<<<<<<< .our
         ['OS=="linux" and clang==1', {
           # Required settings of using breakpad.
           'cflags_cc': [
             '-Wno-reserved-user-defined-literal',
           ],
         }],  # OS=="linux" and clang==1
+=======
+>>>>>>> .their
       ],
     },  # target <(product_name)_lib
     {
@@ -484,13 +631,17 @@
             'python',
             'tools/js2asar.py',
             '<@(_outputs)',
+<<<<<<< .our
             'lib',
+=======
+>>>>>>> .their
             '<@(_inputs)',
           ],
         }
       ],
     },  # target js2asar
     {
+<<<<<<< .our
       'target_name': 'app2asar',
       'type': 'none',
       'actions': [
@@ -617,10 +768,23 @@
           ],
           'outputs': [
             '<(SHARED_INTERMEDIATE_DIR)/atom_natives.h',
+=======
+      'target_name': 'electron_js2c',
+      'type': 'none',
+      'actions': [
+        {
+          'action_name': 'electron_js2c',
+          'inputs': [
+            '<@(js2c_sources)',
+          ],
+          'outputs': [
+            '<(SHARED_INTERMEDIATE_DIR)/electron_natives.h',
+>>>>>>> .their
           ],
           'action': [
             'python',
             'tools/js2c.py',
+<<<<<<< .our
             'vendor/node',
             '<@(_outputs)',
             '<(js2c_input_dir)',
@@ -628,6 +792,14 @@
         }
       ],
     },  # target atom_js2c
+=======
+            '<@(_outputs)',
+            '<@(_inputs)',
+          ],
+        }
+      ],
+    },  # target electron_js2c
+>>>>>>> .their
   ],
   'conditions': [
     ['OS=="mac"', {
@@ -654,15 +826,19 @@
             'libraries': [
               '$(SDKROOT)/System/Library/Frameworks/Carbon.framework',
               '$(SDKROOT)/System/Library/Frameworks/QuartzCore.framework',
+<<<<<<< .our
               '$(SDKROOT)/System/Library/Frameworks/Quartz.framework',
               '$(SDKROOT)/System/Library/Frameworks/Security.framework',
               '$(SDKROOT)/System/Library/Frameworks/SecurityInterface.framework',
               '$(SDKROOT)/System/Library/Frameworks/ServiceManagement.framework',
               '$(SDKROOT)/System/Library/Frameworks/StoreKit.framework',
+=======
+>>>>>>> .their
             ],
           },
           'mac_bundle': 1,
           'mac_bundle_resources': [
+<<<<<<< .our
             'atom/common/resources/mac/MainMenu.xib',
             '<(libchromiumcontent_dir)/icudtl.dat',
             '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
@@ -676,6 +852,17 @@
           'xcode_settings': {
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name).framework',
             'INFOPLIST_FILE': 'atom/common/resources/mac/Info.plist',
+=======
+            'electron/common/resources/mac/MainMenu.xib',
+            '<(libchromiumcontent_dir)/content_shell.pak',
+            '<(libchromiumcontent_dir)/icudtl.dat',
+            '<(libchromiumcontent_dir)/natives_blob.bin',
+            '<(libchromiumcontent_dir)/snapshot_blob.bin',
+          ],
+          'xcode_settings': {
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name).framework',
+            'INFOPLIST_FILE': 'electron/common/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_DYLIB_INSTALL_NAME': '@rpath/<(product_name) Framework.framework/<(product_name) Framework',
             'LD_RUNPATH_SEARCH_PATHS': [
               '@loader_path/Libraries',
@@ -720,6 +907,19 @@
               ],
             },
             {
+<<<<<<< .our
+=======
+              'postbuild_name': 'Fix path of ffmpeg',
+              'action': [
+                'install_name_tool',
+                '-change',
+                '/usr/local/lib/libffmpeg.dylib',
+                '@rpath/libffmpeg.dylib',
+                '${BUILT_PRODUCTS_DIR}/<(product_name) Framework.framework/Versions/A/<(product_name) Framework',
+              ],
+            },
+            {
+>>>>>>> .their
               'postbuild_name': 'Add symlinks for framework subdirectories',
               'action': [
                 'tools/mac/create-framework-subdir-symlinks.sh',
@@ -739,11 +939,14 @@
             },
           ],
           'conditions': [
+<<<<<<< .our
             ['enable_pdf_viewer==1', {
               'mac_bundle_resources': [
                 '<(PRODUCT_DIR)/pdf_viewer_resources.pak',
               ],
             }],  # enable_pdf_viewer
+=======
+>>>>>>> .their
             ['mas_build==0', {
               'link_settings': {
                 'libraries': [
@@ -778,13 +981,19 @@
           ],
           'mac_bundle': 1,
           'xcode_settings': {
+<<<<<<< .our
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name).helper',
             'INFOPLIST_FILE': 'atom/renderer/resources/mac/Info.plist',
+=======
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name).helper',
+            'INFOPLIST_FILE': 'electron/renderer/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_RUNPATH_SEARCH_PATHS': [
               '@executable_path/../../..',
             ],
           },
         },  # target helper
+<<<<<<< .our
         {
           'target_name': '<(project_name)_login_helper',
           'product_name': '<(product_name) Login Helper',
@@ -811,6 +1020,8 @@
             ],
           },
         },  # target login_helper
+=======
+>>>>>>> .their
       ],
     }],  # OS!="mac"
   ],
added in remote
  their  100644 5e5eae74e7f694982bfffe709b5f6fd44251840f electron/app/electron_content_client.cc
@@ -0,0 +1,216 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_content_client.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/common/content_constants.h"
+#include "content/public/common/pepper_plugin_info.h"
+#include "content/public/common/user_agent.h"
+#include "ppapi/shared_impl/ppapi_permissions.h"
+#include "third_party/widevine/cdm/stub/widevine_cdm_version.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "url/url_constants.h"
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+#include "chrome/common/widevine_cdm_constants.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+content::PepperPluginInfo CreatePepperFlashInfo(const base::FilePath& path,
+                                                const std::string& version) {
+  content::PepperPluginInfo plugin;
+
+  plugin.is_out_of_process = true;
+  plugin.name = content::kFlashPluginName;
+  plugin.path = path;
+  plugin.permissions = ppapi::PERMISSION_ALL_BITS;
+
+  std::vector<std::string> flash_version_numbers = base::SplitString(
+      version, ".", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+  if (flash_version_numbers.size() < 1)
+    flash_version_numbers.push_back("11");
+  // |SplitString()| puts in an empty string given an empty string. :(
+  else if (flash_version_numbers[0].empty())
+    flash_version_numbers[0] = "11";
+  if (flash_version_numbers.size() < 2)
+    flash_version_numbers.push_back("2");
+  if (flash_version_numbers.size() < 3)
+    flash_version_numbers.push_back("999");
+  if (flash_version_numbers.size() < 4)
+    flash_version_numbers.push_back("999");
+  // E.g., "Shockwave Flash 10.2 r154":
+  plugin.description = plugin.name + " " + flash_version_numbers[0] + "." +
+      flash_version_numbers[1] + " r" + flash_version_numbers[2];
+  plugin.version = base::JoinString(flash_version_numbers, ".");
+  content::WebPluginMimeType swf_mime_type(
+      content::kFlashPluginSwfMimeType,
+      content::kFlashPluginSwfExtension,
+      content::kFlashPluginSwfDescription);
+  plugin.mime_types.push_back(swf_mime_type);
+  content::WebPluginMimeType spl_mime_type(
+      content::kFlashPluginSplMimeType,
+      content::kFlashPluginSplExtension,
+      content::kFlashPluginSplDescription);
+  plugin.mime_types.push_back(spl_mime_type);
+
+  return plugin;
+}
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+content::PepperPluginInfo CreateWidevineCdmInfo(const base::FilePath& path,
+                                                const std::string& version) {
+  content::PepperPluginInfo widevine_cdm;
+  widevine_cdm.is_out_of_process = true;
+  widevine_cdm.path = path;
+  widevine_cdm.name = kWidevineCdmDisplayName;
+  widevine_cdm.description = kWidevineCdmDescription +
+                             std::string(" (version: ") +
+                             version + ")";
+  widevine_cdm.version = version;
+  content::WebPluginMimeType widevine_cdm_mime_type(
+      kWidevineCdmPluginMimeType,
+      kWidevineCdmPluginExtension,
+      kWidevineCdmPluginMimeTypeDescription);
+
+  // Add the supported codecs as if they came from the component manifest.
+  std::vector<std::string> codecs;
+  codecs.push_back(kCdmSupportedCodecVorbis);
+  codecs.push_back(kCdmSupportedCodecVp8);
+  codecs.push_back(kCdmSupportedCodecVp9);
+#if defined(USE_PROPRIETARY_CODECS)
+  codecs.push_back(kCdmSupportedCodecAac);
+  codecs.push_back(kCdmSupportedCodecAvc1);
+#endif  // defined(USE_PROPRIETARY_CODECS)
+  std::string codec_string = base::JoinString(
+      codecs, std::string(1, kCdmSupportedCodecsValueDelimiter));
+  widevine_cdm_mime_type.additional_param_names.push_back(
+      base::ASCIIToUTF16(kCdmSupportedCodecsParamName));
+  widevine_cdm_mime_type.additional_param_values.push_back(
+      base::ASCIIToUTF16(codec_string));
+
+  widevine_cdm.mime_types.push_back(widevine_cdm_mime_type);
+  widevine_cdm.permissions = kWidevineCdmPluginPermissions;
+
+  return widevine_cdm;
+}
+#endif
+
+void ConvertStringWithSeparatorToVector(std::vector<std::string>* vec,
+                                        const char* separator,
+                                        const char* cmd_switch) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto string_with_separator = command_line->GetSwitchValueASCII(cmd_switch);
+  if (!string_with_separator.empty())
+    *vec = base::SplitString(string_with_separator, separator,
+                             base::TRIM_WHITESPACE,
+                             base::SPLIT_WANT_NONEMPTY);
+}
+
+}  // namespace
+
+void AddPepperFlashFromCommandLine(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto flash_path = command_line->GetSwitchValueNative(
+      switches::kPpapiFlashPath);
+  if (flash_path.empty())
+    return;
+
+  auto flash_version = command_line->GetSwitchValueASCII(
+      switches::kPpapiFlashVersion);
+
+  plugins->push_back(
+      CreatePepperFlashInfo(base::FilePath(flash_path), flash_version));
+}
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+void AddWidevineCdmFromCommandLine(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto widevine_cdm_path = command_line->GetSwitchValueNative(
+      switches::kWidevineCdmPath);
+  if (widevine_cdm_path.empty())
+    return;
+
+  if (!base::PathExists(base::FilePath(widevine_cdm_path)))
+    return;
+
+  auto widevine_cdm_version = command_line->GetSwitchValueASCII(
+      switches::kWidevineCdmVersion);
+  if (widevine_cdm_version.empty())
+    return;
+
+  plugins->push_back(CreateWidevineCdmInfo(base::FilePath(widevine_cdm_path),
+                                           widevine_cdm_version));
+}
+#endif
+
+ElectronContentClient::ElectronContentClient() {
+}
+
+ElectronContentClient::~ElectronContentClient() {
+}
+
+std::string ElectronContentClient::GetProduct() const {
+  return "Chrome/" CHROME_VERSION_STRING;
+}
+
+std::string ElectronContentClient::GetUserAgent() const {
+  return content::BuildUserAgentFromProduct(
+      "Chrome/" CHROME_VERSION_STRING " "
+      ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING);
+}
+
+base::string16 ElectronContentClient::GetLocalizedString(int message_id) const {
+  return l10n_util::GetStringUTF16(message_id);
+}
+
+void ElectronContentClient::AddAdditionalSchemes(
+    std::vector<url::SchemeWithType>* standard_schemes,
+    std::vector<std::string>* savable_schemes) {
+  std::vector<std::string> schemes;
+  ConvertStringWithSeparatorToVector(&schemes, ",",
+                                     switches::kRegisterStandardSchemes);
+  if (!schemes.empty()) {
+    for (const std::string& scheme : schemes)
+      standard_schemes->push_back({scheme.c_str(), url::SCHEME_WITHOUT_PORT});
+  }
+  standard_schemes->push_back({"chrome-extension", url::SCHEME_WITHOUT_PORT});
+}
+
+void ElectronContentClient::AddPepperPlugins(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  AddPepperFlashFromCommandLine(plugins);
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+  AddWidevineCdmFromCommandLine(plugins);
+#endif
+}
+
+void ElectronContentClient::AddServiceWorkerSchemes(
+    std::set<std::string>* service_worker_schemes) {
+  std::vector<std::string> schemes;
+  ConvertStringWithSeparatorToVector(&schemes, ",",
+                                     switches::kRegisterServiceWorkerSchemes);
+  if (!schemes.empty()) {
+    for (const std::string& scheme : schemes)
+      service_worker_schemes->insert(scheme);
+  }
+  service_worker_schemes->insert(url::kFileScheme);
+}
+
+}  // namespace electron
added in remote
  their  100644 99d14289797ec4383023d85dfbd76b45560a3292 electron/app/electron_content_client.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
+#define ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "brightray/common/content_client.h"
+
+namespace electron {
+
+class ElectronContentClient : public brightray::ContentClient {
+ public:
+  ElectronContentClient();
+  virtual ~ElectronContentClient();
+
+ protected:
+  // content::ContentClient:
+  std::string GetProduct() const override;
+  std::string GetUserAgent() const override;
+  base::string16 GetLocalizedString(int message_id) const override;
+  void AddAdditionalSchemes(
+      std::vector<url::SchemeWithType>* standard_schemes,
+      std::vector<std::string>* savable_schemes) override;
+  void AddPepperPlugins(
+      std::vector<content::PepperPluginInfo>* plugins) override;
+  void AddServiceWorkerSchemes(
+      std::set<std::string>* service_worker_schemes) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronContentClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
added in remote
  their  100644 11f76e61e5f79ecc809c5e4dbaaa2905bcdda41f electron/app/electron_library_main.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
+#define ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
+
+#include "build/build_config.h"
+
+#if defined(OS_MACOSX)
+extern "C" {
+__attribute__((visibility("default")))
+int ElectronMain(int argc, const char* argv[]);
+
+__attribute__((visibility("default")))
+int ElectronInitializeICUandStartNode(int argc, char *argv[]);
+}
+#endif  // OS_MACOSX
+
+#endif  // ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
added in remote
  their  100644 98a72397e5fd3500c91085aefeb34f5d46b560e1 electron/app/electron_library_main.mm
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_library_main.h"
+
+#include "electron/app/electron_main_delegate.h"
+#include "electron/app/node_main.h"
+#include "electron/common/electron_command_line.h"
+#include "base/at_exit.h"
+#include "base/i18n/icu_util.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/scoped_nsautorelease_pool.h"
+#include "brightray/common/mac/main_application_bundle.h"
+#include "content/public/app/content_main.h"
+
+#if defined(OS_MACOSX)
+int ElectronMain(int argc, const char* argv[]) {
+  electron::ElectronMainDelegate delegate;
+  content::ContentMainParams params(&delegate);
+  params.argc = argc;
+  params.argv = argv;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+int ElectronInitializeICUandStartNode(int argc, char *argv[]) {
+  base::AtExitManager atexit_manager;
+  base::mac::ScopedNSAutoreleasePool pool;
+  base::mac::SetOverrideFrameworkBundlePath(
+      brightray::MainApplicationBundlePath()
+          .Append("Contents")
+          .Append("Frameworks")
+          .Append(ELECTRON_PRODUCT_NAME " Framework.framework"));
+  base::i18n::InitializeICU();
+  return electron::NodeMain(argc, argv);
+}
+#endif  // OS_MACOSX
added in remote
  their  100644 4d80e607c406e565986f2db25cf3d4952e613008 electron/app/electron_main.cc
@@ -0,0 +1,197 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main.h"
+
+#include <stdlib.h>
+
+#if defined(OS_WIN)
+#include <windows.h>
+#include <shellscalingapi.h>
+#include <tchar.h>
+#include <shellapi.h>
+
+#include "electron/app/electron_main_delegate.h"
+#include "electron/common/crash_reporter/win/crash_service_main.h"
+#include "base/environment.h"
+#include "base/win/windows_version.h"
+#include "content/public/app/sandbox_helper_win.h"
+#include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/dpi.h"
+#elif defined(OS_LINUX)  // defined(OS_WIN)
+#include "electron/app/electron_main_delegate.h"  // NOLINT
+#include "content/public/app/content_main.h"
+#else  // defined(OS_LINUX)
+#include "electron/app/electron_library_main.h"
+#endif  // defined(OS_MACOSX)
+
+#include "electron/app/node_main.h"
+#include "electron/common/electron_command_line.h"
+#include "base/at_exit.h"
+#include "base/i18n/icu_util.h"
+
+namespace {
+
+const char* kRunAsNode = "ELECTRON_RUN_AS_NODE";
+const char* kOldRunAsNode = "ATOM_SHELL_INTERNAL_RUN_AS_NODE";
+
+bool IsEnvSet(const char* name) {
+#if defined(OS_WIN)
+  size_t required_size;
+  getenv_s(&required_size, nullptr, 0, name);
+  return required_size != 0;
+#else
+  char* indicator = getenv(name);
+  return indicator && indicator[0] != '\0';
+#endif
+}
+
+bool IsRunAsNode() {
+  return IsEnvSet(kRunAsNode) || IsEnvSet(kOldRunAsNode);
+}
+
+#if defined(OS_WIN)
+// Win8.1 supports monitor-specific DPI scaling.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  typedef HRESULT(WINAPI *SetProcessDpiAwarenessPtr)(PROCESS_DPI_AWARENESS);
+  SetProcessDpiAwarenessPtr set_process_dpi_awareness_func =
+      reinterpret_cast<SetProcessDpiAwarenessPtr>(
+          GetProcAddress(GetModuleHandleA("user32.dll"),
+                         "SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr)) {
+      VLOG(1) << "SetProcessDpiAwareness succeeded.";
+      return true;
+    } else if (hr == E_ACCESSDENIED) {
+      LOG(ERROR) << "Access denied error from SetProcessDpiAwareness. "
+          "Function called twice, or manifest was used.";
+    }
+  }
+  return false;
+}
+
+// This function works for Windows Vista through Win8. Win8.1 must use
+// SetProcessDpiAwareness[Wrapper].
+BOOL SetProcessDPIAwareWrapper() {
+  typedef BOOL(WINAPI *SetProcessDPIAwarePtr)(VOID);
+  SetProcessDPIAwarePtr set_process_dpi_aware_func =
+      reinterpret_cast<SetProcessDPIAwarePtr>(
+      GetProcAddress(GetModuleHandleA("user32.dll"),
+                      "SetProcessDPIAware"));
+  return set_process_dpi_aware_func &&
+    set_process_dpi_aware_func();
+}
+
+void EnableHighDPISupport() {
+  if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
+    SetProcessDPIAwareWrapper();
+  }
+}
+#endif
+
+}  // namespace
+
+#if defined(OS_WIN)
+int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE, wchar_t* cmd, int) {
+  int argc = 0;
+  wchar_t** wargv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
+
+  // Make output work in console if we are not in cygiwn.
+  if (!IsEnvSet("TERM") && !IsEnvSet("ELECTRON_NO_ATTACH_CONSOLE")) {
+    AttachConsole(ATTACH_PARENT_PROCESS);
+
+    FILE* dontcare;
+    freopen_s(&dontcare, "CON", "w", stdout);
+    freopen_s(&dontcare, "CON", "w", stderr);
+  }
+
+  // Convert argv to to UTF8
+  char** argv = new char*[argc];
+  for (int i = 0; i < argc; i++) {
+    // Compute the size of the required buffer
+    DWORD size = WideCharToMultiByte(CP_UTF8,
+                                     0,
+                                     wargv[i],
+                                     -1,
+                                     NULL,
+                                     0,
+                                     NULL,
+                                     NULL);
+    if (size == 0) {
+      // This should never happen.
+      fprintf(stderr, "Could not convert arguments to utf8.");
+      exit(1);
+    }
+    // Do the actual conversion
+    argv[i] = new char[size];
+    DWORD result = WideCharToMultiByte(CP_UTF8,
+                                       0,
+                                       wargv[i],
+                                       -1,
+                                       argv[i],
+                                       size,
+                                       NULL,
+                                       NULL);
+    if (result == 0) {
+      // This should never happen.
+      fprintf(stderr, "Could not convert arguments to utf8.");
+      exit(1);
+    }
+  }
+
+  if (IsRunAsNode()) {
+    // Now that argv conversion is done, we can finally start.
+    base::AtExitManager atexit_manager;
+    base::i18n::InitializeICU();
+    return electron::NodeMain(argc, argv);
+  } else if (IsEnvSet("ELECTRON_INTERNAL_CRASH_SERVICE")) {
+    return crash_service::Main(cmd);
+  }
+
+  sandbox::SandboxInterfaceInfo sandbox_info = {0};
+  content::InitializeSandboxInfo(&sandbox_info);
+  electron::ElectronMainDelegate delegate;
+
+  // We don't want to set DPI awareness on pre-Win7 because we don't support
+  // DirectWrite there. GDI fonts are kerned very badly, so better to leave
+  // DPI-unaware and at effective 1.0. See also ShouldUseDirectWrite().
+  if (base::win::GetVersion() >= base::win::VERSION_WIN7)
+    EnableHighDPISupport();
+
+  content::ContentMainParams params(&delegate);
+  params.instance = instance;
+  params.sandbox_info = &sandbox_info;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+#elif defined(OS_LINUX)  // defined(OS_WIN)
+
+int main(int argc, const char* argv[]) {
+  if (IsRunAsNode()) {
+    base::i18n::InitializeICU();
+    base::AtExitManager atexit_manager;
+    return electron::NodeMain(argc, const_cast<char**>(argv));
+  }
+
+  electron::ElectronMainDelegate delegate;
+  content::ContentMainParams params(&delegate);
+  params.argc = argc;
+  params.argv = argv;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+#else  // defined(OS_LINUX)
+
+int main(int argc, const char* argv[]) {
+  if (IsRunAsNode()) {
+    return ElectronInitializeICUandStartNode(argc, const_cast<char**>(argv));
+  }
+
+  return ElectronMain(argc, argv);
+}
+
+#endif  // defined(OS_MACOSX)
added in remote
  their  100644 bd507a25b1658c5fce00b9371f205164c53a0aa5 electron/app/electron_main.h
@@ -0,0 +1,10 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_MAIN_H_
+#define ELECTRON_APP_ELECTRON_MAIN_H_
+
+#include "content/public/app/content_main.h"
+
+#endif  // ELECTRON_APP_ELECTRON_MAIN_H_
added in remote
  their  100644 32c3348a7e7a1adc1875185ec514cb42f5313aa9 electron/app/electron_main_delegate.cc
@@ -0,0 +1,141 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main_delegate.h"
+
+#include <string>
+#include <iostream>
+
+#include "electron/app/electron_content_client.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/common/google_api_key.h"
+#include "electron/renderer/electron_renderer_client.h"
+#include "electron/utility/electron_content_utility_client.h"
+#include "base/command_line.h"
+#include "base/debug/stack_trace.h"
+#include "base/environment.h"
+#include "base/logging.h"
+#include "chrome/common/chrome_paths.h"
+#include "content/public/common/content_switches.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace electron {
+
+namespace {
+
+bool IsBrowserProcess(base::CommandLine* cmd) {
+  std::string process_type = cmd->GetSwitchValueASCII(switches::kProcessType);
+  return process_type.empty();
+}
+
+}  // namespace
+
+ElectronMainDelegate::ElectronMainDelegate() {
+}
+
+ElectronMainDelegate::~ElectronMainDelegate() {
+}
+
+bool ElectronMainDelegate::BasicStartupComplete(int* exit_code) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  logging::LoggingSettings settings;
+#if defined(OS_WIN)
+  // On Windows the terminal returns immediately, so we add a new line to
+  // prevent output in the same line as the prompt.
+  if (IsBrowserProcess(command_line))
+    std::wcout << std::endl;
+#if defined(DEBUG)
+  // Print logging to debug.log on Windows
+  settings.logging_dest = logging::LOG_TO_ALL;
+  settings.log_file = L"debug.log";
+  settings.lock_log = logging::LOCK_LOG_FILE;
+  settings.delete_old = logging::DELETE_OLD_LOG_FILE;
+#else
+  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
+#endif  // defined(DEBUG)
+#else  // defined(OS_WIN)
+  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
+#endif  // !defined(OS_WIN)
+
+  // Only enable logging when --enable-logging is specified.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (!command_line->HasSwitch(switches::kEnableLogging) &&
+      !env->HasVar("ELECTRON_ENABLE_LOGGING")) {
+    settings.logging_dest = logging::LOG_NONE;
+    logging::SetMinLogLevel(logging::LOG_NUM_SEVERITIES);
+  }
+
+  logging::InitLogging(settings);
+
+  // Logging with pid and timestamp.
+  logging::SetLogItems(true, false, true, false);
+
+  // Enable convient stack printing.
+  bool enable_stack_dumping = env->HasVar("ELECTRON_ENABLE_STACK_DUMPING");
+#if defined(DEBUG) && defined(OS_LINUX)
+  enable_stack_dumping = true;
+#endif
+  if (enable_stack_dumping)
+    base::debug::EnableInProcessStackDumping();
+
+  chrome::RegisterPathProvider();
+
+  return brightray::MainDelegate::BasicStartupComplete(exit_code);
+}
+
+void ElectronMainDelegate::PreSandboxStartup() {
+  brightray::MainDelegate::PreSandboxStartup();
+
+  // Set google API key.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (!env->HasVar("GOOGLE_API_KEY"))
+    env->SetVar("GOOGLE_API_KEY", GOOGLEAPIS_API_KEY);
+
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  std::string process_type = command_line->GetSwitchValueASCII(
+      switches::kProcessType);
+
+  if (process_type == switches::kUtilityProcess) {
+    ElectronContentUtilityClient::PreSandboxStartup();
+  }
+
+  // Only append arguments for browser process.
+  if (!IsBrowserProcess(command_line))
+    return;
+
+  // Disable renderer sandbox for most of node's functions.
+  command_line->AppendSwitch(switches::kNoSandbox);
+
+  // Allow file:// URIs to read other file:// URIs by default.
+  command_line->AppendSwitch(switches::kAllowFileAccessFromFiles);
+
+#if defined(OS_MACOSX)
+  // Enable AVFoundation.
+  command_line->AppendSwitch("enable-avfoundation");
+#endif
+}
+
+content::ContentBrowserClient* ElectronMainDelegate::CreateContentBrowserClient() {
+  browser_client_.reset(new ElectronBrowserClient);
+  return browser_client_.get();
+}
+
+content::ContentRendererClient*
+    ElectronMainDelegate::CreateContentRendererClient() {
+  renderer_client_.reset(new ElectronRendererClient);
+  return renderer_client_.get();
+}
+
+content::ContentUtilityClient* ElectronMainDelegate::CreateContentUtilityClient() {
+  utility_client_.reset(new ElectronContentUtilityClient);
+  return utility_client_.get();
+}
+
+scoped_ptr<brightray::ContentClient> ElectronMainDelegate::CreateContentClient() {
+  return scoped_ptr<brightray::ContentClient>(new ElectronContentClient);
+}
+
+}  // namespace electron
added in remote
  their  100644 1068c65e3cc41e6a63f9b95133ef138e5c479709 electron/app/electron_main_delegate.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
+#define ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
+
+#include "brightray/common/main_delegate.h"
+#include "brightray/common/content_client.h"
+
+namespace electron {
+
+class ElectronMainDelegate : public brightray::MainDelegate {
+ public:
+  ElectronMainDelegate();
+  ~ElectronMainDelegate();
+
+ protected:
+  // content::ContentMainDelegate:
+  bool BasicStartupComplete(int* exit_code) override;
+  void PreSandboxStartup() override;
+  content::ContentBrowserClient* CreateContentBrowserClient() override;
+  content::ContentRendererClient* CreateContentRendererClient() override;
+  content::ContentUtilityClient* CreateContentUtilityClient() override;
+
+  // brightray::MainDelegate:
+  scoped_ptr<brightray::ContentClient> CreateContentClient() override;
+#if defined(OS_MACOSX)
+  void OverrideChildProcessPath() override;
+  void OverrideFrameworkBundlePath() override;
+#endif
+
+ private:
+  brightray::ContentClient content_client_;
+  scoped_ptr<content::ContentBrowserClient> browser_client_;
+  scoped_ptr<content::ContentRendererClient> renderer_client_;
+  scoped_ptr<content::ContentUtilityClient> utility_client_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronMainDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
added in remote
  their  100644 aa6f2abae3e60da0e132fa07c9b529be49255d60 electron/app/electron_main_delegate_mac.mm
@@ -0,0 +1,51 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main_delegate.h"
+
+#include "base/mac/bundle_locations.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+#include "brightray/common/application_info.h"
+#include "brightray/common/mac/main_application_bundle.h"
+#include "content/public/common/content_paths.h"
+
+namespace electron {
+
+namespace {
+
+base::FilePath GetFrameworksPath() {
+  return brightray::MainApplicationBundlePath().Append("Contents")
+                                               .Append("Frameworks");
+}
+
+base::FilePath GetHelperAppPath(const base::FilePath& frameworks_path,
+                                const std::string& name) {
+  return frameworks_path.Append(name + " Helper.app")
+                        .Append("Contents")
+                        .Append("MacOS")
+                        .Append(name + " Helper");
+}
+
+}  // namespace
+
+void ElectronMainDelegate::OverrideFrameworkBundlePath() {
+  base::mac::SetOverrideFrameworkBundlePath(
+      GetFrameworksPath().Append(ELECTRON_PRODUCT_NAME " Framework.framework"));
+}
+
+void ElectronMainDelegate::OverrideChildProcessPath() {
+  base::FilePath frameworks_path = GetFrameworksPath();
+  base::FilePath helper_path = GetHelperAppPath(frameworks_path,
+                                                ELECTRON_PRODUCT_NAME);
+  if (!base::PathExists(helper_path))
+    helper_path = GetHelperAppPath(frameworks_path,
+                                   brightray::GetApplicationName());
+  if (!base::PathExists(helper_path))
+    LOG(FATAL) << "Unable to find helper app";
+  PathService::Override(content::CHILD_PROCESS_EXE, helper_path);
+}
+
+}  // namespace electron
added in remote
  their  100644 10bab4e16a7f69d175b62550044261dc255230b9 electron/app/node_main.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/node_main.h"
+
+#include "electron/app/uv_task_runner.h"
+#include "electron/browser/javascript_environment.h"
+#include "electron/browser/node_debugger.h"
+#include "base/command_line.h"
+#include "electron/common/node_includes.h"
+#include "base/thread_task_runner_handle.h"
+#include "gin/array_buffer.h"
+#include "gin/public/isolate_holder.h"
+#include "gin/v8_initializer.h"
+
+namespace electron {
+
+int NodeMain(int argc, char *argv[]) {
+  base::CommandLine::Init(argc, argv);
+
+  int exit_code = 1;
+  {
+    // Feed gin::PerIsolateData with a task runner.
+    argv = uv_setup_args(argc, argv);
+    uv_loop_t* loop = uv_default_loop();
+    scoped_refptr<UvTaskRunner> uv_task_runner(new UvTaskRunner(loop));
+    base::ThreadTaskRunnerHandle handle(uv_task_runner);
+
+    gin::V8Initializer::LoadV8Snapshot();
+    gin::V8Initializer::LoadV8Natives();
+    JavascriptEnvironment gin_env;
+
+    int exec_argc;
+    const char** exec_argv;
+    node::Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);
+
+    node::Environment* env = node::CreateEnvironment(
+        gin_env.isolate(), loop, gin_env.context(), argc, argv,
+        exec_argc, exec_argv);
+
+    // Start our custom debugger implementation.
+    NodeDebugger node_debugger(gin_env.isolate());
+    if (node_debugger.IsRunning())
+      env->AssignToContext(v8::Debug::GetDebugContext());
+
+    node::LoadEnvironment(env);
+
+    bool more;
+    do {
+      more = uv_run(env->event_loop(), UV_RUN_ONCE);
+      if (more == false) {
+        node::EmitBeforeExit(env);
+
+        // Emit `beforeExit` if the loop became alive either after emitting
+        // event, or after running some callbacks.
+        more = uv_loop_alive(env->event_loop());
+        if (uv_run(env->event_loop(), UV_RUN_NOWAIT) != 0)
+          more = true;
+      }
+    } while (more == true);
+
+    exit_code = node::EmitExit(env);
+    node::RunAtExit(env);
+
+    env->Dispose();
+  }
+
+  v8::V8::Dispose();
+
+  return exit_code;
+}
+
+}  // namespace electron
added in remote
  their  100644 98a39687267f0b30cc54f96049c9954a42b69d0b electron/app/node_main.h
@@ -0,0 +1,14 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_NODE_MAIN_H_
+#define ELECTRON_APP_NODE_MAIN_H_
+
+namespace electron {
+
+int NodeMain(int argc, char *argv[]);
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_NODE_MAIN_H_
added in remote
  their  100644 4d7bb75e3f31a716bf61cbd7ed4ff42ea0ba7edc electron/app/uv_task_runner.cc
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/uv_task_runner.h"
+
+#include "base/stl_util.h"
+
+namespace electron {
+
+UvTaskRunner::UvTaskRunner(uv_loop_t* loop) : loop_(loop) {
+}
+
+UvTaskRunner::~UvTaskRunner() {
+  for (auto& iter : tasks_) {
+    uv_unref(reinterpret_cast<uv_handle_t*>(iter.first));
+    delete iter.first;
+  }
+}
+
+bool UvTaskRunner::PostDelayedTask(const tracked_objects::Location& from_here,
+                                   const base::Closure& task,
+                                   base::TimeDelta delay) {
+  uv_timer_t* timer = new uv_timer_t;
+  timer->data = this;
+  uv_timer_init(loop_, timer);
+  uv_timer_start(timer, UvTaskRunner::OnTimeout, delay.InMilliseconds(), 0);
+  tasks_[timer] = task;
+  return true;
+}
+
+bool UvTaskRunner::RunsTasksOnCurrentThread() const {
+  return true;
+}
+
+bool UvTaskRunner::PostNonNestableDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  return PostDelayedTask(from_here, task, delay);
+}
+
+// static
+void UvTaskRunner::OnTimeout(uv_timer_t* timer) {
+  UvTaskRunner* self = static_cast<UvTaskRunner*>(timer->data);
+  if (!ContainsKey(self->tasks_, timer))
+    return;
+
+  self->tasks_[timer].Run();
+  self->tasks_.erase(timer);
+  uv_timer_stop(timer);
+  uv_close(reinterpret_cast<uv_handle_t*>(timer), UvTaskRunner::OnClose);
+}
+
+// static
+void UvTaskRunner::OnClose(uv_handle_t* handle) {
+  delete reinterpret_cast<uv_timer_t*>(handle);
+}
+
+}  // namespace electron
added in remote
  their  100644 668836682f0378a05dffe16bf49da255a1c2ea19 electron/app/uv_task_runner.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_UV_TASK_RUNNER_H_
+#define ELECTRON_APP_UV_TASK_RUNNER_H_
+
+#include <map>
+
+#include "base/callback.h"
+#include "base/single_thread_task_runner.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// TaskRunner implementation that posts tasks into libuv's default loop.
+class UvTaskRunner : public base::SingleThreadTaskRunner {
+ public:
+  explicit UvTaskRunner(uv_loop_t* loop);
+  ~UvTaskRunner() override;
+
+  // base::SingleThreadTaskRunner:
+  bool PostDelayedTask(const tracked_objects::Location& from_here,
+                       const base::Closure& task,
+                       base::TimeDelta delay) override;
+  bool RunsTasksOnCurrentThread() const override;
+  bool PostNonNestableDelayedTask(
+      const tracked_objects::Location& from_here,
+      const base::Closure& task,
+      base::TimeDelta delay) override;
+
+ private:
+  static void OnTimeout(uv_timer_t* timer);
+  static void OnClose(uv_handle_t* handle);
+
+  uv_loop_t* loop_;
+
+  std::map<uv_timer_t*, base::Closure> tasks_;
+
+  DISALLOW_COPY_AND_ASSIGN(UvTaskRunner);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_UV_TASK_RUNNER_H_
added in remote
  their  100644 4ac19bcf4ce6d96a815d2825bccead9d3b2cabb7 electron/browser/api/electron_api_app.cc
@@ -0,0 +1,472 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_app.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/api/electron_api_session.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/login_handler.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "brightray/browser/brightray_paths.h"
+#include "chrome/common/chrome_paths.h"
+#include "content/public/browser/client_certificate_delegate.h"
+#include "content/public/browser/gpu_data_manager.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/common/content_switches.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/ssl/ssl_cert_request_info.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/image/image.h"
+
+#if defined(OS_WIN)
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/win/shell.h"
+#endif
+
+using electron::Browser;
+
+namespace mate {
+
+#if defined(OS_WIN)
+template<>
+struct Converter<Browser::UserTask> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     Browser::UserTask* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    if (!dict.Get("program", &(out->program)) ||
+        !dict.Get("title", &(out->title)))
+      return false;
+    if (dict.Get("iconPath", &(out->icon_path)) &&
+        !dict.Get("iconIndex", &(out->icon_index)))
+      return false;
+    dict.Get("arguments", &(out->arguments));
+    dict.Get("description", &(out->description));
+    return true;
+  }
+};
+#endif
+
+}  // namespace mate
+
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Return the path constant from string.
+int GetPathConstant(const std::string& name) {
+  if (name == "appData")
+    return brightray::DIR_APP_DATA;
+  else if (name == "userData")
+    return brightray::DIR_USER_DATA;
+  else if (name == "cache")
+    return brightray::DIR_CACHE;
+  else if (name == "userCache")
+    return brightray::DIR_USER_CACHE;
+  else if (name == "home")
+    return base::DIR_HOME;
+  else if (name == "temp")
+    return base::DIR_TEMP;
+  else if (name == "userDesktop" || name == "desktop")
+    return base::DIR_USER_DESKTOP;
+  else if (name == "exe")
+    return base::FILE_EXE;
+  else if (name == "module")
+    return base::FILE_MODULE;
+  else if (name == "documents")
+    return chrome::DIR_USER_DOCUMENTS;
+  else if (name == "downloads")
+    return chrome::DIR_DEFAULT_DOWNLOADS;
+  else if (name == "music")
+    return chrome::DIR_USER_MUSIC;
+  else if (name == "pictures")
+    return chrome::DIR_USER_PICTURES;
+  else if (name == "videos")
+    return chrome::DIR_USER_VIDEOS;
+  else
+    return -1;
+}
+
+bool NotificationCallbackWrapper(
+    const ProcessSingleton::NotificationCallback& callback,
+    const base::CommandLine::StringVector& cmd,
+    const base::FilePath& cwd) {
+  // Make sure the callback is called after app gets ready.
+  if (Browser::Get()->is_ready()) {
+    callback.Run(cmd, cwd);
+  } else {
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner(
+        base::ThreadTaskRunnerHandle::Get());
+    task_runner->PostTask(
+        FROM_HERE, base::Bind(base::IgnoreResult(callback), cmd, cwd));
+  }
+  // ProcessSingleton needs to know whether current process is quiting.
+  return !Browser::Get()->is_shutting_down();
+}
+
+void OnClientCertificateSelected(
+    v8::Isolate* isolate,
+    std::shared_ptr<content::ClientCertificateDelegate> delegate,
+    mate::Arguments* args) {
+  mate::Dictionary cert_data;
+  if (!args->GetNext(&cert_data)) {
+    args->ThrowError();
+    return;
+  }
+
+  v8::Local<v8::Object> data;
+  if (!cert_data.Get("data", &data))
+    return;
+
+  auto certs = net::X509Certificate::CreateCertificateListFromBytes(
+      node::Buffer::Data(data), node::Buffer::Length(data),
+      net::X509Certificate::FORMAT_AUTO);
+  if (certs.size() > 0)
+    delegate->ContinueWithCertificate(certs[0].get());
+}
+
+void PassLoginInformation(scoped_refptr<LoginHandler> login_handler,
+                          mate::Arguments* args) {
+  base::string16 username, password;
+  if (args->GetNext(&username) && args->GetNext(&password))
+    login_handler->Login(username, password);
+  else
+    login_handler->CancelAuth();
+}
+
+}  // namespace
+
+App::App() {
+  static_cast<ElectronBrowserClient*>(ElectronBrowserClient::Get())->set_delegate(this);
+  Browser::Get()->AddObserver(this);
+  content::GpuDataManager::GetInstance()->AddObserver(this);
+}
+
+App::~App() {
+  static_cast<ElectronBrowserClient*>(ElectronBrowserClient::Get())->set_delegate(
+      nullptr);
+  Browser::Get()->RemoveObserver(this);
+  content::GpuDataManager::GetInstance()->RemoveObserver(this);
+}
+
+void App::OnBeforeQuit(bool* prevent_default) {
+  *prevent_default = Emit("before-quit");
+}
+
+void App::OnWillQuit(bool* prevent_default) {
+  *prevent_default = Emit("will-quit");
+}
+
+void App::OnWindowAllClosed() {
+  Emit("window-all-closed");
+}
+
+void App::OnQuit() {
+  int exitCode = ElectronBrowserMainParts::Get()->GetExitCode();
+  Emit("quit", exitCode);
+
+  if (process_singleton_.get()) {
+    process_singleton_->Cleanup();
+    process_singleton_.reset();
+  }
+}
+
+void App::OnOpenFile(bool* prevent_default, const std::string& file_path) {
+  *prevent_default = Emit("open-file", file_path);
+}
+
+void App::OnOpenURL(const std::string& url) {
+  Emit("open-url", url);
+}
+
+void App::OnActivate(bool has_visible_windows) {
+  Emit("activate", has_visible_windows);
+}
+
+void App::OnWillFinishLaunching() {
+  Emit("will-finish-launching");
+}
+
+void App::OnFinishLaunching() {
+  Emit("ready");
+}
+
+void App::OnLogin(LoginHandler* login_handler) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  bool prevent_default = Emit(
+      "login",
+      WebContents::CreateFrom(isolate(), login_handler->GetWebContents()),
+      login_handler->request(),
+      login_handler->auth_info(),
+      base::Bind(&PassLoginInformation, make_scoped_refptr(login_handler)));
+
+  // Default behavior is to always cancel the auth.
+  if (!prevent_default)
+    login_handler->CancelAuth();
+}
+
+void App::AllowCertificateError(
+    content::WebContents* web_contents,
+    int cert_error,
+    const net::SSLInfo& ssl_info,
+    const GURL& request_url,
+    content::ResourceType resource_type,
+    bool overridable,
+    bool strict_enforcement,
+    bool expired_previous_decision,
+    const base::Callback<void(bool)>& callback,
+    content::CertificateRequestResultType* request) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  bool prevent_default = Emit("certificate-error",
+                              WebContents::CreateFrom(isolate(), web_contents),
+                              request_url,
+                              net::ErrorToString(cert_error),
+                              ssl_info.cert,
+                              callback);
+
+  // Deny the certificate by default.
+  if (!prevent_default)
+    *request = content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY;
+}
+
+void App::SelectClientCertificate(
+    content::WebContents* web_contents,
+    net::SSLCertRequestInfo* cert_request_info,
+    scoped_ptr<content::ClientCertificateDelegate> delegate) {
+  std::shared_ptr<content::ClientCertificateDelegate>
+      shared_delegate(delegate.release());
+  bool prevent_default =
+      Emit("select-client-certificate",
+           WebContents::CreateFrom(isolate(), web_contents),
+           cert_request_info->host_and_port.ToString(),
+           cert_request_info->client_certs,
+           base::Bind(&OnClientCertificateSelected,
+                      isolate(),
+                      shared_delegate));
+
+  // Default to first certificate from the platform store.
+  if (!prevent_default)
+    shared_delegate->ContinueWithCertificate(
+        cert_request_info->client_certs[0].get());
+}
+
+void App::OnGpuProcessCrashed(base::TerminationStatus exit_code) {
+  Emit("gpu-process-crashed");
+}
+
+#if defined(OS_MACOSX)
+void App::OnPlatformThemeChanged() {
+  Emit("platform-theme-changed");
+}
+#endif
+
+base::FilePath App::GetPath(mate::Arguments* args, const std::string& name) {
+  bool succeed = false;
+  base::FilePath path;
+  int key = GetPathConstant(name);
+  if (key >= 0)
+    succeed = PathService::Get(key, &path);
+  if (!succeed)
+    args->ThrowError("Failed to get path");
+  return path;
+}
+
+void App::SetPath(mate::Arguments* args,
+                  const std::string& name,
+                  const base::FilePath& path) {
+  bool succeed = false;
+  int key = GetPathConstant(name);
+  if (key >= 0)
+    succeed = PathService::Override(key, path);
+  if (!succeed)
+    args->ThrowError("Failed to set path");
+}
+
+void App::SetDesktopName(const std::string& desktop_name) {
+#if defined(OS_LINUX)
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  env->SetVar("CHROME_DESKTOP", desktop_name);
+#endif
+}
+
+void App::AllowNTLMCredentialsForAllDomains(bool should_allow) {
+  auto browser_context = static_cast<ElectronBrowserContext*>(
+        ElectronBrowserMainParts::Get()->browser_context());
+  browser_context->AllowNTLMCredentialsForAllDomains(should_allow);
+}
+
+std::string App::GetLocale() {
+  return l10n_util::GetApplicationLocale("");
+}
+
+#if defined(OS_WIN)
+bool App::IsAeroGlassEnabled() {
+  return ui::win::IsAeroGlassEnabled();
+}
+#endif
+
+bool App::MakeSingleInstance(
+    const ProcessSingleton::NotificationCallback& callback) {
+  if (process_singleton_.get())
+    return false;
+
+  base::FilePath user_dir;
+  PathService::Get(brightray::DIR_USER_DATA, &user_dir);
+  process_singleton_.reset(new ProcessSingleton(
+      user_dir, base::Bind(NotificationCallbackWrapper, callback)));
+
+  switch (process_singleton_->NotifyOtherProcessOrCreate()) {
+    case ProcessSingleton::NotifyResult::LOCK_ERROR:
+    case ProcessSingleton::NotifyResult::PROFILE_IN_USE:
+    case ProcessSingleton::NotifyResult::PROCESS_NOTIFIED:
+      process_singleton_.reset();
+      return true;
+    case ProcessSingleton::NotifyResult::PROCESS_NONE:
+    default:  // Shouldn't be needed, but VS warns if it is not there.
+      return false;
+  }
+}
+
+mate::ObjectTemplateBuilder App::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  auto browser = base::Unretained(Browser::Get());
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("quit", base::Bind(&Browser::Quit, browser))
+      .SetMethod("exit", base::Bind(&Browser::Exit, browser))
+      .SetMethod("focus", base::Bind(&Browser::Focus, browser))
+      .SetMethod("getVersion", base::Bind(&Browser::GetVersion, browser))
+      .SetMethod("setVersion", base::Bind(&Browser::SetVersion, browser))
+      .SetMethod("getName", base::Bind(&Browser::GetName, browser))
+      .SetMethod("setName", base::Bind(&Browser::SetName, browser))
+      .SetMethod("isReady", base::Bind(&Browser::is_ready, browser))
+      .SetMethod("addRecentDocument",
+                 base::Bind(&Browser::AddRecentDocument, browser))
+      .SetMethod("clearRecentDocuments",
+                 base::Bind(&Browser::ClearRecentDocuments, browser))
+      .SetMethod("setAppUserModelId",
+                 base::Bind(&Browser::SetAppUserModelID, browser))
+      .SetMethod("setAsDefaultProtocolClient",
+                 base::Bind(&Browser::SetAsDefaultProtocolClient, browser))
+      .SetMethod("removeAsDefaultProtocolClient",
+                 base::Bind(&Browser::RemoveAsDefaultProtocolClient, browser))
+#if defined(OS_MACOSX)
+      .SetMethod("hide", base::Bind(&Browser::Hide, browser))
+      .SetMethod("show", base::Bind(&Browser::Show, browser))
+      .SetMethod("isDarkMode",
+                 base::Bind(&Browser::IsDarkMode, browser))
+#endif
+#if defined(OS_WIN)
+      .SetMethod("setUserTasks",
+                 base::Bind(&Browser::SetUserTasks, browser))
+      .SetMethod("isAeroGlassEnabled", &App::IsAeroGlassEnabled)
+#endif
+      .SetMethod("setPath", &App::SetPath)
+      .SetMethod("getPath", &App::GetPath)
+      .SetMethod("setDesktopName", &App::SetDesktopName)
+      .SetMethod("allowNTLMCredentialsForAllDomains",
+                 &App::AllowNTLMCredentialsForAllDomains)
+      .SetMethod("getLocale", &App::GetLocale)
+      .SetMethod("makeSingleInstance", &App::MakeSingleInstance);
+}
+
+// static
+mate::Handle<App> App::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new App);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void AppendSwitch(const std::string& switch_string, mate::Arguments* args) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  if (switch_string == electron::switches::kPpapiFlashPath ||
+      switch_string == electron::switches::kClientCertificate ||
+      switch_string == switches::kLogNetLog) {
+    base::FilePath path;
+    args->GetNext(&path);
+    command_line->AppendSwitchPath(switch_string, path);
+    return;
+  }
+
+  std::string value;
+  if (args->GetNext(&value))
+    command_line->AppendSwitchASCII(switch_string, value);
+  else
+    command_line->AppendSwitch(switch_string);
+}
+
+#if defined(OS_MACOSX)
+int DockBounce(const std::string& type) {
+  int request_id = -1;
+  if (type == "critical")
+    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_CRITICAL);
+  else if (type == "informational")
+    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_INFORMATIONAL);
+  return request_id;
+}
+
+void DockSetMenu(electron::api::Menu* menu) {
+  Browser::Get()->DockSetMenu(menu->model());
+}
+#endif
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("app", electron::api::App::Create(isolate));
+  dict.SetMethod("appendSwitch", &AppendSwitch);
+  dict.SetMethod("appendArgument",
+                 base::Bind(&base::CommandLine::AppendArg,
+                            base::Unretained(command_line)));
+#if defined(OS_MACOSX)
+  auto browser = base::Unretained(Browser::Get());
+  dict.SetMethod("dockBounce", &DockBounce);
+  dict.SetMethod("dockCancelBounce",
+                 base::Bind(&Browser::DockCancelBounce, browser));
+  dict.SetMethod("dockSetBadgeText",
+                 base::Bind(&Browser::DockSetBadgeText, browser));
+  dict.SetMethod("dockGetBadgeText",
+                 base::Bind(&Browser::DockGetBadgeText, browser));
+  dict.SetMethod("dockHide", base::Bind(&Browser::DockHide, browser));
+  dict.SetMethod("dockShow", base::Bind(&Browser::DockShow, browser));
+  dict.SetMethod("dockSetMenu", &DockSetMenu);
+  dict.SetMethod("dockSetIcon", base::Bind(&Browser::DockSetIcon, browser));
+#endif
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_app, Initialize)
added in remote
  their  100644 a824d4b4ecea505eb572bdb97a3577b37e82d119 electron/browser/api/electron_api_app.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
+
+#include <string>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/browser_observer.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "chrome/browser/process_singleton.h"
+#include "content/public/browser/gpu_data_manager_observer.h"
+#include "native_mate/handle.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class App : public ElectronBrowserClient::Delegate,
+            public mate::EventEmitter,
+            public BrowserObserver,
+            public content::GpuDataManagerObserver {
+ public:
+  static mate::Handle<App> Create(v8::Isolate* isolate);
+
+ protected:
+  App();
+  virtual ~App();
+
+  // BrowserObserver:
+  void OnBeforeQuit(bool* prevent_default) override;
+  void OnWillQuit(bool* prevent_default) override;
+  void OnWindowAllClosed() override;
+  void OnQuit() override;
+  void OnOpenFile(bool* prevent_default, const std::string& file_path) override;
+  void OnOpenURL(const std::string& url) override;
+  void OnActivate(bool has_visible_windows) override;
+  void OnWillFinishLaunching() override;
+  void OnFinishLaunching() override;
+  void OnLogin(LoginHandler* login_handler) override;
+
+  // content::ContentBrowserClient:
+  void AllowCertificateError(
+      content::WebContents* web_contents,
+      int cert_error,
+      const net::SSLInfo& ssl_info,
+      const GURL& request_url,
+      content::ResourceType resource_type,
+      bool overridable,
+      bool strict_enforcement,
+      bool expired_previous_decision,
+      const base::Callback<void(bool)>& callback,
+      content::CertificateRequestResultType* request) override;
+  void SelectClientCertificate(
+      content::WebContents* web_contents,
+      net::SSLCertRequestInfo* cert_request_info,
+      scoped_ptr<content::ClientCertificateDelegate> delegate) override;
+
+  // content::GpuDataManagerObserver:
+  void OnGpuProcessCrashed(base::TerminationStatus exit_code) override;
+
+#if defined(OS_MACOSX)
+  void OnPlatformThemeChanged() override;
+#endif
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  // Get/Set the pre-defined path in PathService.
+  base::FilePath GetPath(mate::Arguments* args, const std::string& name);
+  void SetPath(mate::Arguments* args,
+               const std::string& name,
+               const base::FilePath& path);
+
+  void SetDesktopName(const std::string& desktop_name);
+  void AllowNTLMCredentialsForAllDomains(bool should_allow);
+  bool MakeSingleInstance(
+      const ProcessSingleton::NotificationCallback& callback);
+  std::string GetLocale();
+
+#if defined(OS_WIN)
+  bool IsAeroGlassEnabled();
+#endif
+
+  scoped_ptr<ProcessSingleton> process_singleton_;
+
+  DISALLOW_COPY_AND_ASSIGN(App);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
added in remote
  their  100644 2de74a2077d1ba9104dab6200d1b9d06e00cd2df electron/browser/api/electron_api_auto_updater.cc
@@ -0,0 +1,124 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_auto_updater.h"
+
+#include "base/time/time.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::Time> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::Time& val) {
+    v8::MaybeLocal<v8::Value> date = v8::Date::New(
+        isolate->GetCurrentContext(), val.ToJsTime());
+    if (date.IsEmpty())
+      return v8::Null(isolate);
+    else
+      return date.ToLocalChecked();
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+AutoUpdater::AutoUpdater() {
+  auto_updater::AutoUpdater::SetDelegate(this);
+}
+
+AutoUpdater::~AutoUpdater() {
+  auto_updater::AutoUpdater::SetDelegate(nullptr);
+}
+
+void AutoUpdater::OnError(const std::string& message) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
+  EmitCustomEvent(
+      "error",
+      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked(),
+      // Message is also emitted to keep compatibility with old code.
+      message);
+}
+
+void AutoUpdater::OnCheckingForUpdate() {
+  Emit("checking-for-update");
+}
+
+void AutoUpdater::OnUpdateAvailable() {
+  Emit("update-available");
+}
+
+void AutoUpdater::OnUpdateNotAvailable() {
+  Emit("update-not-available");
+}
+
+void AutoUpdater::OnUpdateDownloaded(const std::string& release_notes,
+                                     const std::string& release_name,
+                                     const base::Time& release_date,
+                                     const std::string& url) {
+  Emit("update-downloaded", release_notes, release_name, release_date, url,
+       // Keep compatibility with old APIs.
+       base::Bind(&AutoUpdater::QuitAndInstall, base::Unretained(this)));
+}
+
+void AutoUpdater::OnWindowAllClosed() {
+  QuitAndInstall();
+}
+
+mate::ObjectTemplateBuilder AutoUpdater::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("setFeedURL", &auto_updater::AutoUpdater::SetFeedURL)
+      .SetMethod("checkForUpdates", &auto_updater::AutoUpdater::CheckForUpdates)
+      .SetMethod("quitAndInstall", &AutoUpdater::QuitAndInstall);
+}
+
+void AutoUpdater::QuitAndInstall() {
+  // If we don't have any window then quitAndInstall immediately.
+  WindowList* window_list = WindowList::GetInstance();
+  if (window_list->size() == 0) {
+    auto_updater::AutoUpdater::QuitAndInstall();
+    return;
+  }
+
+  // Otherwise do the restart after all windows have been closed.
+  window_list->AddObserver(this);
+  for (NativeWindow* window : *window_list)
+    window->Close();
+}
+
+// static
+mate::Handle<AutoUpdater> AutoUpdater::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new AutoUpdater);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("autoUpdater", electron::api::AutoUpdater::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_auto_updater, Initialize)
added in remote
  their  100644 cd9960f6a563774735fd25ecbb21eec3033d7383 electron/browser/api/electron_api_auto_updater.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
+
+#include <string>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/browser/auto_updater.h"
+#include "electron/browser/window_list_observer.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class AutoUpdater : public mate::EventEmitter,
+                    public auto_updater::Delegate,
+                    public WindowListObserver {
+ public:
+  static mate::Handle<AutoUpdater> Create(v8::Isolate* isolate);
+
+ protected:
+  AutoUpdater();
+  virtual ~AutoUpdater();
+
+  // Delegate implementations.
+  void OnError(const std::string& error) override;
+  void OnCheckingForUpdate() override;
+  void OnUpdateAvailable() override;
+  void OnUpdateNotAvailable() override;
+  void OnUpdateDownloaded(const std::string& release_notes,
+                          const std::string& release_name,
+                          const base::Time& release_date,
+                          const std::string& update_url) override;
+
+  // WindowListObserver:
+  void OnWindowAllClosed() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  void QuitAndInstall();
+
+  DISALLOW_COPY_AND_ASSIGN(AutoUpdater);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
added in remote
  their  100644 3a2fb346beaa5eba580aa644b8aa35228388074c electron/browser/api/electron_api_content_tracing.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <set>
+#include <string>
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "content/public/browser/tracing_controller.h"
+#include "native_mate/dictionary.h"
+
+using content::TracingController;
+
+namespace mate {
+
+template<>
+struct Converter<base::trace_event::TraceConfig> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::trace_event::TraceConfig* out) {
+    Dictionary options;
+    if (!ConvertFromV8(isolate, val, &options))
+      return false;
+    std::string category_filter, trace_options;
+    if (!options.Get("categoryFilter", &category_filter) ||
+        !options.Get("traceOptions", &trace_options))
+      return false;
+    *out = base::trace_event::TraceConfig(category_filter, trace_options);
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+using CompletionCallback = base::Callback<void(const base::FilePath&)>;
+
+scoped_refptr<TracingController::TraceDataSink> GetTraceDataSink(
+    const base::FilePath& path, const CompletionCallback& callback) {
+  base::FilePath result_file_path = path;
+  if (result_file_path.empty() && !base::CreateTemporaryFile(&result_file_path))
+    LOG(ERROR) << "Creating temporary file failed";
+
+  return TracingController::CreateFileSink(result_file_path,
+                                           base::Bind(callback,
+                                                      result_file_path));
+}
+
+void StopRecording(const base::FilePath& path,
+                   const CompletionCallback& callback) {
+  TracingController::GetInstance()->StopTracing(
+      GetTraceDataSink(path, callback));
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  auto controller = base::Unretained(TracingController::GetInstance());
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("getCategories", base::Bind(
+      &TracingController::GetCategories, controller));
+  dict.SetMethod("startRecording", base::Bind(
+      &TracingController::StartTracing, controller));
+  dict.SetMethod("stopRecording", &StopRecording);
+  dict.SetMethod("getTraceBufferUsage", base::Bind(
+      &TracingController::GetTraceBufferUsage, controller));
+  dict.SetMethod("setWatchEvent", base::Bind(
+      &TracingController::SetWatchEvent, controller));
+  dict.SetMethod("cancelWatchEvent", base::Bind(
+      &TracingController::CancelWatchEvent, controller));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_content_tracing, Initialize)
added in remote
  their  100644 8974d7492b6fb85ea50539c0cc79297c8050de41 electron/browser/api/electron_api_cookies.cc
@@ -0,0 +1,240 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_cookies.h"
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "base/time/time.h"
+#include "base/values.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/cookies/cookie_monster.h"
+#include "net/cookies/cookie_store.h"
+#include "net/cookies/cookie_util.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_context_getter.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+template<>
+struct Converter<electron::api::Cookies::Error> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   electron::api::Cookies::Error val) {
+    if (val == electron::api::Cookies::SUCCESS)
+      return v8::Null(isolate);
+    else
+      return v8::Exception::Error(StringToV8(isolate, "failed"));
+  }
+};
+
+template<>
+struct Converter<net::CanonicalCookie> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::CanonicalCookie& val) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("name", val.Name());
+    dict.Set("value", val.Value());
+    dict.Set("domain", val.Domain());
+    dict.Set("hostOnly", net::cookie_util::DomainIsHostOnly(val.Domain()));
+    dict.Set("path", val.Path());
+    dict.Set("secure", val.IsSecure());
+    dict.Set("httpOnly", val.IsHttpOnly());
+    dict.Set("session", !val.IsPersistent());
+    if (!val.IsPersistent())
+      dict.Set("expirationDate", val.ExpiryDate().ToDoubleT());
+    return dict.GetHandle();
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Returns whether |domain| matches |filter|.
+bool MatchesDomain(std::string filter, const std::string& domain) {
+  // Add a leading '.' character to the filter domain if it doesn't exist.
+  if (net::cookie_util::DomainIsHostOnly(filter))
+    filter.insert(0, ".");
+
+  std::string sub_domain(domain);
+  // Strip any leading '.' character from the input cookie domain.
+  if (!net::cookie_util::DomainIsHostOnly(sub_domain))
+    sub_domain = sub_domain.substr(1);
+
+  // Now check whether the domain argument is a subdomain of the filter domain.
+  for (sub_domain.insert(0, "."); sub_domain.length() >= filter.length();) {
+    if (sub_domain == filter)
+      return true;
+    const size_t next_dot = sub_domain.find('.', 1);  // Skip over leading dot.
+    sub_domain.erase(0, next_dot);
+  }
+  return false;
+}
+
+// Returns whether |cookie| matches |filter|.
+bool MatchesCookie(const base::DictionaryValue* filter,
+                   const net::CanonicalCookie& cookie) {
+  std::string str;
+  bool b;
+  if (filter->GetString("name", &str) && str != cookie.Name())
+    return false;
+  if (filter->GetString("path", &str) && str != cookie.Path())
+    return false;
+  if (filter->GetString("domain", &str) && !MatchesDomain(str, cookie.Domain()))
+    return false;
+  if (filter->GetBoolean("secure", &b) && b != cookie.IsSecure())
+    return false;
+  if (filter->GetBoolean("session", &b) && b != !cookie.IsPersistent())
+    return false;
+  return true;
+}
+
+// Helper to returns the CookieStore.
+inline net::CookieStore* GetCookieStore(
+    scoped_refptr<net::URLRequestContextGetter> getter) {
+  return getter->GetURLRequestContext()->cookie_store();
+}
+
+// Run |callback| on UI thread.
+void RunCallbackInUI(const base::Closure& callback) {
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
+}
+
+// Remove cookies from |list| not matching |filter|, and pass it to |callback|.
+void FilterCookies(scoped_ptr<base::DictionaryValue> filter,
+                   const Cookies::GetCallback& callback,
+                   const net::CookieList& list) {
+  net::CookieList result;
+  for (const auto& cookie : list) {
+    if (MatchesCookie(filter.get(), cookie))
+      result.push_back(cookie);
+  }
+  RunCallbackInUI(base::Bind(callback, Cookies::SUCCESS, result));
+}
+
+// Receives cookies matching |filter| in IO thread.
+void GetCookiesOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                    scoped_ptr<base::DictionaryValue> filter,
+                    const Cookies::GetCallback& callback) {
+  std::string url;
+  filter->GetString("url", &url);
+
+  auto filtered_callback =
+      base::Bind(FilterCookies, base::Passed(&filter), callback);
+
+  net::CookieMonster* monster = GetCookieStore(getter)->GetCookieMonster();
+  // Empty url will match all url cookies.
+  if (url.empty())
+    monster->GetAllCookiesAsync(filtered_callback);
+  else
+    monster->GetAllCookiesForURLAsync(GURL(url), filtered_callback);
+}
+
+// Removes cookie with |url| and |name| in IO thread.
+void RemoveCookieOnIOThread(scoped_refptr<net::URLRequestContextGetter> getter,
+                            const GURL& url, const std::string& name,
+                            const base::Closure& callback) {
+  GetCookieStore(getter)->DeleteCookieAsync(
+      url, name, base::Bind(RunCallbackInUI, callback));
+}
+
+// Callback of SetCookie.
+void OnSetCookie(const Cookies::SetCallback& callback, bool success) {
+  RunCallbackInUI(
+      base::Bind(callback, success ? Cookies::SUCCESS : Cookies::FAILED));
+}
+
+// Sets cookie with |details| in IO thread.
+void SetCookieOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                   scoped_ptr<base::DictionaryValue> details,
+                   const Cookies::SetCallback& callback) {
+  std::string url, name, value, domain, path;
+  bool secure = false;
+  bool http_only = false;
+  double expiration_date;
+  details->GetString("url", &url);
+  details->GetString("name", &name);
+  details->GetString("value", &value);
+  details->GetString("domain", &domain);
+  details->GetString("path", &path);
+  details->GetBoolean("secure", &secure);
+  details->GetBoolean("httpOnly", &http_only);
+
+  base::Time expiration_time;
+  if (details->GetDouble("expirationDate", &expiration_date)) {
+    expiration_time = (expiration_date == 0) ?
+        base::Time::UnixEpoch() :
+        base::Time::FromDoubleT(expiration_date);
+  }
+
+  GetCookieStore(getter)->GetCookieMonster()->SetCookieWithDetailsAsync(
+      GURL(url), name, value, domain, path, expiration_time, secure, http_only,
+      false, false, false, net::COOKIE_PRIORITY_DEFAULT,
+      base::Bind(OnSetCookie, callback));
+}
+
+}  // namespace
+
+Cookies::Cookies(content::BrowserContext* browser_context)
+    : request_context_getter_(browser_context->GetRequestContext()) {
+}
+
+Cookies::~Cookies() {
+}
+
+void Cookies::Get(const base::DictionaryValue& filter,
+                  const GetCallback& callback) {
+  scoped_ptr<base::DictionaryValue> copied(filter.CreateDeepCopy());
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(GetCookiesOnIO, getter, Passed(&copied), callback));
+}
+
+void Cookies::Remove(const GURL& url, const std::string& name,
+                     const base::Closure& callback) {
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(RemoveCookieOnIOThread, getter, url, name, callback));
+}
+
+void Cookies::Set(const base::DictionaryValue& details,
+                  const SetCallback& callback) {
+  scoped_ptr<base::DictionaryValue> copied(details.CreateDeepCopy());
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(SetCookieOnIO, getter, Passed(&copied), callback));
+}
+
+// static
+mate::Handle<Cookies> Cookies::Create(
+    v8::Isolate* isolate,
+    content::BrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new Cookies(browser_context));
+}
+
+// static
+void Cookies::BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("get", &Cookies::Get)
+      .SetMethod("remove", &Cookies::Remove)
+      .SetMethod("set", &Cookies::Set);
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 196f4576fe6c837eab191f92eee39f9879779dd0 electron/browser/api/electron_api_cookies.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "native_mate/handle.h"
+#include "net/cookies/canonical_cookie.h"
+
+namespace base {
+class DictionaryValue;
+}
+
+namespace content {
+class BrowserContext;
+}
+
+namespace net {
+class URLRequestContextGetter;
+}
+
+namespace electron {
+
+namespace api {
+
+class Cookies : public mate::TrackableObject<Cookies> {
+ public:
+  enum Error {
+    SUCCESS,
+    FAILED,
+  };
+
+  using GetCallback = base::Callback<void(Error, const net::CookieList&)>;
+  using SetCallback = base::Callback<void(Error)>;
+
+  static mate::Handle<Cookies> Create(v8::Isolate* isolate,
+                                      content::BrowserContext* browser_context);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Cookies(content::BrowserContext* browser_context);
+  ~Cookies();
+
+  void Get(const base::DictionaryValue& filter, const GetCallback& callback);
+  void Remove(const GURL& url, const std::string& name,
+              const base::Closure& callback);
+  void Set(const base::DictionaryValue& details, const SetCallback& callback);
+
+ private:
+  net::URLRequestContextGetter* request_context_getter_;
+
+  DISALLOW_COPY_AND_ASSIGN(Cookies);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
added in remote
  their  100644 8721a8cb7299ddf611b5f543a9a834b8c8a22439 electron/browser/api/electron_api_debugger.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_debugger.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/json/json_reader.h"
+#include "base/json/json_writer.h"
+#include "content/public/browser/devtools_agent_host.h"
+#include "content/public/browser/web_contents.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+using content::DevToolsAgentHost;
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapDebugger funtion which is implemented in JavaScript.
+using WrapDebuggerCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapDebuggerCallback g_wrap_debugger;
+
+}  // namespace
+
+Debugger::Debugger(content::WebContents* web_contents)
+    : web_contents_(web_contents),
+      previous_request_id_(0) {
+}
+
+Debugger::~Debugger() {
+}
+
+void Debugger::AgentHostClosed(DevToolsAgentHost* agent_host,
+                               bool replaced_with_another_client) {
+  std::string detach_reason = "target closed";
+  if (replaced_with_another_client)
+    detach_reason = "replaced with devtools";
+  Emit("detach", detach_reason);
+}
+
+void Debugger::DispatchProtocolMessage(DevToolsAgentHost* agent_host,
+                                       const std::string& message) {
+  DCHECK(agent_host == agent_host_.get());
+
+  scoped_ptr<base::Value> parsed_message(base::JSONReader::Read(message));
+  if (!parsed_message->IsType(base::Value::TYPE_DICTIONARY))
+    return;
+
+  base::DictionaryValue* dict =
+      static_cast<base::DictionaryValue*>(parsed_message.get());
+  int id;
+  if (!dict->GetInteger("id", &id)) {
+    std::string method;
+    if (!dict->GetString("method", &method))
+      return;
+    base::DictionaryValue* params_value = nullptr;
+    base::DictionaryValue params;
+    if (dict->GetDictionary("params", &params_value))
+      params.Swap(params_value);
+    Emit("message", method, params);
+  } else {
+    auto send_command_callback = pending_requests_[id];
+    pending_requests_.erase(id);
+    if (send_command_callback.is_null())
+      return;
+    base::DictionaryValue* error_body = nullptr;
+    base::DictionaryValue error;
+    if (dict->GetDictionary("error", &error_body))
+      error.Swap(error_body);
+
+    base::DictionaryValue* result_body = nullptr;
+    base::DictionaryValue result;
+    if (dict->GetDictionary("result", &result_body))
+      result.Swap(result_body);
+    send_command_callback.Run(error, result);
+  }
+}
+
+void Debugger::Attach(mate::Arguments* args) {
+  std::string protocol_version;
+  args->GetNext(&protocol_version);
+
+  if (!protocol_version.empty() &&
+      !DevToolsAgentHost::IsSupportedProtocolVersion(protocol_version)) {
+    args->ThrowError("Requested protocol version is not supported");
+    return;
+  }
+  agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents_);
+  if (!agent_host_.get()) {
+    args->ThrowError("No target available");
+    return;
+  }
+  if (agent_host_->IsAttached()) {
+    args->ThrowError("Another debugger is already attached to this target");
+    return;
+  }
+
+  agent_host_->AttachClient(this);
+}
+
+bool Debugger::IsAttached() {
+  return agent_host_.get() ? agent_host_->IsAttached() : false;
+}
+
+void Debugger::Detach() {
+  if (!agent_host_.get())
+    return;
+  agent_host_->DetachClient();
+  AgentHostClosed(agent_host_.get(), false);
+  agent_host_ = nullptr;
+}
+
+void Debugger::SendCommand(mate::Arguments* args) {
+  if (!agent_host_.get())
+    return;
+
+  std::string method;
+  if (!args->GetNext(&method)) {
+    args->ThrowError();
+    return;
+  }
+  base::DictionaryValue command_params;
+  args->GetNext(&command_params);
+  SendCommandCallback callback;
+  args->GetNext(&callback);
+
+  base::DictionaryValue request;
+  int request_id = ++previous_request_id_;
+  pending_requests_[request_id] = callback;
+  request.SetInteger("id", request_id);
+  request.SetString("method", method);
+  if (!command_params.empty())
+    request.Set("params", command_params.DeepCopy());
+
+  std::string json_args;
+  base::JSONWriter::Write(request, &json_args);
+  agent_host_->DispatchProtocolMessage(json_args);
+}
+
+// static
+mate::Handle<Debugger> Debugger::Create(
+    v8::Isolate* isolate,
+    content::WebContents* web_contents) {
+  auto handle = mate::CreateHandle(isolate, new Debugger(web_contents));
+  g_wrap_debugger.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+void Debugger::BuildPrototype(v8::Isolate* isolate,
+                              v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("attach", &Debugger::Attach)
+      .SetMethod("isAttached", &Debugger::IsAttached)
+      .SetMethod("detach", &Debugger::Detach)
+      .SetMethod("sendCommand", &Debugger::SendCommand);
+}
+
+void ClearWrapDebugger() {
+  g_wrap_debugger.Reset();
+}
+
+void SetWrapDebugger(const WrapDebuggerCallback& callback) {
+  g_wrap_debugger = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapDebugger));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("_setWrapDebugger", &electron::api::SetWrapDebugger);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_debugger, Initialize);
added in remote
  their  100644 5822573d3b1fd06dcba088a990f1fb0537050c9a electron/browser/api/electron_api_debugger.h
@@ -0,0 +1,75 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
+
+#include <map>
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "base/values.h"
+#include "content/public/browser/devtools_agent_host_client.h"
+#include "native_mate/handle.h"
+
+namespace content {
+class DevToolsAgentHost;
+class WebContents;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class Debugger: public mate::TrackableObject<Debugger>,
+                public content::DevToolsAgentHostClient {
+ public:
+  using SendCommandCallback =
+      base::Callback<void(const base::DictionaryValue&,
+                          const base::DictionaryValue&)>;
+
+  static mate::Handle<Debugger> Create(
+      v8::Isolate* isolate, content::WebContents* web_contents);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Debugger(content::WebContents* web_contents);
+  ~Debugger();
+
+  // content::DevToolsAgentHostClient:
+  void AgentHostClosed(content::DevToolsAgentHost* agent_host,
+                       bool replaced_with_another_client) override;
+  void DispatchProtocolMessage(content::DevToolsAgentHost* agent_host,
+                               const std::string& message) override;
+
+ private:
+  using PendingRequestMap = std::map<int, SendCommandCallback>;
+
+  void Attach(mate::Arguments* args);
+  bool IsAttached();
+  void Detach();
+  void SendCommand(mate::Arguments* args);
+
+  content::WebContents* web_contents_;  // Weak Reference.
+  scoped_refptr<content::DevToolsAgentHost> agent_host_;
+
+  PendingRequestMap pending_requests_;
+  int previous_request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(Debugger);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
added in remote
  their  100644 18c562e8951d0da6eb37f20b0a513e8c2be2a8b9 electron/browser/api/electron_api_desktop_capturer.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_desktop_capturer.h"
+
+#include "electron/common/api/electron_api_native_image.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/media/desktop_media_list.h"
+#include "native_mate/dictionary.h"
+#include "third_party/webrtc/modules/desktop_capture/desktop_capture_options.h"
+#include "third_party/webrtc/modules/desktop_capture/screen_capturer.h"
+#include "third_party/webrtc/modules/desktop_capture/window_capturer.h"
+
+#include "electron/common/node_includes.h"
+
+namespace mate {
+
+template<>
+struct Converter<DesktopMediaList::Source> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const DesktopMediaList::Source& source) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    content::DesktopMediaID id = source.id;
+    dict.Set("name", base::UTF16ToUTF8(source.name));
+    dict.Set("id", id.ToString());
+    dict.Set(
+        "thumbnail",
+        electron::api::NativeImage::Create(isolate, gfx::Image(source.thumbnail)));
+    return ConvertToV8(isolate, dict);
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+DesktopCapturer::DesktopCapturer() {
+}
+
+DesktopCapturer::~DesktopCapturer() {
+}
+
+void DesktopCapturer::StartHandling(bool capture_window,
+                                    bool capture_screen,
+                                    const gfx::Size& thumbnail_size) {
+  webrtc::DesktopCaptureOptions options =
+      webrtc::DesktopCaptureOptions::CreateDefault();
+
+#if defined(OS_WIN)
+  // On windows, desktop effects (e.g. Aero) will be disabled when the Desktop
+  // capture API is active by default.
+  // We keep the desktop effects in most times. Howerver, the screen still
+  // fickers when the API is capturing the window due to limitation of current
+  // implemetation. This is a known and wontFix issue in webrtc (see:
+  // http://code.google.com/p/webrtc/issues/detail?id=3373)
+  options.set_disable_effects(false);
+#endif
+
+  scoped_ptr<webrtc::ScreenCapturer> screen_capturer(
+      capture_screen ? webrtc::ScreenCapturer::Create(options) : nullptr);
+  scoped_ptr<webrtc::WindowCapturer> window_capturer(
+      capture_window ? webrtc::WindowCapturer::Create(options) : nullptr);
+  media_list_.reset(new NativeDesktopMediaList(
+      std::move(screen_capturer), std::move(window_capturer)));
+
+  media_list_->SetThumbnailSize(thumbnail_size);
+  media_list_->StartUpdating(this);
+}
+
+void DesktopCapturer::OnSourceAdded(int index) {
+}
+
+void DesktopCapturer::OnSourceRemoved(int index) {
+}
+
+void DesktopCapturer::OnSourceMoved(int old_index, int new_index) {
+}
+
+void DesktopCapturer::OnSourceNameChanged(int index) {
+}
+
+void DesktopCapturer::OnSourceThumbnailChanged(int index) {
+}
+
+bool DesktopCapturer::OnRefreshFinished() {
+  Emit("finished", media_list_->GetSources());
+  media_list_.reset();
+  return false;
+}
+
+mate::ObjectTemplateBuilder DesktopCapturer::GetObjectTemplateBuilder(
+      v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("startHandling", &DesktopCapturer::StartHandling);
+}
+
+// static
+mate::Handle<DesktopCapturer> DesktopCapturer::Create(v8::Isolate* isolate) {
+  return mate::CreateHandle(isolate, new DesktopCapturer);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("desktopCapturer", electron::api::DesktopCapturer::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_desktop_capturer, Initialize);
added in remote
  their  100644 c70348207224d0e370348d10cbe662cf3777dda9 electron/browser/api/electron_api_desktop_capturer.h
@@ -0,0 +1,52 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
+
+#include "electron/browser/api/event_emitter.h"
+#include "chrome/browser/media/desktop_media_list_observer.h"
+#include "chrome/browser/media/native_desktop_media_list.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class DesktopCapturer: public mate::EventEmitter,
+                       public DesktopMediaListObserver {
+ public:
+  static mate::Handle<DesktopCapturer> Create(v8::Isolate* isolate);
+
+  void StartHandling(bool capture_window,
+                     bool capture_screen,
+                     const gfx::Size& thumbnail_size);
+
+ protected:
+  DesktopCapturer();
+  ~DesktopCapturer();
+
+  // DesktopMediaListObserver overrides.
+  void OnSourceAdded(int index) override;
+  void OnSourceRemoved(int index) override;
+  void OnSourceMoved(int old_index, int new_index) override;
+  void OnSourceNameChanged(int index) override;
+  void OnSourceThumbnailChanged(int index) override;
+  bool OnRefreshFinished() override;
+
+ private:
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+  scoped_ptr<DesktopMediaList> media_list_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopCapturer);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
added in remote
  their  100644 61e362f0eb861141de4ca58dc2e45b8cd7e6b6b4 electron/browser/api/electron_api_dialog.cc
@@ -0,0 +1,120 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "electron/browser/ui/message_box.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+namespace mate {
+
+template<>
+struct Converter<file_dialog::Filter> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     file_dialog::Filter* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    if (!dict.Get("name", &(out->first)))
+      return false;
+    if (!dict.Get("extensions", &(out->second)))
+      return false;
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+void ShowMessageBox(int type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  electron::MessageBoxCallback callback;
+  if (mate::Converter<electron::MessageBoxCallback>::FromV8(args->isolate(),
+                                                        peek,
+                                                        &callback)) {
+    electron::ShowMessageBox(window, (electron::MessageBoxType)type, buttons,
+                         default_id, cancel_id, options, title,
+                         message, detail, icon, callback);
+  } else {
+    int chosen = electron::ShowMessageBox(window, (electron::MessageBoxType)type,
+                                      buttons, default_id, cancel_id,
+                                      options, title, message, detail, icon);
+    args->Return(chosen);
+  }
+}
+
+void ShowOpenDialog(const std::string& title,
+                    const base::FilePath& default_path,
+                    const file_dialog::Filters& filters,
+                    int properties,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  file_dialog::OpenDialogCallback callback;
+  if (mate::Converter<file_dialog::OpenDialogCallback>::FromV8(args->isolate(),
+                                                               peek,
+                                                               &callback)) {
+    file_dialog::ShowOpenDialog(window, title, default_path, filters,
+                                properties, callback);
+  } else {
+    std::vector<base::FilePath> paths;
+    if (file_dialog::ShowOpenDialog(window, title, default_path, filters,
+                                    properties, &paths))
+      args->Return(paths);
+  }
+}
+
+void ShowSaveDialog(const std::string& title,
+                    const base::FilePath& default_path,
+                    const file_dialog::Filters& filters,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  file_dialog::SaveDialogCallback callback;
+  if (mate::Converter<file_dialog::SaveDialogCallback>::FromV8(args->isolate(),
+                                                               peek,
+                                                               &callback)) {
+    file_dialog::ShowSaveDialog(window, title, default_path, filters, callback);
+  } else {
+    base::FilePath path;
+    if (file_dialog::ShowSaveDialog(window, title, default_path, filters,
+                                    &path))
+      args->Return(path);
+  }
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("showMessageBox", &ShowMessageBox);
+  dict.SetMethod("showErrorBox", &electron::ShowErrorBox);
+  dict.SetMethod("showOpenDialog", &ShowOpenDialog);
+  dict.SetMethod("showSaveDialog", &ShowSaveDialog);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_dialog, Initialize)
added in remote
  their  100644 7e6db9f7152cbe1c1e7f83d8c649eafdc2796ba6 electron/browser/api/electron_api_download_item.cc
@@ -0,0 +1,212 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_download_item.h"
+
+#include <map>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/memory/linked_ptr.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "native_mate/dictionary.h"
+#include "net/base/filename_util.h"
+
+namespace mate {
+
+template<>
+struct Converter<content::DownloadItem::DownloadState> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::DownloadItem::DownloadState state) {
+    std::string download_state;
+    switch (state) {
+      case content::DownloadItem::COMPLETE:
+        download_state = "completed";
+        break;
+      case content::DownloadItem::CANCELLED:
+        download_state = "cancelled";
+        break;
+      case content::DownloadItem::INTERRUPTED:
+        download_state = "interrupted";
+        break;
+      default:
+        break;
+    }
+    return ConvertToV8(isolate, download_state);
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapDownloadItem funtion which is implemented in JavaScript
+using WrapDownloadItemCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapDownloadItemCallback g_wrap_download_item;
+
+std::map<uint32_t, linked_ptr<v8::Global<v8::Value>>> g_download_item_objects;
+
+}  // namespace
+
+DownloadItem::DownloadItem(content::DownloadItem* download_item)
+    : download_item_(download_item) {
+  download_item_->AddObserver(this);
+  AttachAsUserData(download_item);
+}
+
+DownloadItem::~DownloadItem() {
+  if (download_item_) {
+    // Destroyed by either garbage collection or destroy().
+    download_item_->RemoveObserver(this);
+    download_item_->Remove();
+  }
+
+  // Remove from the global map.
+  auto iter = g_download_item_objects.find(weak_map_id());
+  if (iter != g_download_item_objects.end())
+    g_download_item_objects.erase(iter);
+}
+
+void DownloadItem::OnDownloadUpdated(content::DownloadItem* item) {
+  if (download_item_->IsDone()) {
+    Emit("done", item->GetState());
+
+    // Destroy the item once item is downloaded.
+    base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+  } else {
+    Emit("updated");
+  }
+}
+
+void DownloadItem::OnDownloadDestroyed(content::DownloadItem* download_item) {
+  download_item_ = nullptr;
+  // Destroy the native class immediately when downloadItem is destroyed.
+  delete this;
+}
+
+void DownloadItem::Pause() {
+  download_item_->Pause();
+}
+
+void DownloadItem::Resume() {
+  download_item_->Resume();
+}
+
+void DownloadItem::Cancel() {
+  download_item_->Cancel(true);
+  download_item_->Remove();
+}
+
+int64_t DownloadItem::GetReceivedBytes() const {
+  return download_item_->GetReceivedBytes();
+}
+
+int64_t DownloadItem::GetTotalBytes() const {
+  return download_item_->GetTotalBytes();
+}
+
+std::string DownloadItem::GetMimeType() const {
+  return download_item_->GetMimeType();
+}
+
+bool DownloadItem::HasUserGesture() const {
+  return download_item_->HasUserGesture();
+}
+
+std::string DownloadItem::GetFilename() const {
+  return base::UTF16ToUTF8(net::GenerateFileName(GetURL(),
+                           GetContentDisposition(),
+                           std::string(),
+                           download_item_->GetSuggestedFilename(),
+                           GetMimeType(),
+                           std::string()).LossyDisplayName());
+}
+
+std::string DownloadItem::GetContentDisposition() const {
+  return download_item_->GetContentDisposition();
+}
+
+const GURL& DownloadItem::GetURL() const {
+  return download_item_->GetURL();
+}
+
+void DownloadItem::SetSavePath(const base::FilePath& path) {
+  save_path_ = path;
+}
+
+base::FilePath DownloadItem::GetSavePath() const {
+  return save_path_;
+}
+
+// static
+void DownloadItem::BuildPrototype(v8::Isolate* isolate,
+                                  v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("pause", &DownloadItem::Pause)
+      .SetMethod("resume", &DownloadItem::Resume)
+      .SetMethod("cancel", &DownloadItem::Cancel)
+      .SetMethod("getReceivedBytes", &DownloadItem::GetReceivedBytes)
+      .SetMethod("getTotalBytes", &DownloadItem::GetTotalBytes)
+      .SetMethod("getMimeType", &DownloadItem::GetMimeType)
+      .SetMethod("hasUserGesture", &DownloadItem::HasUserGesture)
+      .SetMethod("getFilename", &DownloadItem::GetFilename)
+      .SetMethod("getContentDisposition", &DownloadItem::GetContentDisposition)
+      .SetMethod("getURL", &DownloadItem::GetURL)
+      .SetMethod("setSavePath", &DownloadItem::SetSavePath)
+      .SetMethod("getSavePath", &DownloadItem::GetSavePath);
+}
+
+// static
+mate::Handle<DownloadItem> DownloadItem::Create(
+    v8::Isolate* isolate, content::DownloadItem* item) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, item);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<DownloadItem*>(existing));
+
+  auto handle = mate::CreateHandle(isolate, new DownloadItem(item));
+  g_wrap_download_item.Run(handle.ToV8());
+
+  // Reference this object in case it got garbage collected.
+  g_download_item_objects[handle->weak_map_id()] = make_linked_ptr(
+      new v8::Global<v8::Value>(isolate, handle.ToV8()));
+  return handle;
+}
+
+void ClearWrapDownloadItem() {
+  g_wrap_download_item.Reset();
+}
+
+void SetWrapDownloadItem(const WrapDownloadItemCallback& callback) {
+  g_wrap_download_item = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapDownloadItem));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("_setWrapDownloadItem", &electron::api::SetWrapDownloadItem);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_download_item, Initialize);
added in remote
  their  100644 d9afc825c22553224e5865f7171bbfc490cb3f78 electron/browser/api/electron_api_download_item.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/files/file_path.h"
+#include "content/public/browser/download_item.h"
+#include "native_mate/handle.h"
+#include "url/gurl.h"
+
+namespace electron {
+
+namespace api {
+
+class DownloadItem : public mate::TrackableObject<DownloadItem>,
+                     public content::DownloadItem::Observer {
+ public:
+  static mate::Handle<DownloadItem> Create(v8::Isolate* isolate,
+                                           content::DownloadItem* item);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+  void Pause();
+  void Resume();
+  void Cancel();
+  int64_t GetReceivedBytes() const;
+  int64_t GetTotalBytes() const;
+  std::string GetMimeType() const;
+  bool HasUserGesture() const;
+  std::string GetFilename() const;
+  std::string GetContentDisposition() const;
+  const GURL& GetURL() const;
+  void SetSavePath(const base::FilePath& path);
+  base::FilePath GetSavePath() const;
+
+ protected:
+  explicit DownloadItem(content::DownloadItem* download_item);
+  ~DownloadItem();
+
+  // Override content::DownloadItem::Observer methods
+  void OnDownloadUpdated(content::DownloadItem* download) override;
+  void OnDownloadDestroyed(content::DownloadItem* download) override;
+
+ private:
+  base::FilePath save_path_;
+  content::DownloadItem* download_item_;
+
+  DISALLOW_COPY_AND_ASSIGN(DownloadItem);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
added in remote
  their  100644 d2be70b1a5f282279671d8864f864e9712bcb955 electron/browser/api/electron_api_global_shortcut.cc
@@ -0,0 +1,98 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_global_shortcut.h"
+
+#include <string>
+
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "base/stl_util.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+using extensions::GlobalShortcutListener;
+
+namespace electron {
+
+namespace api {
+
+GlobalShortcut::GlobalShortcut() {
+}
+
+GlobalShortcut::~GlobalShortcut() {
+  UnregisterAll();
+}
+
+void GlobalShortcut::OnKeyPressed(const ui::Accelerator& accelerator) {
+  if (accelerator_callback_map_.find(accelerator) ==
+      accelerator_callback_map_.end()) {
+    // This should never occur, because if it does, GlobalGlobalShortcutListener
+    // notifes us with wrong accelerator.
+    NOTREACHED();
+    return;
+  }
+  accelerator_callback_map_[accelerator].Run();
+}
+
+bool GlobalShortcut::Register(const ui::Accelerator& accelerator,
+                              const base::Closure& callback) {
+  if (!GlobalShortcutListener::GetInstance()->RegisterAccelerator(
+      accelerator, this)) {
+    return false;
+  }
+
+  accelerator_callback_map_[accelerator] = callback;
+  return true;
+}
+
+void GlobalShortcut::Unregister(const ui::Accelerator& accelerator) {
+  if (!ContainsKey(accelerator_callback_map_, accelerator))
+    return;
+
+  accelerator_callback_map_.erase(accelerator);
+  GlobalShortcutListener::GetInstance()->UnregisterAccelerator(
+      accelerator, this);
+}
+
+bool GlobalShortcut::IsRegistered(const ui::Accelerator& accelerator) {
+  return ContainsKey(accelerator_callback_map_, accelerator);
+}
+
+void GlobalShortcut::UnregisterAll() {
+  accelerator_callback_map_.clear();
+  GlobalShortcutListener::GetInstance()->UnregisterAccelerators(this);
+}
+
+mate::ObjectTemplateBuilder GlobalShortcut::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("register", &GlobalShortcut::Register)
+      .SetMethod("isRegistered", &GlobalShortcut::IsRegistered)
+      .SetMethod("unregister", &GlobalShortcut::Unregister)
+      .SetMethod("unregisterAll", &GlobalShortcut::UnregisterAll);
+}
+
+// static
+mate::Handle<GlobalShortcut> GlobalShortcut::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new GlobalShortcut);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("globalShortcut", electron::api::GlobalShortcut::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_global_shortcut, Initialize)
added in remote
  their  100644 48021f8fd15833886e717d0fc435e5428a78b9a4 electron/browser/api/electron_api_global_shortcut.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
+
+#include <map>
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+#include "native_mate/handle.h"
+#include "ui/base/accelerators/accelerator.h"
+
+namespace electron {
+
+namespace api {
+
+class GlobalShortcut : public extensions::GlobalShortcutListener::Observer,
+                       public mate::TrackableObject<GlobalShortcut> {
+ public:
+  static mate::Handle<GlobalShortcut> Create(v8::Isolate* isolate);
+
+ protected:
+  GlobalShortcut();
+  ~GlobalShortcut() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  typedef std::map<ui::Accelerator, base::Closure> AcceleratorCallbackMap;
+
+  bool Register(const ui::Accelerator& accelerator,
+                const base::Closure& callback);
+  bool IsRegistered(const ui::Accelerator& accelerator);
+  void Unregister(const ui::Accelerator& accelerator);
+  void UnregisterAll();
+
+  // GlobalShortcutListener::Observer implementation.
+  void OnKeyPressed(const ui::Accelerator& accelerator) override;
+
+  AcceleratorCallbackMap accelerator_callback_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcut);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
added in remote
  their  100644 6e2a3c3f80f176e7673b12b7d44640419db149de electron/browser/api/electron_api_menu.cc
@@ -0,0 +1,199 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_menu.h"
+
+#include "electron/browser/native_window.h"
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+Menu::Menu()
+    : model_(new ElectronMenuModel(this)),
+      parent_(NULL) {
+}
+
+Menu::~Menu() {
+}
+
+void Menu::AfterInit(v8::Isolate* isolate) {
+  mate::Dictionary wrappable(isolate, GetWrapper(isolate));
+  mate::Dictionary delegate;
+  if (!wrappable.Get("delegate", &delegate))
+    return;
+
+  delegate.Get("isCommandIdChecked", &is_checked_);
+  delegate.Get("isCommandIdEnabled", &is_enabled_);
+  delegate.Get("isCommandIdVisible", &is_visible_);
+  delegate.Get("getAcceleratorForCommandId", &get_accelerator_);
+  delegate.Get("executeCommand", &execute_command_);
+  delegate.Get("menuWillShow", &menu_will_show_);
+}
+
+bool Menu::IsCommandIdChecked(int command_id) const {
+  return is_checked_.Run(command_id);
+}
+
+bool Menu::IsCommandIdEnabled(int command_id) const {
+  return is_enabled_.Run(command_id);
+}
+
+bool Menu::IsCommandIdVisible(int command_id) const {
+  return is_visible_.Run(command_id);
+}
+
+bool Menu::GetAcceleratorForCommandId(int command_id,
+                                      ui::Accelerator* accelerator) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  v8::Local<v8::Value> val = get_accelerator_.Run(command_id);
+  return mate::ConvertFromV8(isolate(), val, accelerator);
+}
+
+void Menu::ExecuteCommand(int command_id, int event_flags) {
+  execute_command_.Run(command_id);
+}
+
+void Menu::MenuWillShow(ui::SimpleMenuModel* source) {
+  menu_will_show_.Run();
+}
+
+void Menu::InsertItemAt(
+    int index, int command_id, const base::string16& label) {
+  model_->InsertItemAt(index, command_id, label);
+}
+
+void Menu::InsertSeparatorAt(int index) {
+  model_->InsertSeparatorAt(index, ui::NORMAL_SEPARATOR);
+}
+
+void Menu::InsertCheckItemAt(int index,
+                             int command_id,
+                             const base::string16& label) {
+  model_->InsertCheckItemAt(index, command_id, label);
+}
+
+void Menu::InsertRadioItemAt(int index,
+                             int command_id,
+                             const base::string16& label,
+                             int group_id) {
+  model_->InsertRadioItemAt(index, command_id, label, group_id);
+}
+
+void Menu::InsertSubMenuAt(int index,
+                           int command_id,
+                           const base::string16& label,
+                           Menu* menu) {
+  menu->parent_ = this;
+  model_->InsertSubMenuAt(index, command_id, label, menu->model_.get());
+}
+
+void Menu::SetIcon(int index, const gfx::Image& image) {
+  model_->SetIcon(index, image);
+}
+
+void Menu::SetSublabel(int index, const base::string16& sublabel) {
+  model_->SetSublabel(index, sublabel);
+}
+
+void Menu::SetRole(int index, const base::string16& role) {
+  model_->SetRole(index, role);
+}
+
+void Menu::Clear() {
+  model_->Clear();
+}
+
+int Menu::GetIndexOfCommandId(int command_id) {
+  return model_->GetIndexOfCommandId(command_id);
+}
+
+int Menu::GetItemCount() const {
+  return model_->GetItemCount();
+}
+
+int Menu::GetCommandIdAt(int index) const {
+  return model_->GetCommandIdAt(index);
+}
+
+base::string16 Menu::GetLabelAt(int index) const {
+  return model_->GetLabelAt(index);
+}
+
+base::string16 Menu::GetSublabelAt(int index) const {
+  return model_->GetSublabelAt(index);
+}
+
+bool Menu::IsItemCheckedAt(int index) const {
+  return model_->IsItemCheckedAt(index);
+}
+
+bool Menu::IsEnabledAt(int index) const {
+  return model_->IsEnabledAt(index);
+}
+
+bool Menu::IsVisibleAt(int index) const {
+  return model_->IsVisibleAt(index);
+}
+
+// static
+void Menu::BuildPrototype(v8::Isolate* isolate,
+                          v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("insertItem", &Menu::InsertItemAt)
+      .SetMethod("insertCheckItem", &Menu::InsertCheckItemAt)
+      .SetMethod("insertRadioItem", &Menu::InsertRadioItemAt)
+      .SetMethod("insertSeparator", &Menu::InsertSeparatorAt)
+      .SetMethod("insertSubMenu", &Menu::InsertSubMenuAt)
+      .SetMethod("setIcon", &Menu::SetIcon)
+      .SetMethod("setSublabel", &Menu::SetSublabel)
+      .SetMethod("setRole", &Menu::SetRole)
+      .SetMethod("clear", &Menu::Clear)
+      .SetMethod("getIndexOfCommandId", &Menu::GetIndexOfCommandId)
+      .SetMethod("getItemCount", &Menu::GetItemCount)
+      .SetMethod("getCommandIdAt", &Menu::GetCommandIdAt)
+      .SetMethod("getLabelAt", &Menu::GetLabelAt)
+      .SetMethod("getSublabelAt", &Menu::GetSublabelAt)
+      .SetMethod("isItemCheckedAt", &Menu::IsItemCheckedAt)
+      .SetMethod("isEnabledAt", &Menu::IsEnabledAt)
+      .SetMethod("isVisibleAt", &Menu::IsVisibleAt)
+      .SetMethod("popupAt", &Menu::PopupAt);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  using electron::api::Menu;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Menu>(
+      isolate, "Menu", base::Bind(&Menu::Create));
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("Menu", static_cast<v8::Local<v8::Value>>(constructor));
+#if defined(OS_MACOSX)
+  dict.SetMethod("setApplicationMenu", &Menu::SetApplicationMenu);
+  dict.SetMethod("sendActionToFirstResponder",
+                 &Menu::SendActionToFirstResponder);
+#endif
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_menu, Initialize)
added in remote
  their  100644 91ecb49688edb4df91d2741681156b10aa2452ad electron/browser/api/electron_api_menu.h
@@ -0,0 +1,126 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
+
+#include <string>
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/ui/electron_menu_model.h"
+#include "base/callback.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace electron {
+
+namespace api {
+
+class Menu : public mate::TrackableObject<Menu>,
+             public ElectronMenuModel::Delegate {
+ public:
+  static mate::Wrappable* Create();
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+#if defined(OS_MACOSX)
+  // Set the global menubar.
+  static void SetApplicationMenu(Menu* menu);
+
+  // Fake sending an action from the application menu.
+  static void SendActionToFirstResponder(const std::string& action);
+#endif
+
+  ElectronMenuModel* model() const { return model_.get(); }
+
+ protected:
+  Menu();
+  ~Menu() override;
+
+  // mate::Wrappable:
+  void AfterInit(v8::Isolate* isolate) override;
+
+  // ui::SimpleMenuModel::Delegate:
+  bool IsCommandIdChecked(int command_id) const override;
+  bool IsCommandIdEnabled(int command_id) const override;
+  bool IsCommandIdVisible(int command_id) const override;
+  bool GetAcceleratorForCommandId(int command_id,
+                                  ui::Accelerator* accelerator) override;
+  void ExecuteCommand(int command_id, int event_flags) override;
+  void MenuWillShow(ui::SimpleMenuModel* source) override;
+
+  virtual void PopupAt(Window* window,
+                       int x = -1, int y = -1,
+                       int positioning_item = 0) = 0;
+
+  scoped_ptr<ElectronMenuModel> model_;
+  Menu* parent_;
+
+ private:
+  void InsertItemAt(int index, int command_id, const base::string16& label);
+  void InsertSeparatorAt(int index);
+  void InsertCheckItemAt(int index,
+                         int command_id,
+                         const base::string16& label);
+  void InsertRadioItemAt(int index,
+                         int command_id,
+                         const base::string16& label,
+                         int group_id);
+  void InsertSubMenuAt(int index,
+                       int command_id,
+                       const base::string16& label,
+                       Menu* menu);
+  void SetIcon(int index, const gfx::Image& image);
+  void SetSublabel(int index, const base::string16& sublabel);
+  void SetRole(int index, const base::string16& role);
+  void Clear();
+  int GetIndexOfCommandId(int command_id);
+  int GetItemCount() const;
+  int GetCommandIdAt(int index) const;
+  base::string16 GetLabelAt(int index) const;
+  base::string16 GetSublabelAt(int index) const;
+  bool IsItemCheckedAt(int index) const;
+  bool IsEnabledAt(int index) const;
+  bool IsVisibleAt(int index) const;
+
+  // Stored delegate methods.
+  base::Callback<bool(int)> is_checked_;
+  base::Callback<bool(int)> is_enabled_;
+  base::Callback<bool(int)> is_visible_;
+  base::Callback<v8::Local<v8::Value>(int)> get_accelerator_;
+  base::Callback<void(int)> execute_command_;
+  base::Callback<void()> menu_will_show_;
+
+  DISALLOW_COPY_AND_ASSIGN(Menu);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace mate {
+
+template<>
+struct Converter<electron::ElectronMenuModel*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     electron::ElectronMenuModel** out) {
+    // null would be tranfered to NULL.
+    if (val->IsNull()) {
+      *out = nullptr;
+      return true;
+    }
+
+    electron::api::Menu* menu;
+    if (!Converter<electron::api::Menu*>::FromV8(isolate, val, &menu))
+      return false;
+    *out = menu->model();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
added in remote
  their  100644 73bcdfb949a28820a28c0a4112474125e2e996a9 electron/browser/api/electron_api_menu_mac.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
+
+#include "electron/browser/api/electron_api_menu.h"
+
+#include <string>
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+namespace electron {
+
+namespace api {
+
+class MenuMac : public Menu {
+ protected:
+  MenuMac();
+
+  void PopupAt(Window* window, int x, int y, int positioning_item = 0) override;
+
+  base::scoped_nsobject<ElectronMenuController> menu_controller_;
+
+ private:
+  friend class Menu;
+
+  static void SendActionToFirstResponder(const std::string& action);
+
+  DISALLOW_COPY_AND_ASSIGN(MenuMac);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
added in remote
  their  100644 9999b30b934569227fc9a4d9eb11ca33bdd13126 electron/browser/api/electron_api_menu_mac.mm
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/api/electron_api_menu_mac.h"
+
+#include "electron/browser/native_window.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/sys_string_conversions.h"
+#include "content/public/browser/web_contents.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+MenuMac::MenuMac() {
+}
+
+void MenuMac::PopupAt(Window* window, int x, int y, int positioning_item) {
+  NativeWindow* native_window = window->window();
+  if (!native_window)
+    return;
+  content::WebContents* web_contents = native_window->web_contents();
+  if (!web_contents)
+    return;
+
+  base::scoped_nsobject<ElectronMenuController> menu_controller(
+      [[ElectronMenuController alloc] initWithModel:model_.get()]);
+  NSMenu* menu = [menu_controller menu];
+  NSView* view = web_contents->GetContentNativeView();
+
+  // Which menu item to show.
+  NSMenuItem* item = nil;
+  if (positioning_item < [menu numberOfItems] && positioning_item >= 0)
+    item = [menu itemAtIndex:positioning_item];
+
+  // (-1, -1) means showing on mouse location.
+  NSPoint position;
+  if (x == -1 || y == -1) {
+    NSWindow* nswindow = native_window->GetNativeWindow();
+    position = [view convertPoint:[nswindow mouseLocationOutsideOfEventStream]
+                         fromView:nil];
+  } else {
+    position = NSMakePoint(x, [view frame].size.height - y);
+  }
+
+  // Show the menu.
+  [menu popUpMenuPositioningItem:item atLocation:position inView:view];
+}
+
+// static
+void Menu::SetApplicationMenu(Menu* base_menu) {
+  MenuMac* menu = static_cast<MenuMac*>(base_menu);
+  base::scoped_nsobject<ElectronMenuController> menu_controller(
+      [[ElectronMenuController alloc] initWithModel:menu->model_.get()]);
+  [NSApp setMainMenu:[menu_controller menu]];
+
+  // Ensure the menu_controller_ is destroyed after main menu is set.
+  menu_controller.swap(menu->menu_controller_);
+}
+
+// static
+void Menu::SendActionToFirstResponder(const std::string& action) {
+  SEL selector = NSSelectorFromString(base::SysUTF8ToNSString(action));
+  [NSApp sendAction:selector to:nil from:[NSApp mainMenu]];
+}
+
+// static
+mate::Wrappable* Menu::Create() {
+  return new MenuMac();
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 1efa598d415ca0a311cae33e1ac80e1fdf28a1ea electron/browser/api/electron_api_menu_views.cc
@@ -0,0 +1,58 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_menu_views.h"
+
+#include "electron/browser/native_window_views.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "ui/gfx/screen.h"
+#include "ui/views/controls/menu/menu_runner.h"
+
+namespace electron {
+
+namespace api {
+
+MenuViews::MenuViews() {
+}
+
+void MenuViews::PopupAt(Window* window, int x, int y, int positioning_item) {
+  NativeWindow* native_window = static_cast<NativeWindow*>(window->window());
+  if (!native_window)
+    return;
+  content::WebContents* web_contents = native_window->web_contents();
+  if (!web_contents)
+    return;
+  content::RenderWidgetHostView* view = web_contents->GetRenderWidgetHostView();
+  if (!view)
+    return;
+
+  // (-1, -1) means showing on mouse location.
+  gfx::Point location;
+  if (x == -1 || y == -1) {
+    location = gfx::Screen::GetNativeScreen()->GetCursorScreenPoint();
+  } else {
+    gfx::Point origin = view->GetViewBounds().origin();
+    location = gfx::Point(origin.x() + x, origin.y() + y);
+  }
+
+  // Show the menu.
+  views::MenuRunner menu_runner(
+      model(),
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS);
+  ignore_result(menu_runner.RunMenuAt(
+      static_cast<NativeWindowViews*>(window->window())->widget(),
+      NULL,
+      gfx::Rect(location, gfx::Size()),
+      views::MENU_ANCHOR_TOPLEFT,
+      ui::MENU_SOURCE_MOUSE));
+}
+
+// static
+mate::Wrappable* Menu::Create() {
+  return new MenuViews();
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 be42d0abb557e067d4c17dfa74e30330084238d8 electron/browser/api/electron_api_menu_views.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "ui/gfx/screen.h"
+
+namespace electron {
+
+namespace api {
+
+class MenuViews : public Menu {
+ public:
+  MenuViews();
+
+ protected:
+  void PopupAt(Window* window, int x, int y, int positioning_item = 0) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MenuViews);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
added in remote
  their  100644 84fd7a55e005b81d4fa89a6edf2cd09580e1be43 electron/browser/api/electron_api_power_monitor.cc
@@ -0,0 +1,73 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_power_monitor.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/node_includes.h"
+#include "base/power_monitor/power_monitor.h"
+#include "base/power_monitor/power_monitor_device_source.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace api {
+
+PowerMonitor::PowerMonitor() {
+  base::PowerMonitor::Get()->AddObserver(this);
+}
+
+PowerMonitor::~PowerMonitor() {
+  base::PowerMonitor::Get()->RemoveObserver(this);
+}
+
+void PowerMonitor::OnPowerStateChange(bool on_battery_power) {
+  if (on_battery_power)
+    Emit("on-battery");
+  else
+    Emit("on-ac");
+}
+
+void PowerMonitor::OnSuspend() {
+  Emit("suspend");
+}
+
+void PowerMonitor::OnResume() {
+  Emit("resume");
+}
+
+// static
+v8::Local<v8::Value> PowerMonitor::Create(v8::Isolate* isolate) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate,
+        "Cannot initialize \"power-monitor\" module before app is ready")));
+    return v8::Null(isolate);
+  }
+
+  return CreateHandle(isolate, new PowerMonitor).ToV8();
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+#if defined(OS_MACOSX)
+  base::PowerMonitorDeviceSource::AllocateSystemIOPorts();
+#endif
+
+  using electron::api::PowerMonitor;
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("powerMonitor", PowerMonitor::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_power_monitor, Initialize)
added in remote
  their  100644 1ed381df5b42bdea0c280a425895f8a294ac5271 electron/browser/api/electron_api_power_monitor.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/compiler_specific.h"
+#include "base/power_monitor/power_observer.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class PowerMonitor : public mate::TrackableObject<PowerMonitor>,
+                     public base::PowerObserver {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
+
+ protected:
+  PowerMonitor();
+  ~PowerMonitor() override;
+
+  // base::PowerObserver implementations:
+  void OnPowerStateChange(bool on_battery_power) override;
+  void OnSuspend() override;
+  void OnResume() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PowerMonitor);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
added in remote
  their  100644 eb422da50a2f613bd41f18cde438a6028d15c992 electron/browser/api/electron_api_power_save_blocker.cc
@@ -0,0 +1,128 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_power_save_blocker.h"
+
+#include <string>
+
+#include "electron/common/node_includes.h"
+#include "content/public/browser/power_save_blocker.h"
+#include "native_mate/dictionary.h"
+
+namespace mate {
+
+template<>
+struct Converter<content::PowerSaveBlocker::PowerSaveBlockerType> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::PowerSaveBlocker::PowerSaveBlockerType* out) {
+    using content::PowerSaveBlocker;
+    std::string type;
+    if (!ConvertFromV8(isolate, val, &type))
+      return false;
+    if (type == "prevent-app-suspension")
+      *out = PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension;
+    else if (type == "prevent-display-sleep")
+      *out = PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep;
+    else
+      return false;
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+PowerSaveBlocker::PowerSaveBlocker()
+    : current_blocker_type_(
+        content::PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension) {
+}
+
+PowerSaveBlocker::~PowerSaveBlocker() {
+}
+
+void PowerSaveBlocker::UpdatePowerSaveBlocker() {
+  if (power_save_blocker_types_.empty()) {
+    power_save_blocker_.reset();
+    return;
+  }
+
+  // |kPowerSaveBlockPreventAppSuspension| keeps system active, but allows
+  // screen to be turned off.
+  // |kPowerSaveBlockPreventDisplaySleep| keeps system and screen active, has a
+  // higher precedence level than |kPowerSaveBlockPreventAppSuspension|.
+  //
+  // Only the highest-precedence blocker type takes effect.
+  content::PowerSaveBlocker::PowerSaveBlockerType new_blocker_type =
+      content::PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension;
+  for (const auto& element : power_save_blocker_types_) {
+    if (element.second ==
+        content::PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep) {
+      new_blocker_type =
+          content::PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep;
+      break;
+    }
+  }
+
+  if (!power_save_blocker_ || new_blocker_type != current_blocker_type_) {
+    scoped_ptr<content::PowerSaveBlocker> new_blocker =
+        content::PowerSaveBlocker::Create(
+            new_blocker_type,
+            content::PowerSaveBlocker::kReasonOther,
+            ELECTRON_PRODUCT_NAME);
+    power_save_blocker_.swap(new_blocker);
+    current_blocker_type_ = new_blocker_type;
+  }
+}
+
+int PowerSaveBlocker::Start(
+    content::PowerSaveBlocker::PowerSaveBlockerType type) {
+  static int count = 0;
+  power_save_blocker_types_[count] = type;
+  UpdatePowerSaveBlocker();
+  return count++;
+}
+
+bool PowerSaveBlocker::Stop(int id) {
+  bool success = power_save_blocker_types_.erase(id) > 0;
+  UpdatePowerSaveBlocker();
+  return success;
+}
+
+bool PowerSaveBlocker::IsStarted(int id) {
+  return power_save_blocker_types_.find(id) != power_save_blocker_types_.end();
+}
+
+mate::ObjectTemplateBuilder PowerSaveBlocker::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("start", &PowerSaveBlocker::Start)
+      .SetMethod("stop", &PowerSaveBlocker::Stop)
+      .SetMethod("isStarted", &PowerSaveBlocker::IsStarted);
+}
+
+// static
+mate::Handle<PowerSaveBlocker> PowerSaveBlocker::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new PowerSaveBlocker);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("powerSaveBlocker", electron::api::PowerSaveBlocker::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_power_save_blocker, Initialize);
added in remote
  their  100644 484913d4cacec1f5239300e895ea16668af7fae0 electron/browser/api/electron_api_power_save_blocker.h
@@ -0,0 +1,58 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
+
+#include <map>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/memory/scoped_ptr.h"
+#include "content/public/browser/power_save_blocker.h"
+#include "native_mate/handle.h"
+
+namespace mate {
+class Dictionary;
+}
+
+namespace electron {
+
+namespace api {
+
+class PowerSaveBlocker : public mate::TrackableObject<PowerSaveBlocker> {
+ public:
+  static mate::Handle<PowerSaveBlocker> Create(v8::Isolate* isolate);
+
+ protected:
+  PowerSaveBlocker();
+  ~PowerSaveBlocker() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  void UpdatePowerSaveBlocker();
+  int Start(content::PowerSaveBlocker::PowerSaveBlockerType type);
+  bool Stop(int id);
+  bool IsStarted(int id);
+
+  scoped_ptr<content::PowerSaveBlocker> power_save_blocker_;
+
+  // Currnet blocker type used by |power_save_blocker_|
+  content::PowerSaveBlocker::PowerSaveBlockerType current_blocker_type_;
+
+  // Map from id to the corresponding blocker type for each request.
+  using PowerSaveBlockerTypeMap =
+      std::map<int, content::PowerSaveBlocker::PowerSaveBlockerType>;
+  PowerSaveBlockerTypeMap power_save_blocker_types_;
+
+  DISALLOW_COPY_AND_ASSIGN(PowerSaveBlocker);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
added in remote
  their  100644 41fc5eadff2ca01963bea12f6f8381d98c85fd62 electron/browser/api/electron_api_protocol.cc
@@ -0,0 +1,173 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_protocol.h"
+
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/net/url_request_async_asar_job.h"
+#include "electron/browser/net/url_request_buffer_job.h"
+#include "electron/browser/net/url_request_fetch_job.h"
+#include "electron/browser/net/url_request_string_job.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace api {
+
+Protocol::Protocol(ElectronBrowserContext* browser_context)
+    : request_context_getter_(browser_context->GetRequestContext()),
+      job_factory_(browser_context->job_factory()) {
+  CHECK(job_factory_);
+}
+
+mate::ObjectTemplateBuilder Protocol::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("registerStandardSchemes", &Protocol::RegisterStandardSchemes)
+      .SetMethod("registerServiceWorkerSchemes",
+                 &Protocol::RegisterServiceWorkerSchemes)
+      .SetMethod("registerStringProtocol",
+                 &Protocol::RegisterProtocol<URLRequestStringJob>)
+      .SetMethod("registerBufferProtocol",
+                 &Protocol::RegisterProtocol<URLRequestBufferJob>)
+      .SetMethod("registerFileProtocol",
+                 &Protocol::RegisterProtocol<URLRequestAsyncAsarJob>)
+      .SetMethod("registerHttpProtocol",
+                 &Protocol::RegisterProtocol<URLRequestFetchJob>)
+      .SetMethod("unregisterProtocol", &Protocol::UnregisterProtocol)
+      .SetMethod("isProtocolHandled", &Protocol::IsProtocolHandled)
+      .SetMethod("interceptStringProtocol",
+                 &Protocol::InterceptProtocol<URLRequestStringJob>)
+      .SetMethod("interceptBufferProtocol",
+                 &Protocol::InterceptProtocol<URLRequestBufferJob>)
+      .SetMethod("interceptFileProtocol",
+                 &Protocol::InterceptProtocol<URLRequestAsyncAsarJob>)
+      .SetMethod("interceptHttpProtocol",
+                 &Protocol::InterceptProtocol<URLRequestFetchJob>)
+      .SetMethod("uninterceptProtocol", &Protocol::UninterceptProtocol);
+}
+
+void Protocol::RegisterStandardSchemes(
+    const std::vector<std::string>& schemes) {
+  electron::ElectronBrowserClient::SetCustomSchemes(schemes);
+}
+
+void Protocol::RegisterServiceWorkerSchemes(
+    const std::vector<std::string>& schemes) {
+  electron::ElectronBrowserClient::SetCustomServiceWorkerSchemes(schemes);
+}
+
+void Protocol::UnregisterProtocol(
+    const std::string& scheme, mate::Arguments* args) {
+  CompletionCallback callback;
+  args->GetNext(&callback);
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::UnregisterProtocolInIO,
+                 base::Unretained(this), scheme),
+      base::Bind(&Protocol::OnIOCompleted,
+                 base::Unretained(this), callback));
+}
+
+Protocol::ProtocolError Protocol::UnregisterProtocolInIO(
+    const std::string& scheme) {
+  if (!job_factory_->HasProtocolHandler(scheme))
+    return PROTOCOL_NOT_REGISTERED;
+  job_factory_->SetProtocolHandler(scheme, nullptr);
+  return PROTOCOL_OK;
+}
+
+void Protocol::IsProtocolHandled(const std::string& scheme,
+                                    const BooleanCallback& callback) {
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::IsProtocolHandledInIO,
+                 base::Unretained(this), scheme),
+      callback);
+}
+
+bool Protocol::IsProtocolHandledInIO(const std::string& scheme) {
+  return job_factory_->IsHandledProtocol(scheme);
+}
+
+void Protocol::UninterceptProtocol(
+    const std::string& scheme, mate::Arguments* args) {
+  CompletionCallback callback;
+  args->GetNext(&callback);
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::UninterceptProtocolInIO,
+                 base::Unretained(this), scheme),
+      base::Bind(&Protocol::OnIOCompleted,
+                 base::Unretained(this), callback));
+}
+
+Protocol::ProtocolError Protocol::UninterceptProtocolInIO(
+    const std::string& scheme) {
+  if (!original_protocols_.contains(scheme))
+    return PROTOCOL_NOT_INTERCEPTED;
+  job_factory_->ReplaceProtocol(scheme,
+                                original_protocols_.take_and_erase(scheme));
+  return PROTOCOL_OK;
+}
+
+void Protocol::OnIOCompleted(
+    const CompletionCallback& callback, ProtocolError error) {
+  // The completion callback is optional.
+  if (callback.is_null())
+    return;
+
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+
+  if (error == PROTOCOL_OK) {
+    callback.Run(v8::Null(isolate()));
+  } else {
+    std::string str = ErrorCodeToString(error);
+    callback.Run(v8::Exception::Error(mate::StringToV8(isolate(), str)));
+  }
+}
+
+std::string Protocol::ErrorCodeToString(ProtocolError error) {
+  switch (error) {
+    case PROTOCOL_FAIL: return "Failed to manipulate protocol factory";
+    case PROTOCOL_REGISTERED: return "The scheme has been registred";
+    case PROTOCOL_NOT_REGISTERED: return "The scheme has not been registred";
+    case PROTOCOL_INTERCEPTED: return "The scheme has been intercepted";
+    case PROTOCOL_NOT_INTERCEPTED: return "The scheme has not been intercepted";
+    default: return "Unexpected error";
+  }
+}
+
+// static
+mate::Handle<Protocol> Protocol::Create(
+    v8::Isolate* isolate, ElectronBrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new Protocol(browser_context));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  auto browser_context = static_cast<electron::ElectronBrowserContext*>(
+      electron::ElectronBrowserMainParts::Get()->browser_context());
+  dict.Set("protocol", electron::api::Protocol::Create(isolate, browser_context));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_protocol, Initialize)
added in remote
  their  100644 5962211ea4eb443d84fb3f720d0f9c0ae1c0d715 electron/browser/api/electron_api_protocol.h
@@ -0,0 +1,195 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
+
+#include <string>
+#include <map>
+#include <vector>
+
+#include "electron/browser/net/electron_url_request_job_factory.h"
+#include "base/callback.h"
+#include "base/containers/scoped_ptr_hash_map.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+
+namespace net {
+class URLRequest;
+class URLRequestContextGetter;
+}
+
+namespace electron {
+
+class ElectronBrowserContext;
+class ElectronURLRequestJobFactory;
+
+namespace api {
+
+class Protocol : public mate::Wrappable {
+ public:
+  using Handler =
+      base::Callback<void(const net::URLRequest*, v8::Local<v8::Value>)>;
+  using CompletionCallback = base::Callback<void(v8::Local<v8::Value>)>;
+  using BooleanCallback = base::Callback<void(bool)>;
+
+  static mate::Handle<Protocol> Create(
+      v8::Isolate* isolate, ElectronBrowserContext* browser_context);
+
+ protected:
+  explicit Protocol(ElectronBrowserContext* browser_context);
+
+  // mate::Wrappable implementations:
+  virtual mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate);
+
+ private:
+  // Possible errors.
+  enum ProtocolError {
+    PROTOCOL_OK,  // no error
+    PROTOCOL_FAIL,  // operation failed, should never occur
+    PROTOCOL_REGISTERED,
+    PROTOCOL_NOT_REGISTERED,
+    PROTOCOL_INTERCEPTED,
+    PROTOCOL_NOT_INTERCEPTED,
+  };
+
+  // The protocol handler that will create a protocol handler for certain
+  // request job.
+  template<typename RequestJob>
+  class CustomProtocolHandler
+      : public net::URLRequestJobFactory::ProtocolHandler {
+   public:
+    CustomProtocolHandler(
+        v8::Isolate* isolate,
+        net::URLRequestContextGetter* request_context,
+        const Handler& handler)
+        : isolate_(isolate),
+          request_context_(request_context),
+          handler_(handler) {}
+    ~CustomProtocolHandler() override {}
+
+    net::URLRequestJob* MaybeCreateJob(
+        net::URLRequest* request,
+        net::NetworkDelegate* network_delegate) const override {
+      RequestJob* request_job = new RequestJob(request, network_delegate);
+      request_job->SetHandlerInfo(isolate_, request_context_, handler_);
+      return request_job;
+    }
+
+   private:
+    v8::Isolate* isolate_;
+    net::URLRequestContextGetter* request_context_;
+    Protocol::Handler handler_;
+
+    DISALLOW_COPY_AND_ASSIGN(CustomProtocolHandler);
+  };
+
+  // Register schemes to standard scheme list.
+  void RegisterStandardSchemes(const std::vector<std::string>& schemes);
+
+  // Register schemes that can handle service worker.
+  void RegisterServiceWorkerSchemes(const std::vector<std::string>& schemes);
+
+  // Register the protocol with certain request job.
+  template<typename RequestJob>
+  void RegisterProtocol(const std::string& scheme,
+                        const Handler& handler,
+                        mate::Arguments* args) {
+    CompletionCallback callback;
+    args->GetNext(&callback);
+    content::BrowserThread::PostTaskAndReplyWithResult(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&Protocol::RegisterProtocolInIO<RequestJob>,
+                   base::Unretained(this), scheme, handler),
+        base::Bind(&Protocol::OnIOCompleted,
+                   base::Unretained(this), callback));
+  }
+  template<typename RequestJob>
+  ProtocolError RegisterProtocolInIO(const std::string& scheme,
+                                     const Handler& handler) {
+    if (job_factory_->IsHandledProtocol(scheme))
+      return PROTOCOL_REGISTERED;
+    scoped_ptr<CustomProtocolHandler<RequestJob>> protocol_handler(
+        new CustomProtocolHandler<RequestJob>(
+            isolate(), request_context_getter_, handler));
+    if (job_factory_->SetProtocolHandler(scheme, std::move(protocol_handler)))
+      return PROTOCOL_OK;
+    else
+      return PROTOCOL_FAIL;
+  }
+
+  // Unregister the protocol handler that handles |scheme|.
+  void UnregisterProtocol(const std::string& scheme, mate::Arguments* args);
+  ProtocolError UnregisterProtocolInIO(const std::string& scheme);
+
+  // Whether the protocol has handler registered.
+  void IsProtocolHandled(const std::string& scheme,
+                         const BooleanCallback& callback);
+  bool IsProtocolHandledInIO(const std::string& scheme);
+
+  // Replace the protocol handler with a new one.
+  template<typename RequestJob>
+  void InterceptProtocol(const std::string& scheme,
+                         const Handler& handler,
+                         mate::Arguments* args) {
+    CompletionCallback callback;
+    args->GetNext(&callback);
+    content::BrowserThread::PostTaskAndReplyWithResult(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&Protocol::InterceptProtocolInIO<RequestJob>,
+                   base::Unretained(this), scheme, handler),
+        base::Bind(&Protocol::OnIOCompleted,
+                   base::Unretained(this), callback));
+  }
+  template<typename RequestJob>
+  ProtocolError InterceptProtocolInIO(const std::string& scheme,
+                                      const Handler& handler) {
+    if (!job_factory_->IsHandledProtocol(scheme))
+      return PROTOCOL_NOT_REGISTERED;
+    // It is possible a protocol is handled but can not be intercepted.
+    if (!job_factory_->HasProtocolHandler(scheme))
+      return PROTOCOL_FAIL;
+    if (ContainsKey(original_protocols_, scheme))
+      return PROTOCOL_INTERCEPTED;
+    scoped_ptr<CustomProtocolHandler<RequestJob>> protocol_handler(
+        new CustomProtocolHandler<RequestJob>(
+            isolate(), request_context_getter_, handler));
+    original_protocols_.set(
+        scheme,
+        job_factory_->ReplaceProtocol(scheme, std::move(protocol_handler)));
+    return PROTOCOL_OK;
+  }
+
+  // Restore the |scheme| to its original protocol handler.
+  void UninterceptProtocol(const std::string& scheme, mate::Arguments* args);
+  ProtocolError UninterceptProtocolInIO(const std::string& scheme);
+
+  // Convert error code to JS exception and call the callback.
+  void OnIOCompleted(const CompletionCallback& callback, ProtocolError error);
+
+  // Convert error code to string.
+  std::string ErrorCodeToString(ProtocolError error);
+
+  net::URLRequestContextGetter* request_context_getter_;
+
+  // Map that stores the original protocols of schemes.
+  using OriginalProtocolsMap = base::ScopedPtrHashMap<
+      std::string,
+      scoped_ptr<net::URLRequestJobFactory::ProtocolHandler>>;
+  OriginalProtocolsMap original_protocols_;
+
+  ElectronURLRequestJobFactory* job_factory_;  // weak ref
+
+  DISALLOW_COPY_AND_ASSIGN(Protocol);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
added in remote
  their  100644 40e49d2833337c985eb7be6b32684c7d983c3f73 electron/browser/api/electron_api_screen.cc
@@ -0,0 +1,146 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_screen.h"
+
+#include <algorithm>
+#include <string>
+
+#include "electron/browser/browser.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "base/bind.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "ui/gfx/screen.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Find an item in container according to its ID.
+template<class T>
+typename T::iterator FindById(T* container, int id) {
+  auto predicate = [id] (const typename T::value_type& item) -> bool {
+    return item.id() == id;
+  };
+  return std::find_if(container->begin(), container->end(), predicate);
+}
+
+// Convert the changed_metrics bitmask to string array.
+std::vector<std::string> MetricsToArray(uint32_t metrics) {
+  std::vector<std::string> array;
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_BOUNDS)
+    array.push_back("bounds");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_WORK_AREA)
+    array.push_back("workArea");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR)
+    array.push_back("scaleFactor");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_ROTATION)
+    array.push_back("rotation");
+  return array;
+}
+
+}  // namespace
+
+Screen::Screen(gfx::Screen* screen) : screen_(screen) {
+  displays_ = screen_->GetAllDisplays();
+  screen_->AddObserver(this);
+}
+
+Screen::~Screen() {
+  screen_->RemoveObserver(this);
+}
+
+gfx::Point Screen::GetCursorScreenPoint() {
+  return screen_->GetCursorScreenPoint();
+}
+
+gfx::Display Screen::GetPrimaryDisplay() {
+  return screen_->GetPrimaryDisplay();
+}
+
+std::vector<gfx::Display> Screen::GetAllDisplays() {
+  return displays_;
+}
+
+gfx::Display Screen::GetDisplayNearestPoint(const gfx::Point& point) {
+  return screen_->GetDisplayNearestPoint(point);
+}
+
+gfx::Display Screen::GetDisplayMatching(const gfx::Rect& match_rect) {
+  return screen_->GetDisplayMatching(match_rect);
+}
+
+void Screen::OnDisplayAdded(const gfx::Display& new_display) {
+  displays_.push_back(new_display);
+  Emit("display-added", new_display);
+}
+
+void Screen::OnDisplayRemoved(const gfx::Display& old_display) {
+  auto iter = FindById(&displays_, old_display.id());
+  if (iter == displays_.end())
+    return;
+
+  displays_.erase(iter);
+  Emit("display-removed", old_display);
+}
+
+void Screen::OnDisplayMetricsChanged(const gfx::Display& display,
+                                     uint32_t changed_metrics) {
+  auto iter = FindById(&displays_, display.id());
+  if (iter == displays_.end())
+    return;
+
+  *iter = display;
+  Emit("display-metrics-changed", display, MetricsToArray(changed_metrics));
+}
+
+mate::ObjectTemplateBuilder Screen::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("getCursorScreenPoint", &Screen::GetCursorScreenPoint)
+      .SetMethod("getPrimaryDisplay", &Screen::GetPrimaryDisplay)
+      .SetMethod("getAllDisplays", &Screen::GetAllDisplays)
+      .SetMethod("getDisplayNearestPoint", &Screen::GetDisplayNearestPoint)
+      .SetMethod("getDisplayMatching", &Screen::GetDisplayMatching);
+}
+
+// static
+v8::Local<v8::Value> Screen::Create(v8::Isolate* isolate) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate,
+        "Cannot initialize \"screen\" module before app is ready")));
+    return v8::Null(isolate);
+  }
+
+  gfx::Screen* screen = gfx::Screen::GetNativeScreen();
+  if (!screen) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Failed to get screen information")));
+    return v8::Null(isolate);
+  }
+
+  return mate::CreateHandle(isolate, new Screen(screen)).ToV8();
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.Set("screen", electron::api::Screen::Create(context->GetIsolate()));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_screen, Initialize)
added in remote
  their  100644 6c44a66d4143a9bb935f27282a4e3cdc2b6d694b electron/browser/api/electron_api_screen.h
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
+
+#include <vector>
+
+#include "electron/browser/api/event_emitter.h"
+#include "native_mate/handle.h"
+#include "ui/gfx/display_observer.h"
+
+namespace gfx {
+class Point;
+class Rect;
+class Screen;
+}
+
+namespace electron {
+
+namespace api {
+
+class Screen : public mate::EventEmitter,
+               public gfx::DisplayObserver {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
+
+ protected:
+  explicit Screen(gfx::Screen* screen);
+  virtual ~Screen();
+
+  gfx::Point GetCursorScreenPoint();
+  gfx::Display GetPrimaryDisplay();
+  std::vector<gfx::Display> GetAllDisplays();
+  gfx::Display GetDisplayNearestPoint(const gfx::Point& point);
+  gfx::Display GetDisplayMatching(const gfx::Rect& match_rect);
+
+  // gfx::DisplayObserver:
+  void OnDisplayAdded(const gfx::Display& new_display) override;
+  void OnDisplayRemoved(const gfx::Display& old_display) override;
+  void OnDisplayMetricsChanged(const gfx::Display& display,
+                               uint32_t changed_metrics) override;
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  gfx::Screen* screen_;
+  std::vector<gfx::Display> displays_;
+
+  DISALLOW_COPY_AND_ASSIGN(Screen);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
added in remote
  their  100644 c4d14c26369a83eaa03514bebde0e217b8d94f49 electron/browser/api/electron_api_session.cc
@@ -0,0 +1,524 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_session.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_cookies.h"
+#include "electron/browser/api/electron_api_download_item.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/api/electron_api_web_request.h"
+#include "electron/browser/api/save_page_handler.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_permission_manager.h"
+#include "electron/browser/net/electron_cert_verifier.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/content_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/files/file_path.h"
+#include "base/prefs/pref_service.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "brightray/browser/net/devtools_network_conditions.h"
+#include "brightray/browser/net/devtools_network_controller.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/base/load_flags.h"
+#include "net/disk_cache/disk_cache.h"
+#include "net/dns/host_cache.h"
+#include "net/proxy/proxy_service.h"
+#include "net/proxy/proxy_config_service_fixed.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_context_getter.h"
+
+using content::BrowserThread;
+using content::StoragePartition;
+
+namespace {
+
+struct ClearStorageDataOptions {
+  GURL origin;
+  uint32_t storage_types = StoragePartition::REMOVE_DATA_MASK_ALL;
+  uint32_t quota_types = StoragePartition::QUOTA_MANAGED_STORAGE_MASK_ALL;
+};
+
+uint32_t GetStorageMask(const std::vector<std::string>& storage_types) {
+  uint32_t storage_mask = 0;
+  for (const auto& it : storage_types) {
+    auto type = base::ToLowerASCII(it);
+    if (type == "appcache")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_APPCACHE;
+    else if (type == "cookies")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_COOKIES;
+    else if (type == "filesystem")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;
+    else if (type == "indexdb")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;
+    else if (type == "localstorage")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;
+    else if (type == "shadercache")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;
+    else if (type == "websql")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_WEBSQL;
+    else if (type == "serviceworkers")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;
+  }
+  return storage_mask;
+}
+
+uint32_t GetQuotaMask(const std::vector<std::string>& quota_types) {
+  uint32_t quota_mask = 0;
+  for (const auto& it : quota_types) {
+    auto type = base::ToLowerASCII(it);
+    if (type == "temporary")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY;
+    else if (type == "persistent")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;
+    else if (type == "syncable")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_SYNCABLE;
+  }
+  return quota_mask;
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<ClearStorageDataOptions> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     ClearStorageDataOptions* out) {
+    mate::Dictionary options;
+    if (!ConvertFromV8(isolate, val, &options))
+      return false;
+    options.Get("origin", &out->origin);
+    std::vector<std::string> types;
+    if (options.Get("storages", &types))
+      out->storage_types = GetStorageMask(types);
+    if (options.Get("quotas", &types))
+      out->quota_types = GetQuotaMask(types);
+    return true;
+  }
+};
+
+template<>
+struct Converter<net::ProxyConfig> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     net::ProxyConfig* out) {
+    std::string proxy_rules;
+    GURL pac_url;
+    mate::Dictionary options;
+    // Fallback to previous API when passed String.
+    // https://git.io/vuhjj
+    if (ConvertFromV8(isolate, val, &proxy_rules)) {
+      pac_url = GURL(proxy_rules);  // Assume it is PAC script if it is URL.
+    } else if (ConvertFromV8(isolate, val, &options)) {
+      options.Get("pacScript", &pac_url);
+      options.Get("proxyRules", &proxy_rules);
+    } else {
+      return false;
+    }
+
+    // pacScript takes precedence over proxyRules.
+    if (!pac_url.is_empty() && pac_url.is_valid()) {
+      out->set_pac_url(pac_url);
+    } else {
+      out->proxy_rules().ParseFromString(proxy_rules);
+    }
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapSession funtion which is implemented in JavaScript
+using WrapSessionCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapSessionCallback g_wrap_session;
+
+class ResolveProxyHelper {
+ public:
+  ResolveProxyHelper(ElectronBrowserContext* browser_context,
+                     const GURL& url,
+                     Session::ResolveProxyCallback callback)
+      : callback_(callback),
+        original_thread_(base::ThreadTaskRunnerHandle::Get()) {
+    scoped_refptr<net::URLRequestContextGetter> context_getter =
+        browser_context->GetRequestContext();
+    context_getter->GetNetworkTaskRunner()->PostTask(
+        FROM_HERE,
+        base::Bind(&ResolveProxyHelper::ResolveProxy,
+                   base::Unretained(this), context_getter, url));
+  }
+
+  void OnResolveProxyCompleted(int result) {
+    std::string proxy;
+    if (result == net::OK)
+      proxy = proxy_info_.ToPacString();
+    original_thread_->PostTask(FROM_HERE,
+                               base::Bind(callback_, proxy));
+    delete this;
+  }
+
+ private:
+  void ResolveProxy(scoped_refptr<net::URLRequestContextGetter> context_getter,
+                    const GURL& url) {
+    DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+    net::ProxyService* proxy_service =
+        context_getter->GetURLRequestContext()->proxy_service();
+    net::CompletionCallback completion_callback =
+        base::Bind(&ResolveProxyHelper::OnResolveProxyCompleted,
+                   base::Unretained(this));
+
+    // Start the request.
+    int result = proxy_service->ResolveProxy(
+        url, net::LOAD_NORMAL, &proxy_info_, completion_callback,
+        &pac_req_, nullptr, net::BoundNetLog());
+
+    // Completed synchronously.
+    if (result != net::ERR_IO_PENDING)
+      completion_callback.Run(result);
+  }
+
+  Session::ResolveProxyCallback callback_;
+  net::ProxyInfo proxy_info_;
+  net::ProxyService::PacRequest* pac_req_;
+  scoped_refptr<base::SingleThreadTaskRunner> original_thread_;
+
+  DISALLOW_COPY_AND_ASSIGN(ResolveProxyHelper);
+};
+
+// Runs the callback in UI thread.
+template<typename ...T>
+void RunCallbackInUI(const base::Callback<void(T...)>& callback, T... result) {
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE, base::Bind(callback, result...));
+}
+
+// Callback of HttpCache::GetBackend.
+void OnGetBackend(disk_cache::Backend** backend_ptr,
+                  Session::CacheAction action,
+                  const net::CompletionCallback& callback,
+                  int result) {
+  if (result != net::OK) {
+    RunCallbackInUI(callback, result);
+  } else if (backend_ptr && *backend_ptr) {
+    if (action == Session::CacheAction::CLEAR) {
+      (*backend_ptr)->DoomAllEntries(base::Bind(&RunCallbackInUI<int>,
+                                                callback));
+    } else if (action == Session::CacheAction::STATS) {
+      base::StringPairs stats;
+      (*backend_ptr)->GetStats(&stats);
+      for (size_t i = 0; i < stats.size(); ++i) {
+        if (stats[i].first == "Current size") {
+          int current_size;
+          base::StringToInt(stats[i].second, &current_size);
+          RunCallbackInUI(callback, current_size);
+          break;
+        }
+      }
+    }
+  } else {
+    RunCallbackInUI<int>(callback, net::ERR_FAILED);
+  }
+}
+
+void DoCacheActionInIO(
+    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
+    Session::CacheAction action,
+    const net::CompletionCallback& callback) {
+  auto request_context = context_getter->GetURLRequestContext();
+  auto http_cache = request_context->http_transaction_factory()->GetCache();
+  if (!http_cache)
+    RunCallbackInUI<int>(callback, net::ERR_FAILED);
+
+  // Call GetBackend and make the backend's ptr accessable in OnGetBackend.
+  using BackendPtr = disk_cache::Backend*;
+  BackendPtr* backend_ptr = new BackendPtr(nullptr);
+  net::CompletionCallback on_get_backend =
+      base::Bind(&OnGetBackend, base::Owned(backend_ptr), action, callback);
+  int rv = http_cache->GetBackend(backend_ptr, on_get_backend);
+  if (rv != net::ERR_IO_PENDING)
+    on_get_backend.Run(net::OK);
+}
+
+void SetProxyInIO(net::URLRequestContextGetter* getter,
+                  const net::ProxyConfig& config,
+                  const base::Closure& callback) {
+  auto proxy_service = getter->GetURLRequestContext()->proxy_service();
+  proxy_service->ResetConfigService(make_scoped_ptr(
+      new net::ProxyConfigServiceFixed(config)));
+  // Refetches and applies the new pac script if provided.
+  proxy_service->ForceReloadProxyConfig();
+  RunCallbackInUI(callback);
+}
+
+void ClearHostResolverCacheInIO(
+    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
+    const base::Closure& callback) {
+  auto request_context = context_getter->GetURLRequestContext();
+  auto cache = request_context->host_resolver()->GetHostCache();
+  if (cache) {
+    cache->clear();
+    DCHECK_EQ(0u, cache->size());
+    if (!callback.is_null())
+      RunCallbackInUI(callback);
+  }
+}
+
+}  // namespace
+
+Session::Session(ElectronBrowserContext* browser_context)
+    : browser_context_(browser_context) {
+  AttachAsUserData(browser_context);
+
+  // Observe DownloadManger to get download notifications.
+  content::BrowserContext::GetDownloadManager(browser_context)->
+      AddObserver(this);
+}
+
+Session::~Session() {
+  content::BrowserContext::GetDownloadManager(browser_context())->
+      RemoveObserver(this);
+}
+
+void Session::OnDownloadCreated(content::DownloadManager* manager,
+                                content::DownloadItem* item) {
+  auto web_contents = item->GetWebContents();
+  if (SavePageHandler::IsSavePageTypes(item->GetMimeType()))
+    return;
+  bool prevent_default = Emit(
+      "will-download",
+      DownloadItem::Create(isolate(), item),
+      api::WebContents::CreateFrom(isolate(), web_contents));
+  if (prevent_default) {
+    item->Cancel(true);
+    item->Remove();
+  }
+}
+
+void Session::ResolveProxy(const GURL& url, ResolveProxyCallback callback) {
+  new ResolveProxyHelper(browser_context(), url, callback);
+}
+
+template<Session::CacheAction action>
+void Session::DoCacheAction(const net::CompletionCallback& callback) {
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&DoCacheActionInIO,
+                 make_scoped_refptr(browser_context_->GetRequestContext()),
+                 action,
+                 callback));
+}
+
+void Session::ClearStorageData(mate::Arguments* args) {
+  // clearStorageData([options, ]callback)
+  ClearStorageDataOptions options;
+  args->GetNext(&options);
+  base::Closure callback;
+  if (!args->GetNext(&callback)) {
+    args->ThrowError();
+    return;
+  }
+
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
+  storage_partition->ClearData(
+      options.storage_types, options.quota_types, options.origin,
+      content::StoragePartition::OriginMatcherFunction(),
+      base::Time(), base::Time::Max(), callback);
+}
+
+void Session::FlushStorageData() {
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
+  storage_partition->Flush();
+}
+
+void Session::SetProxy(const net::ProxyConfig& config,
+                       const base::Closure& callback) {
+  auto getter = browser_context_->GetRequestContext();
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&SetProxyInIO, base::Unretained(getter), config, callback));
+}
+
+void Session::SetDownloadPath(const base::FilePath& path) {
+  browser_context_->prefs()->SetFilePath(
+      prefs::kDownloadDefaultDirectory, path);
+}
+
+void Session::EnableNetworkEmulation(const mate::Dictionary& options) {
+  scoped_ptr<brightray::DevToolsNetworkConditions> conditions;
+  bool offline = false;
+  double latency, download_throughput, upload_throughput;
+  if (options.Get("offline", &offline) && offline) {
+    conditions.reset(new brightray::DevToolsNetworkConditions(offline));
+  } else {
+    options.Get("latency", &latency);
+    options.Get("downloadThroughput", &download_throughput);
+    options.Get("uploadThroughput", &upload_throughput);
+    conditions.reset(
+        new brightray::DevToolsNetworkConditions(false,
+                                                 latency,
+                                                 download_throughput,
+                                                 upload_throughput));
+  }
+  auto controller = browser_context_->GetDevToolsNetworkController();
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&brightray::DevToolsNetworkController::SetNetworkState,
+                 base::Unretained(controller),
+                 std::string(),
+                 base::Passed(&conditions)));
+}
+
+void Session::DisableNetworkEmulation() {
+  scoped_ptr<brightray::DevToolsNetworkConditions> conditions(
+      new brightray::DevToolsNetworkConditions(false));
+  auto controller = browser_context_->GetDevToolsNetworkController();
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&brightray::DevToolsNetworkController::SetNetworkState,
+                 base::Unretained(controller),
+                 std::string(),
+                 base::Passed(&conditions)));
+}
+
+void Session::SetCertVerifyProc(v8::Local<v8::Value> val,
+                                mate::Arguments* args) {
+  ElectronCertVerifier::VerifyProc proc;
+  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &proc))) {
+    args->ThrowError("Must pass null or function");
+    return;
+  }
+
+  browser_context_->cert_verifier()->SetVerifyProc(proc);
+}
+
+void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,
+                                          mate::Arguments* args) {
+  ElectronPermissionManager::RequestHandler handler;
+  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &handler))) {
+    args->ThrowError("Must pass null or function");
+    return;
+  }
+  auto permission_manager = static_cast<ElectronPermissionManager*>(
+      browser_context()->GetPermissionManager());
+  permission_manager->SetPermissionRequestHandler(handler);
+}
+
+void Session::ClearHostResolverCache(mate::Arguments* args) {
+  base::Closure callback;
+  args->GetNext(&callback);
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&ClearHostResolverCacheInIO,
+                 make_scoped_refptr(browser_context_->GetRequestContext()),
+                 callback));
+}
+
+v8::Local<v8::Value> Session::Cookies(v8::Isolate* isolate) {
+  if (cookies_.IsEmpty()) {
+    auto handle = electron::api::Cookies::Create(isolate, browser_context());
+    cookies_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, cookies_);
+}
+
+v8::Local<v8::Value> Session::WebRequest(v8::Isolate* isolate) {
+  if (web_request_.IsEmpty()) {
+    auto handle = electron::api::WebRequest::Create(isolate, browser_context());
+    web_request_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, web_request_);
+}
+
+// static
+mate::Handle<Session> Session::CreateFrom(
+    v8::Isolate* isolate, ElectronBrowserContext* browser_context) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, browser_context);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<Session*>(existing));
+
+  auto handle = mate::CreateHandle(isolate, new Session(browser_context));
+  g_wrap_session.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+mate::Handle<Session> Session::FromPartition(
+    v8::Isolate* isolate, const std::string& partition, bool in_memory) {
+  auto browser_context = brightray::BrowserContext::From(partition, in_memory);
+  return CreateFrom(isolate,
+                    static_cast<ElectronBrowserContext*>(browser_context.get()));
+}
+
+// static
+void Session::BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("resolveProxy", &Session::ResolveProxy)
+      .SetMethod("getCacheSize", &Session::DoCacheAction<CacheAction::STATS>)
+      .SetMethod("clearCache", &Session::DoCacheAction<CacheAction::CLEAR>)
+      .SetMethod("clearStorageData", &Session::ClearStorageData)
+      .SetMethod("flushStorageData", &Session::FlushStorageData)
+      .SetMethod("setProxy", &Session::SetProxy)
+      .SetMethod("setDownloadPath", &Session::SetDownloadPath)
+      .SetMethod("enableNetworkEmulation", &Session::EnableNetworkEmulation)
+      .SetMethod("disableNetworkEmulation", &Session::DisableNetworkEmulation)
+      .SetMethod("setCertificateVerifyProc", &Session::SetCertVerifyProc)
+      .SetMethod("setPermissionRequestHandler",
+                 &Session::SetPermissionRequestHandler)
+      .SetMethod("clearHostResolverCache", &Session::ClearHostResolverCache)
+      .SetProperty("cookies", &Session::Cookies)
+      .SetProperty("webRequest", &Session::WebRequest);
+}
+
+void ClearWrapSession() {
+  g_wrap_session.Reset();
+}
+
+void SetWrapSession(const WrapSessionCallback& callback) {
+  g_wrap_session = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapSession));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("fromPartition", &electron::api::Session::FromPartition);
+  dict.SetMethod("_setWrapSession", &electron::api::SetWrapSession);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_session, Initialize)
added in remote
  their  100644 42941fee865627a0af7b758e3b99c5e0c05c469a electron/browser/api/electron_api_session.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "content/public/browser/download_manager.h"
+#include "native_mate/handle.h"
+#include "net/base/completion_callback.h"
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace net {
+class ProxyConfig;
+}
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+namespace api {
+
+class Session: public mate::TrackableObject<Session>,
+               public content::DownloadManager::Observer {
+ public:
+  using ResolveProxyCallback = base::Callback<void(std::string)>;
+
+  enum class CacheAction {
+    CLEAR,
+    STATS,
+  };
+
+  // Gets or creates Session from the |browser_context|.
+  static mate::Handle<Session> CreateFrom(
+      v8::Isolate* isolate, ElectronBrowserContext* browser_context);
+
+  // Gets the Session of |partition| and |in_memory|.
+  static mate::Handle<Session> FromPartition(
+      v8::Isolate* isolate, const std::string& partition, bool in_memory);
+
+  ElectronBrowserContext* browser_context() const { return browser_context_.get(); }
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Session(ElectronBrowserContext* browser_context);
+  ~Session();
+
+  // content::DownloadManager::Observer:
+  void OnDownloadCreated(content::DownloadManager* manager,
+                         content::DownloadItem* item) override;
+
+ private:
+  void ResolveProxy(const GURL& url, ResolveProxyCallback callback);
+  template<CacheAction action>
+  void DoCacheAction(const net::CompletionCallback& callback);
+  void ClearStorageData(mate::Arguments* args);
+  void FlushStorageData();
+  void SetProxy(const net::ProxyConfig& config, const base::Closure& callback);
+  void SetDownloadPath(const base::FilePath& path);
+  void EnableNetworkEmulation(const mate::Dictionary& options);
+  void DisableNetworkEmulation();
+  void SetCertVerifyProc(v8::Local<v8::Value> proc, mate::Arguments* args);
+  void SetPermissionRequestHandler(v8::Local<v8::Value> val,
+                                   mate::Arguments* args);
+  void ClearHostResolverCache(mate::Arguments* args);
+  v8::Local<v8::Value> Cookies(v8::Isolate* isolate);
+  v8::Local<v8::Value> WebRequest(v8::Isolate* isolate);
+
+  // Cached object.
+  v8::Global<v8::Value> cookies_;
+  v8::Global<v8::Value> web_request_;
+
+  scoped_refptr<ElectronBrowserContext> browser_context_;
+
+  DISALLOW_COPY_AND_ASSIGN(Session);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
added in remote
  their  100644 c4dc2ddb2c7d674db6837be3859e4d98001816ee electron/browser/api/electron_api_tray.cc
@@ -0,0 +1,187 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_tray.h"
+
+#include <string>
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/ui/tray_icon.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "ui/events/event_constants.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+namespace api {
+
+Tray::Tray(const gfx::Image& image)
+    : tray_icon_(TrayIcon::Create()) {
+  tray_icon_->SetImage(image);
+  tray_icon_->AddObserver(this);
+}
+
+Tray::~Tray() {
+}
+
+// static
+mate::Wrappable* Tray::New(v8::Isolate* isolate, const gfx::Image& image) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Cannot create Tray before app is ready")));
+    return nullptr;
+  }
+  return new Tray(image);
+}
+
+void Tray::OnClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("double-click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnRightClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("right-click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnBalloonShow() {
+  Emit("balloon-show");
+}
+
+void Tray::OnBalloonClicked() {
+  Emit("balloon-click");
+}
+
+void Tray::OnBalloonClosed() {
+  Emit("balloon-closed");
+}
+
+void Tray::OnDrop() {
+  Emit("drop");
+}
+
+void Tray::OnDropFiles(const std::vector<std::string>& files) {
+  Emit("drop-files", files);
+}
+
+void Tray::OnDragEntered() {
+  Emit("drag-enter");
+}
+
+void Tray::OnDragExited() {
+  Emit("drag-leave");
+}
+
+void Tray::OnDragEnded() {
+  Emit("drag-end");
+}
+
+void Tray::SetImage(mate::Arguments* args, const gfx::Image& image) {
+  tray_icon_->SetImage(image);
+}
+
+void Tray::SetPressedImage(mate::Arguments* args, const gfx::Image& image) {
+  tray_icon_->SetPressedImage(image);
+}
+
+void Tray::SetToolTip(mate::Arguments* args, const std::string& tool_tip) {
+  tray_icon_->SetToolTip(tool_tip);
+}
+
+void Tray::SetTitle(mate::Arguments* args, const std::string& title) {
+  tray_icon_->SetTitle(title);
+}
+
+void Tray::SetHighlightMode(mate::Arguments* args, bool highlight) {
+  tray_icon_->SetHighlightMode(highlight);
+}
+
+void Tray::DisplayBalloon(mate::Arguments* args,
+                          const mate::Dictionary& options) {
+  gfx::Image icon;
+  options.Get("icon", &icon);
+  base::string16 title, content;
+  if (!options.Get("title", &title) ||
+      !options.Get("content", &content)) {
+    args->ThrowError("'title' and 'content' must be defined");
+    return;
+  }
+
+  tray_icon_->DisplayBalloon(icon, title, content);
+}
+
+void Tray::PopUpContextMenu(mate::Arguments* args) {
+  mate::Handle<Menu> menu;
+  args->GetNext(&menu);
+  gfx::Point pos;
+  args->GetNext(&pos);
+  tray_icon_->PopUpContextMenu(pos, menu.IsEmpty() ? nullptr : menu->model());
+}
+
+void Tray::SetContextMenu(mate::Arguments* args, Menu* menu) {
+  tray_icon_->SetContextMenu(menu->model());
+}
+
+v8::Local<v8::Object> Tray::ModifiersToObject(v8::Isolate* isolate,
+                                              int modifiers) {
+  mate::Dictionary obj(isolate, v8::Object::New(isolate));
+  obj.Set("shiftKey", static_cast<bool>(modifiers & ui::EF_SHIFT_DOWN));
+  obj.Set("ctrlKey", static_cast<bool>(modifiers & ui::EF_CONTROL_DOWN));
+  obj.Set("altKey", static_cast<bool>(modifiers & ui::EF_ALT_DOWN));
+  obj.Set("metaKey", static_cast<bool>(modifiers & ui::EF_COMMAND_DOWN));
+  return obj.GetHandle();
+}
+
+// static
+void Tray::BuildPrototype(v8::Isolate* isolate,
+                          v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("setImage", &Tray::SetImage)
+      .SetMethod("setPressedImage", &Tray::SetPressedImage)
+      .SetMethod("setToolTip", &Tray::SetToolTip)
+      .SetMethod("setTitle", &Tray::SetTitle)
+      .SetMethod("setHighlightMode", &Tray::SetHighlightMode)
+      .SetMethod("displayBalloon", &Tray::DisplayBalloon)
+      .SetMethod("popUpContextMenu", &Tray::PopUpContextMenu)
+      .SetMethod("_setContextMenu", &Tray::SetContextMenu);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  using electron::api::Tray;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Tray>(
+      isolate, "Tray", base::Bind(&Tray::New));
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("Tray", static_cast<v8::Local<v8::Value>>(constructor));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_tray, Initialize)
added in remote
  their  100644 9fbea743753d9ba05213db03e0136a84388b0a26 electron/browser/api/electron_api_tray.h
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/ui/tray_icon_observer.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace gfx {
+class Image;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+class TrayIcon;
+
+namespace api {
+
+class Menu;
+
+class Tray : public mate::TrackableObject<Tray>,
+             public TrayIconObserver {
+ public:
+  static mate::Wrappable* New(v8::Isolate* isolate, const gfx::Image& image);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Tray(const gfx::Image& image);
+  ~Tray() override;
+
+  // TrayIconObserver:
+  void OnClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnRightClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnBalloonShow() override;
+  void OnBalloonClicked() override;
+  void OnBalloonClosed() override;
+  void OnDrop() override;
+  void OnDropFiles(const std::vector<std::string>& files) override;
+  void OnDragEntered() override;
+  void OnDragExited() override;
+  void OnDragEnded() override;
+
+  void SetImage(mate::Arguments* args, const gfx::Image& image);
+  void SetPressedImage(mate::Arguments* args, const gfx::Image& image);
+  void SetToolTip(mate::Arguments* args, const std::string& tool_tip);
+  void SetTitle(mate::Arguments* args, const std::string& title);
+  void SetHighlightMode(mate::Arguments* args, bool highlight);
+  void DisplayBalloon(mate::Arguments* args, const mate::Dictionary& options);
+  void PopUpContextMenu(mate::Arguments* args);
+  void SetContextMenu(mate::Arguments* args, Menu* menu);
+
+ private:
+  v8::Local<v8::Object> ModifiersToObject(v8::Isolate* isolate, int modifiers);
+
+  scoped_ptr<TrayIcon> tray_icon_;
+
+  DISALLOW_COPY_AND_ASSIGN(Tray);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
added in remote
  their  100644 488f516a3e91fa3856ea503a46d38dfd06d25f1d electron/browser/api/electron_api_web_contents.cc
@@ -0,0 +1,1286 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_contents.h"
+
+#include <set>
+#include <string>
+
+#include "electron/browser/api/electron_api_debugger.h"
+#include "electron/browser/api/electron_api_session.h"
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/web_view_guest_delegate.h"
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/blink_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/content_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/mouse_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "chrome/browser/printing/print_view_manager_basic.h"
+#include "chrome/browser/printing/print_preview_message_handler.h"
+#include "content/common/view_messages.h"
+#include "content/public/browser/favicon_status.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "content/public/browser/navigation_details.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/plugin_service.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/browser/resource_request_details.h"
+#include "content/public/browser/service_worker_context.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/context_menu_params.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/static_http_user_agent_settings.h"
+#include "net/url_request/url_request_context.h"
+#include "third_party/WebKit/public/web/WebInputEvent.h"
+#include "ui/base/l10n/l10n_util.h"
+
+#include "electron/common/node_includes.h"
+
+namespace {
+
+struct PrintSettings {
+  bool silent;
+  bool print_background;
+};
+
+void SetUserAgentInIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                      std::string accept_lang,
+                      std::string user_agent) {
+  getter->GetURLRequestContext()->set_http_user_agent_settings(
+      new net::StaticHttpUserAgentSettings(
+          net::HttpUtil::GenerateAcceptLanguageHeader(accept_lang),
+          user_agent));
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<electron::SetSizeParams> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     electron::SetSizeParams* out) {
+    mate::Dictionary params;
+    if (!ConvertFromV8(isolate, val, &params))
+      return false;
+    bool autosize;
+    if (params.Get("enableAutoSize", &autosize))
+      out->enable_auto_size.reset(new bool(true));
+    gfx::Size size;
+    if (params.Get("min", &size))
+      out->min_size.reset(new gfx::Size(size));
+    if (params.Get("max", &size))
+      out->max_size.reset(new gfx::Size(size));
+    if (params.Get("normal", &size))
+      out->normal_size.reset(new gfx::Size(size));
+    return true;
+  }
+};
+
+template<>
+struct Converter<PrintSettings> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     PrintSettings* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    dict.Get("silent", &(out->silent));
+    dict.Get("printBackground", &(out->print_background));
+    return true;
+  }
+};
+
+template<>
+struct Converter<WindowOpenDisposition> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   WindowOpenDisposition val) {
+    std::string disposition = "other";
+    switch (val) {
+      case CURRENT_TAB: disposition = "default"; break;
+      case NEW_FOREGROUND_TAB: disposition = "foreground-tab"; break;
+      case NEW_BACKGROUND_TAB: disposition = "background-tab"; break;
+      case NEW_POPUP: case NEW_WINDOW: disposition = "new-window"; break;
+      default: break;
+    }
+    return mate::ConvertToV8(isolate, disposition);
+  }
+};
+
+template<>
+struct Converter<net::HttpResponseHeaders*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   net::HttpResponseHeaders* headers) {
+    base::DictionaryValue response_headers;
+    if (headers) {
+      void* iter = nullptr;
+      std::string key;
+      std::string value;
+      while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
+        key = base::ToLowerASCII(key);
+        if (response_headers.HasKey(key)) {
+          base::ListValue* values = nullptr;
+          if (response_headers.GetList(key, &values))
+            values->AppendString(value);
+        } else {
+          scoped_ptr<base::ListValue> values(new base::ListValue());
+          values->AppendString(value);
+          response_headers.Set(key, std::move(values));
+        }
+      }
+    }
+    return ConvertToV8(isolate, response_headers);
+  }
+};
+
+template<>
+struct Converter<content::SavePageType> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::SavePageType* out) {
+    std::string save_type;
+    if (!ConvertFromV8(isolate, val, &save_type))
+      return false;
+    save_type = base::ToLowerASCII(save_type);
+    if (save_type == "htmlonly") {
+      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;
+    } else if (save_type == "htmlcomplete") {
+      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;
+    } else if (save_type == "mhtml") {
+      *out = content::SAVE_PAGE_TYPE_AS_MHTML;
+    } else {
+      return false;
+    }
+    return true;
+  }
+};
+
+}  // namespace mate
+
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapWebContents function which is implemented in JavaScript
+using WrapWebContentsCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapWebContentsCallback g_wrap_web_contents;
+
+content::ServiceWorkerContext* GetServiceWorkerContext(
+    const content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  auto site_instance = web_contents->GetSiteInstance();
+  if (!context || !site_instance)
+    return nullptr;
+
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(context, site_instance);
+  if (!storage_partition)
+    return nullptr;
+
+  return storage_partition->GetServiceWorkerContext();
+}
+
+}  // namespace
+
+WebContents::WebContents(content::WebContents* web_contents)
+    : content::WebContentsObserver(web_contents),
+      type_(REMOTE) {
+  AttachAsUserData(web_contents);
+  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
+}
+
+WebContents::WebContents(v8::Isolate* isolate,
+                         const mate::Dictionary& options)
+    : embedder_(nullptr),
+      request_id_(0) {
+  // Whether it is a guest WebContents.
+  bool is_guest = false;
+  options.Get("isGuest", &is_guest);
+  type_ = is_guest ? WEB_VIEW : BROWSER_WINDOW;
+
+  // Obtain the session.
+  std::string partition;
+  mate::Handle<api::Session> session;
+  if (options.Get("session", &session)) {
+  } else if (options.Get("partition", &partition) && !partition.empty()) {
+    bool in_memory = true;
+    if (base::StartsWith(partition, "persist:", base::CompareCase::SENSITIVE)) {
+      in_memory = false;
+      partition = partition.substr(8);
+    }
+    session = Session::FromPartition(isolate, partition, in_memory);
+  } else {
+    // Use the default session if not specified.
+    session = Session::FromPartition(isolate, "", false);
+  }
+  session_.Reset(isolate, session.ToV8());
+
+  content::WebContents* web_contents;
+  if (is_guest) {
+    content::SiteInstance* site_instance = content::SiteInstance::CreateForURL(
+        session->browser_context(), GURL("chrome-guest://fake-host"));
+    content::WebContents::CreateParams params(
+        session->browser_context(), site_instance);
+    guest_delegate_.reset(new WebViewGuestDelegate);
+    params.guest_delegate = guest_delegate_.get();
+    web_contents = content::WebContents::Create(params);
+  } else {
+    content::WebContents::CreateParams params(session->browser_context());
+    web_contents = content::WebContents::Create(params);
+  }
+
+  Observe(web_contents);
+  AttachAsUserData(web_contents);
+  InitWithWebContents(web_contents);
+
+  managed_web_contents()->GetView()->SetDelegate(this);
+
+  // Save the preferences in C++.
+  new WebContentsPreferences(web_contents, options);
+
+  // Intialize permission helper.
+  WebContentsPermissionHelper::CreateForWebContents(web_contents);
+
+  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
+
+  if (is_guest) {
+    guest_delegate_->Initialize(this);
+
+    NativeWindow* owner_window = nullptr;
+    if (options.Get("embedder", &embedder_) && embedder_) {
+      // New WebContents's owner_window is the embedder's owner_window.
+      auto relay =
+          NativeWindowRelay::FromWebContents(embedder_->web_contents());
+      if (relay)
+        owner_window = relay->window.get();
+    }
+    if (owner_window)
+      SetOwnerWindow(owner_window);
+  }
+}
+
+WebContents::~WebContents() {
+  // The destroy() is called.
+  if (managed_web_contents()) {
+    // For webview we need to tell content module to do some cleanup work before
+    // destroying it.
+    if (type_ == WEB_VIEW)
+      guest_delegate_->Destroy();
+
+    // The WebContentsDestroyed will not be called automatically because we
+    // unsubscribe from webContents before destroying it. So we have to manually
+    // call it here to make sure "destroyed" event is emitted.
+    RenderViewDeleted(web_contents()->GetRenderViewHost());
+    WebContentsDestroyed();
+  }
+}
+
+bool WebContents::AddMessageToConsole(content::WebContents* source,
+                                      int32_t level,
+                                      const base::string16& message,
+                                      int32_t line_no,
+                                      const base::string16& source_id) {
+  if (type_ == BROWSER_WINDOW) {
+    return false;
+  } else {
+    Emit("console-message", level, message, line_no, source_id);
+    return true;
+  }
+}
+
+bool WebContents::ShouldCreateWebContents(
+    content::WebContents* web_contents,
+    int32_t route_id,
+    int32_t main_frame_route_id,
+    int32_t main_frame_widget_route_id,
+    WindowContainerType window_container_type,
+    const std::string& frame_name,
+    const GURL& target_url,
+    const std::string& partition_id,
+    content::SessionStorageNamespace* session_storage_namespace) {
+  if (type_ == BROWSER_WINDOW)
+    Emit("-new-window", target_url, frame_name, NEW_FOREGROUND_TAB);
+  else
+    Emit("new-window", target_url, frame_name, NEW_FOREGROUND_TAB);
+  return false;
+}
+
+content::WebContents* WebContents::OpenURLFromTab(
+    content::WebContents* source,
+    const content::OpenURLParams& params) {
+  if (params.disposition != CURRENT_TAB) {
+    if (type_ == BROWSER_WINDOW)
+      Emit("-new-window", params.url, "", params.disposition);
+    else
+      Emit("new-window", params.url, "", params.disposition);
+    return nullptr;
+  }
+
+  // Give user a chance to cancel navigation.
+  if (Emit("will-navigate", params.url))
+    return nullptr;
+
+  return CommonWebContentsDelegate::OpenURLFromTab(source, params);
+}
+
+void WebContents::BeforeUnloadFired(content::WebContents* tab,
+                                    bool proceed,
+                                    bool* proceed_to_fire_unload) {
+  if (type_ == BROWSER_WINDOW)
+    *proceed_to_fire_unload = proceed;
+  else
+    *proceed_to_fire_unload = true;
+}
+
+void WebContents::MoveContents(content::WebContents* source,
+                               const gfx::Rect& pos) {
+  Emit("move", pos);
+}
+
+void WebContents::CloseContents(content::WebContents* source) {
+  Emit("close");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->CloseContents(source);
+}
+
+void WebContents::ActivateContents(content::WebContents* source) {
+  Emit("activate");
+}
+
+bool WebContents::IsPopupOrPanel(const content::WebContents* source) const {
+  return type_ == BROWSER_WINDOW;
+}
+
+void WebContents::HandleKeyboardEvent(
+    content::WebContents* source,
+    const content::NativeWebKeyboardEvent& event) {
+  if (event.windowsKeyCode == ui::VKEY_ESCAPE && is_html_fullscreen()) {
+    // Escape exits tabbed fullscreen mode.
+    ExitFullscreenModeForTab(source);
+  } else if (type_ == BROWSER_WINDOW) {
+    owner_window()->HandleKeyboardEvent(source, event);
+  } else if (type_ == WEB_VIEW && guest_delegate_) {
+    // Send the unhandled keyboard events back to the embedder.
+    guest_delegate_->HandleKeyboardEvent(source, event);
+  }
+}
+
+void WebContents::EnterFullscreenModeForTab(content::WebContents* source,
+                                            const GURL& origin) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(source);
+  auto callback = base::Bind(&WebContents::OnEnterFullscreenModeForTab,
+                             base::Unretained(this), source, origin);
+  permission_helper->RequestFullscreenPermission(callback);
+}
+
+void WebContents::OnEnterFullscreenModeForTab(content::WebContents* source,
+                                              const GURL& origin,
+                                              bool allowed) {
+  if (!allowed)
+    return;
+  CommonWebContentsDelegate::EnterFullscreenModeForTab(source, origin);
+  Emit("enter-html-full-screen");
+}
+
+void WebContents::ExitFullscreenModeForTab(content::WebContents* source) {
+  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);
+  Emit("leave-html-full-screen");
+}
+
+void WebContents::RendererUnresponsive(content::WebContents* source) {
+  Emit("unresponsive");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->RendererUnresponsive(source);
+}
+
+void WebContents::RendererResponsive(content::WebContents* source) {
+  Emit("responsive");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->RendererResponsive(source);
+}
+
+bool WebContents::HandleContextMenu(const content::ContextMenuParams& params) {
+  if (!params.custom_context.is_pepper_menu)
+    return false;
+
+  Emit("pepper-context-menu", std::make_pair(params, web_contents()));
+  web_contents()->NotifyContextMenuClosed(params.custom_context);
+  return true;
+}
+
+bool WebContents::OnGoToEntryOffset(int offset) {
+  GoToOffset(offset);
+  return false;
+}
+
+void WebContents::FindReply(content::WebContents* web_contents,
+                            int request_id,
+                            int number_of_matches,
+                            const gfx::Rect& selection_rect,
+                            int active_match_ordinal,
+                            bool final_update) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+
+  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate());
+  if (number_of_matches == -1) {
+    result.Set("requestId", request_id);
+    result.Set("selectionArea", selection_rect);
+    result.Set("finalUpdate", final_update);
+    result.Set("activeMatchOrdinal", active_match_ordinal);
+    Emit("found-in-page", result);
+  } else if (final_update) {
+    result.Set("requestId", request_id);
+    result.Set("matches", number_of_matches);
+    result.Set("finalUpdate", final_update);
+    Emit("found-in-page", result);
+  }
+}
+
+bool WebContents::CheckMediaAccessPermission(
+    content::WebContents* web_contents,
+    const GURL& security_origin,
+    content::MediaStreamType type) {
+  return true;
+}
+
+void WebContents::RequestMediaAccessPermission(
+    content::WebContents* web_contents,
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& callback) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  permission_helper->RequestMediaAccessPermission(request, callback);
+}
+
+void WebContents::RequestToLockMouse(
+    content::WebContents* web_contents,
+    bool user_gesture,
+    bool last_unlocked_by_target) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  permission_helper->RequestPointerLockPermission(user_gesture);
+}
+
+void WebContents::BeforeUnloadFired(const base::TimeTicks& proceed_time) {
+  // Do nothing, we override this method just to avoid compilation error since
+  // there are two virtual functions named BeforeUnloadFired.
+}
+
+void WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {
+  Emit("render-view-deleted", render_view_host->GetProcess()->GetID());
+}
+
+void WebContents::RenderProcessGone(base::TerminationStatus status) {
+  Emit("crashed");
+}
+
+void WebContents::PluginCrashed(const base::FilePath& plugin_path,
+                                base::ProcessId plugin_pid) {
+  content::WebPluginInfo info;
+  auto plugin_service = content::PluginService::GetInstance();
+  plugin_service->GetPluginInfoByPath(plugin_path, &info);
+  Emit("plugin-crashed", info.name, info.version);
+}
+
+void WebContents::MediaStartedPlaying(const MediaPlayerId& id) {
+  Emit("media-started-playing");
+}
+
+void WebContents::MediaStoppedPlaying(const MediaPlayerId& id) {
+  Emit("media-paused");
+}
+
+void WebContents::DidChangeThemeColor(SkColor theme_color) {
+  std::string hex_theme_color = base::StringPrintf("#%02X%02X%02X",
+    SkColorGetR(theme_color),
+    SkColorGetG(theme_color),
+    SkColorGetB(theme_color));
+  Emit("did-change-theme-color", hex_theme_color);
+}
+
+void WebContents::DocumentLoadedInFrame(
+    content::RenderFrameHost* render_frame_host) {
+  if (!render_frame_host->GetParent())
+    Emit("dom-ready");
+}
+
+void WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                                const GURL& validated_url) {
+  bool is_main_frame = !render_frame_host->GetParent();
+  Emit("did-frame-finish-load", is_main_frame);
+
+  if (is_main_frame)
+    Emit("did-finish-load");
+}
+
+void WebContents::DidFailProvisionalLoad(
+    content::RenderFrameHost* render_frame_host,
+    const GURL& url,
+    int error_code,
+    const base::string16& error_description,
+    bool was_ignored_by_handler) {
+  Emit("did-fail-provisional-load", error_code, error_description, url);
+}
+
+void WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,
+                              const GURL& validated_url,
+                              int error_code,
+                              const base::string16& error_description,
+                              bool was_ignored_by_handler) {
+  Emit("did-fail-load", error_code, error_description, validated_url);
+}
+
+void WebContents::DidStartLoading() {
+  Emit("did-start-loading");
+}
+
+void WebContents::DidStopLoading() {
+  Emit("did-stop-loading");
+}
+
+void WebContents::DidGetResourceResponseStart(
+    const content::ResourceRequestDetails& details) {
+  Emit("did-get-response-details",
+       details.socket_address.IsEmpty(),
+       details.url,
+       details.original_url,
+       details.http_response_code,
+       details.method,
+       details.referrer,
+       details.headers.get());
+}
+
+void WebContents::DidGetRedirectForResourceRequest(
+    content::RenderFrameHost* render_frame_host,
+    const content::ResourceRedirectDetails& details) {
+  Emit("did-get-redirect-request",
+       details.url,
+       details.new_url,
+       (details.resource_type == content::RESOURCE_TYPE_MAIN_FRAME),
+       details.http_response_code,
+       details.method,
+       details.referrer,
+       details.headers.get());
+}
+
+void WebContents::DidNavigateMainFrame(
+    const content::LoadCommittedDetails& details,
+    const content::FrameNavigateParams& params) {
+  if (details.is_navigation_to_different_page())
+    Emit("did-navigate", params.url);
+  else if (details.is_in_page)
+    Emit("did-navigate-in-page", params.url);
+}
+
+void WebContents::TitleWasSet(content::NavigationEntry* entry,
+                              bool explicit_set) {
+  if (entry)
+    Emit("-page-title-updated", entry->GetTitle(), explicit_set);
+  else
+    Emit("-page-title-updated", "", explicit_set);
+}
+
+void WebContents::DidUpdateFaviconURL(
+    const std::vector<content::FaviconURL>& urls) {
+  std::set<GURL> unique_urls;
+  for (auto iter = urls.begin(); iter != urls.end(); ++iter) {
+    if (iter->icon_type != content::FaviconURL::FAVICON)
+      continue;
+    const GURL& url = iter->icon_url;
+    if (url.is_valid())
+      unique_urls.insert(url);
+  }
+  Emit("page-favicon-updated", unique_urls);
+}
+
+void WebContents::DevToolsFocused() {
+  Emit("devtools-focused");
+}
+
+void WebContents::DevToolsOpened() {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  auto handle = WebContents::CreateFrom(
+      isolate(), managed_web_contents()->GetDevToolsWebContents());
+  devtools_web_contents_.Reset(isolate(), handle.ToV8());
+
+  // Inherit owner window in devtools.
+  if (owner_window())
+    handle->SetOwnerWindow(managed_web_contents()->GetDevToolsWebContents(),
+                           owner_window());
+
+  Emit("devtools-opened");
+}
+
+void WebContents::DevToolsClosed() {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  devtools_web_contents_.Reset();
+
+  Emit("devtools-closed");
+}
+
+bool WebContents::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(WebContents, message)
+    IPC_MESSAGE_HANDLER(ElectronViewHostMsg_Message, OnRendererMessage)
+    IPC_MESSAGE_HANDLER_DELAY_REPLY(ElectronViewHostMsg_Message_Sync,
+                                    OnRendererMessageSync)
+    IPC_MESSAGE_HANDLER_CODE(ViewHostMsg_SetCursor, OnCursorChange,
+      handled = false)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+// There are three ways of destroying a webContents:
+// 1. call webContents.destory();
+// 2. garbage collection;
+// 3. user closes the window of webContents;
+// For webview only #1 will happen, for BrowserWindow both #1 and #3 may
+// happen. The #2 should never happen for webContents, because webview is
+// managed by GuestViewManager, and BrowserWindow's webContents is managed
+// by api::Window.
+// For #1, the destructor will do the cleanup work and we only need to make
+// sure "destroyed" event is emitted. For #3, the content::WebContents will
+// be destroyed on close, and WebContentsDestroyed would be called for it, so
+// we need to make sure the api::WebContents is also deleted.
+void WebContents::WebContentsDestroyed() {
+  // This event is only for internal use, which is emitted when WebContents is
+  // being destroyed.
+  Emit("will-destroy");
+
+  // Cleanup relationships with other parts.
+  RemoveFromWeakMap();
+
+  // We can not call Destroy here because we need to call Emit first, but we
+  // also do not want any method to be used, so just mark as destroyed here.
+  MarkDestroyed();
+
+  Emit("destroyed");
+
+  // Destroy the native class in next tick.
+  base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+}
+
+void WebContents::NavigationEntryCommitted(
+    const content::LoadCommittedDetails& details) {
+  Emit("navigation-entry-commited", details.entry->GetURL(),
+       details.is_in_page, details.did_replace_entry);
+}
+
+int WebContents::GetID() const {
+  return web_contents()->GetRenderProcessHost()->GetID();
+}
+
+bool WebContents::Equal(const WebContents* web_contents) const {
+  return GetID() == web_contents->GetID();
+}
+
+void WebContents::LoadURL(const GURL& url, const mate::Dictionary& options) {
+  if (!url.is_valid()) {
+    Emit("did-fail-load",
+         static_cast<int>(net::ERR_INVALID_URL),
+         net::ErrorToShortString(net::ERR_INVALID_URL),
+         url.possibly_invalid_spec());
+    return;
+  }
+
+  content::NavigationController::LoadURLParams params(url);
+
+  GURL http_referrer;
+  if (options.Get("httpReferrer", &http_referrer))
+    params.referrer = content::Referrer(http_referrer.GetAsReferrer(),
+                                        blink::WebReferrerPolicyDefault);
+
+  std::string user_agent;
+  if (options.Get("userAgent", &user_agent))
+    SetUserAgent(user_agent);
+
+  std::string extra_headers;
+  if (options.Get("extraHeaders", &extra_headers))
+    params.extra_headers = extra_headers;
+
+  params.transition_type = ui::PAGE_TRANSITION_TYPED;
+  params.should_clear_history_list = true;
+  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
+  web_contents()->GetController().LoadURLWithParams(params);
+}
+
+void WebContents::DownloadURL(const GURL& url) {
+  auto browser_context = web_contents()->GetBrowserContext();
+  auto download_manager =
+    content::BrowserContext::GetDownloadManager(browser_context);
+
+  download_manager->DownloadUrl(
+    content::DownloadUrlParameters::FromWebContents(web_contents(), url));
+}
+
+GURL WebContents::GetURL() const {
+  return web_contents()->GetURL();
+}
+
+base::string16 WebContents::GetTitle() const {
+  return web_contents()->GetTitle();
+}
+
+bool WebContents::IsLoading() const {
+  return web_contents()->IsLoading();
+}
+
+bool WebContents::IsWaitingForResponse() const {
+  return web_contents()->IsWaitingForResponse();
+}
+
+void WebContents::Stop() {
+  web_contents()->Stop();
+}
+
+void WebContents::GoBack() {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoBack();
+}
+
+void WebContents::GoForward() {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoForward();
+}
+
+void WebContents::GoToOffset(int offset) {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoToOffset(offset);
+}
+
+bool WebContents::IsCrashed() const {
+  return web_contents()->IsCrashed();
+}
+
+void WebContents::SetUserAgent(const std::string& user_agent) {
+  web_contents()->SetUserAgentOverride(user_agent);
+  scoped_refptr<net::URLRequestContextGetter> getter =
+      web_contents()->GetBrowserContext()->GetRequestContext();
+
+  auto accept_lang = l10n_util::GetApplicationLocale("");
+  getter->GetNetworkTaskRunner()->PostTask(FROM_HERE,
+      base::Bind(&SetUserAgentInIO, getter, accept_lang, user_agent));
+}
+
+std::string WebContents::GetUserAgent() {
+  return web_contents()->GetUserAgentOverride();
+}
+
+void WebContents::InsertCSS(const std::string& css) {
+  web_contents()->InsertCSS(css);
+}
+
+bool WebContents::SavePage(const base::FilePath& full_file_path,
+                           const content::SavePageType& save_type,
+                           const SavePageHandler::SavePageCallback& callback) {
+  auto handler = new SavePageHandler(web_contents(), callback);
+  return handler->Handle(full_file_path, save_type);
+}
+
+void WebContents::OpenDevTools(mate::Arguments* args) {
+  if (type_ == REMOTE)
+    return;
+
+  bool detach = false;
+  if (type_ == WEB_VIEW) {
+    detach = true;
+  } else if (args && args->Length() == 1) {
+    mate::Dictionary options;
+    args->GetNext(&options) && options.Get("detach", &detach);
+  }
+  managed_web_contents()->SetCanDock(!detach);
+  managed_web_contents()->ShowDevTools();
+}
+
+void WebContents::CloseDevTools() {
+  if (type_ == REMOTE)
+    return;
+
+  managed_web_contents()->CloseDevTools();
+}
+
+bool WebContents::IsDevToolsOpened() {
+  if (type_ == REMOTE)
+    return false;
+
+  return managed_web_contents()->IsDevToolsViewShowing();
+}
+
+bool WebContents::IsDevToolsFocused() {
+  if (type_ == REMOTE)
+    return false;
+
+  return managed_web_contents()->GetView()->IsDevToolsViewFocused();
+}
+
+void WebContents::EnableDeviceEmulation(
+    const blink::WebDeviceEmulationParams& params) {
+  if (type_ == REMOTE)
+    return;
+
+  Send(new ViewMsg_EnableDeviceEmulation(routing_id(), params));
+}
+
+void WebContents::DisableDeviceEmulation() {
+  if (type_ == REMOTE)
+    return;
+
+  Send(new ViewMsg_DisableDeviceEmulation(routing_id()));
+}
+
+void WebContents::ToggleDevTools() {
+  if (IsDevToolsOpened())
+    CloseDevTools();
+  else
+    OpenDevTools(nullptr);
+}
+
+void WebContents::InspectElement(int x, int y) {
+  if (type_ == REMOTE)
+    return;
+
+  OpenDevTools(nullptr);
+  scoped_refptr<content::DevToolsAgentHost> agent(
+    content::DevToolsAgentHost::GetOrCreateFor(web_contents()));
+  agent->InspectElement(x, y);
+}
+
+void WebContents::InspectServiceWorker() {
+  if (type_ == REMOTE)
+    return;
+
+  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {
+    if (agent_host->GetType() ==
+        content::DevToolsAgentHost::TYPE_SERVICE_WORKER) {
+      OpenDevTools(nullptr);
+      managed_web_contents()->AttachTo(agent_host);
+      break;
+    }
+  }
+}
+
+void WebContents::HasServiceWorker(
+    const base::Callback<void(bool)>& callback) {
+  auto context = GetServiceWorkerContext(web_contents());
+  if (!context)
+    return;
+
+  context->CheckHasServiceWorker(web_contents()->GetLastCommittedURL(),
+                                 GURL::EmptyGURL(),
+                                 callback);
+}
+
+void WebContents::UnregisterServiceWorker(
+    const base::Callback<void(bool)>& callback) {
+  auto context = GetServiceWorkerContext(web_contents());
+  if (!context)
+    return;
+
+  context->UnregisterServiceWorker(web_contents()->GetLastCommittedURL(),
+                                   callback);
+}
+
+void WebContents::SetAudioMuted(bool muted) {
+  web_contents()->SetAudioMuted(muted);
+}
+
+bool WebContents::IsAudioMuted() {
+  return web_contents()->IsAudioMuted();
+}
+
+void WebContents::Print(mate::Arguments* args) {
+  PrintSettings settings = { false, false };
+  if (args->Length() == 1 && !args->GetNext(&settings)) {
+    args->ThrowError();
+    return;
+  }
+
+  printing::PrintViewManagerBasic::FromWebContents(web_contents())->
+      PrintNow(settings.silent, settings.print_background);
+}
+
+void WebContents::PrintToPDF(const base::DictionaryValue& setting,
+                             const PrintToPDFCallback& callback) {
+  printing::PrintPreviewMessageHandler::FromWebContents(web_contents())->
+      PrintToPDF(setting, callback);
+}
+
+void WebContents::AddWorkSpace(mate::Arguments* args,
+                               const base::FilePath& path) {
+  if (path.empty()) {
+    args->ThrowError("path cannot be empty");
+    return;
+  }
+  DevToolsAddFileSystem(path);
+}
+
+void WebContents::RemoveWorkSpace(mate::Arguments* args,
+                                  const base::FilePath& path) {
+  if (path.empty()) {
+    args->ThrowError("path cannot be empty");
+    return;
+  }
+  DevToolsRemoveFileSystem(path);
+}
+
+void WebContents::Undo() {
+  web_contents()->Undo();
+}
+
+void WebContents::Redo() {
+  web_contents()->Redo();
+}
+
+void WebContents::Cut() {
+  web_contents()->Cut();
+}
+
+void WebContents::Copy() {
+  web_contents()->Copy();
+}
+
+void WebContents::Paste() {
+  web_contents()->Paste();
+}
+
+void WebContents::PasteAndMatchStyle() {
+  web_contents()->PasteAndMatchStyle();
+}
+
+void WebContents::Delete() {
+  web_contents()->Delete();
+}
+
+void WebContents::SelectAll() {
+  web_contents()->SelectAll();
+}
+
+void WebContents::Unselect() {
+  web_contents()->Unselect();
+}
+
+void WebContents::Replace(const base::string16& word) {
+  web_contents()->Replace(word);
+}
+
+void WebContents::ReplaceMisspelling(const base::string16& word) {
+  web_contents()->ReplaceMisspelling(word);
+}
+
+uint32_t WebContents::FindInPage(mate::Arguments* args) {
+  uint32_t request_id = GetNextRequestId();
+  base::string16 search_text;
+  blink::WebFindOptions options;
+  if (!args->GetNext(&search_text) || search_text.empty()) {
+    args->ThrowError("Must provide a non-empty search content");
+    return 0;
+  }
+
+  args->GetNext(&options);
+
+  web_contents()->Find(request_id, search_text, options);
+  return request_id;
+}
+
+void WebContents::StopFindInPage(content::StopFindAction action) {
+  web_contents()->StopFinding(action);
+}
+
+void WebContents::Focus() {
+  web_contents()->Focus();
+}
+
+void WebContents::TabTraverse(bool reverse) {
+  web_contents()->FocusThroughTabTraversal(reverse);
+}
+
+bool WebContents::SendIPCMessage(const base::string16& channel,
+                                 const base::ListValue& args) {
+  return Send(new ElectronViewMsg_Message(routing_id(), channel, args));
+}
+
+void WebContents::SendInputEvent(v8::Isolate* isolate,
+                                 v8::Local<v8::Value> input_event) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (!view)
+    return;
+  const auto host = view->GetRenderWidgetHost();
+  if (!host)
+    return;
+
+  int type = mate::GetWebInputEventType(isolate, input_event);
+  if (blink::WebInputEvent::isMouseEventType(type)) {
+    blink::WebMouseEvent mouse_event;
+    if (mate::ConvertFromV8(isolate, input_event, &mouse_event)) {
+      host->ForwardMouseEvent(mouse_event);
+      return;
+    }
+  } else if (blink::WebInputEvent::isKeyboardEventType(type)) {
+    content::NativeWebKeyboardEvent keyboard_event;
+    if (mate::ConvertFromV8(isolate, input_event, &keyboard_event)) {
+      host->ForwardKeyboardEvent(keyboard_event);
+      return;
+    }
+  } else if (type == blink::WebInputEvent::MouseWheel) {
+    blink::WebMouseWheelEvent mouse_wheel_event;
+    if (mate::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {
+      host->ForwardWheelEvent(mouse_wheel_event);
+      return;
+    }
+  }
+
+  isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+      isolate, "Invalid event object")));
+}
+
+void WebContents::BeginFrameSubscription(
+    const FrameSubscriber::FrameCaptureCallback& callback) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (view) {
+    scoped_ptr<FrameSubscriber> frame_subscriber(new FrameSubscriber(
+        isolate(), view, callback));
+    view->BeginFrameSubscription(std::move(frame_subscriber));
+  }
+}
+
+void WebContents::EndFrameSubscription() {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (view)
+    view->EndFrameSubscription();
+}
+
+void WebContents::OnCursorChange(const content::WebCursor& cursor) {
+  content::WebCursor::CursorInfo info;
+  cursor.GetCursorInfo(&info);
+
+  if (cursor.IsCustom()) {
+    Emit("cursor-changed", CursorTypeToString(info),
+      gfx::Image::CreateFrom1xBitmap(info.custom_image),
+      info.image_scale_factor);
+  } else {
+    Emit("cursor-changed", CursorTypeToString(info));
+  }
+}
+
+void WebContents::SetSize(const SetSizeParams& params) {
+  if (guest_delegate_)
+    guest_delegate_->SetSize(params);
+}
+
+bool WebContents::IsGuest() const {
+  return type_ == WEB_VIEW;
+}
+
+v8::Local<v8::Value> WebContents::GetWebPreferences(v8::Isolate* isolate) {
+  WebContentsPreferences* web_preferences =
+      WebContentsPreferences::FromWebContents(web_contents());
+  return mate::ConvertToV8(isolate, *web_preferences->web_preferences());
+}
+
+v8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() {
+  if (owner_window())
+    return Window::From(isolate(), owner_window());
+  else
+    return v8::Null(isolate());
+}
+
+v8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {
+  return v8::Local<v8::Value>::New(isolate, session_);
+}
+
+content::WebContents* WebContents::HostWebContents() {
+  if (!embedder_)
+    return nullptr;
+  return embedder_->web_contents();
+}
+
+v8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {
+  if (devtools_web_contents_.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);
+}
+
+v8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {
+  if (debugger_.IsEmpty()) {
+    auto handle = electron::api::Debugger::Create(isolate, web_contents());
+    debugger_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, debugger_);
+}
+
+// static
+void WebContents::BuildPrototype(v8::Isolate* isolate,
+                                 v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("getId", &WebContents::GetID)
+      .SetMethod("equal", &WebContents::Equal)
+      .SetMethod("_loadURL", &WebContents::LoadURL)
+      .SetMethod("downloadURL", &WebContents::DownloadURL)
+      .SetMethod("_getURL", &WebContents::GetURL)
+      .SetMethod("getTitle", &WebContents::GetTitle)
+      .SetMethod("isLoading", &WebContents::IsLoading)
+      .SetMethod("isWaitingForResponse", &WebContents::IsWaitingForResponse)
+      .SetMethod("_stop", &WebContents::Stop)
+      .SetMethod("_goBack", &WebContents::GoBack)
+      .SetMethod("_goForward", &WebContents::GoForward)
+      .SetMethod("_goToOffset", &WebContents::GoToOffset)
+      .SetMethod("isCrashed", &WebContents::IsCrashed)
+      .SetMethod("setUserAgent", &WebContents::SetUserAgent)
+      .SetMethod("getUserAgent", &WebContents::GetUserAgent)
+      .SetMethod("insertCSS", &WebContents::InsertCSS)
+      .SetMethod("savePage", &WebContents::SavePage)
+      .SetMethod("openDevTools", &WebContents::OpenDevTools)
+      .SetMethod("closeDevTools", &WebContents::CloseDevTools)
+      .SetMethod("isDevToolsOpened", &WebContents::IsDevToolsOpened)
+      .SetMethod("isDevToolsFocused", &WebContents::IsDevToolsFocused)
+      .SetMethod("enableDeviceEmulation",
+                 &WebContents::EnableDeviceEmulation)
+      .SetMethod("disableDeviceEmulation",
+                 &WebContents::DisableDeviceEmulation)
+      .SetMethod("toggleDevTools", &WebContents::ToggleDevTools)
+      .SetMethod("inspectElement", &WebContents::InspectElement)
+      .SetMethod("setAudioMuted", &WebContents::SetAudioMuted)
+      .SetMethod("isAudioMuted", &WebContents::IsAudioMuted)
+      .SetMethod("undo", &WebContents::Undo)
+      .SetMethod("redo", &WebContents::Redo)
+      .SetMethod("cut", &WebContents::Cut)
+      .SetMethod("copy", &WebContents::Copy)
+      .SetMethod("paste", &WebContents::Paste)
+      .SetMethod("pasteAndMatchStyle", &WebContents::PasteAndMatchStyle)
+      .SetMethod("delete", &WebContents::Delete)
+      .SetMethod("selectAll", &WebContents::SelectAll)
+      .SetMethod("unselect", &WebContents::Unselect)
+      .SetMethod("replace", &WebContents::Replace)
+      .SetMethod("replaceMisspelling", &WebContents::ReplaceMisspelling)
+      .SetMethod("findInPage", &WebContents::FindInPage)
+      .SetMethod("stopFindInPage", &WebContents::StopFindInPage)
+      .SetMethod("focus", &WebContents::Focus)
+      .SetMethod("tabTraverse", &WebContents::TabTraverse)
+      .SetMethod("_send", &WebContents::SendIPCMessage)
+      .SetMethod("sendInputEvent", &WebContents::SendInputEvent)
+      .SetMethod("beginFrameSubscription",
+                 &WebContents::BeginFrameSubscription)
+      .SetMethod("endFrameSubscription", &WebContents::EndFrameSubscription)
+      .SetMethod("setSize", &WebContents::SetSize)
+      .SetMethod("isGuest", &WebContents::IsGuest)
+      .SetMethod("getWebPreferences", &WebContents::GetWebPreferences)
+      .SetMethod("getOwnerBrowserWindow", &WebContents::GetOwnerBrowserWindow)
+      .SetMethod("hasServiceWorker", &WebContents::HasServiceWorker)
+      .SetMethod("unregisterServiceWorker",
+                 &WebContents::UnregisterServiceWorker)
+      .SetMethod("inspectServiceWorker", &WebContents::InspectServiceWorker)
+      .SetMethod("print", &WebContents::Print)
+      .SetMethod("_printToPDF", &WebContents::PrintToPDF)
+      .SetMethod("addWorkSpace", &WebContents::AddWorkSpace)
+      .SetMethod("removeWorkSpace", &WebContents::RemoveWorkSpace)
+      .SetProperty("session", &WebContents::Session)
+      .SetProperty("hostWebContents", &WebContents::HostWebContents)
+      .SetProperty("devToolsWebContents", &WebContents::DevToolsWebContents)
+      .SetProperty("debugger", &WebContents::Debugger);
+}
+
+ElectronBrowserContext* WebContents::GetBrowserContext() const {
+  return static_cast<ElectronBrowserContext*>(web_contents()->GetBrowserContext());
+}
+
+void WebContents::OnRendererMessage(const base::string16& channel,
+                                    const base::ListValue& args) {
+  // webContents.emit(channel, new Event(), args...);
+  Emit(base::UTF16ToUTF8(channel), args);
+}
+
+void WebContents::OnRendererMessageSync(const base::string16& channel,
+                                        const base::ListValue& args,
+                                        IPC::Message* message) {
+  // webContents.emit(channel, new Event(sender, message), args...);
+  EmitWithSender(base::UTF16ToUTF8(channel), web_contents(), message, args);
+}
+
+// static
+mate::Handle<WebContents> WebContents::CreateFrom(
+    v8::Isolate* isolate, content::WebContents* web_contents) {
+  // We have an existing WebContents object in JS.
+  auto existing = TrackableObject::FromWrappedClass(isolate, web_contents);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<WebContents*>(existing));
+
+  // Otherwise create a new WebContents wrapper object.
+  auto handle = mate::CreateHandle(isolate, new WebContents(web_contents));
+  g_wrap_web_contents.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+mate::Handle<WebContents> WebContents::Create(
+    v8::Isolate* isolate, const mate::Dictionary& options) {
+  auto handle = mate::CreateHandle(isolate, new WebContents(isolate, options));
+  g_wrap_web_contents.Run(handle.ToV8());
+  return handle;
+}
+
+void ClearWrapWebContents() {
+  g_wrap_web_contents.Reset();
+}
+
+void SetWrapWebContents(const WrapWebContentsCallback& callback) {
+  g_wrap_web_contents = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapWebContents));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("create", &electron::api::WebContents::Create);
+  dict.SetMethod("_setWrapWebContents", &electron::api::SetWrapWebContents);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_web_contents, Initialize)
added in remote
  their  100644 f09e9597d1527a9e114c3de147708582ef6790dd electron/browser/api/electron_api_web_contents.h
@@ -0,0 +1,311 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/frame_subscriber.h"
+#include "electron/browser/api/save_page_handler.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/common_web_contents_delegate.h"
+#include "content/public/browser/web_contents_observer.h"
+#include "content/public/common/favicon_url.h"
+#include "content/common/cursors/webcursor.h"
+#include "native_mate/handle.h"
+#include "ui/gfx/image/image.h"
+
+namespace blink {
+struct WebDeviceEmulationParams;
+}
+
+namespace brightray {
+class InspectableWebContents;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+struct SetSizeParams;
+class ElectronBrowserContext;
+class WebViewGuestDelegate;
+
+namespace api {
+
+class WebContents : public mate::TrackableObject<WebContents>,
+                    public CommonWebContentsDelegate,
+                    public content::WebContentsObserver {
+ public:
+  // For node.js callback function type: function(error, buffer)
+  using PrintToPDFCallback =
+      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
+
+  // Create from an existing WebContents.
+  static mate::Handle<WebContents> CreateFrom(
+      v8::Isolate* isolate, content::WebContents* web_contents);
+
+  // Create a new WebContents.
+  static mate::Handle<WebContents> Create(
+      v8::Isolate* isolate, const mate::Dictionary& options);
+
+  int GetID() const;
+  bool Equal(const WebContents* web_contents) const;
+  void LoadURL(const GURL& url, const mate::Dictionary& options);
+  void DownloadURL(const GURL& url);
+  GURL GetURL() const;
+  base::string16 GetTitle() const;
+  bool IsLoading() const;
+  bool IsWaitingForResponse() const;
+  void Stop();
+  void ReloadIgnoringCache();
+  void GoBack();
+  void GoForward();
+  void GoToOffset(int offset);
+  bool IsCrashed() const;
+  void SetUserAgent(const std::string& user_agent);
+  std::string GetUserAgent();
+  void InsertCSS(const std::string& css);
+  bool SavePage(const base::FilePath& full_file_path,
+                const content::SavePageType& save_type,
+                const SavePageHandler::SavePageCallback& callback);
+  void OpenDevTools(mate::Arguments* args);
+  void CloseDevTools();
+  bool IsDevToolsOpened();
+  bool IsDevToolsFocused();
+  void ToggleDevTools();
+  void EnableDeviceEmulation(const blink::WebDeviceEmulationParams& params);
+  void DisableDeviceEmulation();
+  void InspectElement(int x, int y);
+  void InspectServiceWorker();
+  void HasServiceWorker(const base::Callback<void(bool)>&);
+  void UnregisterServiceWorker(const base::Callback<void(bool)>&);
+  void SetAudioMuted(bool muted);
+  bool IsAudioMuted();
+  void Print(mate::Arguments* args);
+
+  // Print current page as PDF.
+  void PrintToPDF(const base::DictionaryValue& setting,
+                  const PrintToPDFCallback& callback);
+
+  // DevTools workspace api.
+  void AddWorkSpace(mate::Arguments* args, const base::FilePath& path);
+  void RemoveWorkSpace(mate::Arguments* args, const base::FilePath& path);
+
+  // Editing commands.
+  void Undo();
+  void Redo();
+  void Cut();
+  void Copy();
+  void Paste();
+  void PasteAndMatchStyle();
+  void Delete();
+  void SelectAll();
+  void Unselect();
+  void Replace(const base::string16& word);
+  void ReplaceMisspelling(const base::string16& word);
+  uint32_t FindInPage(mate::Arguments* args);
+  void StopFindInPage(content::StopFindAction action);
+
+  // Focus.
+  void Focus();
+  void TabTraverse(bool reverse);
+
+  // Send messages to browser.
+  bool SendIPCMessage(const base::string16& channel,
+                      const base::ListValue& args);
+
+  // Send WebInputEvent to the page.
+  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);
+
+  // Subscribe to the frame updates.
+  void BeginFrameSubscription(
+      const FrameSubscriber::FrameCaptureCallback& callback);
+  void EndFrameSubscription();
+
+  // Methods for creating <webview>.
+  void SetSize(const SetSizeParams& params);
+  bool IsGuest() const;
+
+  // Callback triggered on permission response.
+  void OnEnterFullscreenModeForTab(content::WebContents* source,
+                                   const GURL& origin,
+                                   bool allowed);
+
+  // Returns the web preferences of current WebContents.
+  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate);
+
+  // Returns the owner window.
+  v8::Local<v8::Value> GetOwnerBrowserWindow();
+
+  // Properties.
+  v8::Local<v8::Value> Session(v8::Isolate* isolate);
+  content::WebContents* HostWebContents();
+  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);
+  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit WebContents(content::WebContents* web_contents);
+  WebContents(v8::Isolate* isolate, const mate::Dictionary& options);
+  ~WebContents();
+
+  // content::WebContentsDelegate:
+  bool AddMessageToConsole(content::WebContents* source,
+                           int32_t level,
+                           const base::string16& message,
+                           int32_t line_no,
+                           const base::string16& source_id) override;
+  bool ShouldCreateWebContents(
+      content::WebContents* web_contents,
+      int32_t route_id,
+      int32_t main_frame_route_id,
+      int32_t main_frame_widget_route_id,
+      WindowContainerType window_container_type,
+      const std::string& frame_name,
+      const GURL& target_url,
+      const std::string& partition_id,
+      content::SessionStorageNamespace* session_storage_namespace) override;
+  content::WebContents* OpenURLFromTab(
+      content::WebContents* source,
+      const content::OpenURLParams& params) override;
+  void BeforeUnloadFired(content::WebContents* tab,
+                         bool proceed,
+                         bool* proceed_to_fire_unload) override;
+  void MoveContents(content::WebContents* source,
+                    const gfx::Rect& pos) override;
+  void CloseContents(content::WebContents* source) override;
+  void ActivateContents(content::WebContents* contents) override;
+  bool IsPopupOrPanel(const content::WebContents* source) const override;
+  void HandleKeyboardEvent(
+      content::WebContents* source,
+      const content::NativeWebKeyboardEvent& event) override;
+  void EnterFullscreenModeForTab(content::WebContents* source,
+                                 const GURL& origin) override;
+  void ExitFullscreenModeForTab(content::WebContents* source) override;
+  void RendererUnresponsive(content::WebContents* source) override;
+  void RendererResponsive(content::WebContents* source) override;
+  bool HandleContextMenu(const content::ContextMenuParams& params) override;
+  bool OnGoToEntryOffset(int offset) override;
+  void FindReply(content::WebContents* web_contents,
+                 int request_id,
+                 int number_of_matches,
+                 const gfx::Rect& selection_rect,
+                 int active_match_ordinal,
+                 bool final_update) override;
+  bool CheckMediaAccessPermission(
+      content::WebContents* web_contents,
+      const GURL& security_origin,
+      content::MediaStreamType type) override;
+  void RequestMediaAccessPermission(
+      content::WebContents* web_contents,
+      const content::MediaStreamRequest& request,
+      const content::MediaResponseCallback& callback) override;
+  void RequestToLockMouse(
+      content::WebContents* web_contents,
+      bool user_gesture,
+      bool last_unlocked_by_target) override;
+
+  // content::WebContentsObserver:
+  void BeforeUnloadFired(const base::TimeTicks& proceed_time) override;
+  void RenderViewDeleted(content::RenderViewHost*) override;
+  void RenderProcessGone(base::TerminationStatus status) override;
+  void DocumentLoadedInFrame(
+      content::RenderFrameHost* render_frame_host) override;
+  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                     const GURL& validated_url) override;
+  void DidFailLoad(content::RenderFrameHost* render_frame_host,
+                   const GURL& validated_url,
+                   int error_code,
+                   const base::string16& error_description,
+                   bool was_ignored_by_handler) override;
+  void DidFailProvisionalLoad(content::RenderFrameHost* render_frame_host,
+                              const GURL& validated_url,
+                              int error_code,
+                              const base::string16& error_description,
+                              bool was_ignored_by_handler) override;
+  void DidStartLoading() override;
+  void DidStopLoading() override;
+  void DidGetResourceResponseStart(
+      const content::ResourceRequestDetails& details) override;
+  void DidGetRedirectForResourceRequest(
+      content::RenderFrameHost* render_frame_host,
+      const content::ResourceRedirectDetails& details) override;
+  void DidNavigateMainFrame(
+      const content::LoadCommittedDetails& details,
+      const content::FrameNavigateParams& params) override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+  void WebContentsDestroyed() override;
+  void NavigationEntryCommitted(
+      const content::LoadCommittedDetails& load_details) override;
+  void TitleWasSet(content::NavigationEntry* entry, bool explicit_set) override;
+  void DidUpdateFaviconURL(
+      const std::vector<content::FaviconURL>& urls) override;
+  void PluginCrashed(const base::FilePath& plugin_path,
+                     base::ProcessId plugin_pid) override;
+  void MediaStartedPlaying(const MediaPlayerId& id) override;
+  void MediaStoppedPlaying(const MediaPlayerId& id) override;
+  void DidChangeThemeColor(SkColor theme_color) override;
+
+  // brightray::InspectableWebContentsViewDelegate:
+  void DevToolsFocused() override;
+  void DevToolsOpened() override;
+  void DevToolsClosed() override;
+
+ private:
+  enum Type {
+    BROWSER_WINDOW,  // Used by BrowserWindow.
+    WEB_VIEW,  // Used by <webview>.
+    REMOTE,  // Thin wrap around an existing WebContents.
+  };
+
+  ElectronBrowserContext* GetBrowserContext() const;
+
+  uint32_t GetNextRequestId() {
+    return ++request_id_;
+  }
+
+  // Called when we receive a CursorChange message from chromium.
+  void OnCursorChange(const content::WebCursor& cursor);
+
+  // Called when received a message from renderer.
+  void OnRendererMessage(const base::string16& channel,
+                         const base::ListValue& args);
+
+  // Called when received a synchronous message from renderer.
+  void OnRendererMessageSync(const base::string16& channel,
+                             const base::ListValue& args,
+                             IPC::Message* message);
+
+  v8::Global<v8::Value> session_;
+  v8::Global<v8::Value> devtools_web_contents_;
+  v8::Global<v8::Value> debugger_;
+
+  scoped_ptr<WebViewGuestDelegate> guest_delegate_;
+
+  // The host webcontents that may contain this webcontents.
+  WebContents* embedder_;
+
+  // The type of current WebContents.
+  Type type_;
+
+  // Request id used for findInPage request.
+  uint32_t request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContents);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
added in remote
  their  100644 36ec558ef11671cb3177ed3ce0db619816f6d6c8 electron/browser/api/electron_api_web_request.cc
@@ -0,0 +1,119 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_request.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+template<>
+struct Converter<extensions::URLPattern> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     extensions::URLPattern* out) {
+    std::string pattern;
+    if (!ConvertFromV8(isolate, val, &pattern))
+      return false;
+    return out->Parse(pattern) == extensions::URLPattern::PARSE_SUCCESS;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+WebRequest::WebRequest(ElectronBrowserContext* browser_context)
+    : browser_context_(browser_context) {
+}
+
+WebRequest::~WebRequest() {
+}
+
+template<ElectronNetworkDelegate::SimpleEvent type>
+void WebRequest::SetSimpleListener(mate::Arguments* args) {
+  SetListener<ElectronNetworkDelegate::SimpleListener>(
+      &ElectronNetworkDelegate::SetSimpleListenerInIO, type, args);
+}
+
+template<ElectronNetworkDelegate::ResponseEvent type>
+void WebRequest::SetResponseListener(mate::Arguments* args) {
+  SetListener<ElectronNetworkDelegate::ResponseListener>(
+      &ElectronNetworkDelegate::SetResponseListenerInIO, type, args);
+}
+
+template<typename Listener, typename Method, typename Event>
+void WebRequest::SetListener(Method method, Event type, mate::Arguments* args) {
+  // { urls }.
+  URLPatterns patterns;
+  mate::Dictionary dict;
+  args->GetNext(&dict) && dict.Get("urls", &patterns);
+
+  // Function or null.
+  v8::Local<v8::Value> value;
+  Listener listener;
+  if (!args->GetNext(&listener) &&
+      !(args->GetNext(&value) && value->IsNull())) {
+    args->ThrowError("Must pass null or a Function");
+    return;
+  }
+
+  auto delegate = browser_context_->network_delegate();
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::Bind(method, base::Unretained(delegate), type,
+                                     patterns, listener));
+}
+
+// static
+mate::Handle<WebRequest> WebRequest::Create(
+    v8::Isolate* isolate,
+    ElectronBrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new WebRequest(browser_context));
+}
+
+// static
+void WebRequest::BuildPrototype(v8::Isolate* isolate,
+                                v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("onBeforeRequest",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnBeforeRequest>)
+      .SetMethod("onBeforeSendHeaders",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnBeforeSendHeaders>)
+      .SetMethod("onHeadersReceived",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnHeadersReceived>)
+      .SetMethod("onSendHeaders",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnSendHeaders>)
+      .SetMethod("onBeforeRedirect",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnBeforeRedirect>)
+      .SetMethod("onResponseStarted",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnResponseStarted>)
+      .SetMethod("onCompleted",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnCompleted>)
+      .SetMethod("onErrorOccurred",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnErrorOccurred>);
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 3005158188cbd7ed36cc99afc41967271f94a6a6 electron/browser/api/electron_api_web_request.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "native_mate/arguments.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+namespace api {
+
+class WebRequest : public mate::TrackableObject<WebRequest> {
+ public:
+  static mate::Handle<WebRequest> Create(v8::Isolate* isolate,
+                                         ElectronBrowserContext* browser_context);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit WebRequest(ElectronBrowserContext* browser_context);
+  ~WebRequest();
+
+  // C++ can not distinguish overloaded member function.
+  template<ElectronNetworkDelegate::SimpleEvent type>
+  void SetSimpleListener(mate::Arguments* args);
+  template<ElectronNetworkDelegate::ResponseEvent type>
+  void SetResponseListener(mate::Arguments* args);
+  template<typename Listener, typename Method, typename Event>
+  void SetListener(Method method, Event type, mate::Arguments* args);
+
+ private:
+  scoped_refptr<ElectronBrowserContext> browser_context_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebRequest);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
added in remote
  their  100644 8596ac2369a3f6515cd799a0ec8dd250dc3b639f electron/browser/api/electron_api_web_view_manager.cc
@@ -0,0 +1,71 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/web_view_manager.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "content/public/browser/browser_context.h"
+#include "native_mate/dictionary.h"
+
+using electron::WebContentsPreferences;
+
+namespace mate {
+
+template<>
+struct Converter<content::WebContents*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::WebContents** out) {
+    electron::api::WebContents* contents;
+    if (!Converter<electron::api::WebContents*>::FromV8(isolate, val, &contents))
+      return false;
+    *out = contents->web_contents();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+electron::WebViewManager* GetWebViewManager(content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  if (context) {
+    auto manager = context->GetGuestManager();
+    return static_cast<electron::WebViewManager*>(manager);
+  } else {
+    return nullptr;
+  }
+}
+
+void AddGuest(int guest_instance_id,
+              int element_instance_id,
+              content::WebContents* embedder,
+              content::WebContents* guest_web_contents,
+              const base::DictionaryValue& options) {
+  auto manager = GetWebViewManager(embedder);
+  if (manager)
+    manager->AddGuest(guest_instance_id, element_instance_id, embedder,
+                      guest_web_contents);
+
+  WebContentsPreferences::FromWebContents(guest_web_contents)->Merge(options);
+}
+
+void RemoveGuest(content::WebContents* embedder, int guest_instance_id) {
+  auto manager = GetWebViewManager(embedder);
+  if (manager)
+    manager->RemoveGuest(guest_instance_id);
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("addGuest", &AddGuest);
+  dict.SetMethod("removeGuest", &RemoveGuest);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_web_view_manager, Initialize)
added in remote
  their  100644 f9994cdc079e2e9159e3328d7bc465e20ef3a5b1 electron/browser/api/electron_api_window.cc
@@ -0,0 +1,848 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "content/public/browser/render_process_host.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/geometry/rect.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/native_window_views.h"
+#include "electron/browser/ui/win/taskbar_host.h"
+#endif
+
+#if defined(OS_WIN)
+namespace mate {
+
+template<>
+struct Converter<electron::TaskbarHost::ThumbarButton> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     electron::TaskbarHost::ThumbarButton* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    dict.Get("click", &(out->clicked_callback));
+    dict.Get("tooltip", &(out->tooltip));
+    dict.Get("flags", &out->flags);
+    return dict.Get("icon", &(out->icon));
+  }
+};
+
+}  // namespace mate
+#endif
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// This function is implemented in JavaScript
+using DeprecatedOptionsCheckCallback =
+    base::Callback<std::string(v8::Local<v8::Value>)>;
+DeprecatedOptionsCheckCallback g_deprecated_options_check;
+
+void OnCapturePageDone(
+    v8::Isolate* isolate,
+    const base::Callback<void(const gfx::Image&)>& callback,
+    const SkBitmap& bitmap) {
+  v8::Locker locker(isolate);
+  v8::HandleScope handle_scope(isolate);
+  callback.Run(gfx::Image::CreateFrom1xBitmap(bitmap));
+}
+
+// Converts min-width to minWidth, returns false if no conversion is needed.
+bool TranslateOldKey(const std::string& key, std::string* new_key) {
+  if (key.find('-') == std::string::npos)
+    return false;
+  new_key->reserve(key.size());
+  bool next_upper_case = false;
+  for (char c : key) {
+    if (c == '-') {
+      next_upper_case = true;
+    } else if (next_upper_case) {
+      new_key->push_back(base::ToUpperASCII(c));
+      next_upper_case = false;
+    } else {
+      new_key->push_back(c);
+    }
+  }
+  return true;
+}
+
+// Converts min-width to minWidth recursively in the dictionary.
+void TranslateOldOptions(v8::Isolate* isolate, v8::Local<v8::Object> options) {
+  auto context = isolate->GetCurrentContext();
+  auto maybe_keys = options->GetOwnPropertyNames(context);
+  if (maybe_keys.IsEmpty())
+    return;
+  std::vector<std::string> keys;
+  if (!mate::ConvertFromV8(isolate, maybe_keys.ToLocalChecked(), &keys))
+    return;
+  mate::Dictionary dict(isolate, options);
+  for (const auto& key : keys) {
+    v8::Local<v8::Value> value;
+    if (!dict.Get(key, &value))  // Shouldn't happen, but guard it anyway.
+      continue;
+    // Go recursively.
+    v8::Local<v8::Object> sub_options;
+    if (mate::ConvertFromV8(isolate, value, &sub_options))
+      TranslateOldOptions(isolate, sub_options);
+    // Translate key.
+    std::string new_key;
+    if (TranslateOldKey(key, &new_key)) {
+      dict.Set(new_key, value);
+      dict.Delete(key);
+    }
+  }
+}
+
+// Converts binary data to Buffer.
+v8::Local<v8::Value> ToBuffer(v8::Isolate* isolate, void* val, int size) {
+  auto buffer = node::Buffer::Copy(isolate, static_cast<char*>(val), size);
+  if (buffer.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return buffer.ToLocalChecked();
+}
+
+}  // namespace
+
+
+Window::Window(v8::Isolate* isolate, const mate::Dictionary& options) {
+  // Be compatible with old style field names like min-width.
+  TranslateOldOptions(isolate, options.GetHandle());
+
+  // Use options.webPreferences to create WebContents.
+  mate::Dictionary web_preferences = mate::Dictionary::CreateEmpty(isolate);
+  options.Get(options::kWebPreferences, &web_preferences);
+
+  // Be compatible with old options which are now in web_preferences.
+  v8::Local<v8::Value> value;
+  if (options.Get(options::kNodeIntegration, &value))
+    web_preferences.Set(options::kNodeIntegration, value);
+  if (options.Get(options::kPreloadScript, &value))
+    web_preferences.Set(options::kPreloadScript, value);
+  if (options.Get(options::kZoomFactor, &value))
+    web_preferences.Set(options::kZoomFactor, value);
+
+  // Creates the WebContents used by BrowserWindow.
+  auto web_contents = WebContents::Create(isolate, web_preferences);
+  web_contents_.Reset(isolate, web_contents.ToV8());
+  api_web_contents_ = web_contents.get();
+
+  // Keep a copy of the options for later use.
+  mate::Dictionary(isolate, web_contents->GetWrapper(isolate)).Set(
+      "browserWindowOptions", options);
+
+  // Creates BrowserWindow.
+  window_.reset(NativeWindow::Create(web_contents->managed_web_contents(),
+                                     options));
+  web_contents->SetOwnerWindow(window_.get());
+  window_->InitFromOptions(options);
+  window_->AddObserver(this);
+  AttachAsUserData(window_.get());
+}
+
+Window::~Window() {
+  if (!window_->IsClosed())
+    window_->CloseContents(nullptr);
+
+  // Destroy the native window in next tick because the native code might be
+  // iterating all windows.
+  base::MessageLoop::current()->DeleteSoon(FROM_HERE, window_.release());
+}
+
+void Window::WillCloseWindow(bool* prevent_default) {
+  *prevent_default = Emit("close");
+}
+
+void Window::OnWindowClosed() {
+  api_web_contents_->DestroyWebContents();
+
+  RemoveFromWeakMap();
+  window_->RemoveObserver(this);
+
+  // We can not call Destroy here because we need to call Emit first, but we
+  // also do not want any method to be used, so just mark as destroyed here.
+  MarkDestroyed();
+
+  Emit("closed");
+
+  // Destroy the native class when window is closed.
+  base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+}
+
+void Window::OnWindowBlur() {
+  Emit("blur");
+}
+
+void Window::OnWindowFocus() {
+  Emit("focus");
+}
+
+void Window::OnWindowShow() {
+  Emit("show");
+}
+
+void Window::OnWindowHide() {
+  Emit("hide");
+}
+
+void Window::OnWindowMaximize() {
+  Emit("maximize");
+}
+
+void Window::OnWindowUnmaximize() {
+  Emit("unmaximize");
+}
+
+void Window::OnWindowMinimize() {
+  Emit("minimize");
+}
+
+void Window::OnWindowRestore() {
+  Emit("restore");
+}
+
+void Window::OnWindowResize() {
+  Emit("resize");
+}
+
+void Window::OnWindowMove() {
+  Emit("move");
+}
+
+void Window::OnWindowMoved() {
+  Emit("moved");
+}
+
+void Window::OnWindowEnterFullScreen() {
+  Emit("enter-full-screen");
+}
+
+void Window::OnWindowLeaveFullScreen() {
+  Emit("leave-full-screen");
+}
+
+void Window::OnWindowScrollTouchBegin() {
+  Emit("scroll-touch-begin");
+}
+
+void Window::OnWindowScrollTouchEnd() {
+  Emit("scroll-touch-end");
+}
+
+void Window::OnWindowSwipe(const std::string& direction) {
+  Emit("swipe", direction);
+}
+
+void Window::OnWindowEnterHtmlFullScreen() {
+  Emit("enter-html-full-screen");
+}
+
+void Window::OnWindowLeaveHtmlFullScreen() {
+  Emit("leave-html-full-screen");
+}
+
+void Window::OnRendererUnresponsive() {
+  Emit("unresponsive");
+}
+
+void Window::OnRendererResponsive() {
+  Emit("responsive");
+}
+
+void Window::OnExecuteWindowsCommand(const std::string& command_name) {
+  Emit("app-command", command_name);
+}
+
+#if defined(OS_WIN)
+void Window::OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {
+  if (IsWindowMessageHooked(message)) {
+    messages_callback_map_[message].Run(
+        ToBuffer(isolate(), static_cast<void*>(&w_param), sizeof(WPARAM)),
+        ToBuffer(isolate(), static_cast<void*>(&l_param), sizeof(LPARAM)));
+  }
+}
+#endif
+
+// static
+mate::Wrappable* Window::New(v8::Isolate* isolate, mate::Arguments* args) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Cannot create BrowserWindow before app is ready")));
+    return nullptr;
+  }
+
+  if (args->Length() > 1) {
+    args->ThrowError();
+    return nullptr;
+  }
+
+  mate::Dictionary options;
+  if (!(args->Length() == 1 && args->GetNext(&options))) {
+    options = mate::Dictionary::CreateEmpty(isolate);
+  }
+
+  std::string deprecation_message = g_deprecated_options_check.Run(
+      options.GetHandle());
+  if (deprecation_message.length() > 0) {
+    args->ThrowError(deprecation_message);
+    return nullptr;
+  }
+
+  return new Window(isolate, options);
+}
+
+void Window::Close() {
+  window_->Close();
+}
+
+void Window::Focus() {
+  window_->Focus(true);
+}
+
+void Window::Blur() {
+  window_->Focus(false);
+}
+
+bool Window::IsFocused() {
+  return window_->IsFocused();
+}
+
+void Window::Show() {
+  window_->Show();
+}
+
+void Window::ShowInactive() {
+  window_->ShowInactive();
+}
+
+void Window::Hide() {
+  window_->Hide();
+}
+
+bool Window::IsVisible() {
+  return window_->IsVisible();
+}
+
+void Window::Maximize() {
+  window_->Maximize();
+}
+
+void Window::Unmaximize() {
+  window_->Unmaximize();
+}
+
+bool Window::IsMaximized() {
+  return window_->IsMaximized();
+}
+
+void Window::Minimize() {
+  window_->Minimize();
+}
+
+void Window::Restore() {
+  window_->Restore();
+}
+
+bool Window::IsMinimized() {
+  return window_->IsMinimized();
+}
+
+void Window::SetFullScreen(bool fullscreen) {
+  window_->SetFullScreen(fullscreen);
+}
+
+bool Window::IsFullscreen() {
+  return window_->IsFullscreen();
+}
+
+void Window::SetBounds(const gfx::Rect& bounds, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetBounds(bounds, animate);
+}
+
+gfx::Rect Window::GetBounds() {
+  return window_->GetBounds();
+}
+
+void Window::SetSize(int width, int height, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetSize(gfx::Size(width, height), animate);
+}
+
+std::vector<int> Window::GetSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetContentSize(int width, int height, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetContentSize(gfx::Size(width, height), animate);
+}
+
+std::vector<int> Window::GetContentSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetContentSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetMinimumSize(int width, int height) {
+  window_->SetMinimumSize(gfx::Size(width, height));
+}
+
+std::vector<int> Window::GetMinimumSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetMinimumSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetMaximumSize(int width, int height) {
+  window_->SetMaximumSize(gfx::Size(width, height));
+}
+
+std::vector<int> Window::GetMaximumSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetMaximumSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetResizable(bool resizable) {
+  window_->SetResizable(resizable);
+}
+
+bool Window::IsResizable() {
+  return window_->IsResizable();
+}
+
+void Window::SetMovable(bool movable) {
+  window_->SetMovable(movable);
+}
+
+bool Window::IsMovable() {
+  return window_->IsMovable();
+}
+
+void Window::SetMinimizable(bool minimizable) {
+  window_->SetMinimizable(minimizable);
+}
+
+bool Window::IsMinimizable() {
+  return window_->IsMinimizable();
+}
+
+void Window::SetMaximizable(bool maximizable) {
+  window_->SetMaximizable(maximizable);
+}
+
+bool Window::IsMaximizable() {
+  return window_->IsMaximizable();
+}
+
+void Window::SetFullScreenable(bool fullscreenable) {
+  window_->SetFullScreenable(fullscreenable);
+}
+
+bool Window::IsFullScreenable() {
+  return window_->IsFullScreenable();
+}
+
+void Window::SetClosable(bool closable) {
+  window_->SetClosable(closable);
+}
+
+bool Window::IsClosable() {
+  return window_->IsClosable();
+}
+
+void Window::SetAlwaysOnTop(bool top) {
+  window_->SetAlwaysOnTop(top);
+}
+
+bool Window::IsAlwaysOnTop() {
+  return window_->IsAlwaysOnTop();
+}
+
+void Window::Center() {
+  window_->Center();
+}
+
+void Window::SetPosition(int x, int y, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetPosition(gfx::Point(x, y), animate);
+}
+
+std::vector<int> Window::GetPosition() {
+  std::vector<int> result(2);
+  gfx::Point pos = window_->GetPosition();
+  result[0] = pos.x();
+  result[1] = pos.y();
+  return result;
+}
+
+void Window::SetTitle(const std::string& title) {
+  window_->SetTitle(title);
+}
+
+std::string Window::GetTitle() {
+  return window_->GetTitle();
+}
+
+void Window::FlashFrame(bool flash) {
+  window_->FlashFrame(flash);
+}
+
+void Window::SetSkipTaskbar(bool skip) {
+  window_->SetSkipTaskbar(skip);
+}
+
+void Window::SetKiosk(bool kiosk) {
+  window_->SetKiosk(kiosk);
+}
+
+bool Window::IsKiosk() {
+  return window_->IsKiosk();
+}
+
+void Window::SetBackgroundColor(const std::string& color_name) {
+  window_->SetBackgroundColor(color_name);
+}
+
+void Window::SetHasShadow(bool has_shadow) {
+  window_->SetHasShadow(has_shadow);
+}
+
+bool Window::HasShadow() {
+  return window_->HasShadow();
+}
+
+void Window::FocusOnWebView() {
+  window_->FocusOnWebView();
+}
+
+void Window::BlurWebView() {
+  window_->BlurWebView();
+}
+
+bool Window::IsWebViewFocused() {
+  return window_->IsWebViewFocused();
+}
+
+void Window::SetRepresentedFilename(const std::string& filename) {
+  window_->SetRepresentedFilename(filename);
+}
+
+std::string Window::GetRepresentedFilename() {
+  return window_->GetRepresentedFilename();
+}
+
+void Window::SetDocumentEdited(bool edited) {
+  window_->SetDocumentEdited(edited);
+}
+
+bool Window::IsDocumentEdited() {
+  return window_->IsDocumentEdited();
+}
+
+void Window::SetIgnoreMouseEvents(bool ignore) {
+  return window_->SetIgnoreMouseEvents(ignore);
+}
+
+void Window::CapturePage(mate::Arguments* args) {
+  gfx::Rect rect;
+  base::Callback<void(const gfx::Image&)> callback;
+
+  if (!(args->Length() == 1 && args->GetNext(&callback)) &&
+      !(args->Length() == 2 && args->GetNext(&rect)
+                            && args->GetNext(&callback))) {
+    args->ThrowError();
+    return;
+  }
+
+  window_->CapturePage(
+      rect, base::Bind(&OnCapturePageDone, args->isolate(), callback));
+}
+
+void Window::SetProgressBar(double progress) {
+  window_->SetProgressBar(progress);
+}
+
+void Window::SetOverlayIcon(const gfx::Image& overlay,
+                            const std::string& description) {
+  window_->SetOverlayIcon(overlay, description);
+}
+
+bool Window::SetThumbarButtons(mate::Arguments* args) {
+#if defined(OS_WIN)
+  std::vector<TaskbarHost::ThumbarButton> buttons;
+  if (!args->GetNext(&buttons)) {
+    args->ThrowError();
+    return false;
+  }
+  auto window = static_cast<NativeWindowViews*>(window_.get());
+  return window->taskbar_host().SetThumbarButtons(
+      window->GetAcceleratedWidget(), buttons);
+#else
+  return false;
+#endif
+}
+
+void Window::SetMenu(v8::Isolate* isolate, v8::Local<v8::Value> value) {
+  mate::Handle<Menu> menu;
+  if (value->IsObject() &&
+      mate::V8ToString(value->ToObject()->GetConstructorName()) == "Menu" &&
+      mate::ConvertFromV8(isolate, value, &menu)) {
+    menu_.Reset(isolate, menu.ToV8());
+    window_->SetMenu(menu->model());
+  } else if (value->IsNull()) {
+    menu_.Reset();
+    window_->SetMenu(nullptr);
+  } else {
+    isolate->ThrowException(v8::Exception::TypeError(
+        mate::StringToV8(isolate, "Invalid Menu")));
+  }
+}
+
+void Window::SetAutoHideMenuBar(bool auto_hide) {
+  window_->SetAutoHideMenuBar(auto_hide);
+}
+
+bool Window::IsMenuBarAutoHide() {
+  return window_->IsMenuBarAutoHide();
+}
+
+void Window::SetMenuBarVisibility(bool visible) {
+  window_->SetMenuBarVisibility(visible);
+}
+
+bool Window::IsMenuBarVisible() {
+  return window_->IsMenuBarVisible();
+}
+
+#if defined(OS_WIN)
+bool Window::HookWindowMessage(UINT message,
+                               const MessageCallback& callback) {
+  messages_callback_map_[message] = callback;
+  return true;
+}
+
+void Window::UnhookWindowMessage(UINT message) {
+  if (!ContainsKey(messages_callback_map_, message))
+    return;
+
+  messages_callback_map_.erase(message);
+}
+
+bool Window::IsWindowMessageHooked(UINT message) {
+  return ContainsKey(messages_callback_map_, message);
+}
+
+void Window::UnhookAllWindowMessages() {
+  messages_callback_map_.clear();
+}
+#endif
+
+#if defined(OS_MACOSX)
+void Window::ShowDefinitionForSelection() {
+  window_->ShowDefinitionForSelection();
+}
+#endif
+
+void Window::SetAspectRatio(double aspect_ratio, mate::Arguments* args) {
+  gfx::Size extra_size;
+  args->GetNext(&extra_size);
+  window_->SetAspectRatio(aspect_ratio, extra_size);
+}
+
+v8::Local<v8::Value> Window::GetNativeWindowHandle() {
+  gfx::AcceleratedWidget handle = window_->GetAcceleratedWidget();
+  return ToBuffer(
+      isolate(), static_cast<void*>(&handle), sizeof(gfx::AcceleratedWidget));
+}
+
+void Window::SetVisibleOnAllWorkspaces(bool visible) {
+  return window_->SetVisibleOnAllWorkspaces(visible);
+}
+
+bool Window::IsVisibleOnAllWorkspaces() {
+  return window_->IsVisibleOnAllWorkspaces();
+}
+
+int32_t Window::ID() const {
+  return weak_map_id();
+}
+
+v8::Local<v8::Value> Window::WebContents(v8::Isolate* isolate) {
+  if (web_contents_.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return v8::Local<v8::Value>::New(isolate, web_contents_);
+}
+
+// static
+void Window::BuildPrototype(v8::Isolate* isolate,
+                            v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("close", &Window::Close)
+      .SetMethod("focus", &Window::Focus)
+      .SetMethod("blur", &Window::Blur)
+      .SetMethod("isFocused", &Window::IsFocused)
+      .SetMethod("show", &Window::Show)
+      .SetMethod("showInactive", &Window::ShowInactive)
+      .SetMethod("hide", &Window::Hide)
+      .SetMethod("isVisible", &Window::IsVisible)
+      .SetMethod("maximize", &Window::Maximize)
+      .SetMethod("unmaximize", &Window::Unmaximize)
+      .SetMethod("isMaximized", &Window::IsMaximized)
+      .SetMethod("minimize", &Window::Minimize)
+      .SetMethod("restore", &Window::Restore)
+      .SetMethod("isMinimized", &Window::IsMinimized)
+      .SetMethod("setFullScreen", &Window::SetFullScreen)
+      .SetMethod("isFullScreen", &Window::IsFullscreen)
+      .SetMethod("setAspectRatio", &Window::SetAspectRatio)
+      .SetMethod("getNativeWindowHandle", &Window::GetNativeWindowHandle)
+      .SetMethod("getBounds", &Window::GetBounds)
+      .SetMethod("setBounds", &Window::SetBounds)
+      .SetMethod("getSize", &Window::GetSize)
+      .SetMethod("setSize", &Window::SetSize)
+      .SetMethod("getContentSize", &Window::GetContentSize)
+      .SetMethod("setContentSize", &Window::SetContentSize)
+      .SetMethod("setMinimumSize", &Window::SetMinimumSize)
+      .SetMethod("getMinimumSize", &Window::GetMinimumSize)
+      .SetMethod("setMaximumSize", &Window::SetMaximumSize)
+      .SetMethod("getMaximumSize", &Window::GetMaximumSize)
+      .SetMethod("setResizable", &Window::SetResizable)
+      .SetMethod("isResizable", &Window::IsResizable)
+      .SetMethod("setMovable", &Window::SetMovable)
+      .SetMethod("isMovable", &Window::IsMovable)
+      .SetMethod("setMinimizable", &Window::SetMinimizable)
+      .SetMethod("isMinimizable", &Window::IsMinimizable)
+      .SetMethod("setMaximizable", &Window::SetMaximizable)
+      .SetMethod("isMaximizable", &Window::IsMaximizable)
+      .SetMethod("setFullScreenable", &Window::SetFullScreenable)
+      .SetMethod("isFullScreenable", &Window::IsFullScreenable)
+      .SetMethod("setClosable", &Window::SetClosable)
+      .SetMethod("isClosable", &Window::IsClosable)
+      .SetMethod("setAlwaysOnTop", &Window::SetAlwaysOnTop)
+      .SetMethod("isAlwaysOnTop", &Window::IsAlwaysOnTop)
+      .SetMethod("center", &Window::Center)
+      .SetMethod("setPosition", &Window::SetPosition)
+      .SetMethod("getPosition", &Window::GetPosition)
+      .SetMethod("setTitle", &Window::SetTitle)
+      .SetMethod("getTitle", &Window::GetTitle)
+      .SetMethod("flashFrame", &Window::FlashFrame)
+      .SetMethod("setSkipTaskbar", &Window::SetSkipTaskbar)
+      .SetMethod("setKiosk", &Window::SetKiosk)
+      .SetMethod("isKiosk", &Window::IsKiosk)
+      .SetMethod("setBackgroundColor", &Window::SetBackgroundColor)
+      .SetMethod("setHasShadow", &Window::SetHasShadow)
+      .SetMethod("hasShadow", &Window::HasShadow)
+      .SetMethod("setRepresentedFilename", &Window::SetRepresentedFilename)
+      .SetMethod("getRepresentedFilename", &Window::GetRepresentedFilename)
+      .SetMethod("setDocumentEdited", &Window::SetDocumentEdited)
+      .SetMethod("isDocumentEdited", &Window::IsDocumentEdited)
+      .SetMethod("setIgnoreMouseEvents", &Window::SetIgnoreMouseEvents)
+      .SetMethod("focusOnWebView", &Window::FocusOnWebView)
+      .SetMethod("blurWebView", &Window::BlurWebView)
+      .SetMethod("isWebViewFocused", &Window::IsWebViewFocused)
+      .SetMethod("capturePage", &Window::CapturePage)
+      .SetMethod("setProgressBar", &Window::SetProgressBar)
+      .SetMethod("setOverlayIcon", &Window::SetOverlayIcon)
+      .SetMethod("setThumbarButtons", &Window::SetThumbarButtons)
+      .SetMethod("setMenu", &Window::SetMenu)
+      .SetMethod("setAutoHideMenuBar", &Window::SetAutoHideMenuBar)
+      .SetMethod("isMenuBarAutoHide", &Window::IsMenuBarAutoHide)
+      .SetMethod("setMenuBarVisibility", &Window::SetMenuBarVisibility)
+      .SetMethod("isMenuBarVisible", &Window::IsMenuBarVisible)
+      .SetMethod("setVisibleOnAllWorkspaces",
+                 &Window::SetVisibleOnAllWorkspaces)
+      .SetMethod("isVisibleOnAllWorkspaces",
+                 &Window::IsVisibleOnAllWorkspaces)
+#if defined(OS_WIN)
+      .SetMethod("hookWindowMessage", &Window::HookWindowMessage)
+      .SetMethod("isWindowMessageHooked", &Window::IsWindowMessageHooked)
+      .SetMethod("unhookWindowMessage", &Window::UnhookWindowMessage)
+      .SetMethod("unhookAllWindowMessages", &Window::UnhookAllWindowMessages)
+#endif
+#if defined(OS_MACOSX)
+      .SetMethod("showDefinitionForSelection",
+                 &Window::ShowDefinitionForSelection)
+#endif
+      .SetProperty("id", &Window::ID)
+      .SetProperty("webContents", &Window::WebContents);
+}
+
+// static
+v8::Local<v8::Value> Window::From(v8::Isolate* isolate,
+                                  NativeWindow* native_window) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, native_window);
+  if (existing)
+    return existing->GetWrapper(isolate);
+  else
+    return v8::Null(isolate);
+}
+
+void SetDeprecatedOptionsCheck(const DeprecatedOptionsCheckCallback& callback) {
+  g_deprecated_options_check = callback;
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+using electron::api::Window;
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Window>(
+      isolate, "BrowserWindow", base::Bind(&Window::New));
+  mate::Dictionary browser_window(isolate, constructor);
+  browser_window.SetMethod("fromId",
+                           &mate::TrackableObject<Window>::FromWeakMapID);
+  browser_window.SetMethod("getAllWindows",
+                           &mate::TrackableObject<Window>::GetAll);
+
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("BrowserWindow", browser_window);
+  dict.SetMethod("_setDeprecatedOptionsCheck",
+                 &electron::api::SetDeprecatedOptionsCheck);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_window, Initialize)
added in remote
  their  100644 bf2bb09510456036dfc5f501f39f871e40b59437 electron/browser/api/electron_api_window.h
@@ -0,0 +1,222 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "ui/gfx/image/image.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/native_window_observer.h"
+#include "native_mate/handle.h"
+
+class GURL;
+
+namespace gfx {
+class Rect;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+namespace api {
+
+class WebContents;
+
+class Window : public mate::TrackableObject<Window>,
+               public NativeWindowObserver {
+ public:
+  static mate::Wrappable* New(v8::Isolate* isolate, mate::Arguments* args);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+  // Returns the BrowserWindow object from |native_window|.
+  static v8::Local<v8::Value> From(v8::Isolate* isolate,
+                                   NativeWindow* native_window);
+
+  NativeWindow* window() const { return window_.get(); }
+
+ protected:
+  Window(v8::Isolate* isolate, const mate::Dictionary& options);
+  virtual ~Window();
+
+  // NativeWindowObserver:
+  void WillCloseWindow(bool* prevent_default) override;
+  void OnWindowClosed() override;
+  void OnWindowBlur() override;
+  void OnWindowFocus() override;
+  void OnWindowShow() override;
+  void OnWindowHide() override;
+  void OnWindowMaximize() override;
+  void OnWindowUnmaximize() override;
+  void OnWindowMinimize() override;
+  void OnWindowRestore() override;
+  void OnWindowResize() override;
+  void OnWindowMove() override;
+  void OnWindowMoved() override;
+  void OnWindowScrollTouchBegin() override;
+  void OnWindowScrollTouchEnd() override;
+  void OnWindowSwipe(const std::string& direction) override;
+  void OnWindowEnterFullScreen() override;
+  void OnWindowLeaveFullScreen() override;
+  void OnWindowEnterHtmlFullScreen() override;
+  void OnWindowLeaveHtmlFullScreen() override;
+  void OnRendererUnresponsive() override;
+  void OnRendererResponsive() override;
+  void OnExecuteWindowsCommand(const std::string& command_name) override;
+
+  #if defined(OS_WIN)
+  void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) override;
+  #endif
+
+ private:
+  // APIs for NativeWindow.
+  void Close();
+  void Focus();
+  void Blur();
+  bool IsFocused();
+  void Show();
+  void ShowInactive();
+  void Hide();
+  bool IsVisible();
+  void Maximize();
+  void Unmaximize();
+  bool IsMaximized();
+  void Minimize();
+  void Restore();
+  bool IsMinimized();
+  void SetFullScreen(bool fullscreen);
+  bool IsFullscreen();
+  void SetBounds(const gfx::Rect& bounds, mate::Arguments* args);
+  gfx::Rect GetBounds();
+  void SetSize(int width, int height, mate::Arguments* args);
+  std::vector<int> GetSize();
+  void SetContentSize(int width, int height, mate::Arguments* args);
+  std::vector<int> GetContentSize();
+  void SetMinimumSize(int width, int height);
+  std::vector<int> GetMinimumSize();
+  void SetMaximumSize(int width, int height);
+  std::vector<int> GetMaximumSize();
+  void SetResizable(bool resizable);
+  bool IsResizable();
+  void SetMovable(bool movable);
+  bool IsMovable();
+  void SetMinimizable(bool minimizable);
+  bool IsMinimizable();
+  void SetMaximizable(bool maximizable);
+  bool IsMaximizable();
+  void SetFullScreenable(bool fullscreenable);
+  bool IsFullScreenable();
+  void SetClosable(bool closable);
+  bool IsClosable();
+  void SetAlwaysOnTop(bool top);
+  bool IsAlwaysOnTop();
+  void Center();
+  void SetPosition(int x, int y, mate::Arguments* args);
+  std::vector<int> GetPosition();
+  void SetTitle(const std::string& title);
+  std::string GetTitle();
+  void FlashFrame(bool flash);
+  void SetSkipTaskbar(bool skip);
+  void SetKiosk(bool kiosk);
+  bool IsKiosk();
+  void SetBackgroundColor(const std::string& color_name);
+  void SetHasShadow(bool has_shadow);
+  bool HasShadow();
+  void FocusOnWebView();
+  void BlurWebView();
+  bool IsWebViewFocused();
+  void SetRepresentedFilename(const std::string& filename);
+  std::string GetRepresentedFilename();
+  void SetDocumentEdited(bool edited);
+  bool IsDocumentEdited();
+  void SetIgnoreMouseEvents(bool ignore);
+  void CapturePage(mate::Arguments* args);
+  void SetProgressBar(double progress);
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description);
+  bool SetThumbarButtons(mate::Arguments* args);
+  void SetMenu(v8::Isolate* isolate, v8::Local<v8::Value> menu);
+  void SetAutoHideMenuBar(bool auto_hide);
+  bool IsMenuBarAutoHide();
+  void SetMenuBarVisibility(bool visible);
+  bool IsMenuBarVisible();
+  void SetAspectRatio(double aspect_ratio, mate::Arguments* args);
+  v8::Local<v8::Value> GetNativeWindowHandle();
+
+#if defined(OS_WIN)
+  typedef base::Callback<void(v8::Local<v8::Value>,
+                              v8::Local<v8::Value>)> MessageCallback;
+
+  bool HookWindowMessage(UINT message, const MessageCallback& callback);
+  bool IsWindowMessageHooked(UINT message);
+  void UnhookWindowMessage(UINT message);
+  void UnhookAllWindowMessages();
+#endif
+
+#if defined(OS_MACOSX)
+  void ShowDefinitionForSelection();
+#endif
+
+  void SetVisibleOnAllWorkspaces(bool visible);
+  bool IsVisibleOnAllWorkspaces();
+
+  int32_t ID() const;
+  v8::Local<v8::Value> WebContents(v8::Isolate* isolate);
+
+#if defined(OS_WIN)
+  typedef std::map<UINT, MessageCallback> MessageCallbackMap;
+  MessageCallbackMap messages_callback_map_;
+#endif
+
+  v8::Global<v8::Value> web_contents_;
+  v8::Global<v8::Value> menu_;
+
+  api::WebContents* api_web_contents_;
+
+  scoped_ptr<NativeWindow> window_;
+
+  DISALLOW_COPY_AND_ASSIGN(Window);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace mate {
+
+template<>
+struct Converter<electron::NativeWindow*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     electron::NativeWindow** out) {
+    // null would be tranfered to NULL.
+    if (val->IsNull()) {
+      *out = NULL;
+      return true;
+    }
+
+    electron::api::Window* window;
+    if (!Converter<electron::api::Window*>::FromV8(isolate, val, &window))
+      return false;
+    *out = window->window();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
added in remote
  their  100644 451955a1fd4dfc2e9c747f18f97444085b5e0382 electron/browser/api/event.cc
@@ -0,0 +1,72 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/event.h"
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "content/public/browser/web_contents.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+}  // namespace
+
+Event::Event()
+    : sender_(NULL),
+      message_(NULL) {
+}
+
+Event::~Event() {
+}
+
+ObjectTemplateBuilder Event::GetObjectTemplateBuilder(v8::Isolate* isolate) {
+  if (template_.IsEmpty())
+    template_.Reset(isolate, ObjectTemplateBuilder(isolate)
+        .SetMethod("preventDefault", &Event::PreventDefault)
+        .SetMethod("sendReply", &Event::SendReply)
+        .Build());
+
+  return ObjectTemplateBuilder(
+      isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+}
+
+void Event::SetSenderAndMessage(content::WebContents* sender,
+                                IPC::Message* message) {
+  DCHECK(!sender_);
+  DCHECK(!message_);
+  sender_ = sender;
+  message_ = message;
+
+  Observe(sender);
+}
+
+void Event::WebContentsDestroyed() {
+  sender_ = NULL;
+  message_ = NULL;
+}
+
+void Event::PreventDefault(v8::Isolate* isolate) {
+  GetWrapper(isolate)->Set(StringToV8(isolate, "defaultPrevented"),
+                           v8::True(isolate));
+}
+
+bool Event::SendReply(const base::string16& json) {
+  if (message_ == NULL || sender_ == NULL)
+    return false;
+
+  ElectronViewHostMsg_Message_Sync::WriteReplyParams(message_, json);
+  return sender_->Send(message_);
+}
+
+// static
+Handle<Event> Event::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new Event);
+}
+
+}  // namespace mate
added in remote
  their  100644 ebdb32a30dd1cdf76511405928c076638ca7a684 electron/browser/api/event.h
@@ -0,0 +1,52 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_EVENT_H_
+#define ELECTRON_BROWSER_API_EVENT_H_
+
+#include "content/public/browser/web_contents_observer.h"
+#include "native_mate/wrappable.h"
+#include "native_mate/handle.h"
+
+namespace IPC {
+class Message;
+}
+
+namespace mate {
+
+class Event : public Wrappable,
+              public content::WebContentsObserver {
+ public:
+  static Handle<Event> Create(v8::Isolate* isolate);
+
+  // Pass the sender and message to be replied.
+  void SetSenderAndMessage(content::WebContents* sender, IPC::Message* message);
+
+  // event.PreventDefault().
+  void PreventDefault(v8::Isolate* isolate);
+
+  // event.sendReply(json), used for replying synchronous message.
+  bool SendReply(const base::string16& json);
+
+ protected:
+  Event();
+  virtual ~Event();
+
+  // Wrappable implementations:
+  ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate* isolate) override;
+
+  // content::WebContentsObserver implementations:
+  void WebContentsDestroyed() override;
+
+ private:
+  // Replyer for the synchronous messages.
+  content::WebContents* sender_;
+  IPC::Message* message_;
+
+  DISALLOW_COPY_AND_ASSIGN(Event);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_EVENT_H_
added in remote
  their  100644 6ef8aa4249a2f735b4be616507291917ad99d309 electron/browser/api/event_emitter.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/event_emitter.h"
+
+#include "electron/browser/api/event.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> event_template;
+
+void PreventDefault(mate::Arguments* args) {
+  mate::Dictionary self(args->isolate(), args->GetThis());
+  self.Set("defaultPrevented", true);
+}
+
+// Create a pure JavaScript Event object.
+v8::Local<v8::Object> CreateEventObject(v8::Isolate* isolate) {
+  if (event_template.IsEmpty()) {
+    event_template.Reset(isolate, ObjectTemplateBuilder(isolate)
+        .SetMethod("preventDefault", &PreventDefault)
+        .Build());
+  }
+
+  return v8::Local<v8::ObjectTemplate>::New(
+      isolate, event_template)->NewInstance();
+}
+
+}  // namespace
+
+EventEmitter::EventEmitter() {
+}
+
+v8::Local<v8::Object> EventEmitter::CreateJSEvent(
+    v8::Isolate* isolate, content::WebContents* sender, IPC::Message* message) {
+  v8::Local<v8::Object> event;
+  bool use_native_event = sender && message;
+
+  if (use_native_event) {
+    mate::Handle<mate::Event> native_event = mate::Event::Create(isolate);
+    native_event->SetSenderAndMessage(sender, message);
+    event = v8::Local<v8::Object>::Cast(native_event.ToV8());
+  } else {
+    event = CreateEventObject(isolate);
+  }
+  mate::Dictionary(isolate, event).Set("sender", GetWrapper(isolate));
+  return event;
+}
+
+v8::Local<v8::Object> EventEmitter::CreateCustomEvent(
+    v8::Isolate* isolate, v8::Local<v8::Object> custom_event) {
+  v8::Local<v8::Object> event = CreateEventObject(isolate);
+  (void)event->SetPrototype(custom_event->CreationContext(), custom_event);
+  mate::Dictionary(isolate, event).Set("sender", GetWrapper(isolate));
+  return event;
+}
+
+}  // namespace mate
added in remote
  their  100644 87b03328073b5b2bc07e6888b41129761f878bc7 electron/browser/api/event_emitter.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_EVENT_EMITTER_H_
+#define ELECTRON_BROWSER_API_EVENT_EMITTER_H_
+
+#include <vector>
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "native_mate/wrappable.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace IPC {
+class Message;
+}
+
+namespace mate {
+
+// Provide helperers to emit event in JavaScript.
+class EventEmitter : public Wrappable {
+ public:
+  typedef std::vector<v8::Local<v8::Value>> ValueArray;
+
+  // this.emit(name, event, args...);
+  template<typename... Args>
+  bool EmitCustomEvent(const base::StringPiece& name,
+                       v8::Local<v8::Object> event,
+                       const Args&... args) {
+    return EmitWithEvent(name, CreateCustomEvent(isolate(), event), args...);
+  }
+
+  // this.emit(name, new Event(), args...);
+  template<typename... Args>
+  bool Emit(const base::StringPiece& name, const Args&... args) {
+    return EmitWithSender(name, nullptr, nullptr, args...);
+  }
+
+  // this.emit(name, new Event(sender, message), args...);
+  template<typename... Args>
+  bool EmitWithSender(const base::StringPiece& name,
+                      content::WebContents* sender,
+                      IPC::Message* message,
+                      const Args&... args) {
+    v8::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    v8::Local<v8::Object> event = CreateJSEvent(isolate(), sender, message);
+    return EmitWithEvent(name, event, args...);
+  }
+
+ protected:
+  EventEmitter();
+
+ private:
+  // this.emit(name, event, args...);
+  template<typename... Args>
+  bool EmitWithEvent(const base::StringPiece& name,
+                     v8::Local<v8::Object> event,
+                     const Args&... args) {
+    v8::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    EmitEvent(isolate(), GetWrapper(isolate()), name, event, args...);
+    return event->Get(
+        StringToV8(isolate(), "defaultPrevented"))->BooleanValue();
+  }
+
+  v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
+                                      content::WebContents* sender,
+                                      IPC::Message* message);
+  v8::Local<v8::Object> CreateCustomEvent(
+      v8::Isolate* isolate, v8::Local<v8::Object> event);
+
+  DISALLOW_COPY_AND_ASSIGN(EventEmitter);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_EVENT_EMITTER_H_
added in remote
  their  100644 cee31b6a620c068b728ced1a7c0242805767e2f2 electron/browser/api/frame_subscriber.cc
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/frame_subscriber.h"
+
+#include "base/bind.h"
+#include "electron/common/node_includes.h"
+#include "content/public/browser/render_widget_host.h"
+
+namespace electron {
+
+namespace api {
+
+FrameSubscriber::FrameSubscriber(v8::Isolate* isolate,
+                                 content::RenderWidgetHostView* view,
+                                 const FrameCaptureCallback& callback)
+    : isolate_(isolate), view_(view), callback_(callback), weak_factory_(this) {
+}
+
+bool FrameSubscriber::ShouldCaptureFrame(
+    const gfx::Rect& damage_rect,
+    base::TimeTicks present_time,
+    scoped_refptr<media::VideoFrame>* storage,
+    DeliverFrameCallback* callback) {
+  const auto host = view_ ? view_->GetRenderWidgetHost() : nullptr;
+  if (!view_ || !host)
+    return false;
+
+  const auto size = view_->GetVisibleViewportSize();
+
+  host->CopyFromBackingStore(
+      gfx::Rect(size),
+      size,
+      base::Bind(&FrameSubscriber::OnFrameDelivered,
+                 weak_factory_.GetWeakPtr(), callback_),
+      kBGRA_8888_SkColorType);
+
+  return false;
+}
+
+void FrameSubscriber::OnFrameDelivered(const FrameCaptureCallback& callback,
+  const SkBitmap& bitmap, content::ReadbackResponse response) {
+  if (bitmap.computeSize64() == 0)
+    return;
+
+  v8::Locker locker(isolate_);
+  v8::HandleScope handle_scope(isolate_);
+
+  size_t rgb_arr_size = bitmap.width() * bitmap.height() *
+    bitmap.bytesPerPixel();
+  v8::MaybeLocal<v8::Object> buffer = node::Buffer::New(isolate_, rgb_arr_size);
+  if (buffer.IsEmpty())
+    return;
+
+  bitmap.copyPixelsTo(
+    reinterpret_cast<uint8_t*>(node::Buffer::Data(buffer.ToLocalChecked())),
+    rgb_arr_size);
+
+  callback_.Run(buffer.ToLocalChecked());
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 321c75228c4989e90c5ae4a9068404e74f447144 electron/browser/api/frame_subscriber.h
@@ -0,0 +1,51 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
+#define ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
+
+#include "base/callback.h"
+#include "base/memory/weak_ptr.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/browser/render_widget_host_view_frame_subscriber.h"
+#include "content/public/browser/readback_types.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/geometry/size.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+namespace api {
+
+class FrameSubscriber : public content::RenderWidgetHostViewFrameSubscriber {
+ public:
+  using FrameCaptureCallback = base::Callback<void(v8::Local<v8::Value>)>;
+
+  FrameSubscriber(v8::Isolate* isolate,
+                  content::RenderWidgetHostView* view,
+                  const FrameCaptureCallback& callback);
+
+  bool ShouldCaptureFrame(const gfx::Rect& damage_rect,
+                          base::TimeTicks present_time,
+                          scoped_refptr<media::VideoFrame>* storage,
+                          DeliverFrameCallback* callback) override;
+
+ private:
+  void OnFrameDelivered(const FrameCaptureCallback& callback,
+    const SkBitmap& bitmap, content::ReadbackResponse response);
+
+  v8::Isolate* isolate_;
+  content::RenderWidgetHostView* view_;
+  FrameCaptureCallback callback_;
+
+  base::WeakPtrFactory<FrameSubscriber> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(FrameSubscriber);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
added in remote
  their  100644 a700d330290eda14e2375d86737be2d95df10875 electron/browser/api/save_page_handler.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/save_page_handler.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_context.h"
+#include "base/callback.h"
+#include "base/files/file_path.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+namespace api {
+
+SavePageHandler::SavePageHandler(content::WebContents* web_contents,
+                                 const SavePageCallback& callback)
+    : web_contents_(web_contents),
+      callback_(callback) {
+}
+
+SavePageHandler::~SavePageHandler() {
+}
+
+void SavePageHandler::OnDownloadCreated(content::DownloadManager* manager,
+                                        content::DownloadItem* item) {
+  // OnDownloadCreated is invoked during WebContents::SavePage, so the |item|
+  // here is the one stated by WebContents::SavePage.
+  item->AddObserver(this);
+}
+
+bool SavePageHandler::Handle(const base::FilePath& full_path,
+                             const content::SavePageType& save_type) {
+  auto download_manager = content::BrowserContext::GetDownloadManager(
+      web_contents_->GetBrowserContext());
+  download_manager->AddObserver(this);
+  // Chromium will create a 'foo_files' directory under the directory of saving
+  // page 'foo.html' for holding other resource files of 'foo.html'.
+  base::FilePath saved_main_directory_path = full_path.DirName().Append(
+      full_path.RemoveExtension().BaseName().value() +
+      FILE_PATH_LITERAL("_files"));
+  bool result = web_contents_->SavePage(full_path,
+                                        saved_main_directory_path,
+                                        save_type);
+  download_manager->RemoveObserver(this);
+  // If initialization fails which means fail to create |DownloadItem|, we need
+  // to delete the |SavePageHandler| instance to avoid memory-leak.
+  if (!result)
+    delete this;
+  return result;
+}
+
+void SavePageHandler::OnDownloadUpdated(content::DownloadItem* item) {
+  if (item->IsDone()) {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    if (item->GetState() == content::DownloadItem::COMPLETE) {
+      callback_.Run(v8::Null(isolate));
+    } else {
+      v8::Local<v8::String> error_message = v8::String::NewFromUtf8(
+          isolate, "Fail to save page");
+      callback_.Run(v8::Exception::Error(error_message));
+    }
+    Destroy(item);
+  }
+}
+
+void SavePageHandler::Destroy(content::DownloadItem* item) {
+  item->RemoveObserver(this);
+  delete this;
+}
+
+// static
+bool SavePageHandler::IsSavePageTypes(const std::string& type) {
+  return type == "multipart/related" || type == "text/html";
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 54829cb2ee0d8770de6e8b4f70aa0286a16a31a7 electron/browser/api/save_page_handler.h
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
+#define ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
+
+#include <string>
+
+#include "content/public/browser/download_item.h"
+#include "content/public/browser/download_manager.h"
+#include "content/public/browser/save_page_type.h"
+#include "v8/include/v8.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace content {
+class WebContents;
+}
+
+namespace electron {
+
+namespace api {
+
+// A self-destroyed class for handling save page request.
+class SavePageHandler : public content::DownloadManager::Observer,
+                        public content::DownloadItem::Observer {
+ public:
+  using SavePageCallback = base::Callback<void(v8::Local<v8::Value>)>;
+
+  SavePageHandler(content::WebContents* web_contents,
+                  const SavePageCallback& callback);
+  ~SavePageHandler();
+
+  bool Handle(const base::FilePath& full_path,
+              const content::SavePageType& save_type);
+
+  static bool IsSavePageTypes(const std::string& type);
+
+ private:
+  void Destroy(content::DownloadItem* item);
+
+  // content::DownloadManager::Observer:
+  void OnDownloadCreated(content::DownloadManager* manager,
+                         content::DownloadItem* item) override;
+
+  // content::DownloadItem::Observer:
+  void OnDownloadUpdated(content::DownloadItem* item) override;
+
+  content::WebContents* web_contents_;  // weak
+  SavePageCallback callback_;
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
added in remote
  their  100644 9f71c3432d26ba91a9445258917ffce7806ea189 electron/browser/api/trackable_object.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/trackable_object.h"
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "base/bind.h"
+#include "base/supports_user_data.h"
+
+namespace mate {
+
+namespace {
+
+const char* kTrackedObjectKey = "TrackedObjectKey";
+
+class IDUserData : public base::SupportsUserData::Data {
+ public:
+  explicit IDUserData(int32_t id) : id_(id) {}
+
+  operator int32_t() const { return id_; }
+
+ private:
+  int32_t id_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDUserData);
+};
+
+}  // namespace
+
+TrackableObjectBase::TrackableObjectBase()
+    : weak_map_id_(0), wrapped_(nullptr), weak_factory_(this) {
+  cleanup_ = RegisterDestructionCallback(GetDestroyClosure());
+}
+
+TrackableObjectBase::~TrackableObjectBase() {
+  cleanup_.Run();
+}
+
+void TrackableObjectBase::AfterInit(v8::Isolate* isolate) {
+  if (wrapped_)
+    AttachAsUserData(wrapped_);
+}
+
+void TrackableObjectBase::MarkDestroyed() {
+  GetWrapper(isolate())->SetAlignedPointerInInternalField(0, nullptr);
+}
+
+base::Closure TrackableObjectBase::GetDestroyClosure() {
+  return base::Bind(&TrackableObjectBase::Destroy, weak_factory_.GetWeakPtr());
+}
+
+void TrackableObjectBase::Destroy() {
+  delete this;
+}
+
+void TrackableObjectBase::AttachAsUserData(base::SupportsUserData* wrapped) {
+  if (weak_map_id_ != 0) {
+    wrapped->SetUserData(kTrackedObjectKey, new IDUserData(weak_map_id_));
+    wrapped_ = nullptr;
+  } else {
+    // If the TrackableObjectBase is not ready yet then delay SetUserData until
+    // AfterInit is called.
+    wrapped_ = wrapped;
+  }
+}
+
+// static
+int32_t TrackableObjectBase::GetIDFromWrappedClass(base::SupportsUserData* w) {
+  auto id = static_cast<IDUserData*>(w->GetUserData(kTrackedObjectKey));
+  if (id)
+    return *id;
+  else
+    return 0;
+}
+
+// static
+base::Closure TrackableObjectBase::RegisterDestructionCallback(
+    const base::Closure& c) {
+  return electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(c);
+}
+
+}  // namespace mate
added in remote
  their  100644 31db58795e0ea1b58d72fc993d934d8b3d60b2b7 electron/browser/api/trackable_object.h
@@ -0,0 +1,156 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
+#define ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
+
+#include <vector>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/common/id_weak_map.h"
+#include "base/bind.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "native_mate/object_template_builder.h"
+
+namespace base {
+class SupportsUserData;
+}
+
+namespace mate {
+
+// Users should use TrackableObject instead.
+class TrackableObjectBase : public mate::EventEmitter {
+ public:
+  TrackableObjectBase();
+
+  // The ID in weak map.
+  int32_t weak_map_id() const { return weak_map_id_; }
+
+  // Wrap TrackableObject into a class that SupportsUserData.
+  void AttachAsUserData(base::SupportsUserData* wrapped);
+
+ protected:
+  ~TrackableObjectBase() override;
+
+  // mate::Wrappable:
+  void AfterInit(v8::Isolate* isolate) override;
+
+  // Mark the JS object as destroyed.
+  void MarkDestroyed();
+
+  // Returns a closure that can destroy the native class.
+  base::Closure GetDestroyClosure();
+
+  // Get the weak_map_id from SupportsUserData.
+  static int32_t GetIDFromWrappedClass(base::SupportsUserData* wrapped);
+
+  // Register a callback that should be destroyed before JavaScript environment
+  // gets destroyed.
+  static base::Closure RegisterDestructionCallback(const base::Closure& c);
+
+  int32_t weak_map_id_;
+  base::SupportsUserData* wrapped_;
+
+ private:
+  void Destroy();
+
+  base::Closure cleanup_;
+  base::WeakPtrFactory<TrackableObjectBase> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrackableObjectBase);
+};
+
+// All instances of TrackableObject will be kept in a weak map and can be got
+// from its ID.
+template<typename T>
+class TrackableObject : public TrackableObjectBase {
+ public:
+  // Finds out the TrackableObject from its ID in weak map.
+  static T* FromWeakMapID(v8::Isolate* isolate, int32_t id) {
+    if (!weak_map_)
+      return nullptr;
+
+    v8::MaybeLocal<v8::Object> object = weak_map_->Get(isolate, id);
+    if (object.IsEmpty())
+      return nullptr;
+
+    T* self = nullptr;
+    mate::ConvertFromV8(isolate, object.ToLocalChecked(), &self);
+    return self;
+  }
+
+  // Finds out the TrackableObject from the class it wraps.
+  static T* FromWrappedClass(v8::Isolate* isolate,
+                             base::SupportsUserData* wrapped) {
+    int32_t id = GetIDFromWrappedClass(wrapped);
+    if (!id)
+      return nullptr;
+    return FromWeakMapID(isolate, id);
+  }
+
+  // Returns all objects in this class's weak map.
+  static std::vector<v8::Local<v8::Object>> GetAll(v8::Isolate* isolate) {
+    if (weak_map_)
+      return weak_map_->Values(isolate);
+    else
+      return std::vector<v8::Local<v8::Object>>();
+  }
+
+  // Removes this instance from the weak map.
+  void RemoveFromWeakMap() {
+    if (weak_map_ && weak_map_->Has(weak_map_id()))
+      weak_map_->Remove(weak_map_id());
+  }
+
+ protected:
+  TrackableObject() {}
+  ~TrackableObject() override {
+    RemoveFromWeakMap();
+  }
+
+  void AfterInit(v8::Isolate* isolate) override {
+    if (!weak_map_) {
+      weak_map_.reset(new electron::IDWeakMap);
+      RegisterDestructionCallback(
+          base::Bind(&TrackableObject<T>::ReleaseAllWeakReferences));
+    }
+    weak_map_id_ = weak_map_->Add(isolate, GetWrapper(isolate));
+    TrackableObjectBase::AfterInit(isolate);
+  }
+
+ private:
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override {
+    if (template_.IsEmpty()) {
+      auto templ = v8::ObjectTemplate::New(isolate);
+      T::BuildPrototype(isolate, templ);
+      template_.Reset(isolate, templ);
+    }
+
+    return ObjectTemplateBuilder(
+        isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+  }
+
+  // Releases all weak references in weak map, called when app is terminating.
+  static void ReleaseAllWeakReferences() {
+    weak_map_.reset();
+  }
+
+  static v8::Persistent<v8::ObjectTemplate> template_;
+  static scoped_ptr<electron::IDWeakMap> weak_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrackableObject);
+};
+
+template<typename T>
+v8::Persistent<v8::ObjectTemplate> TrackableObject<T>::template_;
+
+template<typename T>
+scoped_ptr<electron::IDWeakMap> TrackableObject<T>::weak_map_;
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
added in remote
  their  100644 329871b9e7837d4a9324034290eb3d6ae9515dd3 electron/browser/auto_updater.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/auto_updater.h"
+
+namespace auto_updater {
+
+Delegate* AutoUpdater::delegate_ = nullptr;
+
+Delegate* AutoUpdater::GetDelegate() {
+  return delegate_;
+}
+
+void AutoUpdater::SetDelegate(Delegate* delegate) {
+  delegate_ = delegate;
+}
+
+#if !defined(OS_MACOSX) || defined(MAS_BUILD)
+void AutoUpdater::SetFeedURL(const std::string& url) {
+}
+
+void AutoUpdater::CheckForUpdates() {
+}
+
+void AutoUpdater::QuitAndInstall() {
+}
+#endif
+
+}  // namespace auto_updater
added in remote
  their  100644 7f2d66882770041dddb05b61497bdf0954bf2223 electron/browser/auto_updater.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_AUTO_UPDATER_H_
+#define ELECTRON_BROWSER_AUTO_UPDATER_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "build/build_config.h"
+
+namespace base {
+class Time;
+}
+
+namespace auto_updater {
+
+class Delegate {
+ public:
+  // An error happened.
+  virtual void OnError(const std::string& error) {}
+
+  // Checking to see if there is an update
+  virtual void OnCheckingForUpdate() {}
+
+  // There is an update available and it is being downloaded
+  virtual void OnUpdateAvailable() {}
+
+  // There is no available update.
+  virtual void OnUpdateNotAvailable() {}
+
+  // There is a new update which has been downloaded.
+  virtual void OnUpdateDownloaded(const std::string& release_notes,
+                                  const std::string& release_name,
+                                  const base::Time& release_date,
+                                  const std::string& update_url) {}
+
+ protected:
+  virtual ~Delegate() {}
+};
+
+class AutoUpdater {
+ public:
+  // Gets/Sets the delegate.
+  static Delegate* GetDelegate();
+  static void SetDelegate(Delegate* delegate);
+
+  static void SetFeedURL(const std::string& url);
+  static void CheckForUpdates();
+  static void QuitAndInstall();
+
+ private:
+  static Delegate* delegate_;
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(AutoUpdater);
+};
+
+}  // namespace auto_updater
+
+#endif  // ELECTRON_BROWSER_AUTO_UPDATER_H_
added in remote
  their  100644 6ef2d7773a366ddc306ca2ff2620d7a43bb9b728 electron/browser/auto_updater_mac.mm
@@ -0,0 +1,99 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/auto_updater.h"
+
+#import <ReactiveCocoa/RACCommand.h>
+#import <ReactiveCocoa/RACSignal.h>
+#import <ReactiveCocoa/NSObject+RACPropertySubscribing.h>
+#import <Squirrel/Squirrel.h>
+
+#include "base/bind.h"
+#include "base/time/time.h"
+#include "base/strings/sys_string_conversions.h"
+
+namespace auto_updater {
+
+namespace {
+
+// The gloal SQRLUpdater object.
+SQRLUpdater* g_updater = nil;
+
+}  // namespace
+
+// static
+void AutoUpdater::SetFeedURL(const std::string& feed) {
+  if (g_updater == nil) {
+    Delegate* delegate = GetDelegate();
+    if (!delegate)
+      return;
+
+    // Initialize the SQRLUpdater.
+    NSURL* url = [NSURL URLWithString:base::SysUTF8ToNSString(feed)];
+    NSURLRequest* urlRequest = [NSURLRequest requestWithURL:url];
+
+    @try {
+      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest];
+    } @catch (NSException* error) {
+      delegate->OnError(base::SysNSStringToUTF8(error.reason));
+      return;
+    }
+
+    [[g_updater rac_valuesForKeyPath:@"state" observer:g_updater]
+      subscribeNext:^(NSNumber *stateNumber) {
+        int state = [stateNumber integerValue];
+        // Dispatching the event on main thread.
+        dispatch_async(dispatch_get_main_queue(), ^{
+          if (state == SQRLUpdaterStateCheckingForUpdate)
+            delegate->OnCheckingForUpdate();
+          else if (state == SQRLUpdaterStateDownloadingUpdate)
+            delegate->OnUpdateAvailable();
+        });
+    }];
+  }
+}
+
+// static
+void AutoUpdater::CheckForUpdates() {
+  Delegate* delegate = GetDelegate();
+  if (!delegate)
+    return;
+
+  [[[[g_updater.checkForUpdatesCommand
+      execute:nil]
+      // Send a `nil` after everything...
+      concat:[RACSignal return:nil]]
+      // But only take the first value. If an update is sent, we'll get that.
+      // Otherwise, we'll get our inserted `nil` value.
+      take:1]
+      subscribeNext:^(SQRLDownloadedUpdate *downloadedUpdate) {
+        if (downloadedUpdate) {
+          SQRLUpdate* update = downloadedUpdate.update;
+          // There is a new update that has been downloaded.
+          delegate->OnUpdateDownloaded(
+            base::SysNSStringToUTF8(update.releaseNotes),
+            base::SysNSStringToUTF8(update.releaseName),
+            base::Time::FromDoubleT(update.releaseDate.timeIntervalSince1970),
+            base::SysNSStringToUTF8(update.updateURL.absoluteString));
+        } else {
+          // When the completed event is sent with no update, then we know there
+          // is no update available.
+          delegate->OnUpdateNotAvailable();
+        }
+      } error:^(NSError *error) {
+        delegate->OnError(base::SysNSStringToUTF8(
+            [NSString stringWithFormat:@"%@: %@",
+                error.localizedDescription, error.localizedFailureReason]));
+      }];
+}
+
+void AutoUpdater::QuitAndInstall() {
+  [[g_updater relaunchToInstallUpdate] subscribeError:^(NSError* error) {
+    Delegate* delegate = AutoUpdater::GetDelegate();
+    if (delegate)
+      delegate->OnError(base::SysNSStringToUTF8(error.localizedDescription));
+  }];
+}
+
+}  // namespace auto_updater
added in remote
  their  100644 fb07c7d60a2e9783a0744bd6fd53e8a54114efd5 electron/browser/bridge_task_runner.cc
@@ -0,0 +1,59 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/bridge_task_runner.h"
+
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+void BridgeTaskRunner::MessageLoopIsReady() {
+  auto message_loop = base::MessageLoop::current();
+  CHECK(message_loop);
+  for (const TaskPair& task : tasks_) {
+    message_loop->task_runner()->PostDelayedTask(
+        base::get<0>(task), base::get<1>(task), base::get<2>(task));
+  }
+  for (const TaskPair& task : non_nestable_tasks_) {
+    message_loop->task_runner()->PostNonNestableDelayedTask(
+        base::get<0>(task), base::get<1>(task), base::get<2>(task));
+  }
+}
+
+bool BridgeTaskRunner::PostDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop) {
+    tasks_.push_back(base::MakeTuple(from_here, task, delay));
+    return true;
+  }
+
+  return message_loop->task_runner()->PostDelayedTask(from_here, task, delay);
+}
+
+bool BridgeTaskRunner::RunsTasksOnCurrentThread() const {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop)
+    return true;
+
+  return message_loop->task_runner()->RunsTasksOnCurrentThread();
+}
+
+bool BridgeTaskRunner::PostNonNestableDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop) {
+    non_nestable_tasks_.push_back(base::MakeTuple(from_here, task, delay));
+    return true;
+  }
+
+  return message_loop->task_runner()->PostNonNestableDelayedTask(
+      from_here, task, delay);
+}
+
+}  // namespace electron
added in remote
  their  100644 5ed3ff65ab1fd629332fbf5785afdc3fc39198f1 electron/browser/bridge_task_runner.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
+#define ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
+
+#include <vector>
+
+#include "base/single_thread_task_runner.h"
+#include "base/tuple.h"
+
+namespace electron {
+
+// Post all tasks to the current message loop's task runner if available,
+// otherwise delay the work until message loop is ready.
+class BridgeTaskRunner : public base::SingleThreadTaskRunner {
+ public:
+  BridgeTaskRunner() {}
+  ~BridgeTaskRunner() override {}
+
+  // Called when message loop is ready.
+  void MessageLoopIsReady();
+
+  // base::SingleThreadTaskRunner:
+  bool PostDelayedTask(const tracked_objects::Location& from_here,
+                       const base::Closure& task,
+                       base::TimeDelta delay) override;
+  bool RunsTasksOnCurrentThread() const override;
+  bool PostNonNestableDelayedTask(
+      const tracked_objects::Location& from_here,
+      const base::Closure& task,
+      base::TimeDelta delay) override;
+
+ private:
+  using TaskPair = base::Tuple<
+      tracked_objects::Location, base::Closure, base::TimeDelta>;
+  std::vector<TaskPair> tasks_;
+  std::vector<TaskPair> non_nestable_tasks_;
+
+  DISALLOW_COPY_AND_ASSIGN(BridgeTaskRunner);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
added in remote
  their  100644 f8781b9e719373cba5c2eb4b573da75711dd5e7e electron/browser/browser.cc
@@ -0,0 +1,188 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+Browser::Browser()
+    : is_quiting_(false),
+      is_ready_(false),
+      is_shutdown_(false) {
+  WindowList::AddObserver(this);
+}
+
+Browser::~Browser() {
+  WindowList::RemoveObserver(this);
+}
+
+// static
+Browser* Browser::Get() {
+  return ElectronBrowserMainParts::Get()->browser();
+}
+
+void Browser::Quit() {
+  if (is_quiting_)
+    return;
+
+  is_quiting_ = HandleBeforeQuit();
+  if (!is_quiting_)
+    return;
+
+  electron::WindowList* window_list = electron::WindowList::GetInstance();
+  if (window_list->size() == 0)
+    NotifyAndShutdown();
+
+  window_list->CloseAllWindows();
+}
+
+void Browser::Exit(int code) {
+  if (!ElectronBrowserMainParts::Get()->SetExitCode(code)) {
+    // Message loop is not ready, quit directly.
+    exit(code);
+  } else {
+    // Prepare to quit when all windows have been closed..
+    is_quiting_ = true;
+
+    // Must destroy windows before quitting, otherwise bad things can happen.
+    electron::WindowList* window_list = electron::WindowList::GetInstance();
+    if (window_list->size() == 0) {
+      Shutdown();
+    } else {
+      // Unlike Quit(), we do not ask to close window, but destroy the window
+      // without asking.
+      for (NativeWindow* window : *window_list)
+        window->CloseContents(nullptr);  // e.g. Destroy()
+    }
+  }
+}
+
+void Browser::Shutdown() {
+  if (is_shutdown_)
+    return;
+
+  is_shutdown_ = true;
+  is_quiting_ = true;
+
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnQuit());
+
+  if (base::MessageLoop::current()) {
+    base::MessageLoop::current()->PostTask(
+        FROM_HERE, base::MessageLoop::QuitWhenIdleClosure());
+  } else {
+    // There is no message loop available so we are in early stage.
+    exit(0);
+  }
+}
+
+std::string Browser::GetVersion() const {
+  if (version_override_.empty()) {
+    std::string version = GetExecutableFileVersion();
+    if (!version.empty())
+      return version;
+  }
+
+  return version_override_;
+}
+
+void Browser::SetVersion(const std::string& version) {
+  version_override_ = version;
+}
+
+std::string Browser::GetName() const {
+  if (name_override_.empty()) {
+    std::string name = GetExecutableFileProductName();
+    if (!name.empty())
+      return name;
+  }
+
+  return name_override_;
+}
+
+void Browser::SetName(const std::string& name) {
+  name_override_ = name;
+}
+
+bool Browser::OpenFile(const std::string& file_path) {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnOpenFile(&prevent_default, file_path));
+
+  return prevent_default;
+}
+
+void Browser::OpenURL(const std::string& url) {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnOpenURL(url));
+}
+
+void Browser::Activate(bool has_visible_windows) {
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnActivate(has_visible_windows));
+}
+
+void Browser::WillFinishLaunching() {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWillFinishLaunching());
+}
+
+void Browser::DidFinishLaunching() {
+  is_ready_ = true;
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnFinishLaunching());
+}
+
+void Browser::RequestLogin(LoginHandler* login_handler) {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnLogin(login_handler));
+}
+
+void Browser::NotifyAndShutdown() {
+  if (is_shutdown_)
+    return;
+
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWillQuit(&prevent_default));
+
+  if (prevent_default) {
+    is_quiting_ = false;
+    return;
+  }
+
+  Shutdown();
+}
+
+bool Browser::HandleBeforeQuit() {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnBeforeQuit(&prevent_default));
+
+  return !prevent_default;
+}
+
+void Browser::OnWindowCloseCancelled(NativeWindow* window) {
+  if (is_quiting_)
+    // Once a beforeunload handler has prevented the closing, we think the quit
+    // is cancelled too.
+    is_quiting_ = false;
+}
+
+void Browser::OnWindowAllClosed() {
+  if (is_quiting_)
+    NotifyAndShutdown();
+  else
+    FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWindowAllClosed());
+}
+
+void Browser::PlatformThemeChanged() {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnPlatformThemeChanged());
+}
+
+}  // namespace electron
added in remote
  their  100644 3913476ac4daac19fe0669b7170a4691b6f6652b electron/browser/browser.h
@@ -0,0 +1,210 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BROWSER_H_
+#define ELECTRON_BROWSER_BROWSER_H_
+
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "base/observer_list.h"
+#include "base/strings/string16.h"
+#include "electron/browser/browser_observer.h"
+#include "electron/browser/window_list_observer.h"
+
+#if defined(OS_WIN)
+#include "base/files/file_path.h"
+#endif
+
+namespace base {
+class FilePath;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace gfx {
+class Image;
+}
+
+namespace electron {
+
+class LoginHandler;
+
+// This class is used for control application-wide operations.
+class Browser : public WindowListObserver {
+ public:
+  Browser();
+  ~Browser();
+
+  static Browser* Get();
+
+  // Try to close all windows and quit the application.
+  void Quit();
+
+  // Exit the application immediately and set exit code.
+  void Exit(int code);
+
+  // Cleanup everything and shutdown the application gracefully.
+  void Shutdown();
+
+  // Focus the application.
+  void Focus();
+
+  // Returns the version of the executable (or bundle).
+  std::string GetVersion() const;
+
+  // Overrides the application version.
+  void SetVersion(const std::string& version);
+
+  // Returns the application's name, default is just Electron.
+  std::string GetName() const;
+
+  // Overrides the application name.
+  void SetName(const std::string& name);
+
+  // Add the |path| to recent documents list.
+  void AddRecentDocument(const base::FilePath& path);
+
+  // Clear the recent documents list.
+  void ClearRecentDocuments();
+
+  // Set the application user model ID.
+  void SetAppUserModelID(const base::string16& name);
+
+  // Remove the default protocol handler registry key
+  bool RemoveAsDefaultProtocolClient(const std::string& protocol);
+
+  // Set as default handler for a protocol.
+  bool SetAsDefaultProtocolClient(const std::string& protocol);
+
+#if defined(OS_MACOSX)
+  // Hide the application.
+  void Hide();
+
+  // Show the application.
+  void Show();
+
+  // Check if the system is in Dark Mode.
+  bool IsDarkMode();
+
+  // Bounce the dock icon.
+  enum BounceType {
+    BOUNCE_CRITICAL = 0,
+    BOUNCE_INFORMATIONAL = 10,
+  };
+  int DockBounce(BounceType type);
+  void DockCancelBounce(int request_id);
+
+  // Set/Get dock's badge text.
+  void DockSetBadgeText(const std::string& label);
+  std::string DockGetBadgeText();
+
+  // Hide/Show dock.
+  void DockHide();
+  void DockShow();
+
+  // Set docks' menu.
+  void DockSetMenu(ui::MenuModel* model);
+
+  // Set docks' icon.
+  void DockSetIcon(const gfx::Image& image);
+#endif  // defined(OS_MACOSX)
+
+#if defined(OS_WIN)
+  struct UserTask {
+    base::FilePath program;
+    base::string16 arguments;
+    base::string16 title;
+    base::string16 description;
+    base::FilePath icon_path;
+    int icon_index;
+  };
+
+  // Add a custom task to jump list.
+  void SetUserTasks(const std::vector<UserTask>& tasks);
+
+  // Returns the application user model ID, if there isn't one, then create
+  // one from app's name.
+  // The returned string managed by Browser, and should not be modified.
+  PCWSTR GetAppUserModelID();
+#endif
+
+  // Tell the application to open a file.
+  bool OpenFile(const std::string& file_path);
+
+  // Tell the application to open a url.
+  void OpenURL(const std::string& url);
+
+  // Tell the application that application is activated with visible/invisible
+  // windows.
+  void Activate(bool has_visible_windows);
+
+  // Tell the application the loading has been done.
+  void WillFinishLaunching();
+  void DidFinishLaunching();
+
+  // Request basic auth login.
+  void RequestLogin(LoginHandler* login_handler);
+
+  // Tell the application that plaform's theme changed.
+  void PlatformThemeChanged();
+
+  void AddObserver(BrowserObserver* obs) {
+    observers_.AddObserver(obs);
+  }
+
+  void RemoveObserver(BrowserObserver* obs) {
+    observers_.RemoveObserver(obs);
+  }
+
+  bool is_shutting_down() const { return is_shutdown_; }
+  bool is_quiting() const { return is_quiting_; }
+  bool is_ready() const { return is_ready_; }
+
+ protected:
+  // Returns the version of application bundle or executable file.
+  std::string GetExecutableFileVersion() const;
+
+  // Returns the name of application bundle or executable file.
+  std::string GetExecutableFileProductName() const;
+
+  // Send the will-quit message and then shutdown the application.
+  void NotifyAndShutdown();
+
+  // Send the before-quit message and start closing windows.
+  bool HandleBeforeQuit();
+
+  bool is_quiting_;
+
+ private:
+  // WindowListObserver implementations:
+  void OnWindowCloseCancelled(NativeWindow* window) override;
+  void OnWindowAllClosed() override;
+
+  // Observers of the browser.
+  base::ObserverList<BrowserObserver> observers_;
+
+  // Whether "ready" event has been emitted.
+  bool is_ready_;
+
+  // The browse is being shutdown.
+  bool is_shutdown_;
+
+  std::string version_override_;
+  std::string name_override_;
+
+#if defined(OS_WIN)
+  base::string16 app_user_model_id_;
+#endif
+
+  DISALLOW_COPY_AND_ASSIGN(Browser);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BROWSER_H_
added in remote
  their  100644 d7f09f8af61c3495f340dd7ff854ac8aa3b9e11e electron/browser/browser_linux.cc
@@ -0,0 +1,53 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <stdlib.h>
+
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/electron_version.h"
+#include "brightray/common/application_info.h"
+
+namespace electron {
+
+void Browser::Focus() {
+  // Focus on the first visible window.
+  WindowList* list = WindowList::GetInstance();
+  for (WindowList::iterator iter = list->begin(); iter != list->end(); ++iter) {
+    NativeWindow* window = *iter;
+    if (window->IsVisible()) {
+      window->Focus(true);
+      break;
+    }
+  }
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+}
+
+void Browser::ClearRecentDocuments() {
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  return brightray::GetApplicationVersion();
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  return brightray::GetApplicationName();
+}
+
+}  // namespace electron
added in remote
  their  100644 bc707e6584eb4ba9872d04bdc2d6b99597772a49 electron/browser/browser_mac.mm
@@ -0,0 +1,143 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include "electron/browser/mac/electron_application.h"
+#include "electron/browser/mac/electron_application_delegate.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/foundation_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "brightray/common/application_info.h"
+
+namespace electron {
+
+void Browser::Focus() {
+  [[ElectronApplication sharedApplication] activateIgnoringOtherApps:YES];
+}
+
+void Browser::Hide() {
+  [[ElectronApplication sharedApplication] hide:nil];
+}
+
+void Browser::Show() {
+  [[ElectronApplication sharedApplication] unhide:nil];
+}
+
+bool Browser::IsDarkMode() {
+  NSString *mode = [[NSUserDefaults standardUserDefaults] stringForKey:@"AppleInterfaceStyle"];
+  return [mode isEqualToString: @"Dark"];
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+  NSString* path_string = base::mac::FilePathToNSString(path);
+  if (!path_string)
+    return;
+  NSURL* u = [NSURL fileURLWithPath:path_string];
+  if (!u)
+    return;
+  [[NSDocumentController sharedDocumentController] noteNewRecentDocumentURL:u];
+}
+
+void Browser::ClearRecentDocuments() {
+  [[NSDocumentController sharedDocumentController] clearRecentDocuments:nil];
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  if (protocol.empty())
+    return false;
+
+  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
+  if (!identifier)
+    return false;
+
+  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
+  OSStatus return_code =
+      LSSetDefaultHandlerForURLScheme(base::mac::NSToCFCast(protocol_ns),
+                                      base::mac::NSToCFCast(identifier));
+  return return_code == noErr;
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  return brightray::GetApplicationVersion();
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  return brightray::GetApplicationName();
+}
+
+int Browser::DockBounce(BounceType type) {
+  return [[ElectronApplication sharedApplication]
+      requestUserAttention:(NSRequestUserAttentionType)type];
+}
+
+void Browser::DockCancelBounce(int request_id) {
+  [[ElectronApplication sharedApplication] cancelUserAttentionRequest:request_id];
+}
+
+void Browser::DockSetBadgeText(const std::string& label) {
+  NSDockTile *tile = [[ElectronApplication sharedApplication] dockTile];
+  [tile setBadgeLabel:base::SysUTF8ToNSString(label)];
+}
+
+std::string Browser::DockGetBadgeText() {
+  NSDockTile *tile = [[ElectronApplication sharedApplication] dockTile];
+  return base::SysNSStringToUTF8([tile badgeLabel]);
+}
+
+void Browser::DockHide() {
+  WindowList* list = WindowList::GetInstance();
+  for (WindowList::iterator it = list->begin(); it != list->end(); ++it)
+    [(*it)->GetNativeWindow() setCanHide:NO];
+
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  TransformProcessType(&psn, kProcessTransformToUIElementApplication);
+}
+
+void Browser::DockShow() {
+  BOOL active = [[NSRunningApplication currentApplication] isActive];
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  if (active) {
+    // Workaround buggy behavior of TransformProcessType.
+    // http://stackoverflow.com/questions/7596643/
+    NSArray* runningApps = [NSRunningApplication
+        runningApplicationsWithBundleIdentifier:@"com.apple.dock"];
+    for (NSRunningApplication* app in runningApps) {
+      [app activateWithOptions:NSApplicationActivateIgnoringOtherApps];
+      break;
+    }
+    dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
+    dispatch_after(one_ms, dispatch_get_main_queue(), ^{
+      TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+      dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
+      dispatch_after(one_ms, dispatch_get_main_queue(), ^{
+        [[NSRunningApplication currentApplication]
+            activateWithOptions:NSApplicationActivateIgnoringOtherApps];
+      });
+    });
+  } else {
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+  }
+}
+
+void Browser::DockSetMenu(ui::MenuModel* model) {
+  ElectronApplicationDelegate* delegate = (ElectronApplicationDelegate*)[NSApp delegate];
+  [delegate setApplicationDockMenu:model];
+}
+
+void Browser::DockSetIcon(const gfx::Image& image) {
+  [[ElectronApplication sharedApplication]
+      setApplicationIconImage:image.AsNSImage()];
+}
+
+}  // namespace electron
added in remote
  their  100644 f3f1409ab58be372e97f7b94b253a50831790d45 electron/browser/browser_observer.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BROWSER_OBSERVER_H_
+#define ELECTRON_BROWSER_BROWSER_OBSERVER_H_
+
+#include <string>
+
+namespace electron {
+
+class LoginHandler;
+
+class BrowserObserver {
+ public:
+  // The browser is about to close all windows.
+  virtual void OnBeforeQuit(bool* prevent_default) {}
+
+  // The browser has closed all windows and will quit.
+  virtual void OnWillQuit(bool* prevent_default) {}
+
+  // The browser has closed all windows. If the browser is quiting, then this
+  // method will not be called, instead it will call OnWillQuit.
+  virtual void OnWindowAllClosed() {}
+
+  // The browser is quitting.
+  virtual void OnQuit() {}
+
+  // The browser has opened a file by double clicking in Finder or dragging the
+  // file to the Dock icon. (OS X only)
+  virtual void OnOpenFile(bool* prevent_default,
+                          const std::string& file_path) {}
+
+  // Browser is used to open a url.
+  virtual void OnOpenURL(const std::string& url) {}
+
+  // The browser is activated with visible/invisible windows (usually by
+  // clicking on the dock icon).
+  virtual void OnActivate(bool has_visible_windows) {}
+
+  // The browser has finished loading.
+  virtual void OnWillFinishLaunching() {}
+  virtual void OnFinishLaunching() {}
+
+  // The browser requests HTTP login.
+  virtual void OnLogin(LoginHandler* login_handler) {}
+
+  virtual void OnPlatformThemeChanged() {}
+
+ protected:
+  virtual ~BrowserObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BROWSER_OBSERVER_H_
added in remote
  their  100644 34f5df1b2f66bed0d09ac3aedbb7e186a9ff54a0 electron/browser/browser_win.cc
@@ -0,0 +1,259 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <atlbase.h>
+#include <propkey.h>
+#include <windows.h>
+#include <shlobj.h>
+#include <shobjidl.h>
+
+#include "base/base_paths.h"
+#include "base/file_version_info.h"
+#include "base/files/file_path.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/path_service.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/win_util.h"
+#include "base/win/registry.h"
+#include "base/win/windows_version.h"
+#include "electron/common/electron_version.h"
+
+namespace electron {
+
+namespace {
+
+const wchar_t kAppUserModelIDFormat[] = L"electron.app.$1";
+
+BOOL CALLBACK WindowsEnumerationHandler(HWND hwnd, LPARAM param) {
+  DWORD target_process_id = *reinterpret_cast<DWORD*>(param);
+  DWORD process_id = 0;
+
+  GetWindowThreadProcessId(hwnd, &process_id);
+  if (process_id == target_process_id) {
+    SetFocus(hwnd);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+}  // namespace
+
+void Browser::Focus() {
+  // On Windows we just focus on the first window found for this process.
+  DWORD pid = GetCurrentProcessId();
+  EnumWindows(&WindowsEnumerationHandler, reinterpret_cast<LPARAM>(&pid));
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+  if (base::win::GetVersion() < base::win::VERSION_WIN7)
+    return;
+
+  CComPtr<IShellItem> item;
+  HRESULT hr = SHCreateItemFromParsingName(
+      path.value().c_str(), NULL, IID_PPV_ARGS(&item));
+  if (SUCCEEDED(hr)) {
+    SHARDAPPIDINFO info;
+    info.psi = item;
+    info.pszAppID = GetAppUserModelID();
+    SHAddToRecentDocs(SHARD_APPIDINFO, &info);
+  }
+}
+
+void Browser::ClearRecentDocuments() {
+  CComPtr<IApplicationDestinations> destinations;
+  if (FAILED(destinations.CoCreateInstance(CLSID_ApplicationDestinations,
+                                           NULL, CLSCTX_INPROC_SERVER)))
+    return;
+  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
+    return;
+  destinations->RemoveAllDestinations();
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+  app_user_model_id_ = name;
+  SetCurrentProcessExplicitAppUserModelID(app_user_model_id_.c_str());
+}
+
+void Browser::SetUserTasks(const std::vector<UserTask>& tasks) {
+  CComPtr<ICustomDestinationList> destinations;
+  if (FAILED(destinations.CoCreateInstance(CLSID_DestinationList)))
+    return;
+  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
+    return;
+
+  // Start a transaction that updates the JumpList of this application.
+  UINT max_slots;
+  CComPtr<IObjectArray> removed;
+  if (FAILED(destinations->BeginList(&max_slots, IID_PPV_ARGS(&removed))))
+    return;
+
+  CComPtr<IObjectCollection> collection;
+  if (FAILED(collection.CoCreateInstance(CLSID_EnumerableObjectCollection)))
+    return;
+
+  for (auto& task : tasks) {
+    CComPtr<IShellLink> link;
+    if (FAILED(link.CoCreateInstance(CLSID_ShellLink)) ||
+        FAILED(link->SetPath(task.program.value().c_str())) ||
+        FAILED(link->SetArguments(task.arguments.c_str())) ||
+        FAILED(link->SetDescription(task.description.c_str())))
+      return;
+
+    if (!task.icon_path.empty() &&
+        FAILED(link->SetIconLocation(task.icon_path.value().c_str(),
+                                     task.icon_index)))
+      return;
+
+    CComQIPtr<IPropertyStore> property_store = link;
+    if (!base::win::SetStringValueForPropertyStore(property_store, PKEY_Title,
+                                                   task.title.c_str()))
+      return;
+
+    if (FAILED(collection->AddObject(link)))
+      return;
+  }
+
+  // When the list is empty "AddUserTasks" could fail, so we don't check return
+  // value for it.
+  CComQIPtr<IObjectArray> task_array = collection;
+  destinations->AddUserTasks(task_array);
+  destinations->CommitList();
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  if (protocol.empty())
+    return false;
+
+  base::FilePath path;
+  if (!PathService::Get(base::FILE_EXE, &path)) {
+    LOG(ERROR) << "Error getting app exe path";
+    return false;
+  }
+
+  // Main Registry Key
+  HKEY root = HKEY_CURRENT_USER;
+  std::string keyPathStr = "Software\\Classes\\" + protocol;
+  std::wstring keyPath = std::wstring(keyPathStr.begin(), keyPathStr.end());
+
+  // Command Key
+  std::string cmdPathStr = keyPathStr + "\\shell\\open\\command";
+  std::wstring cmdPath = std::wstring(cmdPathStr.begin(), cmdPathStr.end());
+
+  base::win::RegKey key;
+  base::win::RegKey commandKey;
+  if (FAILED(key.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
+    // Key doesn't even exist, we can confirm that it is not set
+    return true;
+
+  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
+    // Key doesn't even exist, we can confirm that it is not set
+    return true;
+
+  std::wstring keyVal;
+  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
+    // Default value not set, we can confirm that it is not set
+    return true;
+
+  std::wstring exePath(path.value());
+  std::wstring exe = L"\"" + exePath + L"\" \"%1\"";
+  if (keyVal == exe) {
+    // Let's kill the key
+    if (FAILED(key.DeleteKey(L"shell")))
+      return false;
+
+    return true;
+  } else {
+    return true;
+  }
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  // HKEY_CLASSES_ROOT
+  //    $PROTOCOL
+  //       (Default) = "URL:$NAME"
+  //       URL Protocol = ""
+  //       shell
+  //          open
+  //             command
+  //                (Default) = "$COMMAND" "%1"
+  //
+  // However, the "HKEY_CLASSES_ROOT" key can only be written by the
+  // Administrator user. So, we instead write to "HKEY_CURRENT_USER\
+  // Software\Classes", which is inherited by "HKEY_CLASSES_ROOT"
+  // anyway, and can be written by unprivileged users.
+
+  if (protocol.empty())
+    return false;
+
+  base::FilePath path;
+  if (!PathService::Get(base::FILE_EXE, &path)) {
+    LOG(ERROR) << "Error getting app exe path";
+    return false;
+  }
+
+  // Main Registry Key
+  HKEY root = HKEY_CURRENT_USER;
+  std::string keyPathStr = "Software\\Classes\\" + protocol;
+  std::wstring keyPath = std::wstring(keyPathStr.begin(), keyPathStr.end());
+  std::string urlDeclStr = "URL:" + protocol;
+  std::wstring urlDecl = std::wstring(urlDeclStr.begin(), urlDeclStr.end());
+
+  // Command Key
+  std::string cmdPathStr = keyPathStr + "\\shell\\open\\command";
+  std::wstring cmdPath = std::wstring(cmdPathStr.begin(), cmdPathStr.end());
+
+  // Executable Path
+  std::wstring exePath(path.value());
+  std::wstring exe = L"\"" + exePath + L"\" \"%1\"";
+
+  // Write information to registry
+  base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS);
+  if (FAILED(key.WriteValue(L"URL Protocol", L"")) ||
+      FAILED(key.WriteValue(L"", urlDecl.c_str())))
+    return false;
+
+  base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS);
+  if (FAILED(commandKey.WriteValue(L"", exe.c_str())))
+    return false;
+
+  return true;
+}
+
+PCWSTR Browser::GetAppUserModelID() {
+  if (app_user_model_id_.empty()) {
+    SetAppUserModelID(base::ReplaceStringPlaceholders(
+        kAppUserModelIDFormat, base::UTF8ToUTF16(GetName()), nullptr));
+  }
+
+  return app_user_model_id_.c_str();
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  base::FilePath path;
+  if (PathService::Get(base::FILE_EXE, &path)) {
+    scoped_ptr<FileVersionInfo> version_info(
+        FileVersionInfo::CreateFileVersionInfo(path));
+    return base::UTF16ToUTF8(version_info->product_version());
+  }
+
+  return ELECTRON_VERSION_STRING;
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  base::FilePath path;
+  if (PathService::Get(base::FILE_EXE, &path)) {
+    scoped_ptr<FileVersionInfo> version_info(
+        FileVersionInfo::CreateFileVersionInfo(path));
+    return base::UTF16ToUTF8(version_info->product_name());
+  }
+
+  return ELECTRON_PRODUCT_NAME;
+}
+
+}  // namespace electron
added in remote
  their  100644 b04e9d46211bfb28e6e0f3628ffb3605140f1a66 electron/browser/common_web_contents_delegate.cc
@@ -0,0 +1,443 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/common_web_contents_delegate.h"
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_javascript_dialog_manager.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "electron/browser/web_dialog_helper.h"
+#include "base/files/file_util.h"
+#include "base/prefs/pref_service.h"
+#include "base/prefs/scoped_user_pref_update.h"
+#include "chrome/browser/printing/print_preview_message_handler.h"
+#include "chrome/browser/printing/print_view_manager_basic.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "storage/browser/fileapi/isolated_context.h"
+
+#if defined(TOOLKIT_VIEWS)
+#include "electron/browser/native_window_views.h"
+#endif
+
+#if defined(USE_X11)
+#include "electron/browser/browser.h"
+#endif
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+const char kRootName[] = "<root>";
+
+struct FileSystem {
+  FileSystem() {
+  }
+  FileSystem(const std::string& file_system_name,
+             const std::string& root_url,
+             const std::string& file_system_path)
+    : file_system_name(file_system_name),
+      root_url(root_url),
+      file_system_path(file_system_path) {
+  }
+
+  std::string file_system_name;
+  std::string root_url;
+  std::string file_system_path;
+};
+
+std::string RegisterFileSystem(content::WebContents* web_contents,
+                               const base::FilePath& path) {
+  auto isolated_context = storage::IsolatedContext::GetInstance();
+  std::string root_name(kRootName);
+  std::string file_system_id = isolated_context->RegisterFileSystemForPath(
+      storage::kFileSystemTypeNativeLocal,
+      std::string(),
+      path,
+      &root_name);
+
+  content::ChildProcessSecurityPolicy* policy =
+      content::ChildProcessSecurityPolicy::GetInstance();
+  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
+  int renderer_id = render_view_host->GetProcess()->GetID();
+  policy->GrantReadFileSystem(renderer_id, file_system_id);
+  policy->GrantWriteFileSystem(renderer_id, file_system_id);
+  policy->GrantCreateFileForFileSystem(renderer_id, file_system_id);
+  policy->GrantDeleteFromFileSystem(renderer_id, file_system_id);
+
+  if (!policy->CanReadFile(renderer_id, path))
+    policy->GrantReadFile(renderer_id, path);
+
+  return file_system_id;
+}
+
+FileSystem CreateFileSystemStruct(
+    content::WebContents* web_contents,
+    const std::string& file_system_id,
+    const std::string& file_system_path) {
+  const GURL origin = web_contents->GetURL().GetOrigin();
+  std::string file_system_name =
+      storage::GetIsolatedFileSystemName(origin, file_system_id);
+  std::string root_url = storage::GetIsolatedFileSystemRootURIString(
+      origin, file_system_id, kRootName);
+  return FileSystem(file_system_name, root_url, file_system_path);
+}
+
+base::DictionaryValue* CreateFileSystemValue(const FileSystem& file_system) {
+  base::DictionaryValue* file_system_value = new base::DictionaryValue();
+  file_system_value->SetString("fileSystemName", file_system.file_system_name);
+  file_system_value->SetString("rootURL", file_system.root_url);
+  file_system_value->SetString("fileSystemPath", file_system.file_system_path);
+  return file_system_value;
+}
+
+void WriteToFile(const base::FilePath& path,
+                 const std::string& content) {
+  DCHECK_CURRENTLY_ON(BrowserThread::FILE);
+  DCHECK(!path.empty());
+
+  base::WriteFile(path, content.data(), content.size());
+}
+
+void AppendToFile(const base::FilePath& path,
+                  const std::string& content) {
+  DCHECK_CURRENTLY_ON(BrowserThread::FILE);
+  DCHECK(!path.empty());
+
+  base::AppendToFile(path, content.data(), content.size());
+}
+
+PrefService* GetPrefService(content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  return static_cast<electron::ElectronBrowserContext*>(context)->prefs();
+}
+
+std::set<std::string> GetAddedFileSystemPaths(
+    content::WebContents* web_contents) {
+  auto pref_service = GetPrefService(web_contents);
+  const base::DictionaryValue* file_system_paths_value =
+      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);
+  std::set<std::string> result;
+  if (file_system_paths_value) {
+    base::DictionaryValue::Iterator it(*file_system_paths_value);
+    for (; !it.IsAtEnd(); it.Advance()) {
+      result.insert(it.key());
+    }
+  }
+  return result;
+}
+
+}  // namespace
+
+CommonWebContentsDelegate::CommonWebContentsDelegate()
+    : html_fullscreen_(false),
+      native_fullscreen_(false) {
+}
+
+CommonWebContentsDelegate::~CommonWebContentsDelegate() {
+}
+
+void CommonWebContentsDelegate::InitWithWebContents(
+    content::WebContents* web_contents) {
+  web_contents->SetDelegate(this);
+
+  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
+  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
+
+  // Create InspectableWebContents.
+  web_contents_.reset(brightray::InspectableWebContents::Create(web_contents));
+  web_contents_->SetDelegate(this);
+}
+
+void CommonWebContentsDelegate::SetOwnerWindow(NativeWindow* owner_window) {
+  SetOwnerWindow(GetWebContents(), owner_window);
+}
+
+void CommonWebContentsDelegate::SetOwnerWindow(
+    content::WebContents* web_contents, NativeWindow* owner_window) {
+  owner_window_ = owner_window->GetWeakPtr();
+  NativeWindowRelay* relay = new NativeWindowRelay(owner_window_);
+  web_contents->SetUserData(relay->key, relay);
+}
+
+void CommonWebContentsDelegate::DestroyWebContents() {
+  web_contents_.reset();
+}
+
+content::WebContents* CommonWebContentsDelegate::GetWebContents() const {
+  if (!web_contents_)
+    return nullptr;
+  return web_contents_->GetWebContents();
+}
+
+content::WebContents*
+CommonWebContentsDelegate::GetDevToolsWebContents() const {
+  if (!web_contents_)
+    return nullptr;
+  return web_contents_->GetDevToolsWebContents();
+}
+
+content::WebContents* CommonWebContentsDelegate::OpenURLFromTab(
+    content::WebContents* source,
+    const content::OpenURLParams& params) {
+  content::NavigationController::LoadURLParams load_url_params(params.url);
+  load_url_params.referrer = params.referrer;
+  load_url_params.transition_type = params.transition;
+  load_url_params.extra_headers = params.extra_headers;
+  load_url_params.should_replace_current_entry =
+      params.should_replace_current_entry;
+  load_url_params.is_renderer_initiated = params.is_renderer_initiated;
+  load_url_params.should_clear_history_list = true;
+
+  source->GetController().LoadURLWithParams(load_url_params);
+  return source;
+}
+
+bool CommonWebContentsDelegate::CanOverscrollContent() const {
+  return false;
+}
+
+content::JavaScriptDialogManager*
+CommonWebContentsDelegate::GetJavaScriptDialogManager(
+    content::WebContents* source) {
+  if (!dialog_manager_)
+    dialog_manager_.reset(new ElectronJavaScriptDialogManager);
+
+  return dialog_manager_.get();
+}
+
+content::ColorChooser* CommonWebContentsDelegate::OpenColorChooser(
+    content::WebContents* web_contents,
+    SkColor color,
+    const std::vector<content::ColorSuggestion>& suggestions) {
+  return chrome::ShowColorChooser(web_contents, color);
+}
+
+void CommonWebContentsDelegate::RunFileChooser(
+    content::WebContents* guest,
+    const content::FileChooserParams& params) {
+  if (!web_dialog_helper_)
+    web_dialog_helper_.reset(new WebDialogHelper(owner_window()));
+  web_dialog_helper_->RunFileChooser(guest, params);
+}
+
+void CommonWebContentsDelegate::EnumerateDirectory(content::WebContents* guest,
+                                                   int request_id,
+                                                   const base::FilePath& path) {
+  if (!web_dialog_helper_)
+    web_dialog_helper_.reset(new WebDialogHelper(owner_window()));
+  web_dialog_helper_->EnumerateDirectory(guest, request_id, path);
+}
+
+void CommonWebContentsDelegate::EnterFullscreenModeForTab(
+    content::WebContents* source, const GURL& origin) {
+  if (!owner_window_)
+    return;
+  SetHtmlApiFullscreen(true);
+  owner_window_->NotifyWindowEnterHtmlFullScreen();
+  source->GetRenderViewHost()->GetWidget()->WasResized();
+}
+
+void CommonWebContentsDelegate::ExitFullscreenModeForTab(
+    content::WebContents* source) {
+  if (!owner_window_)
+    return;
+  SetHtmlApiFullscreen(false);
+  owner_window_->NotifyWindowLeaveHtmlFullScreen();
+  source->GetRenderViewHost()->GetWidget()->WasResized();
+}
+
+bool CommonWebContentsDelegate::IsFullscreenForTabOrPending(
+    const content::WebContents* source) const {
+  return html_fullscreen_;
+}
+
+void CommonWebContentsDelegate::DevToolsSaveToFile(
+    const std::string& url, const std::string& content, bool save_as) {
+  base::FilePath path;
+  PathsMap::iterator it = saved_files_.find(url);
+  if (it != saved_files_.end() && !save_as) {
+    path = it->second;
+  } else {
+    file_dialog::Filters filters;
+    base::FilePath default_path(base::FilePath::FromUTF8Unsafe(url));
+    if (!file_dialog::ShowSaveDialog(owner_window(), url, default_path,
+                                     filters, &path)) {
+      base::StringValue url_value(url);
+      web_contents_->CallClientFunction(
+          "DevToolsAPI.canceledSaveURL", &url_value, nullptr, nullptr);
+      return;
+    }
+  }
+
+  saved_files_[url] = path;
+  BrowserThread::PostTaskAndReply(
+      BrowserThread::FILE, FROM_HERE,
+      base::Bind(&WriteToFile, path, content),
+      base::Bind(&CommonWebContentsDelegate::OnDevToolsSaveToFile,
+                 base::Unretained(this), url));
+}
+
+void CommonWebContentsDelegate::DevToolsAppendToFile(
+    const std::string& url, const std::string& content) {
+  PathsMap::iterator it = saved_files_.find(url);
+  if (it == saved_files_.end())
+    return;
+
+  BrowserThread::PostTaskAndReply(
+      BrowserThread::FILE, FROM_HERE,
+      base::Bind(&AppendToFile, it->second, content),
+      base::Bind(&CommonWebContentsDelegate::OnDevToolsAppendToFile,
+                 base::Unretained(this), url));
+}
+
+void CommonWebContentsDelegate::DevToolsRequestFileSystems() {
+  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
+  if (file_system_paths.empty()) {
+    base::ListValue empty_file_system_value;
+    web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
+                                      &empty_file_system_value,
+                                      nullptr, nullptr);
+    return;
+  }
+
+  std::vector<FileSystem> file_systems;
+  for (auto file_system_path : file_system_paths) {
+    base::FilePath path = base::FilePath::FromUTF8Unsafe(file_system_path);
+    std::string file_system_id = RegisterFileSystem(GetDevToolsWebContents(),
+                                                    path);
+    FileSystem file_system = CreateFileSystemStruct(GetDevToolsWebContents(),
+                                                    file_system_id,
+                                                    file_system_path);
+    file_systems.push_back(file_system);
+  }
+
+  base::ListValue file_system_value;
+  for (size_t i = 0; i < file_systems.size(); ++i)
+    file_system_value.Append(CreateFileSystemValue(file_systems[i]));
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
+                                    &file_system_value, nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::DevToolsAddFileSystem(
+    const base::FilePath& file_system_path) {
+  base::FilePath path = file_system_path;
+  if (path.empty()) {
+    file_dialog::Filters filters;
+    base::FilePath default_path;
+    std::vector<base::FilePath> paths;
+    int flag = file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
+    if (!file_dialog::ShowOpenDialog(owner_window(), "", default_path,
+                                     filters, flag, &paths))
+      return;
+
+    path = paths[0];
+  }
+
+  std::string file_system_id = RegisterFileSystem(GetDevToolsWebContents(),
+                                                  path);
+  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
+  if (file_system_paths.find(path.AsUTF8Unsafe()) != file_system_paths.end())
+    return;
+
+  FileSystem file_system = CreateFileSystemStruct(GetDevToolsWebContents(),
+                                                 file_system_id,
+                                                 path.AsUTF8Unsafe());
+  scoped_ptr<base::DictionaryValue> file_system_value(
+      CreateFileSystemValue(file_system));
+
+  auto pref_service = GetPrefService(GetDevToolsWebContents());
+  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
+  update.Get()->SetWithoutPathExpansion(
+      path.AsUTF8Unsafe(), base::Value::CreateNullValue());
+
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemAdded",
+                                    file_system_value.get(),
+                                    nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::DevToolsRemoveFileSystem(
+    const base::FilePath& file_system_path) {
+  if (!web_contents_)
+    return;
+
+  std::string path = file_system_path.AsUTF8Unsafe();
+  storage::IsolatedContext::GetInstance()->
+      RevokeFileSystemByPath(file_system_path);
+
+  auto pref_service = GetPrefService(GetDevToolsWebContents());
+  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
+  update.Get()->RemoveWithoutPathExpansion(path, nullptr);
+
+  base::StringValue file_system_path_value(path);
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemRemoved",
+                                    &file_system_path_value,
+                                    nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::OnDevToolsSaveToFile(
+    const std::string& url) {
+  // Notify DevTools.
+  base::StringValue url_value(url);
+  web_contents_->CallClientFunction(
+      "DevToolsAPI.savedURL", &url_value, nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::OnDevToolsAppendToFile(
+    const std::string& url) {
+  // Notify DevTools.
+  base::StringValue url_value(url);
+  web_contents_->CallClientFunction(
+      "DevToolsAPI.appendedToURL", &url_value, nullptr, nullptr);
+}
+
+#if defined(TOOLKIT_VIEWS)
+gfx::ImageSkia CommonWebContentsDelegate::GetDevToolsWindowIcon() {
+  if (!owner_window())
+    return gfx::ImageSkia();
+  return static_cast<views::WidgetDelegate*>(static_cast<NativeWindowViews*>(
+      owner_window()))->GetWindowAppIcon();
+}
+#endif
+
+#if defined(USE_X11)
+void CommonWebContentsDelegate::GetDevToolsWindowWMClass(
+    std::string* name, std::string* class_name) {
+  *class_name = Browser::Get()->GetName();
+  *name = base::ToLowerASCII(*class_name);
+}
+#endif
+
+void CommonWebContentsDelegate::SetHtmlApiFullscreen(bool enter_fullscreen) {
+  // Window is already in fullscreen mode, save the state.
+  if (enter_fullscreen && owner_window_->IsFullscreen()) {
+    native_fullscreen_ = true;
+    html_fullscreen_ = true;
+    return;
+  }
+
+  // Exit html fullscreen state but not window's fullscreen mode.
+  if (!enter_fullscreen && native_fullscreen_) {
+    html_fullscreen_ = false;
+    return;
+  }
+
+  owner_window_->SetFullScreen(enter_fullscreen);
+  html_fullscreen_ = enter_fullscreen;
+  native_fullscreen_ = false;
+}
+
+}  // namespace electron
added in remote
  their  100644 9a35fe85ae53a4ffe98b7fb7f9c75dac12980963 electron/browser/common_web_contents_delegate.h
@@ -0,0 +1,137 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
+#define ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "brightray/browser/inspectable_web_contents_impl.h"
+#include "brightray/browser/inspectable_web_contents_delegate.h"
+#include "brightray/browser/inspectable_web_contents_view_delegate.h"
+#include "content/public/browser/web_contents_delegate.h"
+
+namespace electron {
+
+class ElectronJavaScriptDialogManager;
+class NativeWindow;
+class WebDialogHelper;
+
+class CommonWebContentsDelegate
+    : public content::WebContentsDelegate,
+      public brightray::InspectableWebContentsDelegate,
+      public brightray::InspectableWebContentsViewDelegate {
+ public:
+  CommonWebContentsDelegate();
+  virtual ~CommonWebContentsDelegate();
+
+  // Creates a InspectableWebContents object and takes onwership of
+  // |web_contents|.
+  void InitWithWebContents(content::WebContents* web_contents);
+
+  // Set the window as owner window.
+  void SetOwnerWindow(NativeWindow* owner_window);
+  void SetOwnerWindow(content::WebContents* web_contents,
+                      NativeWindow* owner_window);
+
+  // Destroy the managed InspectableWebContents object.
+  void DestroyWebContents();
+
+  // Returns the WebContents managed by this delegate.
+  content::WebContents* GetWebContents() const;
+
+  // Returns the WebContents of devtools.
+  content::WebContents* GetDevToolsWebContents() const;
+
+  brightray::InspectableWebContents* managed_web_contents() const {
+    return web_contents_.get();
+  }
+
+  NativeWindow* owner_window() const { return owner_window_.get(); }
+
+  bool is_html_fullscreen() const { return html_fullscreen_; }
+
+ protected:
+  // content::WebContentsDelegate:
+  content::WebContents* OpenURLFromTab(
+      content::WebContents* source,
+      const content::OpenURLParams& params) override;
+  bool CanOverscrollContent() const override;
+  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
+      content::WebContents* source) override;
+  content::ColorChooser* OpenColorChooser(
+      content::WebContents* web_contents,
+      SkColor color,
+      const std::vector<content::ColorSuggestion>& suggestions) override;
+  void RunFileChooser(content::WebContents* web_contents,
+                      const content::FileChooserParams& params) override;
+  void EnumerateDirectory(content::WebContents* web_contents,
+                          int request_id,
+                          const base::FilePath& path) override;
+  void EnterFullscreenModeForTab(content::WebContents* source,
+                                 const GURL& origin) override;
+  void ExitFullscreenModeForTab(content::WebContents* source) override;
+  bool IsFullscreenForTabOrPending(
+      const content::WebContents* source) const override;
+
+  // brightray::InspectableWebContentsDelegate:
+  void DevToolsSaveToFile(const std::string& url,
+                          const std::string& content,
+                          bool save_as) override;
+  void DevToolsAppendToFile(const std::string& url,
+                            const std::string& content) override;
+  void DevToolsRequestFileSystems() override;
+  void DevToolsAddFileSystem(const base::FilePath& path) override;
+  void DevToolsRemoveFileSystem(
+      const base::FilePath& file_system_path) override;
+
+  // brightray::InspectableWebContentsViewDelegate:
+#if defined(TOOLKIT_VIEWS)
+  gfx::ImageSkia GetDevToolsWindowIcon() override;
+#endif
+#if defined(USE_X11)
+  void GetDevToolsWindowWMClass(
+      std::string* name, std::string* class_name) override;
+#endif
+
+ private:
+  // Callback for when DevToolsSaveToFile has completed.
+  void OnDevToolsSaveToFile(const std::string& url);
+
+  // Callback for when DevToolsAppendToFile has completed.
+  void OnDevToolsAppendToFile(const std::string& url);
+
+  // Set fullscreen mode triggered by html api.
+  void SetHtmlApiFullscreen(bool enter_fullscreen);
+
+  // The window that this WebContents belongs to.
+  base::WeakPtr<NativeWindow> owner_window_;
+
+  // Whether window is fullscreened by HTML5 api.
+  bool html_fullscreen_;
+
+  // Whether window is fullscreened by window api.
+  bool native_fullscreen_;
+
+  scoped_ptr<WebDialogHelper> web_dialog_helper_;
+  scoped_ptr<ElectronJavaScriptDialogManager> dialog_manager_;
+
+  // The stored InspectableWebContents object.
+  // Notice that web_contents_ must be placed after dialog_manager_, so we can
+  // make sure web_contents_ is destroyed before dialog_manager_, otherwise a
+  // crash would happen.
+  scoped_ptr<brightray::InspectableWebContents> web_contents_;
+
+  // Maps url to file path, used by the file requests sent from devtools.
+  typedef std::map<std::string, base::FilePath> PathsMap;
+  PathsMap saved_files_;
+
+  DISALLOW_COPY_AND_ASSIGN(CommonWebContentsDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
added in remote
  their  100644 da7cef5479361a662c388a5e81526c3a343aa702 electron/browser/electron_access_token_store.cc
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_access_token_store.h"
+
+#include <utility>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/google_api_key.h"
+#include "content/public/browser/geolocation_provider.h"
+
+namespace electron {
+
+namespace {
+
+// Notice that we just combined the api key with the url together here, because
+// if we use the standard {url: key} format Chromium would override our key with
+// the predefined one in common.gypi of libchromiumcontent, which is empty.
+const char* kGeolocationProviderURL =
+    "https://www.googleapis.com/geolocation/v1/geolocate?key="
+    GOOGLEAPIS_API_KEY;
+
+}  // namespace
+
+ElectronAccessTokenStore::ElectronAccessTokenStore() {
+  content::GeolocationProvider::GetInstance()->UserDidOptIntoLocationServices();
+}
+
+ElectronAccessTokenStore::~ElectronAccessTokenStore() {
+}
+
+void ElectronAccessTokenStore::LoadAccessTokens(
+    const LoadAccessTokensCallbackType& callback) {
+  AccessTokenSet access_token_set;
+
+  // Equivelent to access_token_set[kGeolocationProviderURL].
+  // Somehow base::string16 is causing compilation errors when used in a pair
+  // of std::map on Linux, this can work around it.
+  std::pair<GURL, base::string16> token_pair;
+  token_pair.first = GURL(kGeolocationProviderURL);
+  access_token_set.insert(token_pair);
+
+  auto browser_context = ElectronBrowserMainParts::Get()->browser_context();
+  callback.Run(access_token_set, browser_context->url_request_context_getter());
+}
+
+void ElectronAccessTokenStore::SaveAccessToken(const GURL& server_url,
+                                           const base::string16& access_token) {
+}
+
+}  // namespace electron
added in remote
  their  100644 cfc689532517feb9cc0283c3bea033dac5c02752 electron/browser/electron_access_token_store.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
+#define ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
+
+#include "content/public/browser/access_token_store.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+class ElectronAccessTokenStore : public content::AccessTokenStore {
+ public:
+  ElectronAccessTokenStore();
+  virtual ~ElectronAccessTokenStore();
+
+  // content::AccessTokenStore:
+  void LoadAccessTokens(
+      const LoadAccessTokensCallbackType& callback) override;
+  void SaveAccessToken(const GURL& server_url,
+                       const base::string16& access_token) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronAccessTokenStore);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
added in remote
  their  100644 41d51d8c8347f0a1e577bd9ba6fe7eb90b905555 electron/browser/electron_browser_client.cc
@@ -0,0 +1,302 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_client.h"
+
+#if defined(OS_WIN)
+#include <shlobj.h>
+#endif
+
+#include "electron/browser/electron_access_token_store.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_quota_permission_context.h"
+#include "electron/browser/electron_resource_dispatcher_host_delegate.h"
+#include "electron/browser/electron_speech_recognition_manager_delegate.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/printing/printing_message_filter.h"
+#include "chrome/browser/renderer_host/pepper/chrome_browser_pepper_host_factory.h"
+#include "chrome/browser/renderer_host/pepper/widevine_cdm_message_filter.h"
+#include "chrome/browser/speech/tts_message_filter.h"
+#include "content/public/browser/browser_ppapi_host.h"
+#include "content/public/browser/client_certificate_delegate.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/resource_dispatcher_host.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/web_preferences.h"
+#include "net/cert/x509_certificate.h"
+#include "net/ssl/ssl_cert_request_info.h"
+#include "ppapi/host/ppapi_host.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+namespace {
+
+// Next navigation should not restart renderer process.
+bool g_suppress_renderer_process_restart = false;
+
+// Custom schemes to be registered to standard.
+std::string g_custom_schemes = "";
+// Custom schemes to be registered to handle service worker.
+std::string g_custom_service_worker_schemes = "";
+
+scoped_refptr<net::X509Certificate> ImportCertFromFile(
+    const base::FilePath& path) {
+  if (path.empty())
+    return nullptr;
+
+  std::string cert_data;
+  if (!base::ReadFileToString(path, &cert_data))
+    return nullptr;
+
+  net::CertificateList certs =
+      net::X509Certificate::CreateCertificateListFromBytes(
+          cert_data.data(), cert_data.size(),
+          net::X509Certificate::FORMAT_AUTO);
+
+  if (certs.empty())
+    return nullptr;
+
+  return certs[0];
+}
+
+}  // namespace
+
+// static
+void ElectronBrowserClient::SuppressRendererProcessRestartForOnce() {
+  g_suppress_renderer_process_restart = true;
+}
+
+void ElectronBrowserClient::SetCustomSchemes(
+    const std::vector<std::string>& schemes) {
+  g_custom_schemes = base::JoinString(schemes, ",");
+}
+
+void ElectronBrowserClient::SetCustomServiceWorkerSchemes(
+    const std::vector<std::string>& schemes) {
+  g_custom_service_worker_schemes = base::JoinString(schemes, ",");
+}
+
+ElectronBrowserClient::ElectronBrowserClient() : delegate_(nullptr) {
+}
+
+ElectronBrowserClient::~ElectronBrowserClient() {
+}
+
+void ElectronBrowserClient::RenderProcessWillLaunch(
+    content::RenderProcessHost* host) {
+  int process_id = host->GetID();
+  host->AddFilter(new printing::PrintingMessageFilter(process_id));
+  host->AddFilter(new TtsMessageFilter(process_id, host->GetBrowserContext()));
+  host->AddFilter(
+      new WidevineCdmMessageFilter(process_id, host->GetBrowserContext()));
+}
+
+content::SpeechRecognitionManagerDelegate*
+    ElectronBrowserClient::CreateSpeechRecognitionManagerDelegate() {
+  return new ElectronSpeechRecognitionManagerDelegate;
+}
+
+content::AccessTokenStore* ElectronBrowserClient::CreateAccessTokenStore() {
+  return new ElectronAccessTokenStore;
+}
+
+void ElectronBrowserClient::OverrideWebkitPrefs(
+    content::RenderViewHost* host, content::WebPreferences* prefs) {
+  prefs->javascript_enabled = true;
+  prefs->web_security_enabled = true;
+  prefs->javascript_can_open_windows_automatically = true;
+  prefs->plugins_enabled = true;
+  prefs->dom_paste_enabled = true;
+  prefs->allow_scripts_to_close_windows = true;
+  prefs->javascript_can_access_clipboard = true;
+  prefs->local_storage_enabled = true;
+  prefs->databases_enabled = true;
+  prefs->application_cache_enabled = true;
+  prefs->allow_universal_access_from_file_urls = true;
+  prefs->allow_file_access_from_file_urls = true;
+  prefs->experimental_webgl_enabled = true;
+  prefs->allow_displaying_insecure_content = false;
+  prefs->allow_running_insecure_content = false;
+
+  // Custom preferences of guest page.
+  auto web_contents = content::WebContents::FromRenderViewHost(host);
+  WebContentsPreferences::OverrideWebkitPrefs(web_contents, prefs);
+}
+
+std::string ElectronBrowserClient::GetApplicationLocale() {
+  return l10n_util::GetApplicationLocale("");
+}
+
+void ElectronBrowserClient::OverrideSiteInstanceForNavigation(
+    content::BrowserContext* browser_context,
+    content::SiteInstance* current_instance,
+    const GURL& url,
+    content::SiteInstance** new_instance) {
+  if (g_suppress_renderer_process_restart) {
+    g_suppress_renderer_process_restart = false;
+    return;
+  }
+
+  // Restart renderer process for all navigations except "javacript:" scheme.
+  if (url.SchemeIs(url::kJavaScriptScheme))
+    return;
+
+  *new_instance = content::SiteInstance::CreateForURL(browser_context, url);
+
+  // Remember the original renderer process of the pending renderer process.
+  auto current_process = current_instance->GetProcess();
+  auto pending_process = (*new_instance)->GetProcess();
+  pending_processes_[pending_process->GetID()] = current_process->GetID();
+  // Clear the entry in map when process ends.
+  current_process->AddObserver(this);
+}
+
+void ElectronBrowserClient::AppendExtraCommandLineSwitches(
+    base::CommandLine* command_line,
+    int process_id) {
+  std::string process_type = command_line->GetSwitchValueASCII("type");
+  if (process_type != "renderer")
+    return;
+
+  // The registered standard schemes.
+  if (!g_custom_schemes.empty())
+    command_line->AppendSwitchASCII(switches::kRegisterStandardSchemes,
+                                    g_custom_schemes);
+
+  // The registered service worker schemes.
+  if (!g_custom_service_worker_schemes.empty())
+    command_line->AppendSwitchASCII(switches::kRegisterServiceWorkerSchemes,
+                                    g_custom_service_worker_schemes);
+
+#if defined(OS_WIN)
+  // Append --app-user-model-id.
+  PWSTR current_app_id;
+  if (SUCCEEDED(GetCurrentProcessExplicitAppUserModelID(&current_app_id))) {
+    command_line->AppendSwitchNative(switches::kAppUserModelId, current_app_id);
+    CoTaskMemFree(current_app_id);
+  }
+#endif
+
+  // If the process is a pending process, we should use the old one.
+  if (ContainsKey(pending_processes_, process_id))
+    process_id = pending_processes_[process_id];
+
+  // Certain render process will be created with no associated render view,
+  // for example: ServiceWorker.
+  content::WebContents* web_contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(process_id);
+  if (!web_contents)
+    return;
+
+  WebContentsPreferences::AppendExtraCommandLineSwitches(
+      web_contents, command_line);
+}
+
+void ElectronBrowserClient::DidCreatePpapiPlugin(
+    content::BrowserPpapiHost* host) {
+  host->GetPpapiHost()->AddHostFactoryFilter(
+      make_scoped_ptr(new chrome::ChromeBrowserPepperHostFactory(host)));
+}
+
+content::QuotaPermissionContext*
+    ElectronBrowserClient::CreateQuotaPermissionContext() {
+  return new ElectronQuotaPermissionContext;
+}
+
+void ElectronBrowserClient::AllowCertificateError(
+    content::WebContents* web_contents,
+    int cert_error,
+    const net::SSLInfo& ssl_info,
+    const GURL& request_url,
+    content::ResourceType resource_type,
+    bool overridable,
+    bool strict_enforcement,
+    bool expired_previous_decision,
+    const base::Callback<void(bool)>& callback,
+    content::CertificateRequestResultType* request) {
+  if (delegate_) {
+    delegate_->AllowCertificateError(
+        web_contents, cert_error, ssl_info, request_url,
+        resource_type, overridable, strict_enforcement,
+        expired_previous_decision, callback, request);
+  }
+}
+
+void ElectronBrowserClient::SelectClientCertificate(
+    content::WebContents* web_contents,
+    net::SSLCertRequestInfo* cert_request_info,
+    scoped_ptr<content::ClientCertificateDelegate> delegate) {
+  // --client-certificate=`path`
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch(switches::kClientCertificate)) {
+    auto cert_path = cmd->GetSwitchValuePath(switches::kClientCertificate);
+    auto certificate = ImportCertFromFile(cert_path);
+    if (certificate.get())
+      delegate->ContinueWithCertificate(certificate.get());
+    return;
+  }
+
+  if (!cert_request_info->client_certs.empty() && delegate_) {
+    delegate_->SelectClientCertificate(
+        web_contents, cert_request_info, std::move(delegate));
+  }
+}
+
+void ElectronBrowserClient::ResourceDispatcherHostCreated() {
+  resource_dispatcher_host_delegate_.reset(
+      new ElectronResourceDispatcherHostDelegate);
+  content::ResourceDispatcherHost::Get()->SetDelegate(
+      resource_dispatcher_host_delegate_.get());
+}
+
+brightray::BrowserMainParts* ElectronBrowserClient::OverrideCreateBrowserMainParts(
+    const content::MainFunctionParams&) {
+  v8::V8::Initialize();  // Init V8 before creating main parts.
+  return new ElectronBrowserMainParts;
+}
+
+void ElectronBrowserClient::WebNotificationAllowed(
+    int render_process_id,
+    const base::Callback<void(bool)>& callback) {
+  content::WebContents* web_contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(render_process_id);
+  if (!web_contents) {
+    callback.Run(false);
+    return;
+  }
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  if (!permission_helper) {
+    callback.Run(false);
+    return;
+  }
+  permission_helper->RequestWebNotificationPermission(callback);
+}
+
+void ElectronBrowserClient::RenderProcessHostDestroyed(
+    content::RenderProcessHost* host) {
+  int process_id = host->GetID();
+  for (const auto& entry : pending_processes_) {
+    if (entry.first == process_id || entry.second == process_id) {
+      pending_processes_.erase(entry.first);
+      break;
+    }
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 5caf0726cdd06c49b68366b09e78348ed609297a electron/browser/electron_browser_client.h
@@ -0,0 +1,104 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "brightray/browser/browser_client.h"
+#include "content/public/browser/render_process_host_observer.h"
+
+namespace content {
+class QuotaPermissionContext;
+class ClientCertificateDelegate;
+}
+
+namespace net {
+class SSLCertRequestInfo;
+}
+
+namespace electron {
+
+class ElectronResourceDispatcherHostDelegate;
+
+class ElectronBrowserClient : public brightray::BrowserClient,
+                          public content::RenderProcessHostObserver {
+ public:
+  ElectronBrowserClient();
+  virtual ~ElectronBrowserClient();
+
+  using Delegate = content::ContentBrowserClient;
+  void set_delegate(Delegate* delegate) { delegate_ = delegate; }
+
+  // Don't force renderer process to restart for once.
+  static void SuppressRendererProcessRestartForOnce();
+  // Custom schemes to be registered to standard.
+  static void SetCustomSchemes(const std::vector<std::string>& schemes);
+  // Custom schemes to be registered to handle service worker.
+  static void SetCustomServiceWorkerSchemes(
+      const std::vector<std::string>& schemes);
+
+ protected:
+  // content::ContentBrowserClient:
+  void RenderProcessWillLaunch(content::RenderProcessHost* host) override;
+  content::SpeechRecognitionManagerDelegate*
+      CreateSpeechRecognitionManagerDelegate() override;
+  content::AccessTokenStore* CreateAccessTokenStore() override;
+  void OverrideWebkitPrefs(content::RenderViewHost* render_view_host,
+                           content::WebPreferences* prefs) override;
+  std::string GetApplicationLocale() override;
+  void OverrideSiteInstanceForNavigation(
+      content::BrowserContext* browser_context,
+      content::SiteInstance* current_instance,
+      const GURL& dest_url,
+      content::SiteInstance** new_instance) override;
+  void AppendExtraCommandLineSwitches(base::CommandLine* command_line,
+                                      int child_process_id) override;
+  void DidCreatePpapiPlugin(content::BrowserPpapiHost* browser_host) override;
+  content::QuotaPermissionContext* CreateQuotaPermissionContext() override;
+  void AllowCertificateError(
+      content::WebContents* web_contents,
+      int cert_error,
+      const net::SSLInfo& ssl_info,
+      const GURL& request_url,
+      content::ResourceType resource_type,
+      bool overridable,
+      bool strict_enforcement,
+      bool expired_previous_decision,
+      const base::Callback<void(bool)>& callback,
+      content::CertificateRequestResultType* request) override;
+  void SelectClientCertificate(
+      content::WebContents* web_contents,
+      net::SSLCertRequestInfo* cert_request_info,
+      scoped_ptr<content::ClientCertificateDelegate> delegate) override;
+  void ResourceDispatcherHostCreated() override;
+
+  // brightray::BrowserClient:
+  brightray::BrowserMainParts* OverrideCreateBrowserMainParts(
+      const content::MainFunctionParams&) override;
+  void WebNotificationAllowed(
+      int render_process_id,
+      const base::Callback<void(bool)>& callback) override;
+
+  // content::RenderProcessHostObserver:
+  void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
+
+ private:
+  // pending_render_process => current_render_process.
+  std::map<int, int> pending_processes_;
+
+  scoped_ptr<ElectronResourceDispatcherHostDelegate>
+      resource_dispatcher_host_delegate_;
+
+  Delegate* delegate_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
added in remote
  their  100644 3345ea0c21c29a299a3829d8f50bb9b8bacae8d6 electron/browser/electron_browser_context.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_context.h"
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_download_manager_delegate.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/net/electron_cert_verifier.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "electron/browser/net/electron_ssl_config_service.h"
+#include "electron/browser/net/electron_url_request_job_factory.h"
+#include "electron/browser/net/asar/asar_protocol_handler.h"
+#include "electron/browser/net/http_protocol_handler.h"
+#include "electron/browser/electron_permission_manager.h"
+#include "electron/browser/web_view_manager.h"
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "base/prefs/pref_registry_simple.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/threading/sequenced_worker_pool.h"
+#include "base/threading/worker_pool.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/common/user_agent.h"
+#include "net/ftp/ftp_network_layer.h"
+#include "net/url_request/data_protocol_handler.h"
+#include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/url_request_intercepting_job_factory.h"
+#include "net/url_request/url_request_context.h"
+#include "url/url_constants.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+class NoCacheBackend : public net::HttpCache::BackendFactory {
+  int CreateBackend(net::NetLog* net_log,
+                    scoped_ptr<disk_cache::Backend>* backend,
+                    const net::CompletionCallback& callback) override {
+    return net::ERR_FAILED;
+  }
+};
+
+std::string RemoveWhitespace(const std::string& str) {
+  std::string trimmed;
+  if (base::RemoveChars(str, " ", &trimmed))
+    return trimmed;
+  else
+    return str;
+}
+
+}  // namespace
+
+ElectronBrowserContext::ElectronBrowserContext(const std::string& partition,
+                                       bool in_memory)
+    : brightray::BrowserContext(partition, in_memory),
+      cert_verifier_(nullptr),
+      job_factory_(new ElectronURLRequestJobFactory),
+      network_delegate_(new ElectronNetworkDelegate),
+      allow_ntlm_everywhere_(false) {
+}
+
+ElectronBrowserContext::~ElectronBrowserContext() {
+}
+
+net::NetworkDelegate* ElectronBrowserContext::CreateNetworkDelegate() {
+  return network_delegate_;
+}
+
+std::string ElectronBrowserContext::GetUserAgent() {
+  Browser* browser = Browser::Get();
+  std::string name = RemoveWhitespace(browser->GetName());
+  std::string user_agent;
+  if (name == ELECTRON_PRODUCT_NAME) {
+    user_agent = "Chrome/" CHROME_VERSION_STRING " "
+                 ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING;
+  } else {
+    user_agent = base::StringPrintf(
+        "%s/%s Chrome/%s " ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING,
+        name.c_str(),
+        browser->GetVersion().c_str(),
+        CHROME_VERSION_STRING);
+  }
+  return content::BuildUserAgentFromProduct(user_agent);
+}
+
+scoped_ptr<net::URLRequestJobFactory>
+ElectronBrowserContext::CreateURLRequestJobFactory(
+    content::ProtocolHandlerMap* handlers,
+    content::URLRequestInterceptorScopedVector* interceptors) {
+  scoped_ptr<ElectronURLRequestJobFactory> job_factory(job_factory_);
+
+  for (auto& it : *handlers) {
+    job_factory->SetProtocolHandler(it.first,
+                                    make_scoped_ptr(it.second.release()));
+  }
+  handlers->clear();
+
+  job_factory->SetProtocolHandler(
+      url::kDataScheme, make_scoped_ptr(new net::DataProtocolHandler));
+  job_factory->SetProtocolHandler(
+      url::kFileScheme, make_scoped_ptr(new asar::AsarProtocolHandler(
+          BrowserThread::GetBlockingPool()->GetTaskRunnerWithShutdownBehavior(
+              base::SequencedWorkerPool::SKIP_ON_SHUTDOWN))));
+  job_factory->SetProtocolHandler(
+      url::kHttpScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kHttpScheme)));
+  job_factory->SetProtocolHandler(
+      url::kHttpsScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kHttpsScheme)));
+  job_factory->SetProtocolHandler(
+      url::kWsScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kWsScheme)));
+  job_factory->SetProtocolHandler(
+      url::kWssScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kWssScheme)));
+
+  auto host_resolver =
+      url_request_context_getter()->GetURLRequestContext()->host_resolver();
+  job_factory->SetProtocolHandler(
+      url::kFtpScheme,
+      make_scoped_ptr(new net::FtpProtocolHandler(
+          new net::FtpNetworkLayer(host_resolver))));
+
+  // Set up interceptors in the reverse order.
+  scoped_ptr<net::URLRequestJobFactory> top_job_factory =
+      std::move(job_factory);
+  content::URLRequestInterceptorScopedVector::reverse_iterator it;
+  for (it = interceptors->rbegin(); it != interceptors->rend(); ++it)
+    top_job_factory.reset(new net::URLRequestInterceptingJobFactory(
+        std::move(top_job_factory), make_scoped_ptr(*it)));
+  interceptors->weak_clear();
+
+  return top_job_factory;
+}
+
+net::HttpCache::BackendFactory*
+ElectronBrowserContext::CreateHttpCacheBackendFactory(
+    const base::FilePath& base_path) {
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableHttpCache))
+    return new NoCacheBackend;
+  else
+    return brightray::BrowserContext::CreateHttpCacheBackendFactory(base_path);
+}
+
+content::DownloadManagerDelegate*
+ElectronBrowserContext::GetDownloadManagerDelegate() {
+  if (!download_manager_delegate_.get()) {
+    auto download_manager = content::BrowserContext::GetDownloadManager(this);
+    download_manager_delegate_.reset(
+        new ElectronDownloadManagerDelegate(download_manager));
+  }
+  return download_manager_delegate_.get();
+}
+
+content::BrowserPluginGuestManager* ElectronBrowserContext::GetGuestManager() {
+  if (!guest_manager_)
+    guest_manager_.reset(new WebViewManager);
+  return guest_manager_.get();
+}
+
+content::PermissionManager* ElectronBrowserContext::GetPermissionManager() {
+  if (!permission_manager_.get())
+    permission_manager_.reset(new ElectronPermissionManager);
+  return permission_manager_.get();
+}
+
+scoped_ptr<net::CertVerifier> ElectronBrowserContext::CreateCertVerifier() {
+  DCHECK(!cert_verifier_);
+  cert_verifier_ = new ElectronCertVerifier;
+  return make_scoped_ptr(cert_verifier_);
+}
+
+net::SSLConfigService* ElectronBrowserContext::CreateSSLConfigService() {
+  return new ElectronSSLConfigService;
+}
+
+void ElectronBrowserContext::RegisterPrefs(PrefRegistrySimple* pref_registry) {
+  pref_registry->RegisterFilePathPref(prefs::kSelectFileLastDirectory,
+                                      base::FilePath());
+  base::FilePath download_dir;
+  PathService::Get(chrome::DIR_DEFAULT_DOWNLOADS, &download_dir);
+  pref_registry->RegisterFilePathPref(prefs::kDownloadDefaultDirectory,
+                                      download_dir);
+  pref_registry->RegisterDictionaryPref(prefs::kDevToolsFileSystemPaths);
+}
+
+bool ElectronBrowserContext::AllowNTLMCredentialsForDomain(const GURL& origin) {
+  if (allow_ntlm_everywhere_)
+    return true;
+  return Delegate::AllowNTLMCredentialsForDomain(origin);
+}
+
+void ElectronBrowserContext::AllowNTLMCredentialsForAllDomains(bool should_allow) {
+  allow_ntlm_everywhere_ = should_allow;
+}
+
+}  // namespace electron
+
+namespace brightray {
+
+// static
+scoped_refptr<BrowserContext> BrowserContext::Create(
+    const std::string& partition, bool in_memory) {
+  return make_scoped_refptr(new electron::ElectronBrowserContext(partition, in_memory));
+}
+
+}  // namespace brightray
added in remote
  their  100644 c310aa5f351f2b0c3ab4ce6bf95aa561255dfb4e electron/browser/electron_browser_context.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
+
+#include <string>
+
+#include "brightray/browser/browser_context.h"
+
+namespace electron {
+
+class ElectronDownloadManagerDelegate;
+class ElectronCertVerifier;
+class ElectronNetworkDelegate;
+class ElectronPermissionManager;
+class ElectronURLRequestJobFactory;
+class WebViewManager;
+
+class ElectronBrowserContext : public brightray::BrowserContext {
+ public:
+  ElectronBrowserContext(const std::string& partition, bool in_memory);
+  ~ElectronBrowserContext() override;
+
+  // brightray::URLRequestContextGetter::Delegate:
+  net::NetworkDelegate* CreateNetworkDelegate() override;
+  std::string GetUserAgent() override;
+  scoped_ptr<net::URLRequestJobFactory> CreateURLRequestJobFactory(
+      content::ProtocolHandlerMap* handlers,
+      content::URLRequestInterceptorScopedVector* interceptors) override;
+  net::HttpCache::BackendFactory* CreateHttpCacheBackendFactory(
+      const base::FilePath& base_path) override;
+  scoped_ptr<net::CertVerifier> CreateCertVerifier() override;
+  net::SSLConfigService* CreateSSLConfigService() override;
+  bool AllowNTLMCredentialsForDomain(const GURL& auth_origin) override;
+
+  // content::BrowserContext:
+  content::DownloadManagerDelegate* GetDownloadManagerDelegate() override;
+  content::BrowserPluginGuestManager* GetGuestManager() override;
+  content::PermissionManager* GetPermissionManager() override;
+
+  // brightray::BrowserContext:
+  void RegisterPrefs(PrefRegistrySimple* pref_registry) override;
+
+  void AllowNTLMCredentialsForAllDomains(bool should_allow);
+
+  ElectronCertVerifier* cert_verifier() const { return cert_verifier_; }
+
+  ElectronURLRequestJobFactory* job_factory() const { return job_factory_; }
+
+  ElectronNetworkDelegate* network_delegate() const { return network_delegate_; }
+
+ private:
+  scoped_ptr<ElectronDownloadManagerDelegate> download_manager_delegate_;
+  scoped_ptr<WebViewManager> guest_manager_;
+  scoped_ptr<ElectronPermissionManager> permission_manager_;
+
+  // Managed by brightray::BrowserContext.
+  ElectronCertVerifier* cert_verifier_;
+  ElectronURLRequestJobFactory* job_factory_;
+  ElectronNetworkDelegate* network_delegate_;
+
+  bool allow_ntlm_everywhere_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserContext);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
added in remote
  their  100644 3eb568425c7f3965effef3372a4f19d215c3f559 electron/browser/electron_browser_main_parts.cc
@@ -0,0 +1,189 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/bridge_task_runner.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/javascript_environment.h"
+#include "electron/browser/node_debugger.h"
+#include "electron/common/api/electron_bindings.h"
+#include "electron/common/node_bindings.h"
+#include "electron/common/node_includes.h"
+#include "base/command_line.h"
+#include "base/thread_task_runner_handle.h"
+#include "chrome/browser/browser_process.h"
+#include "v8/include/v8-debug.h"
+
+#if defined(USE_X11)
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "ui/events/devices/x11/touch_factory_x11.h"
+#endif
+
+namespace electron {
+
+template<typename T>
+void Erase(T* container, typename T::iterator iter) {
+  container->erase(iter);
+}
+
+// static
+ElectronBrowserMainParts* ElectronBrowserMainParts::self_ = NULL;
+
+ElectronBrowserMainParts::ElectronBrowserMainParts()
+    : fake_browser_process_(new BrowserProcess),
+      exit_code_(nullptr),
+      browser_(new Browser),
+      node_bindings_(NodeBindings::Create(true)),
+      electron_bindings_(new ElectronBindings),
+      gc_timer_(true, true) {
+  DCHECK(!self_) << "Cannot have two ElectronBrowserMainParts";
+  self_ = this;
+}
+
+ElectronBrowserMainParts::~ElectronBrowserMainParts() {
+  // Leak the JavascriptEnvironment on exit.
+  // This is to work around the bug that V8 would be waiting for background
+  // tasks to finish on exit, while somehow it waits forever in Electron, more
+  // about this can be found at https://github.com/electron/electron/issues/4767.
+  // On the other handle there is actually no need to gracefully shutdown V8
+  // on exit in the main process, we already ensured all necessary resources get
+  // cleaned up, and it would make quitting faster.
+  ignore_result(js_env_.release());
+}
+
+// static
+ElectronBrowserMainParts* ElectronBrowserMainParts::Get() {
+  DCHECK(self_);
+  return self_;
+}
+
+bool ElectronBrowserMainParts::SetExitCode(int code) {
+  if (!exit_code_)
+    return false;
+
+  *exit_code_ = code;
+  return true;
+}
+
+int ElectronBrowserMainParts::GetExitCode() {
+  return exit_code_ != nullptr ? *exit_code_ : 0;
+}
+
+base::Closure ElectronBrowserMainParts::RegisterDestructionCallback(
+    const base::Closure& callback) {
+  auto iter = destructors_.insert(destructors_.end(), callback);
+  return base::Bind(&Erase<std::list<base::Closure>>, &destructors_, iter);
+}
+
+void ElectronBrowserMainParts::PreEarlyInitialization() {
+  brightray::BrowserMainParts::PreEarlyInitialization();
+#if defined(OS_POSIX)
+  HandleSIGCHLD();
+#endif
+}
+
+void ElectronBrowserMainParts::PostEarlyInitialization() {
+  brightray::BrowserMainParts::PostEarlyInitialization();
+
+  // Temporary set the bridge_task_runner_ as current thread's task runner,
+  // so we can fool gin::PerIsolateData to use it as its task runner, instead
+  // of getting current message loop's task runner, which is null for now.
+  bridge_task_runner_ = new BridgeTaskRunner;
+  base::ThreadTaskRunnerHandle handle(bridge_task_runner_);
+
+  // The ProxyResolverV8 has setup a complete V8 environment, in order to
+  // avoid conflicts we only initialize our V8 environment after that.
+  js_env_.reset(new JavascriptEnvironment);
+
+  node_bindings_->Initialize();
+
+  // Support the "--debug" switch.
+  node_debugger_.reset(new NodeDebugger(js_env_->isolate()));
+
+  // Create the global environment.
+  node::Environment* env =
+      node_bindings_->CreateEnvironment(js_env_->context());
+
+  // Make sure node can get correct environment when debugging.
+  if (node_debugger_->IsRunning())
+    env->AssignToContext(v8::Debug::GetDebugContext());
+
+  // Add Electron extended APIs.
+  electron_bindings_->BindTo(js_env_->isolate(), env->process_object());
+
+  // Load everything.
+  node_bindings_->LoadEnvironment(env);
+
+  // Wrap the uv loop with global env.
+  node_bindings_->set_uv_env(env);
+}
+
+void ElectronBrowserMainParts::PreMainMessageLoopRun() {
+  // Run user's main script before most things get initialized, so we can have
+  // a chance to setup everything.
+  node_bindings_->PrepareMessageLoop();
+  node_bindings_->RunMessageLoop();
+
+#if defined(USE_X11)
+  ui::TouchFactory::SetTouchDeviceListFromCommandLine();
+#endif
+
+  // Start idle gc.
+  gc_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMinutes(1),
+      base::Bind(base::IgnoreResult(&v8::Isolate::IdleNotification),
+                 base::Unretained(js_env_->isolate()),
+                 1000));
+
+  brightray::BrowserMainParts::PreMainMessageLoopRun();
+  bridge_task_runner_->MessageLoopIsReady();
+  bridge_task_runner_ = nullptr;
+
+#if defined(USE_X11)
+  libgtk2ui::GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
+#endif
+
+#if !defined(OS_MACOSX)
+  // The corresponding call in OS X is in ElectronApplicationDelegate.
+  Browser::Get()->WillFinishLaunching();
+  Browser::Get()->DidFinishLaunching();
+#endif
+}
+
+bool ElectronBrowserMainParts::MainMessageLoopRun(int* result_code) {
+  exit_code_ = result_code;
+  return brightray::BrowserMainParts::MainMessageLoopRun(result_code);
+}
+
+void ElectronBrowserMainParts::PostMainMessageLoopStart() {
+  brightray::BrowserMainParts::PostMainMessageLoopStart();
+#if defined(OS_POSIX)
+  HandleShutdownSignals();
+#endif
+}
+
+void ElectronBrowserMainParts::PostMainMessageLoopRun() {
+  brightray::BrowserMainParts::PostMainMessageLoopRun();
+
+#if defined(OS_MACOSX)
+  FreeAppDelegate();
+#endif
+
+  // Make sure destruction callbacks are called before message loop is
+  // destroyed, otherwise some objects that need to be deleted on IO thread
+  // won't be freed.
+  // We don't use ranged for loop because iterators are getting invalided when
+  // the callback runs.
+  for (auto iter = destructors_.begin(); iter != destructors_.end();) {
+    base::Closure& callback = *iter;
+    ++iter;
+    callback.Run();
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 7018522f15ddaa570b28bad81d5b38097e3e47d8 electron/browser/electron_browser_main_parts.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
+
+#include <list>
+#include <string>
+
+#include "base/callback.h"
+#include "base/timer/timer.h"
+#include "brightray/browser/browser_main_parts.h"
+#include "content/public/browser/browser_context.h"
+
+class BrowserProcess;
+
+namespace electron {
+
+class ElectronBindings;
+class Browser;
+class JavascriptEnvironment;
+class NodeBindings;
+class NodeDebugger;
+class BridgeTaskRunner;
+
+class ElectronBrowserMainParts : public brightray::BrowserMainParts {
+ public:
+  ElectronBrowserMainParts();
+  virtual ~ElectronBrowserMainParts();
+
+  static ElectronBrowserMainParts* Get();
+
+  // Sets the exit code, will fail if the message loop is not ready.
+  bool SetExitCode(int code);
+
+  // Gets the exit code
+  int GetExitCode();
+
+  // Register a callback that should be destroyed before JavaScript environment
+  // gets destroyed.
+  // Returns a closure that can be used to remove |callback| from the list.
+  base::Closure RegisterDestructionCallback(const base::Closure& callback);
+
+  Browser* browser() { return browser_.get(); }
+
+ protected:
+  // content::BrowserMainParts:
+  void PreEarlyInitialization() override;
+  void PostEarlyInitialization() override;
+  void PreMainMessageLoopRun() override;
+  bool MainMessageLoopRun(int* result_code) override;
+  void PostMainMessageLoopStart() override;
+  void PostMainMessageLoopRun() override;
+#if defined(OS_MACOSX)
+  void PreMainMessageLoopStart() override;
+#endif
+
+ private:
+#if defined(OS_POSIX)
+  // Set signal handlers.
+  void HandleSIGCHLD();
+  void HandleShutdownSignals();
+#endif
+
+#if defined(OS_MACOSX)
+  void FreeAppDelegate();
+#endif
+
+  // A fake BrowserProcess object that used to feed the source code from chrome.
+  scoped_ptr<BrowserProcess> fake_browser_process_;
+
+  // The gin::PerIsolateData requires a task runner to create, so we feed it
+  // with a task runner that will post all work to main loop.
+  scoped_refptr<BridgeTaskRunner> bridge_task_runner_;
+
+  // Pointer to exit code.
+  int* exit_code_;
+
+  scoped_ptr<Browser> browser_;
+  scoped_ptr<JavascriptEnvironment> js_env_;
+  scoped_ptr<NodeBindings> node_bindings_;
+  scoped_ptr<ElectronBindings> electron_bindings_;
+  scoped_ptr<NodeDebugger> node_debugger_;
+
+  base::Timer gc_timer_;
+
+  // List of callbacks should be executed before destroying JS env.
+  std::list<base::Closure> destructors_;
+
+  static ElectronBrowserMainParts* self_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserMainParts);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
added in remote
  their  100644 c888de5eb3407eb5baeb8073f3d0f77988bc8db8 electron/browser/electron_browser_main_parts_mac.mm
@@ -0,0 +1,36 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include "electron/browser/mac/electron_application.h"
+#include "electron/browser/mac/electron_application_delegate.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/foundation_util.h"
+#include "ui/base/l10n/l10n_util_mac.h"
+
+namespace electron {
+
+void ElectronBrowserMainParts::PreMainMessageLoopStart() {
+  // Force the NSApplication subclass to be used.
+  [ElectronApplication sharedApplication];
+
+  // Set our own application delegate.
+  ElectronApplicationDelegate* delegate = [[ElectronApplicationDelegate alloc] init];
+  [NSApp setDelegate:(id<NSFileManagerDelegate>)delegate];
+
+  brightray::BrowserMainParts::PreMainMessageLoopStart();
+
+  // Prevent Cocoa from turning command-line arguments into
+  // |-application:openFiles:|, since we already handle them directly.
+  [[NSUserDefaults standardUserDefaults]
+      setObject:@"NO" forKey:@"NSTreatUnknownArgumentsAsOpen"];
+}
+
+void ElectronBrowserMainParts::FreeAppDelegate() {
+  [[NSApp delegate] release];
+  [NSApp setDelegate:nil];
+}
+
+}  // namespace electron
added in remote
  their  100644 c0834e5d77035a69c2c62d679e6a8f8a260240ec electron/browser/electron_browser_main_parts_posix.cc
@@ -0,0 +1,225 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Most code came from: chrome/browser/chrome_browser_main_posix.cc.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include <errno.h>
+#include <limits.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+#include "electron/browser/browser.h"
+#include "base/posix/eintr_wrapper.h"
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// See comment in |PreEarlyInitialization()|, where sigaction is called.
+void SIGCHLDHandler(int signal) {
+}
+
+// The OSX fork() implementation can crash in the child process before
+// fork() returns.  In that case, the shutdown pipe will still be
+// shared with the parent process.  To prevent child crashes from
+// causing parent shutdowns, |g_pipe_pid| is the pid for the process
+// which registered |g_shutdown_pipe_write_fd|.
+// See <http://crbug.com/175341>.
+pid_t g_pipe_pid = -1;
+int g_shutdown_pipe_write_fd = -1;
+int g_shutdown_pipe_read_fd = -1;
+
+// Common code between SIG{HUP, INT, TERM}Handler.
+void GracefulShutdownHandler(int signal) {
+  // Reinstall the default handler.  We had one shot at graceful shutdown.
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIG_DFL;
+  RAW_CHECK(sigaction(signal, &action, NULL) == 0);
+
+  RAW_CHECK(g_pipe_pid == getpid());
+  RAW_CHECK(g_shutdown_pipe_write_fd != -1);
+  RAW_CHECK(g_shutdown_pipe_read_fd != -1);
+  size_t bytes_written = 0;
+  do {
+    int rv = HANDLE_EINTR(
+        write(g_shutdown_pipe_write_fd,
+              reinterpret_cast<const char*>(&signal) + bytes_written,
+              sizeof(signal) - bytes_written));
+    RAW_CHECK(rv >= 0);
+    bytes_written += rv;
+  } while (bytes_written < sizeof(signal));
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGHUPHandler(int signal) {
+  RAW_CHECK(signal == SIGHUP);
+  GracefulShutdownHandler(signal);
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGINTHandler(int signal) {
+  RAW_CHECK(signal == SIGINT);
+  GracefulShutdownHandler(signal);
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGTERMHandler(int signal) {
+  RAW_CHECK(signal == SIGTERM);
+  GracefulShutdownHandler(signal);
+}
+
+class ShutdownDetector : public base::PlatformThread::Delegate {
+ public:
+  explicit ShutdownDetector(int shutdown_fd);
+
+  void ThreadMain() override;
+
+ private:
+  const int shutdown_fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(ShutdownDetector);
+};
+
+ShutdownDetector::ShutdownDetector(int shutdown_fd)
+    : shutdown_fd_(shutdown_fd) {
+  CHECK_NE(shutdown_fd_, -1);
+}
+
+// These functions are used to help us diagnose crash dumps that happen
+// during the shutdown process.
+NOINLINE void ShutdownFDReadError() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+NOINLINE void ShutdownFDClosedError() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+NOINLINE void ExitPosted() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+void ShutdownDetector::ThreadMain() {
+  base::PlatformThread::SetName("CrShutdownDetector");
+
+  int signal;
+  size_t bytes_read = 0;
+  ssize_t ret;
+  do {
+    ret = HANDLE_EINTR(
+        read(shutdown_fd_,
+             reinterpret_cast<char*>(&signal) + bytes_read,
+             sizeof(signal) - bytes_read));
+    if (ret < 0) {
+      NOTREACHED() << "Unexpected error: " << strerror(errno);
+      ShutdownFDReadError();
+      break;
+    } else if (ret == 0) {
+      NOTREACHED() << "Unexpected closure of shutdown pipe.";
+      ShutdownFDClosedError();
+      break;
+    }
+    bytes_read += ret;
+  } while (bytes_read < sizeof(signal));
+  VLOG(1) << "Handling shutdown for signal " << signal << ".";
+  base::Closure task =
+      base::Bind(&Browser::Quit, base::Unretained(Browser::Get()));
+
+  if (!BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, task)) {
+    // Without a UI thread to post the exit task to, there aren't many
+    // options.  Raise the signal again.  The default handler will pick it up
+    // and cause an ungraceful exit.
+    RAW_LOG(WARNING, "No UI thread, exiting ungracefully.");
+    kill(getpid(), signal);
+
+    // The signal may be handled on another thread.  Give that a chance to
+    // happen.
+    sleep(3);
+
+    // We really should be dead by now.  For whatever reason, we're not. Exit
+    // immediately, with the exit status set to the signal number with bit 8
+    // set.  On the systems that we care about, this exit status is what is
+    // normally used to indicate an exit by this signal's default handler.
+    // This mechanism isn't a de jure standard, but even in the worst case, it
+    // should at least result in an immediate exit.
+    RAW_LOG(WARNING, "Still here, exiting really ungracefully.");
+    _exit(signal | (1 << 7));
+  }
+  ExitPosted();
+}
+
+}  // namespace
+
+void ElectronBrowserMainParts::HandleSIGCHLD() {
+  // We need to accept SIGCHLD, even though our handler is a no-op because
+  // otherwise we cannot wait on children. (According to POSIX 2001.)
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIGCHLDHandler;
+  CHECK_EQ(sigaction(SIGCHLD, &action, NULL), 0);
+}
+
+void ElectronBrowserMainParts::HandleShutdownSignals() {
+  int pipefd[2];
+  int ret = pipe(pipefd);
+  if (ret < 0) {
+    PLOG(DFATAL) << "Failed to create pipe";
+  } else {
+    g_pipe_pid = getpid();
+    g_shutdown_pipe_read_fd = pipefd[0];
+    g_shutdown_pipe_write_fd = pipefd[1];
+#if !defined(ADDRESS_SANITIZER) && !defined(KEEP_SHADOW_STACKS)
+    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
+#else
+    // ASan instrumentation and -finstrument-functions (used for keeping the
+    // shadow stacks) bloat the stack frames, so we need to increase the stack
+    // size to avoid hitting the guard page.
+    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
+#endif
+    // TODO(viettrungluu,willchan): crbug.com/29675 - This currently leaks, so
+    // if you change this, you'll probably need to change the suppression.
+    if (!base::PlatformThread::CreateNonJoinable(
+            kShutdownDetectorThreadStackSize,
+            new ShutdownDetector(g_shutdown_pipe_read_fd))) {
+      LOG(DFATAL) << "Failed to create shutdown detector task.";
+    }
+  }
+  // Setup signal handlers for shutdown AFTER shutdown pipe is setup because
+  // it may be called right away after handler is set.
+
+  // If adding to this list of signal handlers, note the new signal probably
+  // needs to be reset in child processes. See
+  // base/process_util_posix.cc:LaunchProcess.
+
+  // We need to handle SIGTERM, because that is how many POSIX-based distros ask
+  // processes to quit gracefully at shutdown time.
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIGTERMHandler;
+  CHECK_EQ(sigaction(SIGTERM, &action, NULL), 0);
+  // Also handle SIGINT - when the user terminates the browser via Ctrl+C. If
+  // the browser process is being debugged, GDB will catch the SIGINT first.
+  action.sa_handler = SIGINTHandler;
+  CHECK_EQ(sigaction(SIGINT, &action, NULL), 0);
+  // And SIGHUP, for when the terminal disappears. On shutdown, many Linux
+  // distros send SIGHUP, SIGTERM, and then SIGKILL.
+  action.sa_handler = SIGHUPHandler;
+  CHECK_EQ(sigaction(SIGHUP, &action, NULL), 0);
+}
+
+}  // namespace electron
added in remote
  their  100644 91a7c49b7771172143cd632642f0622d56db4735 electron/browser/electron_download_manager_delegate.cc
@@ -0,0 +1,167 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_download_manager_delegate.h"
+
+#include <string>
+
+#include "electron/browser/api/electron_api_download_item.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/download_manager.h"
+#include "net/base/filename_util.h"
+
+namespace electron {
+
+ElectronDownloadManagerDelegate::ElectronDownloadManagerDelegate(
+    content::DownloadManager* manager)
+    : download_manager_(manager),
+      weak_ptr_factory_(this) {}
+
+ElectronDownloadManagerDelegate::~ElectronDownloadManagerDelegate() {
+  if (download_manager_) {
+    DCHECK_EQ(static_cast<content::DownloadManagerDelegate*>(this),
+              download_manager_->GetDelegate());
+    download_manager_->SetDelegate(nullptr);
+    download_manager_ = nullptr;
+  }
+}
+
+void ElectronDownloadManagerDelegate::CreateDownloadPath(
+    const GURL& url,
+    const std::string& content_disposition,
+    const std::string& suggested_filename,
+    const std::string& mime_type,
+    const base::FilePath& default_download_path,
+    const CreateDownloadPathCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::FILE);
+
+  auto generated_name = net::GenerateFileName(url,
+                                              content_disposition,
+                                              std::string(),
+                                              suggested_filename,
+                                              mime_type,
+                                              std::string());
+
+  if (!base::PathExists(default_download_path))
+    base::CreateDirectory(default_download_path);
+
+  base::FilePath path(default_download_path.Append(generated_name));
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::Bind(callback, path));
+}
+
+void ElectronDownloadManagerDelegate::OnDownloadPathGenerated(
+    uint32_t download_id,
+    const content::DownloadTargetCallback& callback,
+    const base::FilePath& default_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  auto item = download_manager_->GetDownload(download_id);
+  if (!item)
+    return;
+
+  NativeWindow* window = nullptr;
+  auto relay = NativeWindowRelay::FromWebContents(item->GetWebContents());
+  if (relay)
+    window = relay->window.get();
+
+  base::FilePath path;
+  if (file_dialog::ShowSaveDialog(window, item->GetURL().spec(), default_path,
+                                  file_dialog::Filters(), &path)) {
+    // Remember the last selected download directory.
+    ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+        download_manager_->GetBrowserContext());
+    browser_context->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
+                                          path.DirName());
+  }
+
+  // Running the DownloadTargetCallback with an empty FilePath signals that the
+  // download should be cancelled.
+  // If user cancels the file save dialog, run the callback with empty FilePath.
+  callback.Run(path,
+               content::DownloadItem::TARGET_DISPOSITION_PROMPT,
+               content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS, path);
+}
+
+void ElectronDownloadManagerDelegate::Shutdown() {
+  weak_ptr_factory_.InvalidateWeakPtrs();
+  download_manager_ = nullptr;
+}
+
+bool ElectronDownloadManagerDelegate::DetermineDownloadTarget(
+    content::DownloadItem* download,
+    const content::DownloadTargetCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (!download->GetForcedFilePath().empty()) {
+    callback.Run(download->GetForcedFilePath(),
+                 content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
+                 content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
+                 download->GetForcedFilePath());
+    return true;
+  }
+
+  // Try to get the save path from JS wrapper.
+  {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    api::DownloadItem* download_item = api::DownloadItem::FromWrappedClass(
+        isolate, download);
+    if (download_item) {
+      base::FilePath save_path = download_item->GetSavePath();
+      if (!save_path.empty()) {
+        callback.Run(save_path,
+                     content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
+                     content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
+                     save_path);
+        return true;
+      }
+    }
+  }
+
+  ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+      download_manager_->GetBrowserContext());
+  base::FilePath default_download_path = browser_context->prefs()->GetFilePath(
+      prefs::kDownloadDefaultDirectory);
+
+  CreateDownloadPathCallback download_path_callback =
+      base::Bind(&ElectronDownloadManagerDelegate::OnDownloadPathGenerated,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 download->GetId(), callback);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::FILE, FROM_HERE,
+      base::Bind(&ElectronDownloadManagerDelegate::CreateDownloadPath,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 download->GetURL(),
+                 download->GetContentDisposition(),
+                 download->GetSuggestedFilename(),
+                 download->GetMimeType(),
+                 default_download_path,
+                 download_path_callback));
+  return true;
+}
+
+bool ElectronDownloadManagerDelegate::ShouldOpenDownload(
+    content::DownloadItem* download,
+    const content::DownloadOpenDelayedCallback& callback) {
+  return true;
+}
+
+void ElectronDownloadManagerDelegate::GetNextId(
+    const content::DownloadIdCallback& callback) {
+  static uint32_t next_id = content::DownloadItem::kInvalidId + 1;
+  callback.Run(next_id++);
+}
+
+}  // namespace electron
added in remote
  their  100644 a8f1e44b1a9584604025c3e8cefbddb77eb42c2e electron/browser/electron_download_manager_delegate.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
+
+#include <string>
+
+#include "base/memory/weak_ptr.h"
+#include "content/public/browser/download_manager_delegate.h"
+
+namespace content {
+class DownloadManager;
+}
+
+namespace electron {
+
+class ElectronDownloadManagerDelegate : public content::DownloadManagerDelegate {
+ public:
+  using CreateDownloadPathCallback =
+      base::Callback<void(const base::FilePath&)>;
+
+  explicit ElectronDownloadManagerDelegate(content::DownloadManager* manager);
+  virtual ~ElectronDownloadManagerDelegate();
+
+  // Generate default file path to save the download.
+  void CreateDownloadPath(const GURL& url,
+                          const std::string& suggested_filename,
+                          const std::string& content_disposition,
+                          const std::string& mime_type,
+                          const base::FilePath& path,
+                          const CreateDownloadPathCallback& callback);
+  void OnDownloadPathGenerated(uint32_t download_id,
+                               const content::DownloadTargetCallback& callback,
+                               const base::FilePath& default_path);
+
+  // content::DownloadManagerDelegate:
+  void Shutdown() override;
+  bool DetermineDownloadTarget(
+      content::DownloadItem* download,
+      const content::DownloadTargetCallback& callback) override;
+  bool ShouldOpenDownload(
+      content::DownloadItem* download,
+      const content::DownloadOpenDelayedCallback& callback) override;
+  void GetNextId(const content::DownloadIdCallback& callback) override;
+
+ private:
+  content::DownloadManager* download_manager_;
+  base::WeakPtrFactory<ElectronDownloadManagerDelegate> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronDownloadManagerDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
added in remote
  their  100644 82543988ea9c4531a96bc3919cabc7d761e69989 electron/browser/electron_javascript_dialog_manager.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_javascript_dialog_manager.h"
+
+#include <string>
+
+#include "base/strings/utf_string_conversions.h"
+
+namespace electron {
+
+void ElectronJavaScriptDialogManager::RunJavaScriptDialog(
+    content::WebContents* web_contents,
+    const GURL& origin_url,
+    const std::string& accept_lang,
+    content::JavaScriptMessageType javascript_message_type,
+    const base::string16& message_text,
+    const base::string16& default_prompt_text,
+    const DialogClosedCallback& callback,
+    bool* did_suppress_message) {
+  callback.Run(false, base::string16());
+}
+
+void ElectronJavaScriptDialogManager::RunBeforeUnloadDialog(
+    content::WebContents* web_contents,
+    const base::string16& message_text,
+    bool is_reload,
+    const DialogClosedCallback& callback) {
+  bool prevent_reload = message_text.empty() ||
+                        message_text == base::ASCIIToUTF16("false");
+  callback.Run(!prevent_reload, message_text);
+}
+
+}  // namespace electron
added in remote
  their  100644 eb9cc39cc638ca6e81ce2e6036f5b467b5b9d784 electron/browser/electron_javascript_dialog_manager.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
+#define ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
+
+#include <string>
+
+#include "content/public/browser/javascript_dialog_manager.h"
+
+namespace electron {
+
+class ElectronJavaScriptDialogManager : public content::JavaScriptDialogManager {
+ public:
+  // content::JavaScriptDialogManager implementations.
+  void RunJavaScriptDialog(
+      content::WebContents* web_contents,
+      const GURL& origin_url,
+      const std::string& accept_lang,
+      content::JavaScriptMessageType javascript_message_type,
+      const base::string16& message_text,
+      const base::string16& default_prompt_text,
+      const DialogClosedCallback& callback,
+      bool* did_suppress_message) override;
+  void RunBeforeUnloadDialog(
+      content::WebContents* web_contents,
+      const base::string16& message_text,
+      bool is_reload,
+      const DialogClosedCallback& callback) override;
+  void CancelActiveAndPendingDialogs(
+      content::WebContents* web_contents) override {}
+  void ResetDialogState(content::WebContents* web_contents) override {};
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
added in remote
  their  100644 46292e86419110f0e7e791ae2f8ff89ff0a0eae3 electron/browser/electron_permission_manager.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_permission_manager.h"
+
+#include <vector>
+
+#include "electron/browser/web_contents_preferences.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/permission_type.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+namespace {
+
+bool WebContentsDestroyed(int process_id) {
+  auto contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(process_id);
+  if (!contents)
+    return true;
+  return contents->IsBeingDestroyed();
+}
+
+}  // namespace
+
+ElectronPermissionManager::ElectronPermissionManager()
+    : request_id_(0) {
+}
+
+ElectronPermissionManager::~ElectronPermissionManager() {
+}
+
+void ElectronPermissionManager::SetPermissionRequestHandler(
+    const RequestHandler& handler) {
+  if (handler.is_null() && !pending_requests_.empty()) {
+    for (const auto& request : pending_requests_) {
+      if (!WebContentsDestroyed(request.second.render_process_id))
+        request.second.callback.Run(content::PERMISSION_STATUS_DENIED);
+    }
+    pending_requests_.clear();
+  }
+  request_handler_ = handler;
+}
+
+int ElectronPermissionManager::RequestPermission(
+    content::PermissionType permission,
+    content::RenderFrameHost* render_frame_host,
+    const GURL& requesting_origin,
+    bool user_gesture,
+    const ResponseCallback& response_callback) {
+  int process_id = render_frame_host->GetProcess()->GetID();
+
+  if (permission == content::PermissionType::MIDI_SYSEX) {
+    content::ChildProcessSecurityPolicy::GetInstance()->
+        GrantSendMidiSysExMessage(process_id);
+  }
+
+  if (!request_handler_.is_null()) {
+    auto web_contents =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    ++request_id_;
+    auto callback = base::Bind(&ElectronPermissionManager::OnPermissionResponse,
+                               base::Unretained(this),
+                               request_id_,
+                               requesting_origin,
+                               response_callback);
+    pending_requests_[request_id_] = { process_id, callback };
+    request_handler_.Run(web_contents, permission, callback);
+    return request_id_;
+  }
+
+  response_callback.Run(content::PERMISSION_STATUS_GRANTED);
+  return kNoPendingOperation;
+}
+
+int ElectronPermissionManager::RequestPermissions(
+    const std::vector<content::PermissionType>& permissions,
+    content::RenderFrameHost* render_frame_host,
+    const GURL& requesting_origin,
+    bool user_gesture,
+    const base::Callback<void(
+    const std::vector<content::PermissionStatus>&)>& callback) {
+  // FIXME(zcbenz): Just ignore multiple permissions request for now.
+  std::vector<content::PermissionStatus> permissionStatuses;
+  for (auto permission : permissions) {
+    if (permission == content::PermissionType::MIDI_SYSEX) {
+      content::ChildProcessSecurityPolicy::GetInstance()->
+          GrantSendMidiSysExMessage(render_frame_host->GetProcess()->GetID());
+    }
+    permissionStatuses.push_back(content::PERMISSION_STATUS_GRANTED);
+  }
+  callback.Run(permissionStatuses);
+  return kNoPendingOperation;
+}
+
+void ElectronPermissionManager::OnPermissionResponse(
+    int request_id,
+    const GURL& origin,
+    const ResponseCallback& callback,
+    content::PermissionStatus status) {
+  auto request = pending_requests_.find(request_id);
+  if (request != pending_requests_.end()) {
+    if (!WebContentsDestroyed(request->second.render_process_id))
+      callback.Run(status);
+    pending_requests_.erase(request);
+  }
+}
+
+void ElectronPermissionManager::CancelPermissionRequest(int request_id) {
+  auto request = pending_requests_.find(request_id);
+  if (request != pending_requests_.end()) {
+    if (!WebContentsDestroyed(request->second.render_process_id))
+      request->second.callback.Run(content::PERMISSION_STATUS_DENIED);
+    pending_requests_.erase(request);
+  }
+}
+
+void ElectronPermissionManager::ResetPermission(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+}
+
+content::PermissionStatus ElectronPermissionManager::GetPermissionStatus(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+  return content::PERMISSION_STATUS_GRANTED;
+}
+
+void ElectronPermissionManager::RegisterPermissionUsage(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+}
+
+int ElectronPermissionManager::SubscribePermissionStatusChange(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin,
+    const ResponseCallback& callback) {
+  return -1;
+}
+
+void ElectronPermissionManager::UnsubscribePermissionStatusChange(
+    int subscription_id) {
+}
+
+}  // namespace electron
added in remote
  their  100644 4f7fc605966790033025c1e0bdb4e17a51583be8 electron/browser/electron_permission_manager.h
@@ -0,0 +1,92 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
+#define ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
+
+#include <map>
+#include <vector>
+
+#include "base/callback.h"
+#include "content/public/browser/permission_manager.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace electron {
+
+class ElectronPermissionManager : public content::PermissionManager {
+ public:
+  ElectronPermissionManager();
+  ~ElectronPermissionManager() override;
+
+  using ResponseCallback =
+      base::Callback<void(content::PermissionStatus)>;
+  using RequestHandler =
+      base::Callback<void(content::WebContents*,
+                          content::PermissionType,
+                          const ResponseCallback&)>;
+
+  // Handler to dispatch permission requests in JS.
+  void SetPermissionRequestHandler(const RequestHandler& handler);
+
+  // content::PermissionManager:
+  int RequestPermission(
+      content::PermissionType permission,
+      content::RenderFrameHost* render_frame_host,
+      const GURL& requesting_origin,
+      bool user_gesture,
+      const ResponseCallback& callback) override;
+  int RequestPermissions(
+      const std::vector<content::PermissionType>& permissions,
+      content::RenderFrameHost* render_frame_host,
+      const GURL& requesting_origin,
+      bool user_gesture,
+      const base::Callback<void(
+      const std::vector<content::PermissionStatus>&)>& callback) override;
+
+ protected:
+  void OnPermissionResponse(int request_id,
+                            const GURL& url,
+                            const ResponseCallback& callback,
+                            content::PermissionStatus status);
+
+  // content::PermissionManager:
+  void CancelPermissionRequest(int request_id) override;
+  void ResetPermission(content::PermissionType permission,
+                       const GURL& requesting_origin,
+                       const GURL& embedding_origin) override;
+  content::PermissionStatus GetPermissionStatus(
+      content::PermissionType permission,
+      const GURL& requesting_origin,
+      const GURL& embedding_origin) override;
+  void RegisterPermissionUsage(content::PermissionType permission,
+                               const GURL& requesting_origin,
+                               const GURL& embedding_origin) override;
+  int SubscribePermissionStatusChange(
+      content::PermissionType permission,
+      const GURL& requesting_origin,
+      const GURL& embedding_origin,
+      const base::Callback<void(content::PermissionStatus)>& callback) override;
+  void UnsubscribePermissionStatusChange(int subscription_id) override;
+
+ private:
+  struct RequestInfo {
+    int render_process_id;
+    ResponseCallback callback;
+  };
+
+  RequestHandler request_handler_;
+
+  std::map<int, RequestInfo> pending_requests_;
+
+  int request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronPermissionManager);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
added in remote
  their  100644 a7c7edf5322b260e90c137fb006bcb4de240bd53 electron/browser/electron_quota_permission_context.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_quota_permission_context.h"
+
+#include "storage/common/quota/quota_types.h"
+
+namespace electron {
+
+ElectronQuotaPermissionContext::ElectronQuotaPermissionContext() {
+}
+
+ElectronQuotaPermissionContext::~ElectronQuotaPermissionContext() {
+}
+
+void ElectronQuotaPermissionContext::RequestQuotaPermission(
+    const content::StorageQuotaParams& params,
+    int render_process_id,
+    const PermissionCallback& callback) {
+  callback.Run(response::QUOTA_PERMISSION_RESPONSE_ALLOW);
+}
+
+}  // namespace electron
added in remote
  their  100644 b38d69d1af1986c2a53851d120b953be13c8dd61 electron/browser/electron_quota_permission_context.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
+#define ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
+
+#include "content/public/browser/quota_permission_context.h"
+
+namespace electron {
+
+class ElectronQuotaPermissionContext : public content::QuotaPermissionContext {
+ public:
+  typedef content::QuotaPermissionContext::QuotaPermissionResponse response;
+
+  ElectronQuotaPermissionContext();
+  virtual ~ElectronQuotaPermissionContext();
+
+  // content::QuotaPermissionContext:
+  void RequestQuotaPermission(
+      const content::StorageQuotaParams& params,
+      int render_process_id,
+      const PermissionCallback& callback) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronQuotaPermissionContext);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
added in remote
  their  100644 9b91733f3f7875c89c513b363d3d626e0945645c electron/browser/electron_resource_dispatcher_host_delegate.cc
@@ -0,0 +1,41 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_resource_dispatcher_host_delegate.h"
+
+#include "electron/browser/login_handler.h"
+#include "electron/common/platform_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/escape.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+ElectronResourceDispatcherHostDelegate::ElectronResourceDispatcherHostDelegate() {
+}
+
+bool ElectronResourceDispatcherHostDelegate::HandleExternalProtocol(
+    const GURL& url,
+    int child_id,
+    const content::ResourceRequestInfo::WebContentsGetter&,
+    bool is_main_frame,
+    ui::PageTransition transition,
+    bool has_user_gesture) {
+  GURL escaped_url(net::EscapeExternalHandlerValue(url.spec()));
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+      base::Bind(
+          base::IgnoreResult(platform_util::OpenExternal), escaped_url, true));
+  return true;
+}
+
+content::ResourceDispatcherHostLoginDelegate*
+ElectronResourceDispatcherHostDelegate::CreateLoginDelegate(
+    net::AuthChallengeInfo* auth_info,
+    net::URLRequest* request) {
+  return new LoginHandler(auth_info, request);
+}
+
+}  // namespace electron
added in remote
  their  100644 07082d7e4265a8e6933010be157896e1c4dc04cd electron/browser/electron_resource_dispatcher_host_delegate.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
+
+#include "content/public/browser/resource_dispatcher_host_delegate.h"
+
+namespace electron {
+
+class ElectronResourceDispatcherHostDelegate
+    : public content::ResourceDispatcherHostDelegate {
+ public:
+  ElectronResourceDispatcherHostDelegate();
+
+  // content::ResourceDispatcherHostDelegate:
+  bool HandleExternalProtocol(
+      const GURL& url,
+      int child_id,
+      const content::ResourceRequestInfo::WebContentsGetter&,
+      bool is_main_frame,
+      ui::PageTransition transition,
+      bool has_user_gesture) override;
+  content::ResourceDispatcherHostLoginDelegate* CreateLoginDelegate(
+      net::AuthChallengeInfo* auth_info,
+      net::URLRequest* request) override;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
added in remote
  their  100644 7973568f1d455b06563238d17228d1ec73397693 electron/browser/electron_speech_recognition_manager_delegate.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_speech_recognition_manager_delegate.h"
+
+#include <string>
+
+#include "base/callback.h"
+
+namespace electron {
+
+ElectronSpeechRecognitionManagerDelegate::ElectronSpeechRecognitionManagerDelegate() {
+}
+
+ElectronSpeechRecognitionManagerDelegate::~ElectronSpeechRecognitionManagerDelegate() {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnEnvironmentEstimationComplete(
+    int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnSoundStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnSoundEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionResults(
+    int session_id, const content::SpeechRecognitionResults& result) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionError(
+    int session_id, const content::SpeechRecognitionError& error) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioLevelsChange(
+    int session_id, float volume, float noise_volume) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::GetDiagnosticInformation(
+    bool* can_report_metrics, std::string* hardware_info) {
+  *can_report_metrics = false;
+}
+
+void ElectronSpeechRecognitionManagerDelegate::CheckRecognitionIsAllowed(
+    int session_id,
+    base::Callback<void(bool ask_user, bool is_allowed)> callback) {
+  callback.Run(true, true);
+}
+
+content::SpeechRecognitionEventListener*
+ElectronSpeechRecognitionManagerDelegate::GetEventListener() {
+  return this;
+}
+
+bool ElectronSpeechRecognitionManagerDelegate::FilterProfanities(
+    int render_process_id) {
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 f1a67941b2d8fae87934f949a3b7f41ea156806e electron/browser/electron_speech_recognition_manager_delegate.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "content/public/browser/speech_recognition_event_listener.h"
+#include "content/public/browser/speech_recognition_manager_delegate.h"
+
+namespace electron {
+
+class ElectronSpeechRecognitionManagerDelegate
+    : public content::SpeechRecognitionManagerDelegate,
+      public content::SpeechRecognitionEventListener {
+ public:
+  ElectronSpeechRecognitionManagerDelegate();
+  virtual ~ElectronSpeechRecognitionManagerDelegate();
+
+  // content::SpeechRecognitionEventListener:
+  void OnRecognitionStart(int session_id) override;
+  void OnAudioStart(int session_id) override;
+  void OnEnvironmentEstimationComplete(int session_id) override;
+  void OnSoundStart(int session_id) override;
+  void OnSoundEnd(int session_id) override;
+  void OnAudioEnd(int session_id) override;
+  void OnRecognitionEnd(int session_id) override;
+  void OnRecognitionResults(
+      int session_id, const content::SpeechRecognitionResults& result) override;
+  void OnRecognitionError(
+      int session_id, const content::SpeechRecognitionError& error) override;
+  void OnAudioLevelsChange(int session_id, float volume,
+                           float noise_volume) override;
+
+  // content::SpeechRecognitionManagerDelegate:
+  void GetDiagnosticInformation(bool* can_report_metrics,
+                                std::string* hardware_info) override;
+  void CheckRecognitionIsAllowed(
+      int session_id,
+      base::Callback<void(bool ask_user, bool is_allowed)> callback) override;
+  content::SpeechRecognitionEventListener* GetEventListener() override;
+  bool FilterProfanities(int render_process_id) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronSpeechRecognitionManagerDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
added in remote
  their  100644 e07b39e19c83d8fdc92187119b6dd0166f7902fd electron/browser/javascript_environment.cc
@@ -0,0 +1,45 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/javascript_environment.h"
+
+#include <string>
+
+#include "base/command_line.h"
+#include "content/public/common/content_switches.h"
+#include "gin/array_buffer.h"
+#include "gin/v8_initializer.h"
+
+namespace electron {
+
+JavascriptEnvironment::JavascriptEnvironment()
+    : initialized_(Initialize()),
+      isolate_(isolate_holder_.isolate()),
+      isolate_scope_(isolate_),
+      locker_(isolate_),
+      handle_scope_(isolate_),
+      context_(isolate_, v8::Context::New(isolate_)),
+      context_scope_(v8::Local<v8::Context>::New(isolate_, context_)) {
+}
+
+bool JavascriptEnvironment::Initialize() {
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch("debug-brk")) {
+    // Need to be called before v8::Initialize().
+    const char expose_debug_as[] = "--expose_debug_as=v8debug";
+    v8::V8::SetFlagsFromString(expose_debug_as, sizeof(expose_debug_as) - 1);
+  }
+
+  // --js-flags.
+  std::string js_flags = cmd->GetSwitchValueASCII(switches::kJavaScriptFlags);
+  if (!js_flags.empty())
+    v8::V8::SetFlagsFromString(js_flags.c_str(), js_flags.size());
+
+  gin::IsolateHolder::Initialize(gin::IsolateHolder::kNonStrictMode,
+                                 gin::IsolateHolder::kStableV8Extras,
+                                 gin::ArrayBufferAllocator::SharedInstance());
+  return true;
+}
+
+}  // namespace electron
added in remote
  their  100644 72ae43e8e94040ca4e20d7169488152123e4226e electron/browser/javascript_environment.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
+#define ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
+
+#include "base/macros.h"
+#include "gin/public/isolate_holder.h"
+
+namespace electron {
+
+class JavascriptEnvironment {
+ public:
+  JavascriptEnvironment();
+
+  v8::Isolate* isolate() const { return isolate_; }
+  v8::Local<v8::Context> context() const {
+    return v8::Local<v8::Context>::New(isolate_, context_);
+  }
+
+ private:
+  bool Initialize();
+
+  bool initialized_;
+  gin::IsolateHolder isolate_holder_;
+  v8::Isolate* isolate_;
+  v8::Isolate::Scope isolate_scope_;
+  v8::Locker locker_;
+  v8::HandleScope handle_scope_;
+  v8::UniquePersistent<v8::Context> context_;
+  v8::Context::Scope context_scope_;
+
+  DISALLOW_COPY_AND_ASSIGN(JavascriptEnvironment);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
added in remote
  their  100644 a1780da9aa67e1e861e57117428bc62edc7ccbf7 electron/browser/login_handler.cc
@@ -0,0 +1,109 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/login_handler.h"
+
+#include "electron/browser/browser.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/resource_dispatcher_host.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/web_contents.h"
+#include "net/base/auth.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// Helper to remove the ref from an net::URLRequest to the LoginHandler.
+// Should only be called from the IO thread, since it accesses an
+// net::URLRequest.
+void ResetLoginHandlerForRequest(net::URLRequest* request) {
+  content::ResourceDispatcherHost::Get()->ClearLoginDelegateForRequest(request);
+}
+
+}  // namespace
+
+LoginHandler::LoginHandler(net::AuthChallengeInfo* auth_info,
+                           net::URLRequest* request)
+    : handled_auth_(false),
+      auth_info_(auth_info),
+      request_(request),
+      render_process_host_id_(0),
+      render_frame_id_(0) {
+  content::ResourceRequestInfo::ForRequest(request_)->GetAssociatedRenderFrame(
+      &render_process_host_id_,  &render_frame_id_);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::Bind(&Browser::RequestLogin,
+                                     base::Unretained(Browser::Get()),
+                                     make_scoped_refptr(this)));
+}
+
+LoginHandler::~LoginHandler() {
+}
+
+content::WebContents* LoginHandler::GetWebContents() const {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(
+      render_process_host_id_, render_frame_id_);
+  return content::WebContents::FromRenderFrameHost(rfh);
+}
+
+void LoginHandler::Login(const base::string16& username,
+                         const base::string16& password) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (TestAndSetAuthHandled())
+    return;
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&LoginHandler::DoLogin, this, username, password));
+}
+
+void LoginHandler::CancelAuth() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (TestAndSetAuthHandled())
+    return;
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::Bind(&LoginHandler::DoCancelAuth, this));
+}
+
+void LoginHandler::OnRequestCancelled() {
+  TestAndSetAuthHandled();
+  request_ = nullptr;
+}
+
+// Marks authentication as handled and returns the previous handled state.
+bool LoginHandler::TestAndSetAuthHandled() {
+  base::AutoLock lock(handled_auth_lock_);
+  bool was_handled = handled_auth_;
+  handled_auth_ = true;
+  return was_handled;
+}
+
+void LoginHandler::DoCancelAuth() {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (request_) {
+    request_->CancelAuth();
+    // Verify that CancelAuth doesn't destroy the request via our delegate.
+    DCHECK(request_ != nullptr);
+    ResetLoginHandlerForRequest(request_);
+  }
+}
+
+void LoginHandler::DoLogin(const base::string16& username,
+                           const base::string16& password) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (request_) {
+    request_->SetAuth(net::AuthCredentials(username, password));
+    ResetLoginHandlerForRequest(request_);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 52b94dfeb2a9d57305b418d722d0ed047be45237 electron/browser/login_handler.h
@@ -0,0 +1,76 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_LOGIN_HANDLER_H_
+#define ELECTRON_BROWSER_LOGIN_HANDLER_H_
+
+#include "base/strings/string16.h"
+#include "base/synchronization/lock.h"
+#include "content/public/browser/resource_dispatcher_host_login_delegate.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace net {
+class AuthChallengeInfo;
+class URLRequest;
+}
+
+namespace electron {
+
+// Handles the HTTP basic auth, must be created on IO thread.
+class LoginHandler : public content::ResourceDispatcherHostLoginDelegate {
+ public:
+  LoginHandler(net::AuthChallengeInfo* auth_info, net::URLRequest* request);
+
+  // Returns the WebContents associated with the request, must be called on UI
+  // thread.
+  content::WebContents* GetWebContents() const;
+
+  // The auth is cancelled, must be called on UI thread.
+  void CancelAuth();
+
+  // Login with |username| and |password|, must be called on UI thread.
+  void Login(const base::string16& username, const base::string16& password);
+
+  const net::AuthChallengeInfo* auth_info() const { return auth_info_.get(); }
+  const net::URLRequest* request() const { return request_; }
+
+ protected:
+  ~LoginHandler() override;
+
+  // content::ResourceDispatcherHostLoginDelegate:
+  void OnRequestCancelled() override;
+
+ private:
+  // Must be called on IO thread.
+  void DoCancelAuth();
+  void DoLogin(const base::string16& username, const base::string16& password);
+
+  // Marks authentication as handled and returns the previous handled
+  // state.
+  bool TestAndSetAuthHandled();
+
+  // True if we've handled auth (Login or CancelAuth has been called).
+  bool handled_auth_;
+  mutable base::Lock handled_auth_lock_;
+
+  // Who/where/what asked for the authentication.
+  scoped_refptr<net::AuthChallengeInfo> auth_info_;
+
+  // The request that wants login data.
+  // This should only be accessed on the IO loop.
+  net::URLRequest* request_;
+
+  // Cached from the net::URLRequest, in case it goes NULL on us.
+  int render_process_host_id_;
+  int render_frame_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(LoginHandler);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_LOGIN_HANDLER_H_
added in remote
  their  100644 aca9e8dae77b70efb1ef70adf45fc9c83fdb6e92 electron/browser/mac/electron_application.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "base/mac/scoped_sending_event.h"
+
+@interface ElectronApplication : NSApplication<CrAppProtocol,
+                                           CrAppControlProtocol> {
+ @private
+  BOOL handlingSendEvent_;
+}
+
++ (ElectronApplication*)sharedApplication;
+
+// CrAppProtocol:
+- (BOOL)isHandlingSendEvent;
+
+// CrAppControlProtocol:
+- (void)setHandlingSendEvent:(BOOL)handlingSendEvent;
+
+@end
added in remote
  their  100644 682030da3936d9740808da49b453471483d34148 electron/browser/mac/electron_application.mm
@@ -0,0 +1,74 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/mac/electron_application.h"
+
+#include "electron/browser/browser.h"
+#include "base/auto_reset.h"
+#include "base/strings/sys_string_conversions.h"
+#include "content/public/browser/browser_accessibility_state.h"
+
+@implementation ElectronApplication
+
++ (ElectronApplication*)sharedApplication {
+  return (ElectronApplication*)[super sharedApplication];
+}
+
+- (BOOL)isHandlingSendEvent {
+  return handlingSendEvent_;
+}
+
+- (void)sendEvent:(NSEvent*)event {
+  base::AutoReset<BOOL> scoper(&handlingSendEvent_, YES);
+  [super sendEvent:event];
+}
+
+- (void)setHandlingSendEvent:(BOOL)handlingSendEvent {
+  handlingSendEvent_ = handlingSendEvent;
+}
+
+- (void)awakeFromNib {
+  [[NSAppleEventManager sharedAppleEventManager]
+      setEventHandler:self
+          andSelector:@selector(handleURLEvent:withReplyEvent:)
+        forEventClass:kInternetEventClass
+           andEventID:kAEGetURL];
+}
+
+- (void)handleURLEvent:(NSAppleEventDescriptor*)event
+        withReplyEvent:(NSAppleEventDescriptor*)replyEvent {
+  NSString* url = [
+      [event paramDescriptorForKeyword:keyDirectObject] stringValue];
+  electron::Browser::Get()->OpenURL(base::SysNSStringToUTF8(url));
+}
+
+- (bool)voiceOverEnabled {
+  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+  [defaults addSuiteNamed:@"com.apple.universalaccess"];
+  [defaults synchronize];
+
+  return [defaults boolForKey:@"voiceOverOnOffKey"];
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute {
+  // Undocumented attribute that VoiceOver happens to set while running.
+  // Chromium uses this too, even though it's not exactly right.
+  if ([attribute isEqualToString:@"AXEnhancedUserInterface"]) {
+    bool enableAccessibility = ([self voiceOverEnabled] && [value boolValue]);
+    [self updateAccessibilityEnabled:enableAccessibility];
+  }
+  return [super accessibilitySetValue:value forAttribute:attribute];
+}
+
+- (void)updateAccessibilityEnabled:(BOOL)enabled {
+  auto ax_state = content::BrowserAccessibilityState::GetInstance();
+
+  if (enabled) {
+    ax_state->OnScreenReaderDetected();
+  } else {
+    ax_state->DisableAccessibility();
+  }
+}
+
+@end
added in remote
  their  100644 2a3e265f059d245b77b40eaec11905c1a1e3f683 electron/browser/mac/electron_application_delegate.h
@@ -0,0 +1,19 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import <Cocoa/Cocoa.h>
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+@interface ElectronApplicationDelegate : NSObject<NSApplicationDelegate> {
+ @private
+  base::scoped_nsobject<ElectronMenuController> menu_controller_;
+}
+
+- (id)init;
+
+// Sets the menu that will be returned in "applicationDockMenu:".
+- (void)setApplicationDockMenu:(ui::MenuModel*)model;
+
+@end
added in remote
  their  100644 5d266386635714ed48619c98c16d1ae2674b5dab electron/browser/mac/electron_application_delegate.mm
@@ -0,0 +1,69 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/mac/electron_application_delegate.h"
+
+#import "electron/browser/mac/electron_application.h"
+#include "electron/browser/browser.h"
+#include "base/strings/sys_string_conversions.h"
+
+@implementation ElectronApplicationDelegate
+
+- (id)init {
+  self = [super init];
+  menu_controller_.reset([[ElectronMenuController alloc] init]);
+  return self;
+}
+
+- (void)setApplicationDockMenu:(ui::MenuModel*)model {
+  [menu_controller_ populateWithModel:model];
+}
+
+- (void)applicationWillFinishLaunching:(NSNotification*)notify {
+  // Don't add the "Enter Full Screen" menu item automatically.
+  [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@"NSFullScreenMenuItemEverywhere"];
+
+  // Add observer to monitor the system's Dark Mode theme.
+  [[NSDistributedNotificationCenter defaultCenter] addObserver:self selector:@selector(platformThemeChanged:) name:@"AppleInterfaceThemeChangedNotification" object:nil];
+
+  electron::Browser::Get()->WillFinishLaunching();
+}
+
+- (void)applicationDidFinishLaunching:(NSNotification*)notify {
+  electron::Browser::Get()->DidFinishLaunching();
+}
+
+- (NSMenu*)applicationDockMenu:(NSApplication*)sender {
+  return [menu_controller_ menu];
+}
+
+- (BOOL)application:(NSApplication*)sender
+           openFile:(NSString*)filename {
+  std::string filename_str(base::SysNSStringToUTF8(filename));
+  return electron::Browser::Get()->OpenFile(filename_str) ? YES : NO;
+}
+
+- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication*)sender {
+  electron::Browser* browser = electron::Browser::Get();
+  if (browser->is_quiting()) {
+    return NSTerminateNow;
+  } else {
+    // System started termination.
+    electron::Browser::Get()->Quit();
+    return NSTerminateCancel;
+  }
+}
+
+- (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
+                    hasVisibleWindows:(BOOL)flag {
+  electron::Browser* browser = electron::Browser::Get();
+  browser->Activate(static_cast<bool>(flag));
+  return flag;
+}
+
+- (void)platformThemeChanged:(NSNotification *)notify {
+  electron::Browser::Get()->PlatformThemeChanged();
+}
+
+@end
added in remote
  their  100644 f7ba2f3d888d933266bc62eea033ded94a477065 electron/browser/native_window.cc
@@ -0,0 +1,620 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window.h"
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/options_switches.h"
+#include "base/files/file_util.h"
+#include "base/json/json_writer.h"
+#include "base/prefs/pref_service.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/browser/renderer_host/render_widget_host_impl.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/plugin_service.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/common/content_switches.h"
+#include "ipc/ipc_message_macros.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/size_conversions.h"
+#include "ui/gfx/screen.h"
+#include "ui/gl/gpu_switching_manager.h"
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::NativeWindowRelay);
+
+namespace electron {
+
+NativeWindow::NativeWindow(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options)
+    : content::WebContentsObserver(inspectable_web_contents->GetWebContents()),
+      has_frame_(true),
+      force_using_draggable_region_(false),
+      transparent_(false),
+      enable_larger_than_screen_(false),
+      is_closed_(false),
+      has_dialog_attached_(false),
+      aspect_ratio_(0.0),
+      inspectable_web_contents_(inspectable_web_contents),
+      weak_factory_(this) {
+  options.Get(options::kFrame, &has_frame_);
+  options.Get(options::kTransparent, &transparent_);
+  options.Get(options::kEnableLargerThanScreen, &enable_larger_than_screen_);
+
+  // Tell the content module to initialize renderer widget with transparent
+  // mode.
+  ui::GpuSwitchingManager::SetTransparent(transparent_);
+
+  // Read icon before window is created.
+  options.Get(options::kIcon, &icon_);
+
+  WindowList::AddWindow(this);
+}
+
+NativeWindow::~NativeWindow() {
+  // It's possible that the windows gets destroyed before it's closed, in that
+  // case we need to ensure the OnWindowClosed message is still notified.
+  NotifyWindowClosed();
+}
+
+// static
+NativeWindow* NativeWindow::FromWebContents(
+    content::WebContents* web_contents) {
+  WindowList& window_list = *WindowList::GetInstance();
+  for (NativeWindow* window : window_list) {
+    if (window->web_contents() == web_contents)
+      return window;
+  }
+  return nullptr;
+}
+
+void NativeWindow::InitFromOptions(const mate::Dictionary& options) {
+  // Setup window from options.
+  int x = -1, y = -1;
+  bool center;
+  if (options.Get(options::kX, &x) && options.Get(options::kY, &y)) {
+    SetPosition(gfx::Point(x, y));
+  } else if (options.Get(options::kCenter, &center) && center) {
+    Center();
+  }
+  // On Linux and Window we may already have maximum size defined.
+  extensions::SizeConstraints size_constraints(GetContentSizeConstraints());
+  int min_height = 0, min_width = 0;
+  if (options.Get(options::kMinHeight, &min_height) |
+      options.Get(options::kMinWidth, &min_width)) {
+    size_constraints.set_minimum_size(gfx::Size(min_width, min_height));
+  }
+  int max_height = INT_MAX, max_width = INT_MAX;
+  if (options.Get(options::kMaxHeight, &max_height) |
+      options.Get(options::kMaxWidth, &max_width)) {
+    size_constraints.set_maximum_size(gfx::Size(max_width, max_height));
+  }
+  bool use_content_size = false;
+  options.Get(options::kUseContentSize, &use_content_size);
+  if (use_content_size) {
+    SetContentSizeConstraints(size_constraints);
+  } else {
+    SetSizeConstraints(size_constraints);
+  }
+#if defined(USE_X11)
+  bool resizable;
+  if (options.Get(options::kResizable, &resizable)) {
+    SetResizable(resizable);
+  }
+#endif
+#if defined(OS_WIN) || defined(USE_X11)
+  bool closable;
+  if (options.Get(options::kClosable, &closable)) {
+    SetClosable(closable);
+  }
+#endif
+  bool movable;
+  if (options.Get(options::kMovable, &movable)) {
+    SetMovable(movable);
+  }
+  bool has_shadow;
+  if (options.Get(options::kHasShadow, &has_shadow)) {
+    SetHasShadow(has_shadow);
+  }
+  bool top;
+  if (options.Get(options::kAlwaysOnTop, &top) && top) {
+    SetAlwaysOnTop(true);
+  }
+  // Disable fullscreen button if 'fullscreen' is specified to false.
+  bool fullscreenable = true;
+  bool fullscreen = false;
+  if (options.Get(options::kFullscreen, &fullscreen) && !fullscreen)
+    fullscreenable = false;
+  // Overriden by 'fullscreenable'.
+  options.Get(options::kFullScreenable, &fullscreenable);
+  SetFullScreenable(fullscreenable);
+  if (fullscreen) {
+    SetFullScreen(true);
+  }
+  bool skip;
+  if (options.Get(options::kSkipTaskbar, &skip) && skip) {
+    SetSkipTaskbar(skip);
+  }
+  bool kiosk;
+  if (options.Get(options::kKiosk, &kiosk) && kiosk) {
+    SetKiosk(kiosk);
+  }
+  std::string color;
+  if (options.Get(options::kBackgroundColor, &color)) {
+    SetBackgroundColor(color);
+  }
+  std::string title("Electron");
+  options.Get(options::kTitle, &title);
+  SetTitle(title);
+
+  // Then show it.
+  bool show = true;
+  options.Get(options::kShow, &show);
+  if (show)
+    Show();
+}
+
+void NativeWindow::SetSize(const gfx::Size& size, bool animate) {
+  SetBounds(gfx::Rect(GetPosition(), size), animate);
+}
+
+gfx::Size NativeWindow::GetSize() {
+  return GetBounds().size();
+}
+
+void NativeWindow::SetPosition(const gfx::Point& position, bool animate) {
+  SetBounds(gfx::Rect(position, GetSize()), animate);
+}
+
+gfx::Point NativeWindow::GetPosition() {
+  return GetBounds().origin();
+}
+
+void NativeWindow::SetContentSize(const gfx::Size& size, bool animate) {
+  SetSize(ContentSizeToWindowSize(size), animate);
+}
+
+gfx::Size NativeWindow::GetContentSize() {
+  return WindowSizeToContentSize(GetSize());
+}
+
+void NativeWindow::SetSizeConstraints(
+    const extensions::SizeConstraints& window_constraints) {
+  extensions::SizeConstraints content_constraints;
+  if (window_constraints.HasMaximumSize())
+    content_constraints.set_maximum_size(
+        WindowSizeToContentSize(window_constraints.GetMaximumSize()));
+  if (window_constraints.HasMinimumSize())
+    content_constraints.set_minimum_size(
+        WindowSizeToContentSize(window_constraints.GetMinimumSize()));
+  SetContentSizeConstraints(content_constraints);
+}
+
+extensions::SizeConstraints NativeWindow::GetSizeConstraints() {
+  extensions::SizeConstraints content_constraints = GetContentSizeConstraints();
+  extensions::SizeConstraints window_constraints;
+  if (content_constraints.HasMaximumSize())
+    window_constraints.set_maximum_size(
+        ContentSizeToWindowSize(content_constraints.GetMaximumSize()));
+  if (content_constraints.HasMinimumSize())
+    window_constraints.set_minimum_size(
+        ContentSizeToWindowSize(content_constraints.GetMinimumSize()));
+  return window_constraints;
+}
+
+void NativeWindow::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  size_constraints_ = size_constraints;
+}
+
+extensions::SizeConstraints NativeWindow::GetContentSizeConstraints() {
+  return size_constraints_;
+}
+
+void NativeWindow::SetMinimumSize(const gfx::Size& size) {
+  extensions::SizeConstraints size_constraints;
+  size_constraints.set_minimum_size(size);
+  SetSizeConstraints(size_constraints);
+}
+
+gfx::Size NativeWindow::GetMinimumSize() {
+  return GetSizeConstraints().GetMinimumSize();
+}
+
+void NativeWindow::SetMaximumSize(const gfx::Size& size) {
+  extensions::SizeConstraints size_constraints;
+  size_constraints.set_maximum_size(size);
+  SetSizeConstraints(size_constraints);
+}
+
+gfx::Size NativeWindow::GetMaximumSize() {
+  return GetSizeConstraints().GetMaximumSize();
+}
+
+void NativeWindow::SetRepresentedFilename(const std::string& filename) {
+}
+
+std::string NativeWindow::GetRepresentedFilename() {
+  return "";
+}
+
+void NativeWindow::SetDocumentEdited(bool edited) {
+}
+
+bool NativeWindow::IsDocumentEdited() {
+  return false;
+}
+
+void NativeWindow::SetIgnoreMouseEvents(bool ignore) {
+}
+
+void NativeWindow::SetMenu(ui::MenuModel* menu) {
+}
+
+bool NativeWindow::HasModalDialog() {
+  return has_dialog_attached_;
+}
+
+void NativeWindow::FocusOnWebView() {
+  web_contents()->GetRenderViewHost()->GetWidget()->Focus();
+}
+
+void NativeWindow::BlurWebView() {
+  web_contents()->GetRenderViewHost()->GetWidget()->Blur();
+}
+
+bool NativeWindow::IsWebViewFocused() {
+  auto host_view = web_contents()->GetRenderViewHost()->GetWidget()->GetView();
+  return host_view && host_view->HasFocus();
+}
+
+void NativeWindow::CapturePage(const gfx::Rect& rect,
+                               const CapturePageCallback& callback) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  const auto host = view ? view->GetRenderWidgetHost() : nullptr;
+  if (!view || !host) {
+    callback.Run(SkBitmap());
+    return;
+  }
+
+  // Capture full page if user doesn't specify a |rect|.
+  const gfx::Size view_size = rect.IsEmpty() ? view->GetViewBounds().size() :
+                                               rect.size();
+
+  // By default, the requested bitmap size is the view size in screen
+  // coordinates.  However, if there's more pixel detail available on the
+  // current system, increase the requested bitmap size to capture it all.
+  gfx::Size bitmap_size = view_size;
+  const gfx::NativeView native_view = view->GetNativeView();
+  gfx::Screen* const screen = gfx::Screen::GetScreenFor(native_view);
+  const float scale =
+      screen->GetDisplayNearestWindow(native_view).device_scale_factor();
+  if (scale > 1.0f)
+    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);
+
+  host->CopyFromBackingStore(
+      gfx::Rect(rect.origin(), view_size),
+      bitmap_size,
+      base::Bind(&NativeWindow::OnCapturePageDone,
+                 weak_factory_.GetWeakPtr(),
+                 callback),
+      kBGRA_8888_SkColorType);
+}
+
+void NativeWindow::ShowDefinitionForSelection() {
+  NOTIMPLEMENTED();
+}
+
+void NativeWindow::SetAutoHideMenuBar(bool auto_hide) {
+}
+
+bool NativeWindow::IsMenuBarAutoHide() {
+  return false;
+}
+
+void NativeWindow::SetMenuBarVisibility(bool visible) {
+}
+
+bool NativeWindow::IsMenuBarVisible() {
+  return true;
+}
+
+double NativeWindow::GetAspectRatio() {
+  return aspect_ratio_;
+}
+
+gfx::Size NativeWindow::GetAspectRatioExtraSize() {
+  return aspect_ratio_extraSize_;
+}
+
+void NativeWindow::SetAspectRatio(double aspect_ratio,
+                                  const gfx::Size& extra_size) {
+  aspect_ratio_ = aspect_ratio;
+  aspect_ratio_extraSize_ = extra_size;
+}
+
+void NativeWindow::RequestToClosePage() {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(NativeWindowObserver,
+                    observers_,
+                    WillCloseWindow(&prevent_default));
+  if (prevent_default) {
+    WindowList::WindowCloseCancelled(this);
+    return;
+  }
+
+  // Assume the window is not responding if it doesn't cancel the close and is
+  // not closed in 5s, in this way we can quickly show the unresponsive
+  // dialog when the window is busy executing some script withouth waiting for
+  // the unresponsive timeout.
+  if (window_unresposive_closure_.IsCancelled())
+    ScheduleUnresponsiveEvent(5000);
+
+  if (web_contents()->NeedToFireBeforeUnload())
+    web_contents()->DispatchBeforeUnload(false);
+  else
+    web_contents()->Close();
+}
+
+void NativeWindow::CloseContents(content::WebContents* source) {
+  if (!inspectable_web_contents_)
+    return;
+
+  inspectable_web_contents_->GetView()->SetDelegate(nullptr);
+  inspectable_web_contents_ = nullptr;
+  Observe(nullptr);
+
+  // When the web contents is gone, close the window immediately, but the
+  // memory will not be freed until you call delete.
+  // In this way, it would be safe to manage windows via smart pointers. If you
+  // want to free memory when the window is closed, you can do deleting by
+  // overriding the OnWindowClosed method in the observer.
+  CloseImmediately();
+
+  // Do not sent "unresponsive" event after window is closed.
+  window_unresposive_closure_.Cancel();
+}
+
+void NativeWindow::RendererUnresponsive(content::WebContents* source) {
+  // Schedule the unresponsive shortly later, since we may receive the
+  // responsive event soon. This could happen after the whole application had
+  // blocked for a while.
+  // Also notice that when closing this event would be ignored because we have
+  // explicity started a close timeout counter. This is on purpose because we
+  // don't want the unresponsive event to be sent too early when user is closing
+  // the window.
+  ScheduleUnresponsiveEvent(50);
+}
+
+void NativeWindow::RendererResponsive(content::WebContents* source) {
+  window_unresposive_closure_.Cancel();
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnRendererResponsive());
+}
+
+void NativeWindow::NotifyWindowClosed() {
+  if (is_closed_)
+    return;
+
+  WindowList::RemoveWindow(this);
+
+  is_closed_ = true;
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowClosed());
+}
+
+void NativeWindow::NotifyWindowBlur() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowBlur());
+}
+
+void NativeWindow::NotifyWindowFocus() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowFocus());
+}
+
+void NativeWindow::NotifyWindowShow() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowShow());
+}
+
+void NativeWindow::NotifyWindowHide() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowHide());
+}
+
+void NativeWindow::NotifyWindowMaximize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMaximize());
+}
+
+void NativeWindow::NotifyWindowUnmaximize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowUnmaximize());
+}
+
+void NativeWindow::NotifyWindowMinimize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMinimize());
+}
+
+void NativeWindow::NotifyWindowRestore() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowRestore());
+}
+
+void NativeWindow::NotifyWindowResize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowResize());
+}
+
+void NativeWindow::NotifyWindowMove() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMove());
+}
+
+void NativeWindow::NotifyWindowMoved() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMoved());
+}
+
+void NativeWindow::NotifyWindowEnterFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowEnterFullScreen());
+}
+
+void NativeWindow::NotifyWindowScrollTouchBegin() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowScrollTouchBegin());
+}
+
+void NativeWindow::NotifyWindowScrollTouchEnd() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowScrollTouchEnd());
+}
+
+void NativeWindow::NotifyWindowSwipe(const std::string& direction) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowSwipe(direction));
+}
+
+void NativeWindow::NotifyWindowLeaveFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowLeaveFullScreen());
+}
+
+void NativeWindow::NotifyWindowEnterHtmlFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowEnterHtmlFullScreen());
+}
+
+void NativeWindow::NotifyWindowLeaveHtmlFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowLeaveHtmlFullScreen());
+}
+
+void NativeWindow::NotifyWindowExecuteWindowsCommand(
+    const std::string& command) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnExecuteWindowsCommand(command));
+}
+
+#if defined(OS_WIN)
+void NativeWindow::NotifyWindowMessage(
+    UINT message, WPARAM w_param, LPARAM l_param) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowMessage(message, w_param, l_param));
+}
+#endif
+
+scoped_ptr<SkRegion> NativeWindow::DraggableRegionsToSkRegion(
+    const std::vector<DraggableRegion>& regions) {
+  scoped_ptr<SkRegion> sk_region(new SkRegion);
+  for (const DraggableRegion& region : regions) {
+    sk_region->op(
+        region.bounds.x(),
+        region.bounds.y(),
+        region.bounds.right(),
+        region.bounds.bottom(),
+        region.draggable ? SkRegion::kUnion_Op : SkRegion::kDifference_Op);
+  }
+  return sk_region;
+}
+
+void NativeWindow::RenderViewCreated(
+    content::RenderViewHost* render_view_host) {
+  if (!transparent_)
+    return;
+
+  content::RenderWidgetHostImpl* impl = content::RenderWidgetHostImpl::FromID(
+      render_view_host->GetProcess()->GetID(),
+      render_view_host->GetRoutingID());
+  if (impl)
+    impl->SetBackgroundOpaque(false);
+}
+
+void NativeWindow::BeforeUnloadDialogCancelled() {
+  WindowList::WindowCloseCancelled(this);
+
+  // Cancel unresponsive event when window close is cancelled.
+  window_unresposive_closure_.Cancel();
+}
+
+bool NativeWindow::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(NativeWindow, message)
+    IPC_MESSAGE_HANDLER(ElectronViewHostMsg_UpdateDraggableRegions,
+                        UpdateDraggableRegions)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+void NativeWindow::UpdateDraggableRegions(
+    const std::vector<DraggableRegion>& regions) {
+  // Draggable region is not supported for non-frameless window.
+  if (has_frame_ && !force_using_draggable_region_)
+    return;
+  draggable_region_ = DraggableRegionsToSkRegion(regions);
+}
+
+void NativeWindow::ScheduleUnresponsiveEvent(int ms) {
+  if (!window_unresposive_closure_.IsCancelled())
+    return;
+
+  window_unresposive_closure_.Reset(
+      base::Bind(&NativeWindow::NotifyWindowUnresponsive,
+                 weak_factory_.GetWeakPtr()));
+  base::MessageLoop::current()->PostDelayedTask(
+      FROM_HERE,
+      window_unresposive_closure_.callback(),
+      base::TimeDelta::FromMilliseconds(ms));
+}
+
+void NativeWindow::NotifyWindowUnresponsive() {
+  window_unresposive_closure_.Cancel();
+
+  if (!is_closed_ && !HasModalDialog())
+    FOR_EACH_OBSERVER(NativeWindowObserver,
+                      observers_,
+                      OnRendererUnresponsive());
+}
+
+void NativeWindow::OnCapturePageDone(const CapturePageCallback& callback,
+                                     const SkBitmap& bitmap,
+                                     content::ReadbackResponse response) {
+  callback.Run(bitmap);
+}
+
+SkColor NativeWindow::ParseHexColor(const std::string& name) {
+  auto color = name.substr(1);
+  unsigned length = color.size();
+  SkColor result = (length != 8 ? 0xFF000000 : 0x00000000);
+  unsigned value = 0;
+  if (length != 3 && length != 6 && length != 8)
+    return result;
+  for (unsigned i = 0; i < length; ++i) {
+    if (!base::IsHexDigit(color[i]))
+      return result;
+    value <<= 4;
+    value |= (color[i] < 'A' ? color[i] - '0' : (color[i] - 'A' + 10) & 0xF);
+  }
+  if (length == 6 || length == 8) {
+    result |= value;
+    return result;
+  }
+  result |= (value & 0xF00) << 12 | (value & 0xF00) << 8
+      | (value & 0xF0) << 8 | (value & 0xF0) << 4
+      | (value & 0xF) << 4 | (value & 0xF);
+  return result;
+}
+
+}  // namespace electron
added in remote
  their  100644 ff46845fef38028b3c3280e7409c94965c769853 electron/browser/native_window.h
@@ -0,0 +1,364 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "electron/browser/native_window_observer.h"
+#include "electron/browser/ui/accelerator_util.h"
+#include "base/cancelable_callback.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "base/supports_user_data.h"
+#include "content/public/browser/readback_types.h"
+#include "content/public/browser/web_contents_observer.h"
+#include "content/public/browser/web_contents_user_data.h"
+#include "extensions/browser/app_window/size_constraints.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+
+class SkRegion;
+
+namespace brightray {
+class InspectableWebContents;
+}
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace gfx {
+class Point;
+class Rect;
+class Size;
+}
+
+namespace mate {
+class Dictionary;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace electron {
+
+struct DraggableRegion;
+
+class NativeWindow : public base::SupportsUserData,
+                     public content::WebContentsObserver {
+ public:
+  using CapturePageCallback = base::Callback<void(const SkBitmap& bitmap)>;
+
+  class DialogScope {
+   public:
+    explicit DialogScope(NativeWindow* window)
+        : window_(window) {
+      if (window_ != NULL)
+        window_->set_has_dialog_attached(true);
+    }
+
+    ~DialogScope() {
+      if (window_ != NULL)
+        window_->set_has_dialog_attached(false);
+    }
+
+   private:
+    NativeWindow* window_;
+
+    DISALLOW_COPY_AND_ASSIGN(DialogScope);
+  };
+
+  virtual ~NativeWindow();
+
+  // Create window with existing WebContents, the caller is responsible for
+  // managing the window's live.
+  static NativeWindow* Create(
+      brightray::InspectableWebContents* inspectable_web_contents,
+      const mate::Dictionary& options);
+
+  // Find a window from its WebContents
+  static NativeWindow* FromWebContents(content::WebContents* web_contents);
+
+  void InitFromOptions(const mate::Dictionary& options);
+
+  virtual void Close() = 0;
+  virtual void CloseImmediately() = 0;
+  virtual bool IsClosed() const { return is_closed_; }
+  virtual void Focus(bool focus) = 0;
+  virtual bool IsFocused() = 0;
+  virtual void Show() = 0;
+  virtual void ShowInactive() = 0;
+  virtual void Hide() = 0;
+  virtual bool IsVisible() = 0;
+  virtual void Maximize() = 0;
+  virtual void Unmaximize() = 0;
+  virtual bool IsMaximized() = 0;
+  virtual void Minimize() = 0;
+  virtual void Restore() = 0;
+  virtual bool IsMinimized() = 0;
+  virtual void SetFullScreen(bool fullscreen) = 0;
+  virtual bool IsFullscreen() const = 0;
+  virtual void SetBounds(const gfx::Rect& bounds, bool animate = false) = 0;
+  virtual gfx::Rect GetBounds() = 0;
+  virtual void SetSize(const gfx::Size& size, bool animate = false);
+  virtual gfx::Size GetSize();
+  virtual void SetPosition(const gfx::Point& position, bool animate = false);
+  virtual gfx::Point GetPosition();
+  virtual void SetContentSize(const gfx::Size& size, bool animate = false);
+  virtual gfx::Size GetContentSize();
+  virtual void SetSizeConstraints(
+      const extensions::SizeConstraints& size_constraints);
+  virtual extensions::SizeConstraints GetSizeConstraints();
+  virtual void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints);
+  virtual extensions::SizeConstraints GetContentSizeConstraints();
+  virtual void SetMinimumSize(const gfx::Size& size);
+  virtual gfx::Size GetMinimumSize();
+  virtual void SetMaximumSize(const gfx::Size& size);
+  virtual gfx::Size GetMaximumSize();
+  virtual void SetResizable(bool resizable) = 0;
+  virtual bool IsResizable() = 0;
+  virtual void SetMovable(bool movable) = 0;
+  virtual bool IsMovable() = 0;
+  virtual void SetMinimizable(bool minimizable) = 0;
+  virtual bool IsMinimizable() = 0;
+  virtual void SetMaximizable(bool maximizable) = 0;
+  virtual bool IsMaximizable() = 0;
+  virtual void SetFullScreenable(bool fullscreenable) = 0;
+  virtual bool IsFullScreenable() = 0;
+  virtual void SetClosable(bool closable) = 0;
+  virtual bool IsClosable() = 0;
+  virtual void SetAlwaysOnTop(bool top) = 0;
+  virtual bool IsAlwaysOnTop() = 0;
+  virtual void Center() = 0;
+  virtual void SetTitle(const std::string& title) = 0;
+  virtual std::string GetTitle() = 0;
+  virtual void FlashFrame(bool flash) = 0;
+  virtual void SetSkipTaskbar(bool skip) = 0;
+  virtual void SetKiosk(bool kiosk) = 0;
+  virtual bool IsKiosk() = 0;
+  virtual void SetBackgroundColor(const std::string& color_name) = 0;
+  virtual void SetHasShadow(bool has_shadow) = 0;
+  virtual bool HasShadow() = 0;
+  virtual void SetRepresentedFilename(const std::string& filename);
+  virtual std::string GetRepresentedFilename();
+  virtual void SetDocumentEdited(bool edited);
+  virtual bool IsDocumentEdited();
+  virtual void SetIgnoreMouseEvents(bool ignore);
+  virtual void SetMenu(ui::MenuModel* menu);
+  virtual bool HasModalDialog();
+  virtual gfx::NativeWindow GetNativeWindow() = 0;
+  virtual gfx::AcceleratedWidget GetAcceleratedWidget() = 0;
+
+  // Taskbar/Dock APIs.
+  virtual void SetProgressBar(double progress) = 0;
+  virtual void SetOverlayIcon(const gfx::Image& overlay,
+                              const std::string& description) = 0;
+
+  // Workspace APIs.
+  virtual void SetVisibleOnAllWorkspaces(bool visible) = 0;
+  virtual bool IsVisibleOnAllWorkspaces() = 0;
+
+  // Webview APIs.
+  virtual void FocusOnWebView();
+  virtual void BlurWebView();
+  virtual bool IsWebViewFocused();
+
+  // Captures the page with |rect|, |callback| would be called when capturing is
+  // done.
+  virtual void CapturePage(const gfx::Rect& rect,
+                           const CapturePageCallback& callback);
+
+  // Show popup dictionary.
+  virtual void ShowDefinitionForSelection();
+
+  // Toggle the menu bar.
+  virtual void SetAutoHideMenuBar(bool auto_hide);
+  virtual bool IsMenuBarAutoHide();
+  virtual void SetMenuBarVisibility(bool visible);
+  virtual bool IsMenuBarVisible();
+
+  // Set the aspect ratio when resizing window.
+  double GetAspectRatio();
+  gfx::Size GetAspectRatioExtraSize();
+  void SetAspectRatio(double aspect_ratio, const gfx::Size& extra_size);
+
+  base::WeakPtr<NativeWindow> GetWeakPtr() {
+    return weak_factory_.GetWeakPtr();
+  }
+
+  // Requests the WebContents to close, can be cancelled by the page.
+  virtual void RequestToClosePage();
+
+  // Methods called by the WebContents.
+  virtual void CloseContents(content::WebContents* source);
+  virtual void RendererUnresponsive(content::WebContents* source);
+  virtual void RendererResponsive(content::WebContents* source);
+  virtual void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent& event) {}
+
+  // Public API used by platform-dependent delegates and observers to send UI
+  // related notifications.
+  void NotifyWindowClosed();
+  void NotifyWindowBlur();
+  void NotifyWindowFocus();
+  void NotifyWindowShow();
+  void NotifyWindowHide();
+  void NotifyWindowMaximize();
+  void NotifyWindowUnmaximize();
+  void NotifyWindowMinimize();
+  void NotifyWindowRestore();
+  void NotifyWindowMove();
+  void NotifyWindowResize();
+  void NotifyWindowMoved();
+  void NotifyWindowScrollTouchBegin();
+  void NotifyWindowScrollTouchEnd();
+  void NotifyWindowSwipe(const std::string& direction);
+  void NotifyWindowEnterFullScreen();
+  void NotifyWindowLeaveFullScreen();
+  void NotifyWindowEnterHtmlFullScreen();
+  void NotifyWindowLeaveHtmlFullScreen();
+  void NotifyWindowExecuteWindowsCommand(const std::string& command);
+
+  #if defined(OS_WIN)
+  void NotifyWindowMessage(UINT message, WPARAM w_param, LPARAM l_param);
+  #endif
+
+  void AddObserver(NativeWindowObserver* obs) {
+    observers_.AddObserver(obs);
+  }
+  void RemoveObserver(NativeWindowObserver* obs) {
+    observers_.RemoveObserver(obs);
+  }
+
+  brightray::InspectableWebContents* inspectable_web_contents() const {
+    return inspectable_web_contents_;
+  }
+
+  bool has_frame() const { return has_frame_; }
+  bool transparent() const { return transparent_; }
+  SkRegion* draggable_region() const { return draggable_region_.get(); }
+  bool enable_larger_than_screen() const { return enable_larger_than_screen_; }
+  gfx::ImageSkia icon() const { return icon_; }
+
+  bool force_using_draggable_region() const {
+    return force_using_draggable_region_;
+  }
+  void set_force_using_draggable_region(bool force) {
+    force_using_draggable_region_ = true;
+  }
+
+  void set_has_dialog_attached(bool has_dialog_attached) {
+    has_dialog_attached_ = has_dialog_attached;
+  }
+
+ protected:
+  NativeWindow(brightray::InspectableWebContents* inspectable_web_contents,
+               const mate::Dictionary& options);
+
+  // Convert draggable regions in raw format to SkRegion format. Caller is
+  // responsible for deleting the returned SkRegion instance.
+  scoped_ptr<SkRegion> DraggableRegionsToSkRegion(
+      const std::vector<DraggableRegion>& regions);
+
+  // Converts between content size to window size.
+  virtual gfx::Size ContentSizeToWindowSize(const gfx::Size& size) = 0;
+  virtual gfx::Size WindowSizeToContentSize(const gfx::Size& size) = 0;
+
+  // Called when the window needs to update its draggable region.
+  virtual void UpdateDraggableRegions(
+      const std::vector<DraggableRegion>& regions);
+
+  // content::WebContentsObserver:
+  void RenderViewCreated(content::RenderViewHost* render_view_host) override;
+  void BeforeUnloadDialogCancelled() override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  // Parse hex color like "#FFF" or "#EFEFEF"
+  SkColor ParseHexColor(const std::string& name);
+
+ private:
+  // Schedule a notification unresponsive event.
+  void ScheduleUnresponsiveEvent(int ms);
+
+  // Dispatch unresponsive event to observers.
+  void NotifyWindowUnresponsive();
+
+  // Called when CapturePage has done.
+  void OnCapturePageDone(const CapturePageCallback& callback,
+                         const SkBitmap& bitmap,
+                         content::ReadbackResponse response);
+
+  // Whether window has standard frame.
+  bool has_frame_;
+
+  // Force the window to be aware of draggable regions.
+  bool force_using_draggable_region_;
+
+  // Whether window is transparent.
+  bool transparent_;
+
+  // For custom drag, the whole window is non-draggable and the draggable region
+  // has to been explicitly provided.
+  scoped_ptr<SkRegion> draggable_region_;  // used in custom drag.
+
+  // Minimum and maximum size, stored as content size.
+  extensions::SizeConstraints size_constraints_;
+
+  // Whether window can be resized larger than screen.
+  bool enable_larger_than_screen_;
+
+  // Window icon.
+  gfx::ImageSkia icon_;
+
+  // The windows has been closed.
+  bool is_closed_;
+
+  // There is a dialog that has been attached to window.
+  bool has_dialog_attached_;
+
+  // Closure that would be called when window is unresponsive when closing,
+  // it should be cancelled when we can prove that the window is responsive.
+  base::CancelableClosure window_unresposive_closure_;
+
+  // Used to maintain the aspect ratio of a view which is inside of the
+  // content view.
+  double aspect_ratio_;
+  gfx::Size aspect_ratio_extraSize_;
+
+  // The page this window is viewing.
+  brightray::InspectableWebContents* inspectable_web_contents_;
+
+  // Observers of this window.
+  base::ObserverList<NativeWindowObserver> observers_;
+
+  base::WeakPtrFactory<NativeWindow> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindow);
+};
+
+// This class provides a hook to get a NativeWindow from a WebContents.
+class NativeWindowRelay :
+    public content::WebContentsUserData<NativeWindowRelay> {
+ public:
+  explicit NativeWindowRelay(base::WeakPtr<NativeWindow> window)
+    : key(UserDataKey()), window(window) {}
+
+  void* key;
+  base::WeakPtr<NativeWindow> window;
+
+ private:
+  friend class content::WebContentsUserData<NativeWindow>;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_H_
added in remote
  their  100644 04e2e6f0011cd87ce55b36add9ec0f85b95c4050 electron/browser/native_window_mac.h
@@ -0,0 +1,152 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include <string>
+#include <vector>
+
+#include "base/mac/scoped_nsobject.h"
+#include "electron/browser/native_window.h"
+
+@class ElectronNSWindow;
+@class ElectronNSWindowDelegate;
+@class FullSizeContentView;
+
+namespace electron {
+
+class NativeWindowMac : public NativeWindow {
+ public:
+  NativeWindowMac(brightray::InspectableWebContents* inspectable_web_contents,
+                  const mate::Dictionary& options);
+  ~NativeWindowMac() override;
+
+  // NativeWindow:
+  void Close() override;
+  void CloseImmediately() override;
+  void Focus(bool focus) override;
+  bool IsFocused() override;
+  void Show() override;
+  void ShowInactive() override;
+  void Hide() override;
+  bool IsVisible() override;
+  void Maximize() override;
+  void Unmaximize() override;
+  bool IsMaximized() override;
+  void Minimize() override;
+  void Restore() override;
+  bool IsMinimized() override;
+  void SetFullScreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetBounds(const gfx::Rect& bounds, bool animate = false) override;
+  gfx::Rect GetBounds() override;
+  void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints) override;
+  void SetResizable(bool resizable) override;
+  bool IsResizable() override;
+  void SetMovable(bool movable) override;
+  bool IsMovable() override;
+  void SetMinimizable(bool minimizable) override;
+  bool IsMinimizable() override;
+  void SetMaximizable(bool maximizable) override;
+  bool IsMaximizable() override;
+  void SetFullScreenable(bool fullscreenable) override;
+  bool IsFullScreenable() override;
+  void SetClosable(bool closable) override;
+  bool IsClosable() override;
+  void SetAlwaysOnTop(bool top) override;
+  bool IsAlwaysOnTop() override;
+  void Center() override;
+  void SetTitle(const std::string& title) override;
+  std::string GetTitle() override;
+  void FlashFrame(bool flash) override;
+  void SetSkipTaskbar(bool skip) override;
+  void SetKiosk(bool kiosk) override;
+  bool IsKiosk() override;
+  void SetBackgroundColor(const std::string& color_name) override;
+  void SetHasShadow(bool has_shadow) override;
+  bool HasShadow() override;
+  void SetRepresentedFilename(const std::string& filename) override;
+  std::string GetRepresentedFilename() override;
+  void SetDocumentEdited(bool edited) override;
+  bool IsDocumentEdited() override;
+  void SetIgnoreMouseEvents(bool ignore) override;
+  bool HasModalDialog() override;
+  gfx::NativeWindow GetNativeWindow() override;
+  gfx::AcceleratedWidget GetAcceleratedWidget() override;
+  void SetProgressBar(double progress) override;
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description) override;
+  void ShowDefinitionForSelection() override;
+
+  void SetVisibleOnAllWorkspaces(bool visible) override;
+  bool IsVisibleOnAllWorkspaces() override;
+
+  // Refresh the DraggableRegion views.
+  void UpdateDraggableRegionViews() {
+    UpdateDraggableRegionViews(draggable_regions_);
+  }
+
+  bool should_hide_native_toolbar_in_fullscreen() const {
+    return should_hide_native_toolbar_in_fullscreen_;
+  }
+
+ protected:
+  // NativeWindow:
+  void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent&) override;
+
+  // Return a vector of non-draggable regions that fill a window of size
+  // |width| by |height|, but leave gaps where the window should be draggable.
+  std::vector<gfx::Rect> CalculateNonDraggableRegions(
+      const std::vector<DraggableRegion>& regions, int width, int height);
+
+ private:
+  // NativeWindow:
+  gfx::Size ContentSizeToWindowSize(const gfx::Size& size) override;
+  gfx::Size WindowSizeToContentSize(const gfx::Size& size) override;
+  void UpdateDraggableRegions(
+      const std::vector<DraggableRegion>& regions) override;
+
+  void InstallView();
+  void UninstallView();
+
+  // Install the drag view, which will cover the whole window and decides
+  // whehter we can drag.
+  void UpdateDraggableRegionViews(const std::vector<DraggableRegion>& regions);
+
+  // Set the attribute of NSWindow while work around a bug of zo0m button.
+  void SetStyleMask(bool on, NSUInteger flag);
+  void SetCollectionBehavior(bool on, NSUInteger flag);
+
+  base::scoped_nsobject<ElectronNSWindow> window_;
+  base::scoped_nsobject<ElectronNSWindowDelegate> window_delegate_;
+
+  // Event monitor for scroll wheel event.
+  id wheel_event_monitor_;
+
+  // The view that will fill the whole frameless window.
+  base::scoped_nsobject<FullSizeContentView> content_view_;
+
+  std::vector<DraggableRegion> draggable_regions_;
+
+  bool is_kiosk_;
+
+  NSInteger attention_request_id_;  // identifier from requestUserAttention
+
+  // The presentation options before entering kiosk mode.
+  NSApplicationPresentationOptions kiosk_options_;
+
+  bool should_hide_native_toolbar_in_fullscreen_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowMac);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
added in remote
  their  100644 7fe60a43f141fd72ad518ee47c6b0fe94ac0227d electron/browser/native_window_mac.mm
@@ -0,0 +1,1096 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_mac.h"
+
+#include <string>
+
+#include "electron/common/draggable_region.h"
+#include "electron/common/options_switches.h"
+#include "base/mac/mac_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/public/browser/browser_accessibility_state.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/skia_util.h"
+
+namespace {
+
+// Prevents window from resizing during the scope.
+class ScopedDisableResize {
+ public:
+  ScopedDisableResize() { disable_resize_ = true; }
+  ~ScopedDisableResize() { disable_resize_ = false; }
+
+  static bool IsResizeDisabled() { return disable_resize_; }
+
+ private:
+  static bool disable_resize_;
+};
+
+bool ScopedDisableResize::disable_resize_ = false;
+
+}  // namespace
+
+// This view always takes the size of its superview. It is intended to be used
+// as a NSWindow's contentView.  It is needed because NSWindow's implementation
+// explicitly resizes the contentView at inopportune times.
+@interface FullSizeContentView : NSView
+@end
+
+@implementation FullSizeContentView
+
+// This method is directly called by NSWindow during a window resize on OSX
+// 10.10.0, beta 2. We must override it to prevent the content view from
+// shrinking.
+- (void)setFrameSize:(NSSize)size {
+  if ([self superview])
+    size = [[self superview] bounds].size;
+  [super setFrameSize:size];
+}
+
+// The contentView gets moved around during certain full-screen operations.
+// This is less than ideal, and should eventually be removed.
+- (void)viewDidMoveToSuperview {
+  [self setFrame:[[self superview] bounds]];
+}
+
+@end
+
+@interface ElectronNSWindowDelegate : NSObject<NSWindowDelegate> {
+ @private
+  electron::NativeWindowMac* shell_;
+}
+- (id)initWithShell:(electron::NativeWindowMac*)shell;
+@end
+
+@implementation ElectronNSWindowDelegate
+
+- (id)initWithShell:(electron::NativeWindowMac*)shell {
+  if ((self = [super init])) {
+    shell_ = shell;
+  }
+  return self;
+}
+
+- (void)windowDidChangeOcclusionState:(NSNotification *)notification {
+  // notification.object is the window that changed its state.
+  // It's safe to use self.window instead if you don't assign one delegate to many windows
+  NSWindow *window = notification.object;
+
+  // check occlusion binary flag
+  if (window.occlusionState & NSWindowOcclusionStateVisible)   {
+     // The app is visible
+     shell_->NotifyWindowShow();
+   } else {
+     // The app is not visible
+     shell_->NotifyWindowHide();
+   }
+}
+
+- (void)windowDidBecomeMain:(NSNotification*)notification {
+  content::WebContents* web_contents = shell_->web_contents();
+  if (!web_contents)
+    return;
+
+  web_contents->RestoreFocus();
+
+  content::RenderWidgetHostView* rwhv = web_contents->GetRenderWidgetHostView();
+  if (rwhv)
+    rwhv->SetActive(true);
+
+  shell_->NotifyWindowFocus();
+}
+
+- (void)windowDidResignMain:(NSNotification*)notification {
+  content::WebContents* web_contents = shell_->web_contents();
+  if (!web_contents)
+    return;
+
+  web_contents->StoreFocus();
+
+  content::RenderWidgetHostView* rwhv = web_contents->GetRenderWidgetHostView();
+  if (rwhv)
+    rwhv->SetActive(false);
+
+  shell_->NotifyWindowBlur();
+}
+
+- (NSSize)windowWillResize:(NSWindow*)sender toSize:(NSSize)frameSize {
+  NSSize newSize = frameSize;
+  double aspectRatio = shell_->GetAspectRatio();
+
+  if (aspectRatio > 0.0) {
+    gfx::Size windowSize = shell_->GetSize();
+    gfx::Size contentSize = shell_->GetContentSize();
+    gfx::Size extraSize = shell_->GetAspectRatioExtraSize();
+
+    double extraWidthPlusFrame =
+        windowSize.width() - contentSize.width() + extraSize.width();
+    double extraHeightPlusFrame =
+        windowSize.height() - contentSize.height() + extraSize.height();
+
+    newSize.width =
+        roundf((frameSize.height - extraHeightPlusFrame) * aspectRatio +
+               extraWidthPlusFrame);
+
+    // If the new width is less than the frame size use it as the primary
+    // constraint. This ensures that the value returned by this method will
+    // never be larger than the users requested window size.
+    if (newSize.width <= frameSize.width) {
+      newSize.height =
+          roundf((newSize.width - extraWidthPlusFrame) / aspectRatio +
+                 extraHeightPlusFrame);
+    } else {
+      newSize.height =
+          roundf((frameSize.width - extraWidthPlusFrame) / aspectRatio +
+                 extraHeightPlusFrame);
+      newSize.width =
+          roundf((newSize.height - extraHeightPlusFrame) * aspectRatio +
+                 extraWidthPlusFrame);
+    }
+  }
+
+  return newSize;
+}
+
+- (void)windowDidResize:(NSNotification*)notification {
+  shell_->UpdateDraggableRegionViews();
+  shell_->NotifyWindowResize();
+}
+
+- (void)windowDidMove:(NSNotification*)notification {
+  // TODO(zcbenz): Remove the alias after figuring out a proper
+  // way to disptach move.
+  shell_->NotifyWindowMove();
+  shell_->NotifyWindowMoved();
+}
+
+- (void)windowDidMiniaturize:(NSNotification*)notification {
+  shell_->NotifyWindowMinimize();
+}
+
+- (void)windowDidDeminiaturize:(NSNotification*)notification {
+  shell_->NotifyWindowRestore();
+}
+
+- (BOOL)windowShouldZoom:(NSWindow*)window toFrame:(NSRect)newFrame {
+  // Cocoa doen't have concept of maximize/unmaximize, so wee need to emulate
+  // them by calculating size change when zooming.
+  if (newFrame.size.width < [window frame].size.width ||
+      newFrame.size.height < [window frame].size.height)
+    shell_->NotifyWindowUnmaximize();
+  else
+    shell_->NotifyWindowMaximize();
+  return YES;
+}
+
+- (void)windowWillEnterFullScreen:(NSNotification*)notification {
+  // Hide the native toolbar before entering fullscreen, so there is no visual
+  // artifacts.
+  if (shell_->should_hide_native_toolbar_in_fullscreen()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    [window setToolbar:nil];
+  }
+}
+
+- (void)windowDidEnterFullScreen:(NSNotification*)notification {
+  shell_->NotifyWindowEnterFullScreen();
+
+  // Restore the native toolbar immediately after entering fullscreen, if we do
+  // this before leaving fullscreen, traffic light buttons will be jumping.
+  if (shell_->should_hide_native_toolbar_in_fullscreen()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    base::scoped_nsobject<NSToolbar> toolbar(
+        [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
+    [toolbar setShowsBaselineSeparator:NO];
+    [window setToolbar:toolbar];
+  }
+}
+
+- (void)windowDidExitFullScreen:(NSNotification*)notification {
+  if (!shell_->has_frame()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    [[window standardWindowButton:NSWindowFullScreenButton] setHidden:YES];
+  }
+
+  shell_->NotifyWindowLeaveFullScreen();
+}
+
+- (void)windowWillClose:(NSNotification*)notification {
+  shell_->NotifyWindowClosed();
+
+  // Clears the delegate when window is going to be closed, since EL Capitan it
+  // is possible that the methods of delegate would get called after the window
+  // has been closed.
+  [shell_->GetNativeWindow() setDelegate:nil];
+}
+
+- (BOOL)windowShouldClose:(id)window {
+  // When user tries to close the window by clicking the close button, we do
+  // not close the window immediately, instead we try to close the web page
+  // fisrt, and when the web page is closed the window will also be closed.
+  shell_->RequestToClosePage();
+  return NO;
+}
+
+@end
+
+@interface ElectronNSWindow : NSWindow {
+ @private
+  electron::NativeWindowMac* shell_;
+  bool enable_larger_than_screen_;
+}
+@property BOOL acceptsFirstMouse;
+@property BOOL disableAutoHideCursor;
+@property BOOL disableKeyOrMainWindow;
+
+- (void)setShell:(electron::NativeWindowMac*)shell;
+- (void)setEnableLargerThanScreen:(bool)enable;
+@end
+
+@implementation ElectronNSWindow
+
+- (void)setShell:(electron::NativeWindowMac*)shell {
+  shell_ = shell;
+}
+
+- (void)setEnableLargerThanScreen:(bool)enable {
+  enable_larger_than_screen_ = enable;
+}
+
+// NSWindow overrides.
+
+- (void)swipeWithEvent:(NSEvent *)event {
+  if (event.deltaY == 1.0) {
+    shell_->NotifyWindowSwipe("up");
+  } else if (event.deltaX == -1.0) {
+    shell_->NotifyWindowSwipe("right");
+  } else if (event.deltaY == -1.0) {
+    shell_->NotifyWindowSwipe("down");
+  } else if (event.deltaX == 1.0) {
+    shell_->NotifyWindowSwipe("left");
+  }
+}
+
+- (NSRect)constrainFrameRect:(NSRect)frameRect toScreen:(NSScreen*)screen {
+  // Resizing is disabled.
+  if (ScopedDisableResize::IsResizeDisabled())
+    return [self frame];
+
+  // Enable the window to be larger than screen.
+  if (enable_larger_than_screen_)
+    return frameRect;
+  else
+    return [super constrainFrameRect:frameRect toScreen:screen];
+}
+
+- (id)accessibilityAttributeValue:(NSString*)attribute {
+  if (![attribute isEqualToString:@"AXChildren"])
+    return [super accessibilityAttributeValue:attribute];
+
+  // Filter out objects that aren't the title bar buttons. This has the effect
+  // of removing the window title, which VoiceOver already sees.
+  // * when VoiceOver is disabled, this causes Cmd+C to be used for TTS but
+  //   still leaves the buttons available in the accessibility tree.
+  // * when VoiceOver is enabled, the full accessibility tree is used.
+  // Without removing the title and with VO disabled, the TTS would always read
+  // the window title instead of using Cmd+C to get the selected text.
+  NSPredicate *predicate = [NSPredicate predicateWithFormat:
+      @"(self isKindOfClass: %@) OR (self.className == %@)",
+      [NSButtonCell class],
+      @"RenderWidgetHostViewCocoa"];
+
+  NSArray *children = [super accessibilityAttributeValue:attribute];
+  return [children filteredArrayUsingPredicate:predicate];
+}
+
+- (BOOL)canBecomeMainWindow {
+  return !self.disableKeyOrMainWindow;
+}
+
+- (BOOL)canBecomeKeyWindow {
+  return !self.disableKeyOrMainWindow;
+}
+
+@end
+
+@interface ControlRegionView : NSView
+@end
+
+@implementation ControlRegionView
+
+- (BOOL)mouseDownCanMoveWindow {
+  return NO;
+}
+
+- (NSView*)hitTest:(NSPoint)aPoint {
+  return nil;
+}
+
+@end
+
+@interface NSView (WebContentsView)
+- (void)setMouseDownCanMoveWindow:(BOOL)can_move;
+@end
+
+@interface ElectronProgressBar : NSProgressIndicator
+@end
+
+@implementation ElectronProgressBar
+
+- (void)drawRect:(NSRect)dirtyRect {
+  if (self.style != NSProgressIndicatorBarStyle)
+    return;
+  // Draw edges of rounded rect.
+  NSRect rect = NSInsetRect([self bounds], 1.0, 1.0);
+  CGFloat radius = rect.size.height / 2;
+  NSBezierPath* bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect xRadius:radius yRadius:radius];
+  [bezier_path setLineWidth:2.0];
+  [[NSColor grayColor] set];
+  [bezier_path stroke];
+
+  // Fill the rounded rect.
+  rect = NSInsetRect(rect, 2.0, 2.0);
+  radius = rect.size.height / 2;
+  bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect xRadius:radius yRadius:radius];
+  [bezier_path setLineWidth:1.0];
+  [bezier_path addClip];
+
+  // Calculate the progress width.
+  rect.size.width = floor(rect.size.width * ([self doubleValue] / [self maxValue]));
+
+  // Fill the progress bar with color blue.
+  [[NSColor colorWithSRGBRed:0.2 green:0.6 blue:1 alpha:1] set];
+  NSRectFill(rect);
+}
+
+@end
+
+namespace electron {
+
+NativeWindowMac::NativeWindowMac(
+    brightray::InspectableWebContents* web_contents,
+    const mate::Dictionary& options)
+    : NativeWindow(web_contents, options),
+      is_kiosk_(false),
+      attention_request_id_(0),
+      should_hide_native_toolbar_in_fullscreen_(false) {
+  int width = 800, height = 600;
+  options.Get(options::kWidth, &width);
+  options.Get(options::kHeight, &height);
+
+  NSRect main_screen_rect = [[[NSScreen screens] objectAtIndex:0] frame];
+  NSRect cocoa_bounds = NSMakeRect(
+      round((NSWidth(main_screen_rect) - width) / 2) ,
+      round((NSHeight(main_screen_rect) - height) / 2),
+      width,
+      height);
+
+  bool resizable = true;
+  options.Get(options::kResizable, &resizable);
+
+  bool minimizable = true;
+  options.Get(options::kMinimizable, &minimizable);
+
+  bool maximizable = true;
+  options.Get(options::kMaximizable, &maximizable);
+
+  bool closable = true;
+  options.Get(options::kClosable, &closable);
+
+  // New title bar styles are available in Yosemite or newer
+  std::string titleBarStyle;
+  if (base::mac::IsOSYosemiteOrLater())
+    options.Get(options::kTitleBarStyle, &titleBarStyle);
+
+  std::string windowType;
+  options.Get(options::kType, &windowType);
+
+  bool useStandardWindow = true;
+  // eventually deprecate separate "standardWindow" option in favor of
+  // standard / textured window types
+  options.Get(options::kStandardWindow, &useStandardWindow);
+  if (windowType == "textured") {
+    useStandardWindow = false;
+  }
+
+  NSUInteger styleMask = NSTitledWindowMask;
+  if (minimizable) {
+    styleMask |= NSMiniaturizableWindowMask;
+  }
+  if (closable) {
+    styleMask |= NSClosableWindowMask;
+  }
+  if (!useStandardWindow || transparent() || !has_frame()) {
+    styleMask |= NSTexturedBackgroundWindowMask;
+  }
+  if (resizable) {
+    styleMask |= NSResizableWindowMask;
+  }
+  if ((titleBarStyle == "hidden") || (titleBarStyle == "hidden-inset")) {
+    styleMask |= NSFullSizeContentViewWindowMask;
+    styleMask |= NSUnifiedTitleAndToolbarWindowMask;
+  }
+  // We capture this because we need to access the option later when
+  // entering/exiting fullscreen and since the options dict is only passed to
+  // the constructor but not stored, lets store this option this way.
+  if (titleBarStyle == "hidden-inset") {
+    should_hide_native_toolbar_in_fullscreen_ = true;
+  }
+
+  window_.reset([[ElectronNSWindow alloc]
+      initWithContentRect:cocoa_bounds
+                styleMask:styleMask
+                  backing:NSBackingStoreBuffered
+                    defer:YES]);
+  [window_ setShell:this];
+  [window_ setEnableLargerThanScreen:enable_larger_than_screen()];
+
+  window_delegate_.reset([[ElectronNSWindowDelegate alloc] initWithShell:this]);
+  [window_ setDelegate:window_delegate_];
+
+  if (transparent()) {
+    // Make window has transparent background.
+    [window_ setOpaque:NO];
+    // Setting the background color to clear will also hide the shadow.
+    [window_ setBackgroundColor:[NSColor clearColor]];
+  }
+
+  if (windowType == "desktop") {
+    [window_ setLevel:kCGDesktopWindowLevel - 1];
+    [window_ setDisableKeyOrMainWindow:YES];
+    [window_ setCollectionBehavior:
+        (NSWindowCollectionBehaviorCanJoinAllSpaces |
+         NSWindowCollectionBehaviorStationary |
+         NSWindowCollectionBehaviorIgnoresCycle)];
+  }
+
+  // Remove non-transparent corners, see http://git.io/vfonD.
+  if (!has_frame())
+    [window_ setOpaque:NO];
+
+  // We will manage window's lifetime ourselves.
+  [window_ setReleasedWhenClosed:NO];
+
+  // Hide the title bar.
+  if ((titleBarStyle == "hidden") || (titleBarStyle == "hidden-inset")) {
+    [window_ setTitlebarAppearsTransparent:YES];
+    [window_ setTitleVisibility:NSWindowTitleHidden];
+    if (titleBarStyle == "hidden-inset") {
+      base::scoped_nsobject<NSToolbar> toolbar(
+          [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
+      [toolbar setShowsBaselineSeparator:NO];
+      [window_ setToolbar:toolbar];
+    }
+    // We should be aware of draggable regions when using hidden titlebar.
+    set_force_using_draggable_region(true);
+  }
+
+  // On OS X the initial window size doesn't include window frame.
+  bool use_content_size = false;
+  options.Get(options::kUseContentSize, &use_content_size);
+  if (!has_frame() || !use_content_size)
+    SetSize(gfx::Size(width, height));
+
+  // Enable the NSView to accept first mouse event.
+  bool acceptsFirstMouse = false;
+  options.Get(options::kAcceptFirstMouse, &acceptsFirstMouse);
+  [window_ setAcceptsFirstMouse:acceptsFirstMouse];
+
+  // Disable auto-hiding cursor.
+  bool disableAutoHideCursor = false;
+  options.Get(options::kDisableAutoHideCursor, &disableAutoHideCursor);
+  [window_ setDisableAutoHideCursor:disableAutoHideCursor];
+
+  // Disable zoom button if window is not resizable.
+  if (!maximizable)
+    SetMaximizable(false);
+
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  [view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+
+  // Use an NSEvent monitor to listen for the wheel event.
+  BOOL __block began = NO;
+  wheel_event_monitor_ = [NSEvent
+    addLocalMonitorForEventsMatchingMask:NSScrollWheelMask
+    handler:^(NSEvent* event) {
+      if ([[event window] windowNumber] != [window_ windowNumber])
+        return event;
+
+      if (!web_contents)
+        return event;
+
+      if (!began && (([event phase] == NSEventPhaseMayBegin) ||
+                     ([event phase] == NSEventPhaseBegan))) {
+        this->NotifyWindowScrollTouchBegin();
+        began = YES;
+      } else if (began && (([event phase] == NSEventPhaseEnded) ||
+                           ([event phase] == NSEventPhaseCancelled))) {
+        this->NotifyWindowScrollTouchEnd();
+        began = NO;
+      }
+      return event;
+  }];
+
+  InstallView();
+}
+
+NativeWindowMac::~NativeWindowMac() {
+  [NSEvent removeMonitor:wheel_event_monitor_];
+  Observe(nullptr);
+}
+
+void NativeWindowMac::Close() {
+  [window_ performClose:nil];
+}
+
+void NativeWindowMac::CloseImmediately() {
+  [window_ close];
+}
+
+void NativeWindowMac::Focus(bool focus) {
+  if (!IsVisible())
+    return;
+
+  if (focus) {
+    [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
+    [window_ makeKeyAndOrderFront:nil];
+  } else {
+    [window_ orderBack:nil];
+  }
+}
+
+bool NativeWindowMac::IsFocused() {
+  return [window_ isKeyWindow];
+}
+
+void NativeWindowMac::Show() {
+  // This method is supposed to put focus on window, however if the app does not
+  // have focus then "makeKeyAndOrderFront" will only show the window.
+  [NSApp activateIgnoringOtherApps:YES];
+
+  [window_ makeKeyAndOrderFront:nil];
+}
+
+void NativeWindowMac::ShowInactive() {
+  [window_ orderFrontRegardless];
+}
+
+void NativeWindowMac::Hide() {
+  [window_ orderOut:nil];
+}
+
+bool NativeWindowMac::IsVisible() {
+  return [window_ isVisible];
+}
+
+void NativeWindowMac::Maximize() {
+  [window_ zoom:nil];
+}
+
+void NativeWindowMac::Unmaximize() {
+  [window_ zoom:nil];
+}
+
+bool NativeWindowMac::IsMaximized() {
+  if (([window_ styleMask] & NSResizableWindowMask) != 0) {
+    return [window_ isZoomed];
+  } else {
+    NSRect rectScreen = [[NSScreen mainScreen] visibleFrame];
+    NSRect rectWindow = [window_ frame];
+    return (rectScreen.origin.x == rectWindow.origin.x &&
+            rectScreen.origin.y == rectWindow.origin.y &&
+            rectScreen.size.width == rectWindow.size.width &&
+            rectScreen.size.height == rectWindow.size.height);
+  }
+}
+
+void NativeWindowMac::Minimize() {
+  [window_ miniaturize:nil];
+}
+
+void NativeWindowMac::Restore() {
+  [window_ deminiaturize:nil];
+}
+
+bool NativeWindowMac::IsMinimized() {
+  return [window_ isMiniaturized];
+}
+
+void NativeWindowMac::SetFullScreen(bool fullscreen) {
+  if (fullscreen == IsFullscreen())
+    return;
+
+  if (!base::mac::IsOSLionOrLater()) {
+    LOG(ERROR) << "Fullscreen mode is only supported above Lion";
+    return;
+  }
+
+  [window_ toggleFullScreen:nil];
+}
+
+bool NativeWindowMac::IsFullscreen() const {
+  return [window_ styleMask] & NSFullScreenWindowMask;
+}
+
+void NativeWindowMac::SetBounds(const gfx::Rect& bounds, bool animate) {
+  NSRect cocoa_bounds = NSMakeRect(bounds.x(), 0,
+                                   bounds.width(),
+                                   bounds.height());
+  // Flip coordinates based on the primary screen.
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  cocoa_bounds.origin.y =
+      NSHeight([screen frame]) - bounds.height() - bounds.y();
+
+  [window_ setFrame:cocoa_bounds display:YES animate:animate];
+}
+
+gfx::Rect NativeWindowMac::GetBounds() {
+  NSRect frame = [window_ frame];
+  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
+  return bounds;
+}
+
+void NativeWindowMac::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  auto convertSize = [this](const gfx::Size& size) {
+    // Our frameless window still has titlebar attached, so setting contentSize
+    // will result in actual content size being larger.
+    if (!has_frame()) {
+      NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
+      NSRect content = [window_ contentRectForFrameRect:frame];
+      return content.size;
+    } else {
+      return NSMakeSize(size.width(), size.height());
+    }
+  };
+
+  NSView* content = [window_ contentView];
+  if (size_constraints.HasMinimumSize()) {
+    NSSize min_size = convertSize(size_constraints.GetMinimumSize());
+    [window_ setContentMinSize:[content convertSize:min_size toView:nil]];
+  }
+  if (size_constraints.HasMaximumSize()) {
+    NSSize max_size = convertSize(size_constraints.GetMaximumSize());
+    [window_ setContentMaxSize:[content convertSize:max_size toView:nil]];
+  }
+  NativeWindow::SetContentSizeConstraints(size_constraints);
+}
+
+void NativeWindowMac::SetResizable(bool resizable) {
+  // Change styleMask for frameless causes the window to change size, so we have
+  // to explicitly disables that.
+  ScopedDisableResize disable_resize;
+  SetStyleMask(resizable, NSResizableWindowMask);
+}
+
+bool NativeWindowMac::IsResizable() {
+  return [window_ styleMask] & NSResizableWindowMask;
+}
+
+void NativeWindowMac::SetMovable(bool movable) {
+  [window_ setMovable:movable];
+}
+
+bool NativeWindowMac::IsMovable() {
+  return [window_ isMovable];
+}
+
+void NativeWindowMac::SetMinimizable(bool minimizable) {
+  SetStyleMask(minimizable, NSMiniaturizableWindowMask);
+}
+
+bool NativeWindowMac::IsMinimizable() {
+  return [window_ styleMask] & NSMiniaturizableWindowMask;
+}
+
+void NativeWindowMac::SetMaximizable(bool maximizable) {
+  [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:maximizable];
+}
+
+bool NativeWindowMac::IsMaximizable() {
+  return [[window_ standardWindowButton:NSWindowZoomButton] isEnabled];
+}
+
+void NativeWindowMac::SetFullScreenable(bool fullscreenable) {
+  SetCollectionBehavior(
+      fullscreenable, NSWindowCollectionBehaviorFullScreenPrimary);
+  // On EL Capitan this flag is required to hide fullscreen button.
+  SetCollectionBehavior(
+      !fullscreenable, NSWindowCollectionBehaviorFullScreenAuxiliary);
+}
+
+bool NativeWindowMac::IsFullScreenable() {
+  NSUInteger collectionBehavior = [window_ collectionBehavior];
+  return collectionBehavior & NSWindowCollectionBehaviorFullScreenPrimary;
+}
+
+void NativeWindowMac::SetClosable(bool closable) {
+  SetStyleMask(closable, NSClosableWindowMask);
+}
+
+bool NativeWindowMac::IsClosable() {
+  return [window_ styleMask] & NSClosableWindowMask;
+}
+
+void NativeWindowMac::SetAlwaysOnTop(bool top) {
+  [window_ setLevel:(top ? NSFloatingWindowLevel : NSNormalWindowLevel)];
+}
+
+bool NativeWindowMac::IsAlwaysOnTop() {
+  return [window_ level] == NSFloatingWindowLevel;
+}
+
+void NativeWindowMac::Center() {
+  [window_ center];
+}
+
+void NativeWindowMac::SetTitle(const std::string& title) {
+  // We don't want the title to show in transparent or frameless window.
+  if (transparent() || !has_frame())
+    return;
+
+  [window_ setTitle:base::SysUTF8ToNSString(title)];
+}
+
+std::string NativeWindowMac::GetTitle() {
+  return base::SysNSStringToUTF8([window_ title]);
+}
+
+void NativeWindowMac::FlashFrame(bool flash) {
+  if (flash) {
+    attention_request_id_ = [NSApp requestUserAttention:NSInformationalRequest];
+  } else {
+    [NSApp cancelUserAttentionRequest:attention_request_id_];
+    attention_request_id_ = 0;
+  }
+}
+
+void NativeWindowMac::SetSkipTaskbar(bool skip) {
+}
+
+void NativeWindowMac::SetKiosk(bool kiosk) {
+  if (kiosk && !is_kiosk_) {
+    kiosk_options_ = [NSApp currentSystemPresentationOptions];
+    NSApplicationPresentationOptions options =
+        NSApplicationPresentationHideDock +
+        NSApplicationPresentationHideMenuBar +
+        NSApplicationPresentationDisableAppleMenu +
+        NSApplicationPresentationDisableProcessSwitching +
+        NSApplicationPresentationDisableForceQuit +
+        NSApplicationPresentationDisableSessionTermination +
+        NSApplicationPresentationDisableHideApplication;
+    [NSApp setPresentationOptions:options];
+    is_kiosk_ = true;
+    SetFullScreen(true);
+  } else if (!kiosk && is_kiosk_) {
+    is_kiosk_ = false;
+    SetFullScreen(false);
+    [NSApp setPresentationOptions:kiosk_options_];
+  }
+}
+
+bool NativeWindowMac::IsKiosk() {
+  return is_kiosk_;
+}
+
+void NativeWindowMac::SetBackgroundColor(const std::string& color_name) {
+  SkColor background_color = NativeWindow::ParseHexColor(color_name);
+  NSColor *color = [NSColor colorWithCalibratedRed:SkColorGetR(background_color)
+    green:SkColorGetG(background_color)
+    blue:SkColorGetB(background_color)
+    alpha:SkColorGetA(background_color)/255.0f];
+  [window_ setBackgroundColor:color];
+}
+
+void NativeWindowMac::SetHasShadow(bool has_shadow) {
+  [window_ setHasShadow:has_shadow];
+}
+
+bool NativeWindowMac::HasShadow() {
+  return [window_ hasShadow];
+}
+
+void NativeWindowMac::SetRepresentedFilename(const std::string& filename) {
+  [window_ setRepresentedFilename:base::SysUTF8ToNSString(filename)];
+}
+
+std::string NativeWindowMac::GetRepresentedFilename() {
+  return base::SysNSStringToUTF8([window_ representedFilename]);
+}
+
+void NativeWindowMac::SetDocumentEdited(bool edited) {
+  [window_ setDocumentEdited:edited];
+}
+
+bool NativeWindowMac::IsDocumentEdited() {
+  return [window_ isDocumentEdited];
+}
+
+void NativeWindowMac::SetIgnoreMouseEvents(bool ignore) {
+  [window_ setIgnoresMouseEvents:ignore];
+}
+
+bool NativeWindowMac::HasModalDialog() {
+  return [window_ attachedSheet] != nil;
+}
+
+gfx::NativeWindow NativeWindowMac::GetNativeWindow() {
+  return window_;
+}
+
+gfx::AcceleratedWidget NativeWindowMac::GetAcceleratedWidget() {
+  return inspectable_web_contents()->GetView()->GetNativeView();
+}
+
+void NativeWindowMac::SetProgressBar(double progress) {
+  NSDockTile* dock_tile = [NSApp dockTile];
+
+  // For the first time API invoked, we need to create a ContentView in DockTile.
+  if (dock_tile.contentView == NULL) {
+    NSImageView* image_view = [[NSImageView alloc] init];
+    [image_view setImage:[NSApp applicationIconImage]];
+    [dock_tile setContentView:image_view];
+
+    NSProgressIndicator* progress_indicator = [[ElectronProgressBar alloc]
+        initWithFrame:NSMakeRect(0.0f, 0.0f, dock_tile.size.width, 15.0)];
+    [progress_indicator setStyle:NSProgressIndicatorBarStyle];
+    [progress_indicator setIndeterminate:NO];
+    [progress_indicator setBezeled:YES];
+    [progress_indicator setMinValue:0];
+    [progress_indicator setMaxValue:1];
+    [progress_indicator setHidden:NO];
+    [image_view addSubview:progress_indicator];
+  }
+
+  NSProgressIndicator* progress_indicator =
+      static_cast<NSProgressIndicator*>([[[dock_tile contentView] subviews]
+           objectAtIndex:0]);
+  if (progress < 0) {
+    [progress_indicator setHidden:YES];
+  } else if (progress > 1) {
+    [progress_indicator setHidden:NO];
+    [progress_indicator setIndeterminate:YES];
+    [progress_indicator setDoubleValue:1];
+  } else {
+    [progress_indicator setHidden:NO];
+    [progress_indicator setDoubleValue:progress];
+  }
+  [dock_tile display];
+}
+
+void NativeWindowMac::SetOverlayIcon(const gfx::Image& overlay,
+                                     const std::string& description) {
+}
+
+void NativeWindowMac::ShowDefinitionForSelection() {
+  if (!web_contents())
+    return;
+  auto rwhv = web_contents()->GetRenderWidgetHostView();
+  if (!rwhv)
+    return;
+  rwhv->ShowDefinitionForSelection();
+}
+
+void NativeWindowMac::SetVisibleOnAllWorkspaces(bool visible) {
+  SetCollectionBehavior(visible, NSWindowCollectionBehaviorCanJoinAllSpaces);
+}
+
+bool NativeWindowMac::IsVisibleOnAllWorkspaces() {
+  NSUInteger collectionBehavior = [window_ collectionBehavior];
+  return collectionBehavior & NSWindowCollectionBehaviorCanJoinAllSpaces;
+}
+
+void NativeWindowMac::HandleKeyboardEvent(
+    content::WebContents*,
+    const content::NativeWebKeyboardEvent& event) {
+  if (event.skip_in_browser ||
+      event.type == content::NativeWebKeyboardEvent::Char)
+    return;
+
+  BOOL handled = [[NSApp mainMenu] performKeyEquivalent:event.os_event];
+  if (!handled && event.os_event.window) {
+    // Handle the cmd+~ shortcut.
+    if ((event.os_event.modifierFlags & NSCommandKeyMask) /* cmd */ &&
+        (event.os_event.keyCode == 50  /* ~ */)) {
+      if (event.os_event.modifierFlags & NSShiftKeyMask) {
+        [NSApp sendAction:@selector(_cycleWindowsReversed:) to:nil from:nil];
+      } else {
+        [NSApp sendAction:@selector(_cycleWindows:) to:nil from:nil];
+      }
+    }
+  }
+}
+
+std::vector<gfx::Rect> NativeWindowMac::CalculateNonDraggableRegions(
+    const std::vector<DraggableRegion>& regions, int width, int height) {
+  std::vector<gfx::Rect> result;
+  if (regions.empty()) {
+    result.push_back(gfx::Rect(0, 0, width, height));
+  } else {
+    scoped_ptr<SkRegion> draggable(DraggableRegionsToSkRegion(regions));
+    scoped_ptr<SkRegion> non_draggable(new SkRegion);
+    non_draggable->op(0, 0, width, height, SkRegion::kUnion_Op);
+    non_draggable->op(*draggable, SkRegion::kDifference_Op);
+    for (SkRegion::Iterator it(*non_draggable); !it.done(); it.next()) {
+      result.push_back(gfx::SkIRectToRect(it.rect()));
+    }
+  }
+  return result;
+}
+
+gfx::Size NativeWindowMac::ContentSizeToWindowSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  NSRect content = NSMakeRect(0, 0, size.width(), size.height());
+  NSRect frame = [window_ frameRectForContentRect:content];
+  return gfx::Size(frame.size);
+}
+
+gfx::Size NativeWindowMac::WindowSizeToContentSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
+  NSRect content = [window_ contentRectForFrameRect:frame];
+  return gfx::Size(content.size);
+}
+
+void NativeWindowMac::UpdateDraggableRegions(
+    const std::vector<DraggableRegion>& regions) {
+  NativeWindow::UpdateDraggableRegions(regions);
+  draggable_regions_ = regions;
+  UpdateDraggableRegionViews(regions);
+}
+
+void NativeWindowMac::InstallView() {
+  // Make sure the bottom corner is rounded: http://crbug.com/396264.
+  [[window_ contentView] setWantsLayer:YES];
+
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  if (has_frame()) {
+    [view setFrame:[[window_ contentView] bounds]];
+    [[window_ contentView] addSubview:view];
+  } else {
+    // In OSX 10.10, adding subviews to the root view for the NSView hierarchy
+    // produces warnings. To eliminate the warnings, we resize the contentView
+    // to fill the window, and add subviews to that.
+    // http://crbug.com/380412
+    content_view_.reset([[FullSizeContentView alloc] init]);
+    [content_view_
+        setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+    [content_view_ setFrame:[[[window_ contentView] superview] bounds]];
+    [window_ setContentView:content_view_];
+
+    [view setFrame:[content_view_ bounds]];
+    [content_view_ addSubview:view];
+
+    [[window_ standardWindowButton:NSWindowZoomButton] setHidden:YES];
+    [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
+    [[window_ standardWindowButton:NSWindowCloseButton] setHidden:YES];
+
+    // Some third-party OS X utilities check the zoom button's enabled state to
+    // determine whether to show custom UI on hover, so we disable it here to
+    // prevent them from doing so in a frameless app window.
+    [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:NO];
+  }
+}
+
+void NativeWindowMac::UninstallView() {
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  [view removeFromSuperview];
+}
+
+void NativeWindowMac::UpdateDraggableRegionViews(
+    const std::vector<DraggableRegion>& regions) {
+  if (has_frame() && !force_using_draggable_region())
+    return;
+
+  // All ControlRegionViews should be added as children of the WebContentsView,
+  // because WebContentsView will be removed and re-added when entering and
+  // leaving fullscreen mode.
+  NSView* webView = web_contents()->GetNativeView();
+  NSInteger webViewWidth = NSWidth([webView bounds]);
+  NSInteger webViewHeight = NSHeight([webView bounds]);
+
+  [webView setMouseDownCanMoveWindow:YES];
+
+  // Remove all ControlRegionViews that are added last time.
+  // Note that [webView subviews] returns the view's mutable internal array and
+  // it should be copied to avoid mutating the original array while enumerating
+  // it.
+  base::scoped_nsobject<NSArray> subviews([[webView subviews] copy]);
+  for (NSView* subview in subviews.get())
+    if ([subview isKindOfClass:[ControlRegionView class]])
+      [subview removeFromSuperview];
+
+  // Draggable regions is implemented by having the whole web view draggable
+  // (mouseDownCanMoveWindow) and overlaying regions that are not draggable.
+  std::vector<gfx::Rect> system_drag_exclude_areas =
+      CalculateNonDraggableRegions(regions, webViewWidth, webViewHeight);
+
+  // Create and add a ControlRegionView for each region that needs to be
+  // excluded from the dragging.
+  for (std::vector<gfx::Rect>::const_iterator iter =
+           system_drag_exclude_areas.begin();
+       iter != system_drag_exclude_areas.end();
+       ++iter) {
+    base::scoped_nsobject<NSView> controlRegion(
+        [[ControlRegionView alloc] initWithFrame:NSZeroRect]);
+    [controlRegion setFrame:NSMakeRect(iter->x(),
+                                       webViewHeight - iter->bottom(),
+                                       iter->width(),
+                                       iter->height())];
+    [webView addSubview:controlRegion];
+  }
+
+  // AppKit will not update its cache of mouseDownCanMoveWindow unless something
+  // changes. Previously we tried adding an NSView and removing it, but for some
+  // reason it required reposting the mouse-down event, and didn't always work.
+  // Calling the below seems to be an effective solution.
+  [window_ setMovableByWindowBackground:NO];
+  [window_ setMovableByWindowBackground:YES];
+}
+
+void NativeWindowMac::SetStyleMask(bool on, NSUInteger flag) {
+  bool zoom_button_enabled = IsMaximizable();
+  if (on)
+    [window_ setStyleMask:[window_ styleMask] | flag];
+  else
+    [window_ setStyleMask:[window_ styleMask] & (~flag)];
+  // Change style mask will make the zoom button revert to default, probably
+  // a bug of Cocoa or OS X.
+  if (!zoom_button_enabled)
+    SetMaximizable(false);
+}
+
+void NativeWindowMac::SetCollectionBehavior(bool on, NSUInteger flag) {
+  bool zoom_button_enabled = IsMaximizable();
+  if (on)
+    [window_ setCollectionBehavior:[window_ collectionBehavior] | flag];
+  else
+    [window_ setCollectionBehavior:[window_ collectionBehavior] & (~flag)];
+  // Change collectionBehavior will make the zoom button revert to default,
+  // probably a bug of Cocoa or OS X.
+  if (!zoom_button_enabled)
+    SetMaximizable(false);
+}
+
+// static
+NativeWindow* NativeWindow::Create(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options) {
+  return new NativeWindowMac(inspectable_web_contents, options);
+}
+
+}  // namespace electron
added in remote
  their  100644 459872dc07685e449bf394b60772d64761109cf3 electron/browser/native_window_observer.h
@@ -0,0 +1,84 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
+
+#include <string>
+
+#include "base/strings/string16.h"
+#include "ui/base/window_open_disposition.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+namespace electron {
+
+class NativeWindowObserver {
+ public:
+  virtual ~NativeWindowObserver() {}
+
+  // Called when the web page in window wants to create a popup window.
+  virtual void WillCreatePopupWindow(const base::string16& frame_name,
+                                     const GURL& target_url,
+                                     const std::string& partition_id,
+                                     WindowOpenDisposition disposition) {}
+
+  // Called when user is starting an navigation in web page.
+  virtual void WillNavigate(bool* prevent_default, const GURL& url) {}
+
+  // Called when the window is gonna closed.
+  virtual void WillCloseWindow(bool* prevent_default) {}
+
+  // Called when the window is closed.
+  virtual void OnWindowClosed() {}
+
+  // Called when window loses focus.
+  virtual void OnWindowBlur() {}
+
+  // Called when window gains focus.
+  virtual void OnWindowFocus() {}
+
+  // Called when window is shown.
+  virtual void OnWindowShow() {}
+
+  // Called when window is hidden.
+  virtual void OnWindowHide() {}
+
+  // Called when window state changed.
+  virtual void OnWindowMaximize() {}
+  virtual void OnWindowUnmaximize() {}
+  virtual void OnWindowMinimize() {}
+  virtual void OnWindowRestore() {}
+  virtual void OnWindowResize() {}
+  virtual void OnWindowMove() {}
+  virtual void OnWindowMoved() {}
+  virtual void OnWindowScrollTouchBegin() {}
+  virtual void OnWindowScrollTouchEnd() {}
+  virtual void OnWindowSwipe(const std::string& direction) {}
+  virtual void OnWindowEnterFullScreen() {}
+  virtual void OnWindowLeaveFullScreen() {}
+  virtual void OnWindowEnterHtmlFullScreen() {}
+  virtual void OnWindowLeaveHtmlFullScreen() {}
+
+  // Called when window message received
+  #if defined(OS_WIN)
+  virtual void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {}
+  #endif
+
+  // Called when renderer is hung.
+  virtual void OnRendererUnresponsive() {}
+
+  // Called when renderer recovers.
+  virtual void OnRendererResponsive() {}
+
+  // Called on Windows when App Commands arrive (WM_APPCOMMAND)
+  virtual void OnExecuteWindowsCommand(const std::string& command_name) {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
added in remote
  their  100644 470c32a21fbe2e1623686c4c17818ed6bbd2a5de electron/browser/native_window_views.cc
@@ -0,0 +1,1030 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_views.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/views/menu_bar.h"
+#include "electron/browser/ui/views/menu_layout.h"
+#include "electron/common/draggable_region.h"
+#include "electron/common/options_switches.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "native_mate/dictionary.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/hit_test.h"
+#include "ui/gfx/image/image.h"
+#include "ui/views/background.h"
+#include "ui/views/controls/webview/unhandled_keyboard_event_handler.h"
+#include "ui/views/controls/webview/webview.h"
+#include "ui/views/window/client_view.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/shadow_types.h"
+
+#if defined(USE_X11)
+#include "electron/browser/browser.h"
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
+#include "electron/browser/ui/views/frameless_view.h"
+#include "electron/browser/ui/views/native_frame_view.h"
+#include "electron/browser/ui/x/window_state_watcher.h"
+#include "electron/browser/ui/x/x_window_utils.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/ui/libgtk2ui/unity_service.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/gfx/x/x11_types.h"
+#include "ui/views/window/native_frame_view.h"
+#elif defined(OS_WIN)
+#include "electron/browser/ui/views/win_frame_view.h"
+#include "electron/browser/ui/win/electron_desktop_window_tree_host_win.h"
+#include "skia/ext/skia_utils_win.h"
+#include "ui/base/win/shell.h"
+#include "ui/gfx/win/dpi.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+// The menu bar height in pixels.
+#if defined(OS_WIN)
+const int kMenuBarHeight = 20;
+#else
+const int kMenuBarHeight = 25;
+#endif
+
+#if defined(OS_WIN)
+void FlipWindowStyle(HWND handle, bool on, DWORD flag) {
+  DWORD style = ::GetWindowLong(handle, GWL_STYLE);
+  if (on)
+    style |= flag;
+  else
+    style &= ~flag;
+  ::SetWindowLong(handle, GWL_STYLE, style);
+}
+#endif
+
+bool IsAltKey(const content::NativeWebKeyboardEvent& event) {
+  return event.windowsKeyCode == ui::VKEY_MENU;
+}
+
+bool IsAltModifier(const content::NativeWebKeyboardEvent& event) {
+  typedef content::NativeWebKeyboardEvent::Modifiers Modifiers;
+  int modifiers = event.modifiers;
+  modifiers &= ~Modifiers::NumLockOn;
+  modifiers &= ~Modifiers::CapsLockOn;
+  return (modifiers == Modifiers::AltKey) ||
+         (modifiers == (Modifiers::AltKey | Modifiers::IsLeft)) ||
+         (modifiers == (Modifiers::AltKey | Modifiers::IsRight));
+}
+
+class NativeWindowClientView : public views::ClientView {
+ public:
+  NativeWindowClientView(views::Widget* widget,
+                         NativeWindowViews* contents_view)
+      : views::ClientView(widget, contents_view) {
+  }
+  virtual ~NativeWindowClientView() {}
+
+  bool CanClose() override {
+    static_cast<NativeWindowViews*>(contents_view())->RequestToClosePage();
+    return false;
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowClientView);
+};
+
+}  // namespace
+
+NativeWindowViews::NativeWindowViews(
+    brightray::InspectableWebContents* web_contents,
+    const mate::Dictionary& options)
+    : NativeWindow(web_contents, options),
+      window_(new views::Widget),
+      web_view_(inspectable_web_contents()->GetView()->GetView()),
+      menu_bar_autohide_(false),
+      menu_bar_visible_(false),
+      menu_bar_alt_pressed_(false),
+      keyboard_event_handler_(new views::UnhandledKeyboardEventHandler),
+      use_content_size_(false),
+      movable_(true),
+      resizable_(true),
+      maximizable_(true),
+      minimizable_(true),
+      fullscreenable_(true) {
+  options.Get(options::kTitle, &title_);
+  options.Get(options::kAutoHideMenuBar, &menu_bar_autohide_);
+
+#if defined(OS_WIN)
+  // On Windows we rely on the CanResize() to indicate whether window can be
+  // resized, and it should be set before window is created.
+  options.Get(options::kResizable, &resizable_);
+  options.Get(options::kMinimizable, &minimizable_);
+  options.Get(options::kMaximizable, &maximizable_);
+#endif
+
+  if (enable_larger_than_screen())
+    // We need to set a default maximum window size here otherwise Windows
+    // will not allow us to resize the window larger than scree.
+    // Setting directly to INT_MAX somehow doesn't work, so we just devide
+    // by 10, which should still be large enough.
+    SetContentSizeConstraints(extensions::SizeConstraints(
+        gfx::Size(), gfx::Size(INT_MAX / 10, INT_MAX / 10)));
+
+  int width = 800, height = 600;
+  options.Get(options::kWidth, &width);
+  options.Get(options::kHeight, &height);
+  gfx::Rect bounds(0, 0, width, height);
+  widget_size_ = bounds.size();
+
+  window_->AddObserver(this);
+
+  views::Widget::InitParams params;
+  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
+  params.bounds = bounds;
+  params.delegate = this;
+  params.type = views::Widget::InitParams::TYPE_WINDOW;
+  params.remove_standard_frame = !has_frame();
+
+  if (transparent())
+    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
+
+  // The given window is most likely not rectangular since it uses
+  // transparency and has no standard frame, don't show a shadow for it.
+  if (transparent() && !has_frame())
+    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
+
+#if defined(OS_WIN)
+  params.native_widget =
+      new views::DesktopNativeWidgetAura(window_.get());
+  electron_desktop_window_tree_host_win_ = new ElectronDesktopWindowTreeHostWin(
+      this,
+      window_.get(),
+      static_cast<views::DesktopNativeWidgetAura*>(params.native_widget));
+  params.desktop_window_tree_host = electron_desktop_window_tree_host_win_;
+#elif defined(USE_X11)
+  std::string name = Browser::Get()->GetName();
+  // Set WM_WINDOW_ROLE.
+  params.wm_role_name = "browser-window";
+  // Set WM_CLASS.
+  params.wm_class_name = base::ToLowerASCII(name);
+  params.wm_class_class = name;
+#endif
+
+  window_->Init(params);
+
+  bool fullscreen = false;
+  options.Get(options::kFullscreen, &fullscreen);
+
+#if defined(USE_X11)
+  // Start monitoring window states.
+  window_state_watcher_.reset(new WindowStateWatcher(this));
+
+  // Set _GTK_THEME_VARIANT to dark if we have "dark-theme" option set.
+  bool use_dark_theme = false;
+  if (options.Get(options::kDarkTheme, &use_dark_theme) && use_dark_theme) {
+    XDisplay* xdisplay = gfx::GetXDisplay();
+    XChangeProperty(xdisplay, GetAcceleratedWidget(),
+                    XInternAtom(xdisplay, "_GTK_THEME_VARIANT", False),
+                    XInternAtom(xdisplay, "UTF8_STRING", False),
+                    8, PropModeReplace,
+                    reinterpret_cast<const unsigned char*>("dark"),
+                    4);
+  }
+
+  // Before the window is mapped the SetWMSpecState can not work, so we have
+  // to manually set the _NET_WM_STATE.
+  std::vector<::Atom> state_electron_list;
+  bool skip_taskbar = false;
+  if (options.Get(options::kSkipTaskbar, &skip_taskbar) && skip_taskbar) {
+    state_electron_list.push_back(GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
+  }
+
+  // Before the window is mapped, there is no SHOW_FULLSCREEN_STATE.
+  if (fullscreen) {
+    state_electron_list.push_back(GetAtom("_NET_WM_STATE_FULLSCREEN"));
+  }
+
+  ui::SetElectronArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", "ATOM",
+                           state_electron_list);
+
+  // Set the _NET_WM_WINDOW_TYPE.
+  std::string window_type;
+  if (options.Get(options::kType, &window_type))
+    SetWindowType(GetAcceleratedWidget(), window_type);
+#endif
+
+  // Add web view.
+  SetLayoutManager(new MenuLayout(this, kMenuBarHeight));
+
+  AddChildView(web_view_);
+
+#if defined(OS_WIN)
+  // Save initial window state.
+  if (fullscreen)
+    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+  else
+    last_window_state_ = ui::SHOW_STATE_NORMAL;
+  last_normal_size_ = gfx::Size(widget_size_);
+
+  if (!has_frame()) {
+    // Set Window style so that we get a minimize and maximize animation when
+    // frameless.
+    DWORD frame_style = WS_CAPTION;
+    if (resizable_)
+      frame_style |= WS_THICKFRAME;
+    if (minimizable_)
+      frame_style |= WS_MINIMIZEBOX;
+    if (maximizable_)
+      frame_style |= WS_MAXIMIZEBOX;
+    // We should not show a frame for transparent window.
+    if (transparent())
+      frame_style &= ~(WS_THICKFRAME | WS_CAPTION);
+    ::SetWindowLong(GetAcceleratedWidget(), GWL_STYLE, frame_style);
+  }
+
+  if (transparent()) {
+    // Transparent window on Windows has to have WS_EX_COMPOSITED style.
+    LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
+    ex_style |= WS_EX_COMPOSITED;
+    ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
+  }
+#endif
+
+  // TODO(zcbenz): This was used to force using native frame on Windows 2003, we
+  // should check whether setting it in InitParams can work.
+  if (has_frame()) {
+    window_->set_frame_type(views::Widget::FrameType::FRAME_TYPE_FORCE_NATIVE);
+    window_->FrameTypeChanged();
+  }
+
+  gfx::Size size = bounds.size();
+  if (has_frame() &&
+      options.Get(options::kUseContentSize, &use_content_size_) &&
+      use_content_size_)
+    size = ContentSizeToWindowSize(size);
+
+  window_->UpdateWindowIcon();
+  window_->CenterWindow(size);
+  Layout();
+}
+
+NativeWindowViews::~NativeWindowViews() {
+  window_->RemoveObserver(this);
+}
+
+void NativeWindowViews::Close() {
+  window_->Close();
+}
+
+void NativeWindowViews::CloseImmediately() {
+  window_->CloseNow();
+}
+
+void NativeWindowViews::Focus(bool focus) {
+  if (focus)
+    window_->Activate();
+  else
+    window_->Deactivate();
+}
+
+bool NativeWindowViews::IsFocused() {
+  return window_->IsActive();
+}
+
+void NativeWindowViews::Show() {
+  window_->native_widget_private()->ShowWithWindowState(GetRestoredState());
+
+  NotifyWindowShow();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowMapped();
+#endif
+}
+
+void NativeWindowViews::ShowInactive() {
+  window_->ShowInactive();
+
+  NotifyWindowShow();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowMapped();
+#endif
+}
+
+void NativeWindowViews::Hide() {
+  window_->Hide();
+
+  NotifyWindowHide();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowUnmapped();
+#endif
+}
+
+bool NativeWindowViews::IsVisible() {
+  return window_->IsVisible();
+}
+
+void NativeWindowViews::Maximize() {
+  if (IsVisible())
+    window_->Maximize();
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_MAXIMIZED);
+}
+
+void NativeWindowViews::Unmaximize() {
+  window_->Restore();
+}
+
+bool NativeWindowViews::IsMaximized() {
+  return window_->IsMaximized();
+}
+
+void NativeWindowViews::Minimize() {
+  if (IsVisible())
+    window_->Minimize();
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_MINIMIZED);
+}
+
+void NativeWindowViews::Restore() {
+  window_->Restore();
+}
+
+bool NativeWindowViews::IsMinimized() {
+  return window_->IsMinimized();
+}
+
+void NativeWindowViews::SetFullScreen(bool fullscreen) {
+  if (!IsFullScreenable())
+    return;
+
+#if defined(OS_WIN)
+  // There is no native fullscreen state on Windows.
+  if (fullscreen) {
+    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+    NotifyWindowEnterFullScreen();
+  } else {
+    last_window_state_ = ui::SHOW_STATE_NORMAL;
+    NotifyWindowLeaveFullScreen();
+  }
+  // We set the new value after notifying, so we can handle the size event
+  // correctly.
+  window_->SetFullscreen(fullscreen);
+#else
+  if (IsVisible())
+    window_->SetFullscreen(fullscreen);
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_FULLSCREEN);
+#endif
+}
+
+bool NativeWindowViews::IsFullscreen() const {
+  return window_->IsFullscreen();
+}
+
+void NativeWindowViews::SetBounds(const gfx::Rect& bounds,
+    bool animate = false) {
+#if defined(USE_X11)
+  // On Linux the minimum and maximum size should be updated with window size
+  // when window is not resizable.
+  if (!resizable_) {
+    SetMaximumSize(bounds.size());
+    SetMinimumSize(bounds.size());
+  }
+#endif
+
+  window_->SetBounds(bounds);
+}
+
+gfx::Rect NativeWindowViews::GetBounds() {
+#if defined(OS_WIN)
+  if (IsMinimized())
+    return window_->GetRestoredBounds();
+#endif
+
+  return window_->GetWindowBoundsInScreen();
+}
+
+gfx::Size NativeWindowViews::GetContentSize() {
+#if defined(OS_WIN)
+  if (IsMinimized())
+    return NativeWindow::GetContentSize();
+#endif
+
+  return web_view_->size();
+}
+
+void NativeWindowViews::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  NativeWindow::SetContentSizeConstraints(size_constraints);
+  // widget_delegate() is only available after Init() is called, we make use of
+  // this to determine whether native widget has initialized.
+  if (window_ && window_->widget_delegate())
+    window_->OnSizeConstraintsChanged();
+#if defined(USE_X11)
+  if (resizable_)
+    old_size_constraints_ = size_constraints;
+#endif
+}
+
+void NativeWindowViews::SetResizable(bool resizable) {
+#if defined(OS_WIN)
+  if (!transparent())
+    FlipWindowStyle(GetAcceleratedWidget(), resizable, WS_THICKFRAME);
+#elif defined(USE_X11)
+  if (resizable != resizable_) {
+    // On Linux there is no "resizable" property of a window, we have to set
+    // both the minimum and maximum size to the window size to achieve it.
+    if (resizable) {
+      SetContentSizeConstraints(old_size_constraints_);
+    } else {
+      old_size_constraints_ = GetContentSizeConstraints();
+      resizable_ = false;
+      gfx::Size content_size = GetContentSize();
+      SetContentSizeConstraints(
+          extensions::SizeConstraints(content_size, content_size));
+    }
+  }
+#endif
+
+  resizable_ = resizable;
+}
+
+bool NativeWindowViews::IsResizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME;
+#else
+  return CanResize();
+#endif
+}
+
+void NativeWindowViews::SetMovable(bool movable) {
+  movable_ = movable;
+}
+
+bool NativeWindowViews::IsMovable() {
+#if defined(OS_WIN)
+  return movable_;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetMinimizable(bool minimizable) {
+#if defined(OS_WIN)
+  FlipWindowStyle(GetAcceleratedWidget(), minimizable, WS_MINIMIZEBOX);
+#endif
+  minimizable_ = minimizable;
+}
+
+bool NativeWindowViews::IsMinimizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MINIMIZEBOX;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetMaximizable(bool maximizable) {
+#if defined(OS_WIN)
+  FlipWindowStyle(GetAcceleratedWidget(), maximizable, WS_MAXIMIZEBOX);
+#endif
+  maximizable_ = maximizable;
+}
+
+bool NativeWindowViews::IsMaximizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MAXIMIZEBOX;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetFullScreenable(bool fullscreenable) {
+  fullscreenable_ = fullscreenable;
+}
+
+bool NativeWindowViews::IsFullScreenable() {
+  return fullscreenable_;
+}
+
+void NativeWindowViews::SetClosable(bool closable) {
+#if defined(OS_WIN)
+  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
+  if (closable) {
+    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
+  } else {
+    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
+  }
+#endif
+}
+
+bool NativeWindowViews::IsClosable() {
+#if defined(OS_WIN)
+  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
+  MENUITEMINFO info;
+  memset(&info, 0, sizeof(info));
+  info.cbSize = sizeof(info);
+  info.fMask = MIIM_STATE;
+  if (!GetMenuItemInfo(menu, SC_CLOSE, false, &info)) {
+    return false;
+  }
+  return !(info.fState & MFS_DISABLED);
+#elif defined(USE_X11)
+  return true;
+#endif
+}
+
+void NativeWindowViews::SetAlwaysOnTop(bool top) {
+  window_->SetAlwaysOnTop(top);
+}
+
+bool NativeWindowViews::IsAlwaysOnTop() {
+  return window_->IsAlwaysOnTop();
+}
+
+void NativeWindowViews::Center() {
+  window_->CenterWindow(GetSize());
+}
+
+void NativeWindowViews::SetTitle(const std::string& title) {
+  title_ = title;
+  window_->UpdateWindowTitle();
+}
+
+std::string NativeWindowViews::GetTitle() {
+  return title_;
+}
+
+void NativeWindowViews::FlashFrame(bool flash) {
+#if defined(OS_WIN)
+  // The Chromium's implementation has a bug stopping flash.
+  if (!flash) {
+    FLASHWINFO fwi;
+    fwi.cbSize = sizeof(fwi);
+    fwi.hwnd = GetAcceleratedWidget();
+    fwi.dwFlags = FLASHW_STOP;
+    fwi.uCount = 0;
+    FlashWindowEx(&fwi);
+    return;
+  }
+#endif
+  window_->FlashFrame(flash);
+}
+
+void NativeWindowViews::SetSkipTaskbar(bool skip) {
+#if defined(OS_WIN)
+  base::win::ScopedComPtr<ITaskbarList> taskbar;
+  if (FAILED(taskbar.CreateInstance(CLSID_TaskbarList, NULL,
+                                    CLSCTX_INPROC_SERVER)) ||
+      FAILED(taskbar->HrInit()))
+    return;
+  if (skip)
+    taskbar->DeleteTab(GetAcceleratedWidget());
+  else
+    taskbar->AddTab(GetAcceleratedWidget());
+#elif defined(USE_X11)
+  SetWMSpecState(GetAcceleratedWidget(), skip,
+                 GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
+#endif
+}
+
+void NativeWindowViews::SetKiosk(bool kiosk) {
+  SetFullScreen(kiosk);
+}
+
+bool NativeWindowViews::IsKiosk() {
+  return IsFullscreen();
+}
+
+void NativeWindowViews::SetBackgroundColor(const std::string& color_name) {
+  // web views' background color.
+  SkColor background_color = NativeWindow::ParseHexColor(color_name);
+  set_background(views::Background::CreateSolidBackground(background_color));
+
+#if defined(OS_WIN)
+  // Set the background color of native window.
+  HBRUSH brush = CreateSolidBrush(skia::SkColorToCOLORREF(background_color));
+  ULONG_PTR previous_brush = SetClassLongPtr(
+      GetAcceleratedWidget(), GCLP_HBRBACKGROUND, (LONG)brush);
+  if (previous_brush)
+    DeleteObject((HBRUSH)previous_brush);
+#endif
+}
+
+void NativeWindowViews::SetHasShadow(bool has_shadow) {
+  wm::SetShadowType(
+      GetNativeWindow(),
+      has_shadow ? wm::SHADOW_TYPE_RECTANGULAR : wm::SHADOW_TYPE_NONE);
+}
+
+bool NativeWindowViews::HasShadow() {
+  return wm::GetShadowType(GetNativeWindow()) != wm::SHADOW_TYPE_NONE;
+}
+
+void NativeWindowViews::SetMenu(ui::MenuModel* menu_model) {
+  if (menu_model == nullptr) {
+    // Remove accelerators
+    accelerator_table_.clear();
+    GetFocusManager()->UnregisterAccelerators(this);
+    // and menu bar.
+#if defined(USE_X11)
+    global_menu_bar_.reset();
+#endif
+    SetMenuBarVisibility(false);
+    menu_bar_.reset();
+    return;
+  }
+
+  RegisterAccelerators(menu_model);
+
+#if defined(USE_X11)
+  if (!global_menu_bar_ && ShouldUseGlobalMenuBar())
+    global_menu_bar_.reset(new GlobalMenuBarX11(this));
+
+  // Use global application menu bar when possible.
+  if (global_menu_bar_ && global_menu_bar_->IsServerStarted()) {
+    global_menu_bar_->SetMenu(menu_model);
+    return;
+  }
+#endif
+
+  // Do not show menu bar in frameless window.
+  if (!has_frame())
+    return;
+
+  if (!menu_bar_) {
+    gfx::Size content_size = GetContentSize();
+    menu_bar_.reset(new MenuBar);
+    menu_bar_->set_owned_by_client();
+
+    if (!menu_bar_autohide_) {
+      SetMenuBarVisibility(true);
+      if (use_content_size_) {
+        // Enlarge the size constraints for the menu.
+        extensions::SizeConstraints constraints = GetContentSizeConstraints();
+        if (constraints.HasMinimumSize()) {
+          gfx::Size min_size = constraints.GetMinimumSize();
+          min_size.set_height(min_size.height() + kMenuBarHeight);
+          constraints.set_minimum_size(min_size);
+        }
+        if (constraints.HasMaximumSize()) {
+          gfx::Size max_size = constraints.GetMaximumSize();
+          max_size.set_height(max_size.height() + kMenuBarHeight);
+          constraints.set_maximum_size(max_size);
+        }
+        SetContentSizeConstraints(constraints);
+
+        // Resize the window to make sure content size is not changed.
+        SetContentSize(content_size);
+      }
+    }
+  }
+
+  menu_bar_->SetMenu(menu_model);
+  Layout();
+}
+
+gfx::NativeWindow NativeWindowViews::GetNativeWindow() {
+  return window_->GetNativeWindow();
+}
+
+void NativeWindowViews::SetProgressBar(double progress) {
+#if defined(OS_WIN)
+  taskbar_host_.SetProgressBar(GetAcceleratedWidget(), progress);
+#elif defined(USE_X11)
+  if (unity::IsRunning()) {
+    unity::SetProgressFraction(progress);
+  }
+#endif
+}
+
+void NativeWindowViews::SetOverlayIcon(const gfx::Image& overlay,
+                                       const std::string& description) {
+#if defined(OS_WIN)
+  taskbar_host_.SetOverlayIcon(GetAcceleratedWidget(), overlay, description);
+#endif
+}
+
+void NativeWindowViews::SetAutoHideMenuBar(bool auto_hide) {
+  menu_bar_autohide_ = auto_hide;
+}
+
+bool NativeWindowViews::IsMenuBarAutoHide() {
+  return menu_bar_autohide_;
+}
+
+void NativeWindowViews::SetMenuBarVisibility(bool visible) {
+  if (!menu_bar_ || menu_bar_visible_ == visible)
+    return;
+
+  // Always show the accelerator when the auto-hide menu bar shows.
+  if (menu_bar_autohide_)
+    menu_bar_->SetAcceleratorVisibility(visible);
+
+  menu_bar_visible_ = visible;
+  if (visible) {
+    DCHECK_EQ(child_count(), 1);
+    AddChildView(menu_bar_.get());
+  } else {
+    DCHECK_EQ(child_count(), 2);
+    RemoveChildView(menu_bar_.get());
+  }
+
+  Layout();
+}
+
+bool NativeWindowViews::IsMenuBarVisible() {
+  return menu_bar_visible_;
+}
+
+void NativeWindowViews::SetVisibleOnAllWorkspaces(bool visible) {
+  window_->SetVisibleOnAllWorkspaces(visible);
+}
+
+bool NativeWindowViews::IsVisibleOnAllWorkspaces() {
+#if defined(USE_X11)
+  // Use the presence/absence of _NET_WM_STATE_STICKY in _NET_WM_STATE to
+  // determine whether the current window is visible on all workspaces.
+  XAtom sticky_atom = GetAtom("_NET_WM_STATE_STICKY");
+  std::vector<XAtom> wm_states;
+  ui::GetElectronArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", &wm_states);
+  return std::find(wm_states.begin(),
+                   wm_states.end(), sticky_atom) != wm_states.end();
+#endif
+  return false;
+}
+
+gfx::AcceleratedWidget NativeWindowViews::GetAcceleratedWidget() {
+  return GetNativeWindow()->GetHost()->GetAcceleratedWidget();
+}
+
+void NativeWindowViews::OnWidgetActivationChanged(
+    views::Widget* widget, bool active) {
+  if (widget != window_.get())
+    return;
+
+  if (active)
+    NotifyWindowFocus();
+  else
+    NotifyWindowBlur();
+
+  if (active && inspectable_web_contents() &&
+      !inspectable_web_contents()->IsDevToolsViewShowing())
+    web_contents()->Focus();
+
+  // Hide menu bar when window is blured.
+  if (!active && menu_bar_autohide_ && menu_bar_visible_)
+    SetMenuBarVisibility(false);
+}
+
+void NativeWindowViews::OnWidgetBoundsChanged(
+    views::Widget* widget, const gfx::Rect& bounds) {
+  if (widget != window_.get())
+    return;
+
+  if (widget_size_ != bounds.size()) {
+    NotifyWindowResize();
+    widget_size_ = bounds.size();
+  }
+}
+
+void NativeWindowViews::DeleteDelegate() {
+  NotifyWindowClosed();
+}
+
+views::View* NativeWindowViews::GetInitiallyFocusedView() {
+  return inspectable_web_contents()->GetView()->GetWebView();
+}
+
+bool NativeWindowViews::CanResize() const {
+  return resizable_;
+}
+
+bool NativeWindowViews::CanMaximize() const {
+  return resizable_ && maximizable_;
+}
+
+bool NativeWindowViews::CanMinimize() const {
+#if defined(OS_WIN)
+  return minimizable_;
+#elif defined(USE_X11)
+  return true;
+#endif
+}
+
+base::string16 NativeWindowViews::GetWindowTitle() const {
+  return base::UTF8ToUTF16(title_);
+}
+
+bool NativeWindowViews::ShouldHandleSystemCommands() const {
+  return true;
+}
+
+gfx::ImageSkia NativeWindowViews::GetWindowAppIcon() {
+  return icon();
+}
+
+gfx::ImageSkia NativeWindowViews::GetWindowIcon() {
+  return GetWindowAppIcon();
+}
+
+views::Widget* NativeWindowViews::GetWidget() {
+  return window_.get();
+}
+
+const views::Widget* NativeWindowViews::GetWidget() const {
+  return window_.get();
+}
+
+views::View* NativeWindowViews::GetContentsView() {
+  return this;
+}
+
+bool NativeWindowViews::ShouldDescendIntoChildForEventHandling(
+    gfx::NativeView child,
+    const gfx::Point& location) {
+  // App window should claim mouse events that fall within the draggable region.
+  if (draggable_region() &&
+      draggable_region()->contains(location.x(), location.y()))
+    return false;
+
+  // And the events on border for dragging resizable frameless window.
+  if (!has_frame() && CanResize()) {
+    FramelessView* frame = static_cast<FramelessView*>(
+        window_->non_client_view()->frame_view());
+    return frame->ResizingBorderHitTest(location) == HTNOWHERE;
+  }
+
+  return true;
+}
+
+views::ClientView* NativeWindowViews::CreateClientView(views::Widget* widget) {
+  return new NativeWindowClientView(widget, this);
+}
+
+views::NonClientFrameView* NativeWindowViews::CreateNonClientFrameView(
+    views::Widget* widget) {
+#if defined(OS_WIN)
+  WinFrameView* frame_view = new WinFrameView;
+  frame_view->Init(this, widget);
+  return frame_view;
+#else
+  if (has_frame()) {
+    return new NativeFrameView(this, widget);
+  } else {
+    FramelessView* frame_view = new FramelessView;
+    frame_view->Init(this, widget);
+    return frame_view;
+  }
+#endif
+}
+
+void NativeWindowViews::OnWidgetMove() {
+  NotifyWindowMove();
+}
+
+gfx::Size NativeWindowViews::ContentSizeToWindowSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  gfx::Size window_size(size);
+#if defined(OS_WIN)
+  gfx::Rect dpi_bounds =
+      gfx::Rect(gfx::Point(), gfx::win::DIPToScreenSize(size));
+  gfx::Rect window_bounds = gfx::win::ScreenToDIPRect(
+      window_->non_client_view()->GetWindowBoundsForClientBounds(dpi_bounds));
+  window_size = window_bounds.size();
+#endif
+
+  if (menu_bar_ && menu_bar_visible_)
+    window_size.set_height(window_size.height() + kMenuBarHeight);
+  return window_size;
+}
+
+gfx::Size NativeWindowViews::WindowSizeToContentSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  gfx::Size content_size(size);
+#if defined(OS_WIN)
+  content_size = gfx::win::DIPToScreenSize(content_size);
+  RECT rect;
+  SetRectEmpty(&rect);
+  HWND hwnd = GetAcceleratedWidget();
+  DWORD style = ::GetWindowLong(hwnd, GWL_STYLE);
+  DWORD ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
+  AdjustWindowRectEx(&rect, style, FALSE, ex_style);
+  content_size.set_width(content_size.width() - (rect.right - rect.left));
+  content_size.set_height(content_size.height() - (rect.bottom - rect.top));
+  content_size = gfx::win::ScreenToDIPSize(content_size);
+#endif
+
+  if (menu_bar_ && menu_bar_visible_)
+    content_size.set_height(content_size.height() - kMenuBarHeight);
+  return content_size;
+}
+
+void NativeWindowViews::HandleKeyboardEvent(
+    content::WebContents*,
+    const content::NativeWebKeyboardEvent& event) {
+  keyboard_event_handler_->HandleKeyboardEvent(event, GetFocusManager());
+
+  if (!menu_bar_)
+    return;
+
+  // Show accelerator when "Alt" is pressed.
+  if (menu_bar_visible_ && IsAltKey(event))
+    menu_bar_->SetAcceleratorVisibility(
+        event.type == blink::WebInputEvent::RawKeyDown);
+
+  // Show the submenu when "Alt+Key" is pressed.
+  if (event.type == blink::WebInputEvent::RawKeyDown && !IsAltKey(event) &&
+      IsAltModifier(event)) {
+    if (!menu_bar_visible_ &&
+        (menu_bar_->GetAcceleratorIndex(event.windowsKeyCode) != -1))
+      SetMenuBarVisibility(true);
+    menu_bar_->ActivateAccelerator(event.windowsKeyCode);
+    return;
+  }
+
+  if (!menu_bar_autohide_)
+    return;
+
+  // Toggle the menu bar only when a single Alt is released.
+  if (event.type == blink::WebInputEvent::RawKeyDown && IsAltKey(event)) {
+    // When a single Alt is pressed:
+    menu_bar_alt_pressed_ = true;
+  } else if (event.type == blink::WebInputEvent::KeyUp && IsAltKey(event) &&
+             menu_bar_alt_pressed_) {
+    // When a single Alt is released right after a Alt is pressed:
+    menu_bar_alt_pressed_ = false;
+    SetMenuBarVisibility(!menu_bar_visible_);
+  } else {
+    // When any other keys except single Alt have been pressed/released:
+    menu_bar_alt_pressed_ = false;
+  }
+}
+
+gfx::Size NativeWindowViews::GetMinimumSize() {
+  return NativeWindow::GetMinimumSize();
+}
+
+gfx::Size NativeWindowViews::GetMaximumSize() {
+  return NativeWindow::GetMaximumSize();
+}
+
+bool NativeWindowViews::AcceleratorPressed(const ui::Accelerator& accelerator) {
+  return accelerator_util::TriggerAcceleratorTableCommand(
+      &accelerator_table_, accelerator);
+}
+
+void NativeWindowViews::RegisterAccelerators(ui::MenuModel* menu_model) {
+  // Clear previous accelerators.
+  views::FocusManager* focus_manager = GetFocusManager();
+  accelerator_table_.clear();
+  focus_manager->UnregisterAccelerators(this);
+
+  // Register accelerators with focus manager.
+  accelerator_util::GenerateAcceleratorTable(&accelerator_table_, menu_model);
+  accelerator_util::AcceleratorTable::const_iterator iter;
+  for (iter = accelerator_table_.begin();
+       iter != accelerator_table_.end();
+       ++iter) {
+    focus_manager->RegisterAccelerator(
+        iter->first, ui::AcceleratorManager::kNormalPriority, this);
+  }
+}
+
+ui::WindowShowState NativeWindowViews::GetRestoredState() {
+  if (IsMaximized())
+    return ui::SHOW_STATE_MAXIMIZED;
+  if (IsFullscreen())
+    return ui::SHOW_STATE_FULLSCREEN;
+
+  return ui::SHOW_STATE_NORMAL;
+}
+
+// static
+NativeWindow* NativeWindow::Create(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options) {
+  return new NativeWindowViews(inspectable_web_contents, options);
+}
+
+}  // namespace electron
added in remote
  their  100644 1412c047227d6fae7bba45289031615e3d76718c electron/browser/native_window_views.h
@@ -0,0 +1,224 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
+
+#include "electron/browser/native_window.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/accelerator_util.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/widget_observer.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/ui/win/message_handler_delegate.h"
+#include "electron/browser/ui/win/taskbar_host.h"
+#endif
+
+namespace views {
+class UnhandledKeyboardEventHandler;
+}
+
+namespace electron {
+
+class GlobalMenuBarX11;
+class MenuBar;
+class WindowStateWatcher;
+
+#if defined(OS_WIN)
+class ElectronDesktopWindowTreeHostWin;
+#endif
+
+class NativeWindowViews : public NativeWindow,
+#if defined(OS_WIN)
+                          public MessageHandlerDelegate,
+#endif
+                          public views::WidgetDelegateView,
+                          public views::WidgetObserver {
+ public:
+  NativeWindowViews(brightray::InspectableWebContents* inspectable_web_contents,
+                    const mate::Dictionary& options);
+  ~NativeWindowViews() override;
+
+  // NativeWindow:
+  void Close() override;
+  void CloseImmediately() override;
+  void Focus(bool focus) override;
+  bool IsFocused() override;
+  void Show() override;
+  void ShowInactive() override;
+  void Hide() override;
+  bool IsVisible() override;
+  void Maximize() override;
+  void Unmaximize() override;
+  bool IsMaximized() override;
+  void Minimize() override;
+  void Restore() override;
+  bool IsMinimized() override;
+  void SetFullScreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetBounds(const gfx::Rect& bounds, bool animate) override;
+  gfx::Rect GetBounds() override;
+  gfx::Size GetContentSize() override;
+  void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints) override;
+  void SetResizable(bool resizable) override;
+  bool IsResizable() override;
+  void SetMovable(bool movable) override;
+  bool IsMovable() override;
+  void SetMinimizable(bool minimizable) override;
+  bool IsMinimizable() override;
+  void SetMaximizable(bool maximizable) override;
+  bool IsMaximizable() override;
+  void SetFullScreenable(bool fullscreenable) override;
+  bool IsFullScreenable() override;
+  void SetClosable(bool closable) override;
+  bool IsClosable() override;
+  void SetAlwaysOnTop(bool top) override;
+  bool IsAlwaysOnTop() override;
+  void Center() override;
+  void SetTitle(const std::string& title) override;
+  std::string GetTitle() override;
+  void FlashFrame(bool flash) override;
+  void SetSkipTaskbar(bool skip) override;
+  void SetKiosk(bool kiosk) override;
+  bool IsKiosk() override;
+  void SetBackgroundColor(const std::string& color_name) override;
+  void SetHasShadow(bool has_shadow) override;
+  bool HasShadow() override;
+  void SetMenu(ui::MenuModel* menu_model) override;
+  gfx::NativeWindow GetNativeWindow() override;
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description) override;
+  void SetProgressBar(double value) override;
+  void SetAutoHideMenuBar(bool auto_hide) override;
+  bool IsMenuBarAutoHide() override;
+  void SetMenuBarVisibility(bool visible) override;
+  bool IsMenuBarVisible() override;
+  void SetVisibleOnAllWorkspaces(bool visible) override;
+  bool IsVisibleOnAllWorkspaces() override;
+
+  gfx::AcceleratedWidget GetAcceleratedWidget() override;
+
+  views::Widget* widget() const { return window_.get(); }
+
+#if defined(OS_WIN)
+  TaskbarHost& taskbar_host() { return taskbar_host_; }
+#endif
+
+ private:
+  // views::WidgetObserver:
+  void OnWidgetActivationChanged(
+      views::Widget* widget, bool active) override;
+  void OnWidgetBoundsChanged(
+      views::Widget* widget, const gfx::Rect& bounds) override;
+
+  // views::WidgetDelegate:
+  void DeleteDelegate() override;
+  views::View* GetInitiallyFocusedView() override;
+  bool CanResize() const override;
+  bool CanMaximize() const override;
+  bool CanMinimize() const override;
+  base::string16 GetWindowTitle() const override;
+  bool ShouldHandleSystemCommands() const override;
+  gfx::ImageSkia GetWindowAppIcon() override;
+  gfx::ImageSkia GetWindowIcon() override;
+  views::Widget* GetWidget() override;
+  const views::Widget* GetWidget() const override;
+  views::View* GetContentsView() override;
+  bool ShouldDescendIntoChildForEventHandling(
+     gfx::NativeView child,
+     const gfx::Point& location) override;
+  views::ClientView* CreateClientView(views::Widget* widget) override;
+  views::NonClientFrameView* CreateNonClientFrameView(
+      views::Widget* widget) override;
+  void OnWidgetMove() override;
+#if defined(OS_WIN)
+  bool ExecuteWindowsCommand(int command_id) override;
+#endif
+
+#if defined(OS_WIN)
+  // MessageHandlerDelegate:
+  bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) override;
+
+  void HandleSizeEvent(WPARAM w_param, LPARAM l_param);
+#endif
+
+  // NativeWindow:
+  gfx::Size ContentSizeToWindowSize(const gfx::Size& size) override;
+  gfx::Size WindowSizeToContentSize(const gfx::Size& size) override;
+  void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent& event) override;
+
+  // views::View:
+  gfx::Size GetMinimumSize() override;
+  gfx::Size GetMaximumSize() override;
+  bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
+
+  // Register accelerators supported by the menu model.
+  void RegisterAccelerators(ui::MenuModel* menu_model);
+
+  // Returns the restore state for the window.
+  ui::WindowShowState GetRestoredState();
+
+  scoped_ptr<views::Widget> window_;
+  views::View* web_view_;  // Managed by inspectable_web_contents_.
+
+  scoped_ptr<MenuBar> menu_bar_;
+  bool menu_bar_autohide_;
+  bool menu_bar_visible_;
+  bool menu_bar_alt_pressed_;
+
+#if defined(USE_X11)
+  scoped_ptr<GlobalMenuBarX11> global_menu_bar_;
+
+  // Handles window state events.
+  scoped_ptr<WindowStateWatcher> window_state_watcher_;
+
+  // The "resizable" flag on Linux is implemented by setting size constraints,
+  // we need to make sure size constraints are restored when window becomes
+  // resizable again.
+  extensions::SizeConstraints old_size_constraints_;
+#elif defined(OS_WIN)
+  // Weak ref.
+  ElectronDesktopWindowTreeHostWin* electron_desktop_window_tree_host_win_;
+
+  ui::WindowShowState last_window_state_;
+
+  // There's an issue with restore on Windows, that sometimes causes the Window
+  // to receive the wrong size (#2498). To circumvent that, we keep tabs on the
+  // size of the window while in the normal state (not maximized, minimized or
+  // fullscreen), so we restore it correctly.
+  gfx::Size last_normal_size_;
+
+  // In charge of running taskbar related APIs.
+  TaskbarHost taskbar_host_;
+#endif
+
+  // Handles unhandled keyboard messages coming back from the renderer process.
+  scoped_ptr<views::UnhandledKeyboardEventHandler> keyboard_event_handler_;
+
+  // Map from accelerator to menu item's command id.
+  accelerator_util::AcceleratorTable accelerator_table_;
+
+  bool use_content_size_;
+  bool movable_;
+  bool resizable_;
+  bool maximizable_;
+  bool minimizable_;
+  bool fullscreenable_;
+  std::string title_;
+  gfx::Size widget_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowViews);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
added in remote
  their  100644 ccc583f4004e7f8489d1d0fa918d2d8253c88e13 electron/browser/native_window_views_win.cc
@@ -0,0 +1,156 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_views.h"
+#include "content/public/browser/browser_accessibility_state.h"
+
+namespace electron {
+
+namespace {
+
+// Convert Win32 WM_APPCOMMANDS to strings.
+const char* AppCommandToString(int command_id) {
+  switch (command_id) {
+    case APPCOMMAND_BROWSER_BACKWARD       : return "browser-backward";
+    case APPCOMMAND_BROWSER_FORWARD        : return "browser-forward";
+    case APPCOMMAND_BROWSER_REFRESH        : return "browser-refresh";
+    case APPCOMMAND_BROWSER_STOP           : return "browser-stop";
+    case APPCOMMAND_BROWSER_SEARCH         : return "browser-search";
+    case APPCOMMAND_BROWSER_FAVORITES      : return "browser-favorites";
+    case APPCOMMAND_BROWSER_HOME           : return "browser-home";
+    case APPCOMMAND_VOLUME_MUTE            : return "volume-mute";
+    case APPCOMMAND_VOLUME_DOWN            : return "volume-down";
+    case APPCOMMAND_VOLUME_UP              : return "volume-up";
+    case APPCOMMAND_MEDIA_NEXTTRACK        : return "media-nexttrack";
+    case APPCOMMAND_MEDIA_PREVIOUSTRACK    : return "media-previoustrack";
+    case APPCOMMAND_MEDIA_STOP             : return "media-stop";
+    case APPCOMMAND_MEDIA_PLAY_PAUSE       : return "media-play_pause";
+    case APPCOMMAND_LAUNCH_MAIL            : return "launch-mail";
+    case APPCOMMAND_LAUNCH_MEDIA_SELECT    : return "launch-media-select";
+    case APPCOMMAND_LAUNCH_APP1            : return "launch-app1";
+    case APPCOMMAND_LAUNCH_APP2            : return "launch-app2";
+    case APPCOMMAND_BASS_DOWN              : return "bass-down";
+    case APPCOMMAND_BASS_BOOST             : return "bass-boost";
+    case APPCOMMAND_BASS_UP                : return "bass-up";
+    case APPCOMMAND_TREBLE_DOWN            : return "treble-down";
+    case APPCOMMAND_TREBLE_UP              : return "treble-up";
+    case APPCOMMAND_MICROPHONE_VOLUME_MUTE : return "microphone-volume-mute";
+    case APPCOMMAND_MICROPHONE_VOLUME_DOWN : return "microphone-volume-down";
+    case APPCOMMAND_MICROPHONE_VOLUME_UP   : return "microphone-volume-up";
+    case APPCOMMAND_HELP                   : return "help";
+    case APPCOMMAND_FIND                   : return "find";
+    case APPCOMMAND_NEW                    : return "new";
+    case APPCOMMAND_OPEN                   : return "open";
+    case APPCOMMAND_CLOSE                  : return "close";
+    case APPCOMMAND_SAVE                   : return "save";
+    case APPCOMMAND_PRINT                  : return "print";
+    case APPCOMMAND_UNDO                   : return "undo";
+    case APPCOMMAND_REDO                   : return "redo";
+    case APPCOMMAND_COPY                   : return "copy";
+    case APPCOMMAND_CUT                    : return "cut";
+    case APPCOMMAND_PASTE                  : return "paste";
+    case APPCOMMAND_REPLY_TO_MAIL          : return "reply-to-mail";
+    case APPCOMMAND_FORWARD_MAIL           : return "forward-mail";
+    case APPCOMMAND_SEND_MAIL              : return "send-mail";
+    case APPCOMMAND_SPELL_CHECK            : return "spell-check";
+    case APPCOMMAND_MIC_ON_OFF_TOGGLE      : return "mic-on-off-toggle";
+    case APPCOMMAND_CORRECTION_LIST        : return "correction-list";
+    case APPCOMMAND_MEDIA_PLAY             : return "media-play";
+    case APPCOMMAND_MEDIA_PAUSE            : return "media-pause";
+    case APPCOMMAND_MEDIA_RECORD           : return "media-record";
+    case APPCOMMAND_MEDIA_FAST_FORWARD     : return "media-fast-forward";
+    case APPCOMMAND_MEDIA_REWIND           : return "media-rewind";
+    case APPCOMMAND_MEDIA_CHANNEL_UP       : return "media-channel-up";
+    case APPCOMMAND_MEDIA_CHANNEL_DOWN     : return "media-channel-down";
+    case APPCOMMAND_DELETE                 : return "delete";
+    case APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE:
+      return "dictate-or-command-control-toggle";
+    default:
+      return "unknown";
+  }
+}
+
+}  // namespace
+
+bool NativeWindowViews::ExecuteWindowsCommand(int command_id) {
+  std::string command = AppCommandToString(command_id);
+  NotifyWindowExecuteWindowsCommand(command);
+  return false;
+}
+
+bool NativeWindowViews::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  NotifyWindowMessage(message, w_param, l_param);
+
+  switch (message) {
+    case WM_COMMAND:
+      // Handle thumbar button click message.
+      if (HIWORD(w_param) == THBN_CLICKED)
+        return taskbar_host_.HandleThumbarButtonEvent(LOWORD(w_param));
+      return false;
+
+    case WM_SIZE:
+      // Handle window state change.
+      HandleSizeEvent(w_param, l_param);
+      return false;
+
+    case WM_MOVING: {
+      if (!movable_)
+        ::GetWindowRect(GetAcceleratedWidget(), (LPRECT)l_param);
+      return false;
+    }
+
+    default:
+      return false;
+  }
+}
+
+void NativeWindowViews::HandleSizeEvent(WPARAM w_param, LPARAM l_param) {
+  // Here we handle the WM_SIZE event in order to figure out what is the current
+  // window state and notify the user accordingly.
+  switch (w_param) {
+    case SIZE_MAXIMIZED:
+      last_window_state_ = ui::SHOW_STATE_MAXIMIZED;
+      NotifyWindowMaximize();
+      break;
+    case SIZE_MINIMIZED:
+      last_window_state_ = ui::SHOW_STATE_MINIMIZED;
+      NotifyWindowMinimize();
+      break;
+    case SIZE_RESTORED:
+      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
+        // Window was resized so we save it's new size.
+        last_normal_size_ = GetSize();
+      } else {
+        switch (last_window_state_) {
+          case ui::SHOW_STATE_MAXIMIZED:
+            last_window_state_ = ui::SHOW_STATE_NORMAL;
+
+            // When the window is restored we resize it to the previous known
+            // normal size.
+            NativeWindow::SetSize(last_normal_size_);
+
+            NotifyWindowUnmaximize();
+            break;
+          case ui::SHOW_STATE_MINIMIZED:
+            if (IsFullscreen()) {
+              last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+              NotifyWindowEnterFullScreen();
+            } else {
+              last_window_state_ = ui::SHOW_STATE_NORMAL;
+
+              // When the window is restored we resize it to the previous known
+              // normal size.
+              NativeWindow::SetSize(last_normal_size_);
+
+              NotifyWindowRestore();
+            }
+            break;
+        }
+      }
+      break;
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 dbeabe15142fd505b5aa9ad2d3d7362876c33bc6 electron/browser/net/asar/asar_protocol_handler.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/asar/asar_protocol_handler.h"
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+
+namespace asar {
+
+AsarProtocolHandler::AsarProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+AsarProtocolHandler::~AsarProtocolHandler() {
+}
+
+net::URLRequestJob* AsarProtocolHandler::MaybeCreateJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  base::FilePath full_path;
+  net::FileURLToFilePath(request->url(), &full_path);
+  URLRequestAsarJob* job = new URLRequestAsarJob(request, network_delegate);
+  job->Initialize(file_task_runner_, full_path);
+  return job;
+}
+
+bool AsarProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace asar
added in remote
  their  100644 98647a56e5a3103524262c947df1ee18d6ac5428 electron/browser/net/asar/asar_protocol_handler.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
+#define ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
+
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace base {
+class TaskRunner;
+}
+
+namespace asar {
+
+class AsarProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit AsarProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  virtual ~AsarProtocolHandler();
+
+  // net::URLRequestJobFactory::ProtocolHandler:
+  net::URLRequestJob* MaybeCreateJob(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  DISALLOW_COPY_AND_ASSIGN(AsarProtocolHandler);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
added in remote
  their  100644 dda5b8fdf29155291fec43494ec2fecd8e2b7ddd electron/browser/net/asar/url_request_asar_job.cc
@@ -0,0 +1,346 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/archive.h"
+#include "electron/common/asar/asar_util.h"
+#include "electron/common/electron_constants.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_status.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace asar {
+
+URLRequestAsarJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequestAsarJob::URLRequestAsarJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate)
+    : net::URLRequestJob(request, network_delegate),
+      type_(TYPE_ERROR),
+      remaining_bytes_(0),
+      range_parse_result_(net::OK),
+      weak_ptr_factory_(this) {}
+
+URLRequestAsarJob::~URLRequestAsarJob() {}
+
+void URLRequestAsarJob::Initialize(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    const base::FilePath& file_path) {
+  // Determine whether it is an asar file.
+  base::FilePath asar_path, relative_path;
+  if (!GetAsarArchivePath(file_path, &asar_path, &relative_path)) {
+    InitializeFileJob(file_task_runner, file_path);
+    return;
+  }
+
+  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
+  Archive::FileInfo file_info;
+  if (!archive || !archive->GetFileInfo(relative_path, &file_info)) {
+    type_ = TYPE_ERROR;
+    return;
+  }
+
+  if (file_info.unpacked) {
+    base::FilePath real_path;
+    archive->CopyFileOut(relative_path, &real_path);
+    InitializeFileJob(file_task_runner, real_path);
+    return;
+  }
+
+  InitializeAsarJob(file_task_runner, archive, relative_path, file_info);
+}
+
+void URLRequestAsarJob::InitializeAsarJob(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    std::shared_ptr<Archive> archive,
+    const base::FilePath& file_path,
+    const Archive::FileInfo& file_info) {
+  type_ = TYPE_ASAR;
+  file_task_runner_ = file_task_runner;
+  stream_.reset(new net::FileStream(file_task_runner_));
+  archive_ = archive;
+  file_path_ = file_path;
+  file_info_ = file_info;
+}
+
+void URLRequestAsarJob::InitializeFileJob(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    const base::FilePath& file_path) {
+  type_ = TYPE_FILE;
+  file_task_runner_ = file_task_runner;
+  stream_.reset(new net::FileStream(file_task_runner_));
+  file_path_ = file_path;
+}
+
+void URLRequestAsarJob::Start() {
+  if (type_ == TYPE_ASAR) {
+    remaining_bytes_ = static_cast<int64_t>(file_info_.size);
+
+    int flags = base::File::FLAG_OPEN |
+                base::File::FLAG_READ |
+                base::File::FLAG_ASYNC;
+    int rv = stream_->Open(archive_->path(), flags,
+                           base::Bind(&URLRequestAsarJob::DidOpen,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != net::ERR_IO_PENDING)
+      DidOpen(rv);
+  } else if (type_ == TYPE_FILE) {
+    FileMetaInfo* meta_info = new FileMetaInfo();
+    file_task_runner_->PostTaskAndReply(
+        FROM_HERE,
+        base::Bind(&URLRequestAsarJob::FetchMetaInfo, file_path_,
+                   base::Unretained(meta_info)),
+        base::Bind(&URLRequestAsarJob::DidFetchMetaInfo,
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(meta_info)));
+  } else {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_FILE_NOT_FOUND));
+  }
+}
+
+void URLRequestAsarJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+int URLRequestAsarJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size)
+    return 0;
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestAsarJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  return rv;
+}
+
+bool URLRequestAsarJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (type_ != TYPE_FILE)
+    return false;
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!base::LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = net::FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+net::Filter* URLRequestAsarJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return base::LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? net::Filter::GZipFactory() : NULL;
+}
+
+bool URLRequestAsarJob::GetMimeType(std::string* mime_type) const {
+  if (type_ == TYPE_ASAR) {
+    return net::GetMimeTypeFromFile(file_path_, mime_type);
+  } else {
+    if (meta_info_.mime_type_result) {
+      *mime_type = meta_info_.mime_type;
+      return true;
+    }
+    return false;
+  }
+}
+
+void URLRequestAsarJob::SetExtraRequestHeaders(
+    const net::HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(net::HttpRequestHeaders::kRange, &range_header)) {
+    // This job only cares about the Range header. This method stashes the value
+    // for later use in DidOpen(), which is responsible for some of the range
+    // validation as well. NotifyStartError is not legal to call here since
+    // the job has not started.
+    std::vector<net::HttpByteRange> ranges;
+    if (net::HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        range_parse_result_ = net::ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+      }
+    }
+  }
+}
+
+int URLRequestAsarJob::GetResponseCode() const {
+  // Request Job gets created only if path exists.
+  return 200;
+}
+
+void URLRequestAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(electron::kCORSHeader);
+  info->headers = headers;
+}
+
+void URLRequestAsarJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result =
+      net::GetMimeTypeFromFile(file_path, &meta_info->mime_type);
+}
+
+void URLRequestAsarJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+  if (!meta_info_.file_exists || meta_info_.is_directory) {
+    DidOpen(net::ERR_FILE_NOT_FOUND);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestAsarJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != net::ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestAsarJob::DidOpen(int result) {
+  if (result != net::OK) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           result));
+    return;
+  }
+
+  if (range_parse_result_ != net::OK) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           range_parse_result_));
+    return;
+  }
+
+  if (type_ == TYPE_ASAR) {
+    int rv = stream_->Seek(file_info_.offset,
+                           base::Bind(&URLRequestAsarJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != net::ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+
+    remaining_bytes_ = byte_range_.last_byte_position() -
+                       byte_range_.first_byte_position() + 1;
+
+    if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+      int rv = stream_->Seek(byte_range_.first_byte_position(),
+                             base::Bind(&URLRequestAsarJob::DidSeek,
+                                        weak_ptr_factory_.GetWeakPtr()));
+      if (rv != net::ERR_IO_PENDING) {
+        // stream_->Seek() failed, so pass an intentionally erroneous value
+        // into DidSeek().
+        DidSeek(-1);
+      }
+    } else {
+      // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+      // the value that would mean seek success. This way we skip the code
+      // handling seek failure.
+      DidSeek(byte_range_.first_byte_position());
+    }
+  }
+}
+
+void URLRequestAsarJob::DidSeek(int64_t result) {
+  if (type_ == TYPE_ASAR) {
+    if (result != static_cast<int64_t>(file_info_.offset)) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+  } else {
+    if (result != byte_range_.first_byte_position()) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+  }
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequestAsarJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result >= 0) {
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  buf = NULL;
+
+  ReadRawDataComplete(result);
+}
+
+}  // namespace asar
added in remote
  their  100644 e4c5320cf4d68838c136d0f94bd84ecaab373a39 electron/browser/net/asar/url_request_asar_job.h
@@ -0,0 +1,131 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
+#define ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
+
+#include <memory>
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "electron/common/asar/archive.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+class FileStream;
+}
+
+namespace asar {
+
+// Createa a request job according to the file path.
+net::URLRequestJob* CreateJobFromPath(
+    const base::FilePath& full_path,
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate,
+    const scoped_refptr<base::TaskRunner> file_task_runner);
+
+class URLRequestAsarJob : public net::URLRequestJob {
+ public:
+  URLRequestAsarJob(net::URLRequest* request,
+                    net::NetworkDelegate* network_delegate);
+
+  void Initialize(const scoped_refptr<base::TaskRunner> file_task_runner,
+                  const base::FilePath& file_path);
+
+ protected:
+  virtual ~URLRequestAsarJob();
+
+  void InitializeAsarJob(const scoped_refptr<base::TaskRunner> file_task_runner,
+                         std::shared_ptr<Archive> archive,
+                         const base::FilePath& file_path,
+                         const Archive::FileInfo& file_info);
+  void InitializeFileJob(const scoped_refptr<base::TaskRunner> file_task_runner,
+                         const base::FilePath& file_path);
+
+  // net::URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  net::Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const net::HttpRequestHeaders& headers) override;
+  int GetResponseCode() const override;
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestFileJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64_t file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64_t result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  // The type of this job.
+  enum JobType {
+    TYPE_ERROR,
+    TYPE_ASAR,
+    TYPE_FILE,
+  };
+  JobType type_;
+
+  std::shared_ptr<Archive> archive_;
+  base::FilePath file_path_;
+  Archive::FileInfo file_info_;
+
+  scoped_ptr<net::FileStream> stream_;
+  FileMetaInfo meta_info_;
+  scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  net::HttpByteRange byte_range_;
+  int64_t remaining_bytes_;
+
+  net::Error range_parse_result_;
+
+  base::WeakPtrFactory<URLRequestAsarJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestAsarJob);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
added in remote
  their  100644 be5e2e2104c73c4e918ffac8046f6c2bd38fe2ec electron/browser/net/electron_cert_verifier.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_cert_verifier.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/net_errors.h"
+#include "net/cert/crl_set.h"
+#include "net/cert/x509_certificate.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+void OnResult(
+    net::CertVerifyResult* verify_result,
+    const net::CompletionCallback& callback,
+    bool result) {
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(callback, result ? net::OK : net::ERR_FAILED));
+}
+
+}  // namespace
+
+ElectronCertVerifier::ElectronCertVerifier()
+    : default_cert_verifier_(net::CertVerifier::CreateDefault()) {
+}
+
+ElectronCertVerifier::~ElectronCertVerifier() {
+}
+
+void ElectronCertVerifier::SetVerifyProc(const VerifyProc& proc) {
+  base::AutoLock auto_lock(lock_);
+  verify_proc_ = proc;
+}
+
+int ElectronCertVerifier::Verify(
+    net::X509Certificate* cert,
+    const std::string& hostname,
+    const std::string& ocsp_response,
+    int flags,
+    net::CRLSet* crl_set,
+    net::CertVerifyResult* verify_result,
+    const net::CompletionCallback& callback,
+    scoped_ptr<Request>* out_req,
+    const net::BoundNetLog& net_log) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  VerifyProc proc;
+  {
+    base::AutoLock auto_lock(lock_);
+    proc = verify_proc_;
+  }
+
+  if (proc.is_null())
+    return default_cert_verifier_->Verify(
+        cert, hostname, ocsp_response, flags, crl_set, verify_result, callback,
+        out_req, net_log);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(proc, hostname, make_scoped_refptr(cert),
+                 base::Bind(OnResult, verify_result, callback)));
+  return net::ERR_IO_PENDING;
+}
+
+bool ElectronCertVerifier::SupportsOCSPStapling() {
+  return true;
+}
+
+}  // namespace electron
added in remote
  their  100644 34343f3e5c717c052c0b176e7e502eee0e44325c electron/browser/net/electron_cert_verifier.h
@@ -0,0 +1,51 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
+
+#include <string>
+
+#include "base/memory/ref_counted.h"
+#include "base/synchronization/lock.h"
+#include "net/cert/cert_verifier.h"
+
+namespace electron {
+
+class ElectronCertVerifier : public net::CertVerifier {
+ public:
+  ElectronCertVerifier();
+  virtual ~ElectronCertVerifier();
+
+  using VerifyProc =
+      base::Callback<void(const std::string& hostname,
+                          scoped_refptr<net::X509Certificate>,
+                          const base::Callback<void(bool)>&)>;
+
+  void SetVerifyProc(const VerifyProc& proc);
+
+ protected:
+  // net::CertVerifier:
+  int Verify(net::X509Certificate* cert,
+             const std::string& hostname,
+             const std::string& ocsp_response,
+             int flags,
+             net::CRLSet* crl_set,
+             net::CertVerifyResult* verify_result,
+             const net::CompletionCallback& callback,
+             scoped_ptr<Request>* out_req,
+             const net::BoundNetLog& net_log) override;
+  bool SupportsOCSPStapling() override;
+
+ private:
+  base::Lock lock_;
+  VerifyProc verify_proc_;
+  scoped_ptr<net::CertVerifier> default_cert_verifier_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronCertVerifier);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
added in remote
  their  100644 e6aa9d5e15cd40ad614c2c9d706b167d54a6513b electron/browser/net/electron_network_delegate.cc
@@ -0,0 +1,401 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_network_delegate.h"
+
+#include <string>
+
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+const char* ResourceTypeToString(content::ResourceType type) {
+  switch (type) {
+    case content::RESOURCE_TYPE_MAIN_FRAME:
+      return "mainFrame";
+    case content::RESOURCE_TYPE_SUB_FRAME:
+      return "subFrame";
+    case content::RESOURCE_TYPE_STYLESHEET:
+      return "stylesheet";
+    case content::RESOURCE_TYPE_SCRIPT:
+      return "script";
+    case content::RESOURCE_TYPE_IMAGE:
+      return "image";
+    case content::RESOURCE_TYPE_OBJECT:
+      return "object";
+    case content::RESOURCE_TYPE_XHR:
+      return "xhr";
+    default:
+      return "other";
+  }
+}
+
+void RunSimpleListener(const ElectronNetworkDelegate::SimpleListener& listener,
+                       scoped_ptr<base::DictionaryValue> details) {
+  return listener.Run(*(details.get()));
+}
+
+void RunResponseListener(
+    const ElectronNetworkDelegate::ResponseListener& listener,
+    scoped_ptr<base::DictionaryValue> details,
+    const ElectronNetworkDelegate::ResponseCallback& callback) {
+  return listener.Run(*(details.get()), callback);
+}
+
+// Test whether the URL of |request| matches |patterns|.
+bool MatchesFilterCondition(net::URLRequest* request,
+                            const URLPatterns& patterns) {
+  if (patterns.empty())
+    return true;
+
+  for (const auto& pattern : patterns) {
+    if (pattern.MatchesURL(request->url()))
+      return true;
+  }
+  return false;
+}
+
+// Overloaded by multiple types to fill the |details| object.
+void ToDictionary(base::DictionaryValue* details, net::URLRequest* request) {
+  details->SetInteger("id", request->identifier());
+  details->SetString("url", request->url().spec());
+  details->SetString("method", request->method());
+  details->SetDouble("timestamp", base::Time::Now().ToDoubleT() * 1000);
+  auto info = content::ResourceRequestInfo::ForRequest(request);
+  details->SetString("resourceType",
+                     info ? ResourceTypeToString(info->GetResourceType())
+                          : "other");
+  scoped_ptr<base::ListValue> list(new base::ListValue);
+  GetUploadData(list.get(), request);
+  if (!list->empty())
+    details->Set("uploadData", std::move(list));
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HttpRequestHeaders& headers) {
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  net::HttpRequestHeaders::Iterator it(headers);
+  while (it.GetNext())
+    dict->SetString(it.name(), it.value());
+  details->Set("requestHeaders", std::move(dict));
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HttpResponseHeaders* headers) {
+  if (!headers)
+    return;
+
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  void* iter = nullptr;
+  std::string key;
+  std::string value;
+  while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
+    if (dict->HasKey(key)) {
+      base::ListValue* values = nullptr;
+      if (dict->GetList(key, &values))
+        values->AppendString(value);
+    } else {
+      scoped_ptr<base::ListValue> values(new base::ListValue);
+      values->AppendString(value);
+      dict->Set(key, std::move(values));
+    }
+  }
+  details->Set("responseHeaders", std::move(dict));
+  details->SetString("statusLine", headers->GetStatusLine());
+  details->SetInteger("statusCode", headers->response_code());
+}
+
+void ToDictionary(base::DictionaryValue* details, const GURL& location) {
+  details->SetString("redirectURL", location.spec());
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HostPortPair& host_port) {
+  if (host_port.host().empty())
+    details->SetString("ip", host_port.host());
+}
+
+void ToDictionary(base::DictionaryValue* details, bool from_cache) {
+  details->SetBoolean("fromCache", from_cache);
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::URLRequestStatus& status) {
+  details->SetString("error", net::ErrorToString(status.error()));
+}
+
+// Helper function to fill |details| with arbitrary |args|.
+template<typename Arg>
+void FillDetailsObject(base::DictionaryValue* details, Arg arg) {
+  ToDictionary(details, arg);
+}
+
+template<typename Arg, typename... Args>
+void FillDetailsObject(base::DictionaryValue* details, Arg arg, Args... args) {
+  ToDictionary(details, arg);
+  FillDetailsObject(details, args...);
+}
+
+// Fill the native types with the result from the response object.
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            GURL* new_location) {
+  std::string url;
+  if (response.GetString("redirectURL", &url))
+    *new_location = GURL(url);
+}
+
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            net::HttpRequestHeaders* headers) {
+  const base::DictionaryValue* dict;
+  if (response.GetDictionary("requestHeaders", &dict)) {
+    headers->Clear();
+    for (base::DictionaryValue::Iterator it(*dict);
+         !it.IsAtEnd();
+         it.Advance()) {
+      std::string value;
+      if (it.value().GetAsString(&value))
+        headers->SetHeader(it.key(), value);
+    }
+  }
+}
+
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            scoped_refptr<net::HttpResponseHeaders>* headers) {
+  const base::DictionaryValue* dict;
+  if (response.GetDictionary("responseHeaders", &dict)) {
+    *headers = new net::HttpResponseHeaders("");
+    for (base::DictionaryValue::Iterator it(*dict);
+         !it.IsAtEnd();
+         it.Advance()) {
+      const base::ListValue* list;
+      if (it.value().GetAsList(&list)) {
+        (*headers)->RemoveHeader(it.key());
+        for (size_t i = 0; i < list->GetSize(); ++i) {
+          std::string value;
+          if (list->GetString(i, &value))
+            (*headers)->AddHeader(it.key() + " : " + value);
+        }
+      }
+    }
+  }
+}
+
+}  // namespace
+
+ElectronNetworkDelegate::ElectronNetworkDelegate() {
+}
+
+ElectronNetworkDelegate::~ElectronNetworkDelegate() {
+}
+
+void ElectronNetworkDelegate::SetSimpleListenerInIO(
+    SimpleEvent type,
+    const URLPatterns& patterns,
+    const SimpleListener& callback) {
+  if (callback.is_null())
+    simple_listeners_.erase(type);
+  else
+    simple_listeners_[type] = { patterns, callback };
+}
+
+void ElectronNetworkDelegate::SetResponseListenerInIO(
+    ResponseEvent type,
+    const URLPatterns& patterns,
+    const ResponseListener& callback) {
+  if (callback.is_null())
+    response_listeners_.erase(type);
+  else
+    response_listeners_[type] = { patterns, callback };
+}
+
+int ElectronNetworkDelegate::OnBeforeURLRequest(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    GURL* new_url) {
+  if (!ContainsKey(response_listeners_, kOnBeforeRequest))
+    return brightray::NetworkDelegate::OnBeforeURLRequest(
+        request, callback, new_url);
+
+  return HandleResponseEvent(kOnBeforeRequest, request, callback, new_url);
+}
+
+int ElectronNetworkDelegate::OnBeforeSendHeaders(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    net::HttpRequestHeaders* headers) {
+  if (!ContainsKey(response_listeners_, kOnBeforeSendHeaders))
+    return brightray::NetworkDelegate::OnBeforeSendHeaders(
+        request, callback, headers);
+
+  return HandleResponseEvent(
+      kOnBeforeSendHeaders, request, callback, headers, *headers);
+}
+
+void ElectronNetworkDelegate::OnSendHeaders(
+    net::URLRequest* request,
+    const net::HttpRequestHeaders& headers) {
+  if (!ContainsKey(simple_listeners_, kOnSendHeaders)) {
+    brightray::NetworkDelegate::OnSendHeaders(request, headers);
+    return;
+  }
+
+  HandleSimpleEvent(kOnSendHeaders, request, headers);
+}
+
+int ElectronNetworkDelegate::OnHeadersReceived(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    const net::HttpResponseHeaders* original,
+    scoped_refptr<net::HttpResponseHeaders>* override,
+    GURL* allowed) {
+  if (!ContainsKey(response_listeners_, kOnHeadersReceived))
+    return brightray::NetworkDelegate::OnHeadersReceived(
+        request, callback, original, override, allowed);
+
+  return HandleResponseEvent(
+      kOnHeadersReceived, request, callback, override, original);
+}
+
+void ElectronNetworkDelegate::OnBeforeRedirect(net::URLRequest* request,
+                                           const GURL& new_location) {
+  if (!ContainsKey(simple_listeners_, kOnBeforeRedirect)) {
+    brightray::NetworkDelegate::OnBeforeRedirect(request, new_location);
+    return;
+  }
+
+  HandleSimpleEvent(kOnBeforeRedirect, request, new_location,
+                    request->response_headers(), request->GetSocketAddress(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnResponseStarted(net::URLRequest* request) {
+  if (!ContainsKey(simple_listeners_, kOnResponseStarted)) {
+    brightray::NetworkDelegate::OnResponseStarted(request);
+    return;
+  }
+
+  if (request->status().status() != net::URLRequestStatus::SUCCESS)
+    return;
+
+  HandleSimpleEvent(kOnResponseStarted, request, request->response_headers(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnCompleted(net::URLRequest* request, bool started) {
+  // OnCompleted may happen before other events.
+  callbacks_.erase(request->identifier());
+
+  if (request->status().status() == net::URLRequestStatus::FAILED ||
+      request->status().status() == net::URLRequestStatus::CANCELED) {
+    // Error event.
+    OnErrorOccurred(request, started);
+    return;
+  } else if (request->response_headers() &&
+             net::HttpResponseHeaders::IsRedirectResponseCode(
+                 request->response_headers()->response_code())) {
+    // Redirect event.
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  if (!ContainsKey(simple_listeners_, kOnCompleted)) {
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  HandleSimpleEvent(kOnCompleted, request, request->response_headers(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnURLRequestDestroyed(net::URLRequest* request) {
+  callbacks_.erase(request->identifier());
+}
+
+void ElectronNetworkDelegate::OnErrorOccurred(
+    net::URLRequest* request, bool started) {
+  if (!ContainsKey(simple_listeners_, kOnErrorOccurred)) {
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
+                    request->status());
+}
+
+template<typename Out, typename... Args>
+int ElectronNetworkDelegate::HandleResponseEvent(
+    ResponseEvent type,
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    Out out,
+    Args... args) {
+  const auto& info = response_listeners_[type];
+  if (!MatchesFilterCondition(request, info.url_patterns))
+    return net::OK;
+
+  scoped_ptr<base::DictionaryValue> details(new base::DictionaryValue);
+  FillDetailsObject(details.get(), request, args...);
+
+  // The |request| could be destroyed before the |callback| is called.
+  callbacks_[request->identifier()] = callback;
+
+  ResponseCallback response =
+      base::Bind(&ElectronNetworkDelegate::OnListenerResultInUI<Out>,
+                 base::Unretained(this), request->identifier(), out);
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(RunResponseListener, info.listener, base::Passed(&details),
+                 response));
+  return net::ERR_IO_PENDING;
+}
+
+template<typename...Args>
+void ElectronNetworkDelegate::HandleSimpleEvent(
+    SimpleEvent type, net::URLRequest* request, Args... args) {
+  const auto& info = simple_listeners_[type];
+  if (!MatchesFilterCondition(request, info.url_patterns))
+    return;
+
+  scoped_ptr<base::DictionaryValue> details(new base::DictionaryValue);
+  FillDetailsObject(details.get(), request, args...);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(RunSimpleListener, info.listener, base::Passed(&details)));
+}
+
+template<typename T>
+void ElectronNetworkDelegate::OnListenerResultInIO(
+    uint64_t id, T out, scoped_ptr<base::DictionaryValue> response) {
+  // The request has been destroyed.
+  if (!ContainsKey(callbacks_, id))
+    return;
+
+  ReadFromResponseObject(*response.get(), out);
+
+  bool cancel = false;
+  response->GetBoolean("cancel", &cancel);
+  callbacks_[id].Run(cancel ? net::ERR_BLOCKED_BY_CLIENT : net::OK);
+}
+
+template<typename T>
+void ElectronNetworkDelegate::OnListenerResultInUI(
+    uint64_t id, T out, const base::DictionaryValue& response) {
+  scoped_ptr<base::DictionaryValue> copy = response.CreateDeepCopy();
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&ElectronNetworkDelegate::OnListenerResultInIO<T>,
+                 base::Unretained(this),  id, out, base::Passed(&copy)));
+}
+
+}  // namespace electron
added in remote
  their  100644 89f4290145df57e14d6e01a6654c8b294da7e644 electron/browser/net/electron_network_delegate.h
@@ -0,0 +1,121 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
+
+#include <map>
+#include <set>
+
+#include "brightray/browser/network_delegate.h"
+#include "base/callback.h"
+#include "base/values.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_request_headers.h"
+#include "net/http/http_response_headers.h"
+
+namespace extensions {
+class URLPattern;
+}
+
+namespace electron {
+
+using URLPatterns = std::set<extensions::URLPattern>;
+
+class ElectronNetworkDelegate : public brightray::NetworkDelegate {
+ public:
+  using ResponseCallback = base::Callback<void(const base::DictionaryValue&)>;
+  using SimpleListener = base::Callback<void(const base::DictionaryValue&)>;
+  using ResponseListener = base::Callback<void(const base::DictionaryValue&,
+                                               const ResponseCallback&)>;
+
+  enum SimpleEvent {
+    kOnSendHeaders,
+    kOnBeforeRedirect,
+    kOnResponseStarted,
+    kOnCompleted,
+    kOnErrorOccurred,
+  };
+
+  enum ResponseEvent {
+    kOnBeforeRequest,
+    kOnBeforeSendHeaders,
+    kOnHeadersReceived,
+  };
+
+  struct SimpleListenerInfo {
+    URLPatterns url_patterns;
+    SimpleListener listener;
+  };
+
+  struct ResponseListenerInfo {
+    URLPatterns url_patterns;
+    ResponseListener listener;
+  };
+
+  ElectronNetworkDelegate();
+  ~ElectronNetworkDelegate() override;
+
+  void SetSimpleListenerInIO(SimpleEvent type,
+                             const URLPatterns& patterns,
+                             const SimpleListener& callback);
+  void SetResponseListenerInIO(ResponseEvent type,
+                               const URLPatterns& patterns,
+                               const ResponseListener& callback);
+
+ protected:
+  // net::NetworkDelegate:
+  int OnBeforeURLRequest(net::URLRequest* request,
+                         const net::CompletionCallback& callback,
+                         GURL* new_url) override;
+  int OnBeforeSendHeaders(net::URLRequest* request,
+                          const net::CompletionCallback& callback,
+                          net::HttpRequestHeaders* headers) override;
+  void OnSendHeaders(net::URLRequest* request,
+                     const net::HttpRequestHeaders& headers) override;
+  int OnHeadersReceived(
+      net::URLRequest* request,
+      const net::CompletionCallback& callback,
+      const net::HttpResponseHeaders* original_response_headers,
+      scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
+      GURL* allowed_unsafe_redirect_url) override;
+  void OnBeforeRedirect(net::URLRequest* request,
+                        const GURL& new_location) override;
+  void OnResponseStarted(net::URLRequest* request) override;
+  void OnCompleted(net::URLRequest* request, bool started) override;
+  void OnURLRequestDestroyed(net::URLRequest* request) override;
+
+ private:
+  void OnErrorOccurred(net::URLRequest* request, bool started);
+
+  template<typename...Args>
+  void HandleSimpleEvent(SimpleEvent type,
+                         net::URLRequest* request,
+                         Args... args);
+  template<typename Out, typename... Args>
+  int HandleResponseEvent(ResponseEvent type,
+                          net::URLRequest* request,
+                          const net::CompletionCallback& callback,
+                          Out out,
+                          Args... args);
+
+  // Deal with the results of Listener.
+  template<typename T>
+  void OnListenerResultInIO(
+      uint64_t id, T out, scoped_ptr<base::DictionaryValue> response);
+  template<typename T>
+  void OnListenerResultInUI(
+      uint64_t id, T out, const base::DictionaryValue& response);
+
+  std::map<SimpleEvent, SimpleListenerInfo> simple_listeners_;
+  std::map<ResponseEvent, ResponseListenerInfo> response_listeners_;
+  std::map<uint64_t, net::CompletionCallback> callbacks_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronNetworkDelegate);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
added in remote
  their  100644 a07f31caa209bdf91d30d0d629aba525a18574a0 electron/browser/net/electron_ssl_config_service.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_ssl_config_service.h"
+
+#include <string>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/strings/string_split.h"
+#include "electron/common/options_switches.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/socket/ssl_client_socket.h"
+#include "net/ssl/ssl_cipher_suite_names.h"
+
+namespace electron {
+
+namespace {
+
+uint16_t GetSSLProtocolVersion(const std::string& version_string) {
+  uint16_t version = 0;  // Invalid
+  if (version_string == "tls1")
+    version = net::SSL_PROTOCOL_VERSION_TLS1;
+  else if (version_string == "tls1.1")
+    version = net::SSL_PROTOCOL_VERSION_TLS1_1;
+  else if (version_string == "tls1.2")
+    version = net::SSL_PROTOCOL_VERSION_TLS1_2;
+  return version;
+}
+
+std::vector<uint16_t> ParseCipherSuites(
+    const std::vector<std::string>& cipher_strings) {
+  std::vector<uint16_t> cipher_suites;
+  cipher_suites.reserve(cipher_strings.size());
+
+  for (auto& cipher_string : cipher_strings) {
+    uint16_t cipher_suite = 0;
+    if (!net::ParseSSLCipherString(cipher_string, &cipher_suite)) {
+      LOG(ERROR) << "Ignoring unrecognised cipher suite : "
+                 << cipher_string;
+      continue;
+    }
+    cipher_suites.push_back(cipher_suite);
+  }
+  return cipher_suites;
+}
+
+}  // namespace
+
+ElectronSSLConfigService::ElectronSSLConfigService() {
+  auto cmd_line = base::CommandLine::ForCurrentProcess();
+  if (cmd_line->HasSwitch(switches::kSSLVersionFallbackMin)) {
+    auto version_string =
+        cmd_line->GetSwitchValueASCII(switches::kSSLVersionFallbackMin);
+    config_.version_fallback_min = GetSSLProtocolVersion(version_string);
+  }
+
+  if (cmd_line->HasSwitch(switches::kCipherSuiteBlacklist)) {
+    auto cipher_strings = base::SplitString(
+        cmd_line->GetSwitchValueASCII(switches::kCipherSuiteBlacklist),
+        ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+    config_.disabled_cipher_suites = ParseCipherSuites(cipher_strings);
+  }
+}
+
+ElectronSSLConfigService::~ElectronSSLConfigService() {
+}
+
+void ElectronSSLConfigService::GetSSLConfig(net::SSLConfig* config) {
+  *config = config_;
+}
+
+}  // namespace electron
added in remote
  their  100644 4f96936754b74b63d7aec53ce7ba2aedde285b3e electron/browser/net/electron_ssl_config_service.h
@@ -0,0 +1,28 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
+
+#include "net/ssl/ssl_config_service.h"
+
+namespace electron {
+
+class ElectronSSLConfigService : public net::SSLConfigService {
+ public:
+  ElectronSSLConfigService();
+  ~ElectronSSLConfigService() override;
+
+  // net::SSLConfigService:
+  void GetSSLConfig(net::SSLConfig* config) override;
+
+ private:
+  net::SSLConfig config_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronSSLConfigService);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
added in remote
  their  100644 10e3b93de7b8059c9b688732b031697f47186dfe electron/browser/net/electron_url_request_job_factory.cc
@@ -0,0 +1,113 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_url_request_job_factory.h"
+
+#include "base/stl_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/load_flags.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+typedef net::URLRequestJobFactory::ProtocolHandler ProtocolHandler;
+
+ElectronURLRequestJobFactory::ElectronURLRequestJobFactory() {}
+
+ElectronURLRequestJobFactory::~ElectronURLRequestJobFactory() {
+  STLDeleteValues(&protocol_handler_map_);
+}
+
+bool ElectronURLRequestJobFactory::SetProtocolHandler(
+    const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler) {
+  if (!protocol_handler) {
+    ProtocolHandlerMap::iterator it = protocol_handler_map_.find(scheme);
+    if (it == protocol_handler_map_.end())
+      return false;
+
+    delete it->second;
+    protocol_handler_map_.erase(it);
+    return true;
+  }
+
+  if (ContainsKey(protocol_handler_map_, scheme))
+    return false;
+  protocol_handler_map_[scheme] = protocol_handler.release();
+  return true;
+}
+
+scoped_ptr<ProtocolHandler> ElectronURLRequestJobFactory::ReplaceProtocol(
+    const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler) {
+  if (!ContainsKey(protocol_handler_map_, scheme))
+    return nullptr;
+  ProtocolHandler* original_protocol_handler = protocol_handler_map_[scheme];
+  protocol_handler_map_[scheme] = protocol_handler.release();
+  return make_scoped_ptr(original_protocol_handler);
+}
+
+ProtocolHandler* ElectronURLRequestJobFactory::GetProtocolHandler(
+    const std::string& scheme) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  ProtocolHandlerMap::const_iterator it = protocol_handler_map_.find(scheme);
+  if (it == protocol_handler_map_.end())
+    return nullptr;
+  return it->second;
+}
+
+bool ElectronURLRequestJobFactory::HasProtocolHandler(
+    const std::string& scheme) const {
+  return ContainsKey(protocol_handler_map_, scheme);
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeCreateJobWithProtocolHandler(
+    const std::string& scheme,
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  ProtocolHandlerMap::const_iterator it = protocol_handler_map_.find(scheme);
+  if (it == protocol_handler_map_.end())
+    return nullptr;
+  return it->second->MaybeCreateJob(request, network_delegate);
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeInterceptRedirect(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate,
+    const GURL& location) const {
+  return nullptr;
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeInterceptResponse(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  return nullptr;
+}
+
+bool ElectronURLRequestJobFactory::IsHandledProtocol(
+    const std::string& scheme) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  return HasProtocolHandler(scheme) ||
+      net::URLRequest::IsHandledProtocol(scheme);
+}
+
+bool ElectronURLRequestJobFactory::IsHandledURL(const GURL& url) const {
+  if (!url.is_valid()) {
+    // We handle error cases.
+    return true;
+  }
+  return IsHandledProtocol(url.scheme());
+}
+
+bool ElectronURLRequestJobFactory::IsSafeRedirectTarget(
+    const GURL& location) const {
+  return IsHandledURL(location);
+}
+
+}  // namespace electron
added in remote
  their  100644 4623e6c94cb5adb130f08efb27dc22366255e9ca electron/browser/net/electron_url_request_job_factory.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "base/synchronization/lock.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace electron {
+
+class ElectronURLRequestJobFactory : public net::URLRequestJobFactory {
+ public:
+  ElectronURLRequestJobFactory();
+  virtual ~ElectronURLRequestJobFactory();
+
+  // Sets the ProtocolHandler for a scheme. Returns true on success, false on
+  // failure (a ProtocolHandler already exists for |scheme|). On success,
+  // URLRequestJobFactory takes ownership of |protocol_handler|.
+  bool SetProtocolHandler(
+      const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler);
+
+  // Intercepts the ProtocolHandler for a scheme. Returns the original protocol
+  // handler on success, otherwise returns NULL.
+  scoped_ptr<ProtocolHandler> ReplaceProtocol(
+      const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler);
+
+  // Returns the protocol handler registered with scheme.
+  ProtocolHandler* GetProtocolHandler(const std::string& scheme) const;
+
+  // Whether the protocol handler is registered by the job factory.
+  bool HasProtocolHandler(const std::string& scheme) const;
+
+  // URLRequestJobFactory implementation
+  net::URLRequestJob* MaybeCreateJobWithProtocolHandler(
+      const std::string& scheme,
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  net::URLRequestJob* MaybeInterceptRedirect(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate,
+      const GURL& location) const override;
+  net::URLRequestJob* MaybeInterceptResponse(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  bool IsHandledProtocol(const std::string& scheme) const override;
+  bool IsHandledURL(const GURL& url) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  using ProtocolHandlerMap = std::map<std::string, ProtocolHandler*>;
+
+  ProtocolHandlerMap protocol_handler_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronURLRequestJobFactory);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
added in remote
  their  100644 0425364c7ce4ed92960d77c7b9772351494dd4b4 electron/browser/net/http_protocol_handler.cc
@@ -0,0 +1,26 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/http_protocol_handler.h"
+
+#include "net/url_request/url_request_http_job.h"
+
+namespace electron {
+
+HttpProtocolHandler::HttpProtocolHandler(const std::string& scheme)
+    : scheme_(scheme) {
+}
+
+HttpProtocolHandler::~HttpProtocolHandler() {
+}
+
+net::URLRequestJob* HttpProtocolHandler::MaybeCreateJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  return net::URLRequestHttpJob::Factory(request,
+                                         network_delegate,
+                                         scheme_);
+}
+
+}  // namespace electron
added in remote
  their  100644 570f8fa50fec76f14bd8a70c95b4b70bb7accfc4 electron/browser/net/http_protocol_handler.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
+#define ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
+
+#include <string>
+
+#include "net/url_request/url_request_job_factory.h"
+
+namespace electron {
+
+class HttpProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit HttpProtocolHandler(const std::string&);
+  virtual ~HttpProtocolHandler();
+
+  // net::URLRequestJobFactory::ProtocolHandler:
+  net::URLRequestJob* MaybeCreateJob(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+
+ private:
+  std::string scheme_;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
added in remote
  their  100644 0cad1065961363e23a75a6c1363bb05c298751c4 electron/browser/net/js_asker.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/js_asker.h"
+
+#include <vector>
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+
+namespace electron {
+
+namespace internal {
+
+namespace {
+
+// The callback which is passed to |handler|.
+void HandlerCallback(const BeforeStartCallback& before_start,
+                     const ResponseCallback& callback,
+                     mate::Arguments* args) {
+  // If there is no argument passed then we failed.
+  v8::Local<v8::Value> value;
+  if (!args->GetNext(&value)) {
+    content::BrowserThread::PostTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(callback, false, nullptr));
+    return;
+  }
+
+  // Give the job a chance to parse V8 value.
+  before_start.Run(args->isolate(), value);
+
+  // Pass whatever user passed to the actaul request job.
+  V8ValueConverter converter;
+  v8::Local<v8::Context> context = args->isolate()->GetCurrentContext();
+  scoped_ptr<base::Value> options(converter.FromV8Value(value, context));
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(callback, true, base::Passed(&options)));
+}
+
+}  // namespace
+
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   net::URLRequest* request,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  v8::Locker locker(isolate);
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Context::Scope context_scope(context);
+  handler.Run(
+      request,
+      mate::ConvertToV8(isolate,
+                        base::Bind(&HandlerCallback, before_start, callback)));
+}
+
+bool IsErrorOptions(base::Value* value, int* error) {
+  if (value->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict = static_cast<base::DictionaryValue*>(value);
+    if (dict->GetInteger("error", error))
+      return true;
+  } else if (value->IsType(base::Value::TYPE_INTEGER)) {
+    if (value->GetAsInteger(error))
+      return true;
+  }
+  return false;
+}
+
+}  // namespace internal
+
+}  // namespace electron
added in remote
  their  100644 3d846f25fede7a774ec1aedb53249d7081639a93 electron/browser/net/js_asker.h
@@ -0,0 +1,108 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_JS_ASKER_H_
+#define ELECTRON_BROWSER_NET_JS_ASKER_H_
+
+#include "base/callback.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/values.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "net/url_request/url_request_job.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+using JavaScriptHandler =
+    base::Callback<void(const net::URLRequest*, v8::Local<v8::Value>)>;
+
+namespace internal {
+
+using BeforeStartCallback =
+    base::Callback<void(v8::Isolate*, v8::Local<v8::Value>)>;
+using ResponseCallback =
+    base::Callback<void(bool, scoped_ptr<base::Value> options)>;
+
+// Ask handler for options in UI thread.
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   net::URLRequest* request,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback);
+
+// Test whether the |options| means an error.
+bool IsErrorOptions(base::Value* value, int* error);
+
+}  // namespace internal
+
+template<typename RequestJob>
+class JsAsker : public RequestJob {
+ public:
+  JsAsker(net::URLRequest* request, net::NetworkDelegate* network_delegate)
+      : RequestJob(request, network_delegate), weak_factory_(this) {}
+
+  // Called by |CustomProtocolHandler| to store handler related information.
+  void SetHandlerInfo(
+      v8::Isolate* isolate,
+      net::URLRequestContextGetter* request_context_getter,
+      const JavaScriptHandler& handler) {
+    isolate_ = isolate;
+    request_context_getter_ = request_context_getter;
+    handler_ = handler;
+  }
+
+  // Subclass should do initailze work here.
+  virtual void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) {}
+  virtual void StartAsync(scoped_ptr<base::Value> options) = 0;
+
+  net::URLRequestContextGetter* request_context_getter() const {
+    return request_context_getter_;
+  }
+
+ private:
+  // RequestJob:
+  void Start() override {
+    content::BrowserThread::PostTask(
+        content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&internal::AskForOptions,
+                   isolate_,
+                   handler_,
+                   RequestJob::request(),
+                   base::Bind(&JsAsker::BeforeStartInUI,
+                              weak_factory_.GetWeakPtr()),
+                   base::Bind(&JsAsker::OnResponse,
+                              weak_factory_.GetWeakPtr())));
+  }
+  void GetResponseInfo(net::HttpResponseInfo* info) override {
+    info->headers = new net::HttpResponseHeaders("");
+  }
+
+  // Called when the JS handler has sent the response, we need to decide whether
+  // to start, or fail the job.
+  void OnResponse(bool success, scoped_ptr<base::Value> value) {
+    int error = net::ERR_NOT_IMPLEMENTED;
+    if (success && value && !internal::IsErrorOptions(value.get(), &error)) {
+      StartAsync(std::move(value));
+    } else {
+      RequestJob::NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
+    }
+  }
+
+  v8::Isolate* isolate_;
+  net::URLRequestContextGetter* request_context_getter_;
+  JavaScriptHandler handler_;
+
+  base::WeakPtrFactory<JsAsker> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(JsAsker);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_JS_ASKER_H_
added in remote
  their  100644 fa88add14883ca721355322ede8281dbf5499d9b electron/browser/net/url_request_async_asar_job.cc
@@ -0,0 +1,49 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_async_asar_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+
+namespace electron {
+
+URLRequestAsyncAsarJob::URLRequestAsyncAsarJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate)
+    : JsAsker<asar::URLRequestAsarJob>(request, network_delegate) {
+}
+
+void URLRequestAsyncAsarJob::StartAsync(scoped_ptr<base::Value> options) {
+  base::FilePath::StringType file_path;
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    static_cast<base::DictionaryValue*>(options.get())->GetString(
+        "path", &file_path);
+  } else if (options->IsType(base::Value::TYPE_STRING)) {
+    options->GetAsString(&file_path);
+  }
+
+  if (file_path.empty()) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+  } else {
+    asar::URLRequestAsarJob::Initialize(
+        content::BrowserThread::GetBlockingPool()->
+            GetTaskRunnerWithShutdownBehavior(
+                base::SequencedWorkerPool::SKIP_ON_SHUTDOWN),
+        base::FilePath(file_path));
+    asar::URLRequestAsarJob::Start();
+  }
+}
+
+void URLRequestAsyncAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+  info->headers = headers;
+}
+
+}  // namespace electron
added in remote
  their  100644 ee921c64337d81d28b5b4b37165b753979a5abed electron/browser/net/url_request_async_asar_job.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+#include "electron/browser/net/js_asker.h"
+
+namespace electron {
+
+// Like URLRequestAsarJob, but asks the JavaScript handler for file path.
+class URLRequestAsyncAsarJob : public JsAsker<asar::URLRequestAsarJob> {
+ public:
+  URLRequestAsyncAsarJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(URLRequestAsyncAsarJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
added in remote
  their  100644 56a1b94b1f82b724b33a67d669a3a690bf4d5b3a electron/browser/net/url_request_buffer_job.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_buffer_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+#include "base/strings/string_number_conversions.h"
+#include "net/base/net_errors.h"
+
+namespace electron {
+
+URLRequestBufferJob::URLRequestBufferJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate),
+      status_code_(net::HTTP_NOT_IMPLEMENTED) {
+}
+
+void URLRequestBufferJob::StartAsync(scoped_ptr<base::Value> options) {
+  const base::BinaryValue* binary = nullptr;
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict =
+        static_cast<base::DictionaryValue*>(options.get());
+    dict->GetString("mimeType", &mime_type_);
+    dict->GetString("charset", &charset_);
+    dict->GetBinary("data", &binary);
+  } else if (options->IsType(base::Value::TYPE_BINARY)) {
+    options->GetAsBinary(&binary);
+  }
+
+  if (!binary) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+    return;
+  }
+
+  data_ = new base::RefCountedBytes(
+      reinterpret_cast<const unsigned char*>(binary->GetBuffer()),
+      binary->GetSize());
+  status_code_ = net::HTTP_OK;
+  net::URLRequestSimpleJob::Start();
+}
+
+void URLRequestBufferJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 ");
+  status.append(base::IntToString(status_code_));
+  status.append(" ");
+  status.append(net::GetHttpReasonPhrase(status_code_));
+  status.append("\0\0", 2);
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+
+  if (!mime_type_.empty()) {
+    std::string content_type_header(net::HttpRequestHeaders::kContentType);
+    content_type_header.append(": ");
+    content_type_header.append(mime_type_);
+    headers->AddHeader(content_type_header);
+  }
+
+  info->headers = headers;
+}
+
+int URLRequestBufferJob::GetRefCountedData(
+    std::string* mime_type,
+    std::string* charset,
+    scoped_refptr<base::RefCountedMemory>* data,
+    const net::CompletionCallback& callback) const {
+  *mime_type = mime_type_;
+  *charset = charset_;
+  *data = data_;
+  return net::OK;
+}
+
+}  // namespace electron
added in remote
  their  100644 0868cb64f43aa61bb082dfde76894ff8211321b1 electron/browser/net/url_request_buffer_job.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "base/memory/ref_counted_memory.h"
+#include "net/http/http_status_code.h"
+#include "net/url_request/url_request_simple_job.h"
+
+namespace electron {
+
+class URLRequestBufferJob : public JsAsker<net::URLRequestSimpleJob> {
+ public:
+  URLRequestBufferJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+  // URLRequestSimpleJob:
+  int GetRefCountedData(std::string* mime_type,
+                        std::string* charset,
+                        scoped_refptr<base::RefCountedMemory>* data,
+                        const net::CompletionCallback& callback) const override;
+
+ private:
+  std::string mime_type_;
+  std::string charset_;
+  scoped_refptr<base::RefCountedBytes> data_;
+  net::HttpStatusCode status_code_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestBufferJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
added in remote
  their  100644 061a1a67e17b507a0b499eb41577ce8bb2dfa8f3 electron/browser/net/url_request_fetch_job.cc
@@ -0,0 +1,240 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_fetch_job.h"
+
+#include <algorithm>
+#include <string>
+
+#include "base/strings/string_util.h"
+#include "native_mate/dictionary.h"
+#include "net/base/io_buffer.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_fetcher.h"
+#include "net/url_request/url_fetcher_response_writer.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// Convert string to RequestType.
+net::URLFetcher::RequestType GetRequestType(const std::string& raw) {
+  std::string method = base::ToUpperASCII(raw);
+  if (method.empty() || method == "GET")
+    return net::URLFetcher::GET;
+  else if (method == "POST")
+    return net::URLFetcher::POST;
+  else if (method == "HEAD")
+    return net::URLFetcher::HEAD;
+  else if (method == "DELETE")
+    return net::URLFetcher::DELETE_REQUEST;
+  else if (method == "PUT")
+    return net::URLFetcher::PUT;
+  else if (method == "PATCH")
+    return net::URLFetcher::PATCH;
+  else  // Use "GET" as fallback.
+    return net::URLFetcher::GET;
+}
+
+// Pipe the response writer back to URLRequestFetchJob.
+class ResponsePiper : public net::URLFetcherResponseWriter {
+ public:
+  explicit ResponsePiper(URLRequestFetchJob* job)
+      : first_write_(true), job_(job) {}
+
+  // net::URLFetcherResponseWriter:
+  int Initialize(const net::CompletionCallback& callback) override {
+    return net::OK;
+  }
+  int Write(net::IOBuffer* buffer,
+            int num_bytes,
+            const net::CompletionCallback& callback) override {
+    if (first_write_) {
+      // The URLFetcherResponseWriter doesn't have an event when headers have
+      // been read, so we have to emulate by hooking to first write event.
+      job_->HeadersCompleted();
+      first_write_ = false;
+    }
+    return job_->DataAvailable(buffer, num_bytes);
+  }
+  int Finish(const net::CompletionCallback& callback) override {
+    return net::OK;
+  }
+
+ private:
+  bool first_write_;
+  URLRequestFetchJob* job_;
+
+  DISALLOW_COPY_AND_ASSIGN(ResponsePiper);
+};
+
+}  // namespace
+
+URLRequestFetchJob::URLRequestFetchJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestJob>(request, network_delegate),
+      pending_buffer_size_(0) {
+}
+
+void URLRequestFetchJob::BeforeStartInUI(
+    v8::Isolate* isolate, v8::Local<v8::Value> value) {
+  mate::Dictionary options;
+  if (!mate::ConvertFromV8(isolate, value, &options))
+    return;
+
+  // When |session| is set to |null| we use a new request context for fetch job.
+  // TODO(zcbenz): Handle the case when it is not null.
+  v8::Local<v8::Value> session;
+  if (options.Get("session", &session) && session->IsNull()) {
+    // We have to create the URLRequestContextGetter on UI thread.
+    url_request_context_getter_ = new brightray::URLRequestContextGetter(
+        this, nullptr, nullptr, base::FilePath(), true,
+        BrowserThread::UnsafeGetMessageLoopForThread(BrowserThread::IO),
+        BrowserThread::UnsafeGetMessageLoopForThread(BrowserThread::FILE),
+        nullptr, content::URLRequestInterceptorScopedVector());
+  }
+}
+
+void URLRequestFetchJob::StartAsync(scoped_ptr<base::Value> options) {
+  if (!options->IsType(base::Value::TYPE_DICTIONARY)) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+    return;
+  }
+
+  std::string url, method, referrer;
+  base::DictionaryValue* upload_data = nullptr;
+  base::DictionaryValue* dict =
+      static_cast<base::DictionaryValue*>(options.get());
+  dict->GetString("url", &url);
+  dict->GetString("method", &method);
+  dict->GetString("referrer", &referrer);
+  dict->GetDictionary("uploadData", &upload_data);
+
+  // Check if URL is valid.
+  GURL formated_url(url);
+  if (!formated_url.is_valid()) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_INVALID_URL));
+    return;
+  }
+
+  // Use |request|'s method if |method| is not specified.
+  net::URLFetcher::RequestType request_type;
+  if (method.empty())
+    request_type = GetRequestType(request()->method());
+  else
+    request_type = GetRequestType(method);
+
+  fetcher_ = net::URLFetcher::Create(formated_url, request_type, this);
+  fetcher_->SaveResponseWithWriter(make_scoped_ptr(new ResponsePiper(this)));
+
+  // A request context getter is passed by the user.
+  if (url_request_context_getter_)
+    fetcher_->SetRequestContext(url_request_context_getter_.get());
+  else
+    fetcher_->SetRequestContext(request_context_getter());
+
+  // Use |request|'s referrer if |referrer| is not specified.
+  if (referrer.empty())
+    fetcher_->SetReferrer(request()->referrer());
+  else
+    fetcher_->SetReferrer(referrer);
+
+  // Set the data needed for POSTs.
+  if (upload_data && request_type == net::URLFetcher::POST) {
+    std::string content_type, data;
+    upload_data->GetString("contentType", &content_type);
+    upload_data->GetString("data", &data);
+    fetcher_->SetUploadData(content_type, data);
+  }
+
+  // Use |request|'s headers.
+  fetcher_->SetExtraRequestHeaders(
+      request()->extra_request_headers().ToString());
+
+  fetcher_->Start();
+}
+
+void URLRequestFetchJob::HeadersCompleted() {
+  response_info_.reset(new net::HttpResponseInfo);
+  response_info_->headers = fetcher_->GetResponseHeaders();
+  NotifyHeadersComplete();
+}
+
+int URLRequestFetchJob::DataAvailable(net::IOBuffer* buffer, int num_bytes) {
+  // Do nothing if pending_buffer_ is empty, i.e. there's no ReadRawData()
+  // operation waiting for IO completion.
+  if (!pending_buffer_.get())
+    return net::ERR_IO_PENDING;
+
+  // pending_buffer_ is set to the IOBuffer instance provided to ReadRawData()
+  // by URLRequestJob.
+  int bytes_read = std::min(num_bytes, pending_buffer_size_);
+  memcpy(pending_buffer_->data(), buffer->data(), bytes_read);
+
+  // Clear the buffers before notifying the read is complete, so that it is
+  // safe for the observer to read.
+  pending_buffer_ = nullptr;
+  pending_buffer_size_ = 0;
+
+  ReadRawDataComplete(bytes_read);
+  return bytes_read;
+}
+
+void URLRequestFetchJob::Kill() {
+  JsAsker<URLRequestJob>::Kill();
+  fetcher_.reset();
+}
+
+int URLRequestFetchJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
+  if (GetResponseCode() == 204) {
+    request()->set_received_response_content_length(prefilter_bytes_read());
+    return net::OK;
+  }
+  pending_buffer_ = dest;
+  pending_buffer_size_ = dest_size;
+  return net::ERR_IO_PENDING;
+}
+
+bool URLRequestFetchJob::GetMimeType(std::string* mime_type) const {
+  if (!response_info_ || !response_info_->headers)
+    return false;
+
+  return response_info_->headers->GetMimeType(mime_type);
+}
+
+void URLRequestFetchJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  if (response_info_)
+    *info = *response_info_;
+}
+
+int URLRequestFetchJob::GetResponseCode() const {
+  if (!response_info_ || !response_info_->headers)
+    return -1;
+
+  return response_info_->headers->response_code();
+}
+
+void URLRequestFetchJob::OnURLFetchComplete(const net::URLFetcher* source) {
+  if (!response_info_) {
+    // Since we notify header completion only after first write there will be
+    // no response object constructed for http respones with no content 204.
+    // We notify header completion here.
+    HeadersCompleted();
+    return;
+  }
+
+  pending_buffer_ = nullptr;
+  pending_buffer_size_ = 0;
+  if (fetcher_->GetStatus().is_success())
+    ReadRawDataComplete(0);
+  else
+    NotifyStartError(fetcher_->GetStatus());
+}
+
+}  // namespace electron
added in remote
  their  100644 78b819d068f2c0fc0845739b728c95a0f6d37799 electron/browser/net/url_request_fetch_job.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "browser/url_request_context_getter.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "net/url_request/url_fetcher_delegate.h"
+#include "net/url_request/url_request_job.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+class URLRequestFetchJob : public JsAsker<net::URLRequestJob>,
+                           public net::URLFetcherDelegate,
+                           public brightray::URLRequestContextGetter::Delegate {
+ public:
+  URLRequestFetchJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // Called by response writer.
+  void HeadersCompleted();
+  int DataAvailable(net::IOBuffer* buffer, int num_bytes);
+
+ protected:
+  // JsAsker:
+  void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) override;
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // net::URLRequestJob:
+  void Kill() override;
+  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+  int GetResponseCode() const override;
+
+  // net::URLFetcherDelegate:
+  void OnURLFetchComplete(const net::URLFetcher* source) override;
+
+ private:
+  scoped_refptr<net::URLRequestContextGetter> url_request_context_getter_;
+  scoped_ptr<net::URLFetcher> fetcher_;
+  scoped_refptr<net::IOBuffer> pending_buffer_;
+  int pending_buffer_size_;
+  scoped_ptr<net::HttpResponseInfo> response_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestFetchJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
added in remote
  their  100644 0db713e4b752a4c58c8edfbc0911b09a2a163206 electron/browser/net/url_request_string_job.cc
@@ -0,0 +1,59 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_string_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+#include "net/base/net_errors.h"
+
+namespace electron {
+
+URLRequestStringJob::URLRequestStringJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate) {
+}
+
+void URLRequestStringJob::StartAsync(scoped_ptr<base::Value> options) {
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict =
+        static_cast<base::DictionaryValue*>(options.get());
+    dict->GetString("mimeType", &mime_type_);
+    dict->GetString("charset", &charset_);
+    dict->GetString("data", &data_);
+  } else if (options->IsType(base::Value::TYPE_STRING)) {
+    options->GetAsString(&data_);
+  }
+  net::URLRequestSimpleJob::Start();
+}
+
+void URLRequestStringJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+
+  if (!mime_type_.empty()) {
+    std::string content_type_header(net::HttpRequestHeaders::kContentType);
+    content_type_header.append(": ");
+    content_type_header.append(mime_type_);
+    headers->AddHeader(content_type_header);
+  }
+
+  info->headers = headers;
+}
+
+int URLRequestStringJob::GetData(
+    std::string* mime_type,
+    std::string* charset,
+    std::string* data,
+    const net::CompletionCallback& callback) const {
+  *mime_type = mime_type_;
+  *charset = charset_;
+  *data = data_;
+  return net::OK;
+}
+
+}  // namespace electron
added in remote
  their  100644 bbcd1cb6a88fe96e3544152fa9f62efdfb4a51d3 electron/browser/net/url_request_string_job.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "net/url_request/url_request_simple_job.h"
+
+namespace electron {
+
+class URLRequestStringJob : public JsAsker<net::URLRequestSimpleJob> {
+ public:
+  URLRequestStringJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+  // URLRequestSimpleJob:
+  int GetData(std::string* mime_type,
+              std::string* charset,
+              std::string* data,
+              const net::CompletionCallback& callback) const override;
+
+ private:
+  std::string mime_type_;
+  std::string charset_;
+  std::string data_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestStringJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
added in remote
  their  100644 e65cfb2c1c3396fe6c7d9552fad32770644aa309 electron/browser/node_debugger.cc
@@ -0,0 +1,203 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/node_debugger.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/test/embedded_test_server/tcp_listen_socket.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace {
+
+// NodeDebugger is stored in Isolate's data, slots 0, 1, 3 have already been
+// taken by gin, blink and node, using 2 is a safe option for now.
+const int kIsolateSlot = 2;
+
+const char* kContentLength = "Content-Length";
+
+}  // namespace
+
+NodeDebugger::NodeDebugger(v8::Isolate* isolate)
+    : isolate_(isolate),
+      thread_("NodeDebugger"),
+      content_length_(-1),
+      weak_factory_(this) {
+  bool use_debug_agent = false;
+  int port = 5858;
+
+  std::string port_str;
+  base::CommandLine* cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch("debug")) {
+    use_debug_agent = true;
+    port_str = cmd->GetSwitchValueASCII("debug");
+  } else if (cmd->HasSwitch("debug-brk")) {
+    use_debug_agent = true;
+    port_str = cmd->GetSwitchValueASCII("debug-brk");
+  }
+
+  if (use_debug_agent) {
+    if (!port_str.empty())
+      base::StringToInt(port_str, &port);
+
+    isolate_->SetData(kIsolateSlot, this);
+    v8::Debug::SetMessageHandler(DebugMessageHandler);
+
+    uv_async_init(uv_default_loop(), &weak_up_ui_handle_, ProcessMessageInUI);
+
+    // Start a new IO thread.
+    base::Thread::Options options;
+    options.message_loop_type = base::MessageLoop::TYPE_IO;
+    if (!thread_.StartWithOptions(options)) {
+      LOG(ERROR) << "Unable to start debugger thread";
+      return;
+    }
+
+    // Start the server in new IO thread.
+    thread_.message_loop()->PostTask(
+        FROM_HERE,
+        base::Bind(&NodeDebugger::StartServer, weak_factory_.GetWeakPtr(),
+                   port));
+  }
+}
+
+NodeDebugger::~NodeDebugger() {
+  thread_.Stop();
+}
+
+bool NodeDebugger::IsRunning() const {
+  return thread_.IsRunning();
+}
+
+void NodeDebugger::StartServer(int port) {
+  server_ = net::test_server::TCPListenSocket::CreateAndListen(
+      "127.0.0.1", port, this);
+  if (!server_) {
+    LOG(ERROR) << "Cannot start debugger server";
+    return;
+  }
+}
+
+void NodeDebugger::CloseSession() {
+  accepted_socket_.reset();
+}
+
+void NodeDebugger::OnMessage(const std::string& message) {
+  if (message.find("\"type\":\"request\",\"command\":\"disconnect\"}") !=
+          std::string::npos)
+    CloseSession();
+
+  base::string16 message16 = base::UTF8ToUTF16(message);
+  v8::Debug::SendCommand(
+      isolate_,
+      reinterpret_cast<const uint16_t*>(message16.data()), message16.size());
+
+  uv_async_send(&weak_up_ui_handle_);
+}
+
+void NodeDebugger::SendMessage(const std::string& message) {
+  if (accepted_socket_) {
+    std::string header = base::StringPrintf(
+        "%s: %d\r\n\r\n", kContentLength, static_cast<int>(message.size()));
+    accepted_socket_->Send(header);
+    accepted_socket_->Send(message);
+  }
+}
+
+void NodeDebugger::SendConnectMessage() {
+  accepted_socket_->Send(base::StringPrintf(
+      "Type: connect\r\n"
+      "V8-Version: %s\r\n"
+      "Protocol-Version: 1\r\n"
+      "Embedding-Host: %s\r\n"
+      "%s: 0\r\n",
+      v8::V8::GetVersion(), ELECTRON_PRODUCT_NAME, kContentLength), true);
+}
+
+// static
+void NodeDebugger::ProcessMessageInUI(uv_async_t* handle) {
+  v8::Debug::ProcessDebugMessages();
+}
+
+// static
+void NodeDebugger::DebugMessageHandler(const v8::Debug::Message& message) {
+  NodeDebugger* self = static_cast<NodeDebugger*>(
+      message.GetIsolate()->GetData(kIsolateSlot));
+
+  if (self) {
+    std::string message8(*v8::String::Utf8Value(message.GetJSON()));
+    self->thread_.message_loop()->PostTask(
+        FROM_HERE,
+        base::Bind(&NodeDebugger::SendMessage, self->weak_factory_.GetWeakPtr(),
+                   message8));
+  }
+}
+
+void NodeDebugger::DidAccept(
+    net::test_server::StreamListenSocket* server,
+    scoped_ptr<net::test_server::StreamListenSocket> socket) {
+  // Only accept one session.
+  if (accepted_socket_) {
+    socket->Send(std::string("Remote debugging session already active"), true);
+    return;
+  }
+
+  accepted_socket_ = std::move(socket);
+  SendConnectMessage();
+}
+
+void NodeDebugger::DidRead(net::test_server::StreamListenSocket* socket,
+                           const char* data,
+                           int len) {
+  buffer_.append(data, len);
+
+  do {
+    if (buffer_.size() == 0)
+      return;
+
+    // Read the "Content-Length" header.
+    if (content_length_ < 0) {
+      size_t pos = buffer_.find("\r\n\r\n");
+      if (pos == std::string::npos)
+        return;
+
+      // We can be sure that the header is "Content-Length: xxx\r\n".
+      std::string content_length = buffer_.substr(16, pos - 16);
+      if (!base::StringToInt(content_length, &content_length_)) {
+        DidClose(accepted_socket_.get());
+        return;
+      }
+
+      // Strip header from buffer.
+      buffer_ = buffer_.substr(pos + 4);
+    }
+
+    // Read the message.
+    if (buffer_.size() >= static_cast<size_t>(content_length_)) {
+      std::string message = buffer_.substr(0, content_length_);
+      buffer_ = buffer_.substr(content_length_);
+
+      OnMessage(message);
+
+      // Get ready for next message.
+      content_length_ = -1;
+    }
+  } while (true);
+}
+
+void NodeDebugger::DidClose(net::test_server::StreamListenSocket* socket) {
+  // If we lost the connection, then simulate a disconnect msg:
+  OnMessage("{\"seq\":1,\"type\":\"request\",\"command\":\"disconnect\"}");
+}
+
+}  // namespace electron
added in remote
  their  100644 8e650804fbb843ed07f8a008016042708f7d35ed electron/browser/node_debugger.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NODE_DEBUGGER_H_
+#define ELECTRON_BROWSER_NODE_DEBUGGER_H_
+
+#include <string>
+
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread.h"
+#include "net/test/embedded_test_server/stream_listen_socket.h"
+#include "v8/include/v8-debug.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// Add support for node's "--debug" switch.
+class NodeDebugger : public net::test_server::StreamListenSocket::Delegate {
+ public:
+  explicit NodeDebugger(v8::Isolate* isolate);
+  virtual ~NodeDebugger();
+
+  bool IsRunning() const;
+
+ private:
+  void StartServer(int port);
+  void CloseSession();
+  void OnMessage(const std::string& message);
+  void SendMessage(const std::string& message);
+  void SendConnectMessage();
+
+  static void ProcessMessageInUI(uv_async_t* handle);
+
+  static void DebugMessageHandler(const v8::Debug::Message& message);
+
+  // net::test_server::StreamListenSocket::Delegate:
+  void DidAccept(
+      net::test_server::StreamListenSocket* server,
+      scoped_ptr<net::test_server::StreamListenSocket> socket) override;
+  void DidRead(net::test_server::StreamListenSocket* socket,
+               const char* data,
+               int len) override;
+  void DidClose(net::test_server::StreamListenSocket* socket) override;
+
+  v8::Isolate* isolate_;
+
+  uv_async_t weak_up_ui_handle_;
+
+  base::Thread thread_;
+  scoped_ptr<net::test_server::StreamListenSocket> server_;
+  scoped_ptr<net::test_server::StreamListenSocket> accepted_socket_;
+
+  std::string buffer_;
+  int content_length_;
+
+  base::WeakPtrFactory<NodeDebugger> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeDebugger);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NODE_DEBUGGER_H_
added in remote
  their  100644 21c02d74e2372989ce170a00fc5684ee1e119618 electron/browser/resources/mac/Info.plist
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDisplayName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundleExecutable</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${ELECTRON_BUNDLE_ID}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>APPL</string>
+  <key>CFBundleIconFile</key>
+  <string>electron.icns</string>
+  <key>CFBundleVersion</key>
+  <string>0.37.3</string>
+  <key>CFBundleShortVersionString</key>
+  <string>0.37.3</string>
+  <key>LSApplicationCategoryType</key>
+  <string>public.app-category.developer-tools</string>
+  <key>LSMinimumSystemVersion</key>
+  <string>10.9.0</string>
+  <key>NSMainNibFile</key>
+  <string>MainMenu</string>
+  <key>NSPrincipalClass</key>
+  <string>ElectronApplication</string>
+  <key>NSSupportsAutomaticGraphicsSwitching</key>
+  <true/>
+  <key>NSHighResolutionCapable</key>
+  <true/>
+</dict>
+</plist>
added in remote
  their  100644 dac213ed9d8c096d0b8c3a8848b1d3c4ab545059 electron/browser/resources/mac/electron.icns
@@ -0,0 +1,3373 @@
+icns++++
++`ctWU]]]_J5x_k}5-PCW$r\`l_x/D{-5JW tcNw(GZn[q`:th__LK&755M2d555WUU]]]:;;uhqu{mm%K_x|q]0xGp-O~fliiY!C]".)(H	,TaCFNOOo[/U>G-hh!vC=])eRMy{>D_p5_;rK]=;%dCFdQ!zd}d
+Vz<p3h+OV*>>)]*uiLRCK8Vm:lT8H!QAz={uc<xpO?m]&^BoH~d{k.\uuu'odfWo 0gf\*
+Rj~*D?7OAX(xgD"@/uy(KVmjJ:=Sd+S:m02+/U<tprr}Q/_`vhecGw7~_?oJ/F[gOoo+L2AXN5j0$\Qg@P?*;;S#F[8|e3}GB=`xMRk1teFw\cqhML8Ce;)p.R-
+k9G[smEm)56xF?NZkJIv'G0$$t2&'p!c@%3T*fd"OV>ylp
+GxGF+?h$-]9sg5R8-UZ-qEAM:bJ+/eR9\oruHG(:dOS'0>^I+=bJ_O8_N0{B"R/W*KP$r?<yt1J[B3c@BLh(u&3oDY.WJFl?F#;u}}Y/:xy|:t1+X^Nx	M	Mti@H Pd)tzA+#\u$F*mC([nr=mBdt_9j>3<s)S0>1_|*FDy0WF(&(
+5-Z/GI2Mhx[7^DQ0(.erlRlke'g-2zL6L.ucZpJNEt=|@5$$-I(78Y28H@3+P2
+(4*W$F(UX{y"DAy#y#Ik8*@{VCM5Z38.`~nyH=Vht2D}$fe2C[
+P/b7]_
+BsfcX<i;:Vwtp3AIkTO	0zJ3+	`Vc~jj/[lN%M,O-V}}yA==j7,Ea-0Ab	'ZFu$LQ'"@T%p/M5[,HgJ{YE>%A4twB04/'`	:BQOuh;s=szX6FFBIoILL&kKLFm&[G\{L{nN`R5f+(`LXC0h@I7K^]tTP_o,a6_ktlfYL&d?s,`&AeI`Pq4B>m~e1Iosv(p:+1	];4;irykjhoIkl!z)qSN"Lie}gN/YTSD@~O:[[A|o3dZYoPj'
+KJ <:`s+LUj
+7hSt	JJJr]P6PrLPQ]M;756%9d)6G7ai1lL(N?+xJXi*;yQ6Xwi(Bmm/p&kUvCs+Z?([up"+Z6	NCi1:aXzOfVg\u!Gs;G-NFiku6A\@a R@"E[6.Z@Fm[nN@n>I6!1si	`iv@c|o=P0#k5ja{kwlMGwhsjRm8#jR]{#CvX!B+<ApOC%mnT	??N4iBlH4iV=u6dFXo0%1iqwI4eUk6&gy^tKrT0t&w{o0h]BNe9Lm5iM.^xqzGM<{Nzbt
+CI#0rqii&H\E3S"dvt ]Dz\{U;W:p<@<q7z
+o(!m@C0J-VdukKjSvn_}(`0G[mMMiS067NHX6n&FM-G]/4;cFKRkml|.	Gcn%
+Uf<Duj!k)pc$cCYjV,@q!1
+TiL,"H=t7w)^$MC9ax3P
+9R[qE6|x{-&T1Rk)e>=8|I>Q2rFwssK44sT69q3mfZ'LglL-h8GVUl (3G)5Yr2UPPYy[O=gwvVs_SJcD!g9Mg>Hzu?>M257!:/7;+khm	~W^zqKdpK+q1ts*@Ah5%P9jgU$e_xeGe\/-L9u$`)+>gpYgM31. +FDFr8IYqS-[RG&5]9eW]u9}.Kk+eD(VZ!S )O1';A??>GtgcN2`MB!f*F+VAAB[
+lbq#@	Ng4IVIQ%OvEw{lJ;O>`/\ytS]N@K%iLSxF,)f&^y! Rg`	wrTjp6eywj`C8;<`CG7O}+Xe8+N[oKss.RF2 [k~rwL<K2a]0cofN*Y+#d-E&M<EE42nSg`>E<)btfT`n143Z@@NA)#ITic`;R+?RWf- *AB<4Q%d7m^V0l<=E8R[lX=wc{c!hAO4JNO7jo-^
+&9MY+Wfi\bW>]7zH4@Tg3p!kuhu&"M,9\^k: o`)l`;o6T9QP/|dQ7I6"d\o*"<j	U7XSHw>3~/F/h@9}.($Hgh@+z	TPaC!OH.P@ltC
+8+5uG)/`:
+/kM\-aJmcQ*z$lcLoVvfCS6nIt~*< (W/	?N0M*8GEo`FVXme^v(+(L#,WV>7Y1.*s3UaJB96@x7M5R64W~_Q
+>w[j~
+dbeU{^ Sg3|r~cwb~0n/ID6vg1%HxMX9@ K<#H)Q@5+bY)}<.mX[i`i6%.W&<h! ,i|-zA`a\n&Pm$okQ]N66l|hrdB+VlE=*hIW=59/H;u^)~ q#4,
+pWW\uV_t-o
+;V%	\%8dSV.41NLNy B)L+Bs-+put/qnsJ+iH8v+r"Zz{Y_$r,}}Q,09y=-fk'CIS\C_39H-$T%YtFT%%\ 6<4@H\
+ElTC2pc;l|(8A<2XiXx$PPTVQXBb}p+7H+<i0J&N!^v*l
+yVQ4yt+m~9]z}{pPt
+]>A%P44HSevIzh&OBRlvaFoJ1i8vU#kd,dr:I]	)(r+?Q*877yHE%TJ{|1).id,7a	:wS6+9-[_UZ3rbbG1S/FSKE52*$t/u0Pe2T2DJ&
+Ov0n9VTr8h<|'` L>!*^TBZzMlM#4`PV7~i$,z5o~{%1Ct(F~!LmA:^==D~@*ncpX4hj4Aw/FZ<`A=xHc)Y5#&!16+}5Q,84Q35}n/+b^y%[/\vyGXA0r~zjor"]O.KV[.5e~}6X3GEmDFV.^5Rq{rV9mEjw7nLM@
+C$Ee>=+aG(V_kWaa|ED#mQUgA-xn{!Cgc4GR;1ijgc\Pl1zMldF=?Cr 9
+isg-Jo<Vli	q!\:t;{K (8Mw	E* ;PtIBd2@1GIO<P+f*KA^=Sy#vh#uoI16Gwf2.]b\`c:@_#+qeyTg4Jn>Hn%M\r5zOP~\^@huY ZmgX/<~~LK,=!.#2fhWG={/*=*^sVT4wxz`:h(BPX(f<x;6U|@Z6eMl)xpm?2hJj1%GM&Y!sp|4B1|u2E2TcwVu=*,ytjm0Q^#:z^x1U* N@58^bl:f'HiUrgblMwK?#k'p3D^ruindZP/}Rz^gmO#Q!t&Mv/}AZt+vr8-# _^vef? 9 |8]
+rC\I7_vUw?9OFh{@-s3fI^~}Xc~aWMvNjB+a*e&Y\_=.O*!}h|<ki.6nd0O%}!t%e`g@3-1N\!.Xs~VK;uX#ChMF(+Jn
+|,!E'\~i>(}+A+?:=pP<K+3A|@^6ld&HqBLq0nC$X#z>d.WJ!+X.^f#UooiN?^=.F]N=73YJ1v*uD:g*'=gz]/>n=5\sj#IJTRUFli@)/3q:=kbCZ#'`Y+C_ocf2pxK"n%z=}Z}	m@"&FqjG	@
+Y4
+ri]yXc#Pb<ow~9y]+
++X
+}0#(4Sl;KB+v>ooXw+GV99d/]w@:.|\x=cu&+#hC48?xvMQ)	p@U>VszA5Q"cW6cQ^U0~>,zr,;A8B8+;W\7l+&zs0|r:s;o7n7j^o4z<:X2GMvir6dZ|n-_S9/`1<0nGo^r[x7:@Q3`lF0zeusSw4BH	a1YcMs8bZ,LwE\B1	KD#1">a=7ZIExwR	2zS4"0+B|1*|Xq/h+JxW
+PEVqbY1cbHWus/E(yT,aTQV/}VLC2+}5o3|J,+
++WWc.Q[5}	K,9a)D:jp79M^ewF7?#ek$	r&MpWOGwy777O;cO>}cY:.-J/)jpo}o?}W	B.Jy.)W#OOs:7O4L-ObRx8}7zc}6lS_&D"wsCe@(^TS:~<?3fE3YGQX8hbVYn??[H5l%y%	b5u_N;s~d6H29{;-~2<v+4\?M_>-C@QQ{)q[n	|\^D]t+-k*Wyg/^QF-i`_?Xy/?t+W'>}+_	5`BP:@M+WhUoVKI[nNC@P,\s5uYf7`7"vqXQ7DapYR0^Sk\eucwy=DLx!"X7wq}.N,L
+hJ&PDCiCi(w7nM`|UWOmwp`*GNL{4vi+0S	7%`CBRD3L<(e=8E#de=&Gk";mE$-PJ=@?{B+GN:P+aFZxQ9&}{MKH:`+s.+%boNDYPP!pfJIf*Ypi'?yCk;$zm8{@(K+]
+
+>FU)W2T`|SAQ/]=%!=P&^xT@9j6"i71L=awDmE|R!~8'<0FN9%?)34[<*th:OjN%o%oh?`]<GZC@G2+jS,aA!mU#6+tJ%~gzpJUtMGldxfce3QAt#9D24sYq#UAQOAC
+f%:`-/aWX	y5^H}EM<+vDT+&V?YfX3U}t|R9=@_lB
+/+p5+Xu+SW #KT<FN])BudO.Hkz1lm		_+!|e}j~xF};Y[:[}?&D`,N}o3Op-Wi_  #"8\@'Xk H`99#y,%J_,[y\CHH9acQE	}'95K^d$?a~hS#x)uF0je}zu-f}uZ	XAx&wk-j]p[o/&NxO.9**83+oe6]h A^*I>h!"z_bB}ud`nQ1r:^U-`>uaQq	36$9a_m5pv#{[%$D%
++0%K~uTkj}}Uqjz]vq@`CP!A2I
+K%r}"W	;<DQ	6cd!r,O@v+z%:7/KP)[`@%]JS*
+=|
+"U=xt]U?FL
+@1ZT<:TW`9OOe<I6Y?C$%GPTUIv$`Rm@4	rab/8L0R0^wxX
++
+<YHV6E&	H1"H6D9[mVYfJ7P)6X>vH>)_`n
+nr?}y7:~:"
+%eBJFZ-; Vt=mi#VU.VqY68tu]KPQ[Z}7>y_Df2q,P_$2ylHDo-^6e[X6<-@4%L]6bP"Q6jVCU.fUm3mG^&9\g(?~6Qf*HvbGL+hZ;\Eoler2I
+4W1KQvXr9_}g~@-  %qG/X'{E@LED-a*CIcYW-AxOD:K+=P*D"	,I8	&>t
+i-eWTSSfM|%.3J{d]4&4y&0K%aI5guTv e0^o+Y9l:c@>F LKYm_
+_
+*!G{t !PC	(2;g3ik'I#PJ"o*kQ)BYjeRS3*hDq{R(X,)R?~1X;U,_j?V2Z!/U9i'6MF6N++lg\5+/mF"DY\Fn'3$!o_m."a	gsi~-JJ2PcPIk.WXBtX2!!!/E\  7e)t9\A2pBVP/Ixx<\'&i5y,YY/4;vj+>I+:Coa;cXP/6VEk;%7uQZWfS)(8oUUMWUe9+WI&]X7Ov]#Me``:qE	F`xn$!Lfd^%jLLY]r '}vbS4\wnIjZrmo:35l'7U_S*
+79D8A7X)k,Q8z1A !QVEX&:eF2vu;]n$+j+\S 2DLs=+)
+U	G@O:QF],dokA!"H5Dn7IXkY%;Gp-nv#s/J\9bDd<_fqC=yXvk T<!*L]TP`FQp'b>*JFdhB=%OI>3g]ve|a	ZdW;c=tuW|cdm+vaNG(8eROz7#0EoAd^7|zmr/;	74joAb#Fhf;eLh@7l1aH:r	G1++!l+Oh("jB}s2`y|?n)'vkxT^A'WP~W4>nfo<V&[ ..;Kg~D^Gm#r"T0@ 
+J%5LP
+
+"JTl%LLr\U+0t95m%}ims=7m+%4,5V4*v*~$S	(n,	aM5r~G5[US'+@#W\>}rN3lS'.{@t%QPtlQ{+NEE-,j>d}g;ms0Xr'"U?l	h/Aq;20<n2,~vw(WFp=CXqDm+Fu7q#++Ja;a~t|3Wj0t[Fx?sRk#SYx+h=zfW}>SO)-W@1\3+G&lSb|a_I+IzD<,)F.[w'X#FXm oC%"<6&--"*Z^T (SC 6$C9.cYy2]Xea|$oov9WHJ9.9ef?Htq7yUN7~1~R^WEn{rEE5ZzXY@]AihLp]cJg8)Pj=l]z.,="|ngb)G1n>zebA0^J+IIew0Voa-mDDc~f!tSVcC^/
+J:0NG>?
+p!9.:N?y=] k,I<`< ",?'@!=U@4h'p(P!i';8a)Z,70WO,]}U.#)Qr^s=[Q/EMO%Mi.(hqz(RQ5O>y[.lV
+H"OEP~S!)Qe+:z")LcdtKd"+K"~	H\w5#GK{UW7#J>^oLNSN)NC+%`yeI="m_
+(DBryf
+t"4BZ'i?	te%3q7VGWKqoxbOp
+[pm+Hw0C`8r"Pujj<g(T+#U&d.-Chb1LuW^U'-3J#V+*#RO+/[d
+d	Bm2`~]+pD03$	
+r*|s\.+JQ>V8x'*,9$ov`i	=-4Ojr+xXZ<Ej,yLF^MJ*|z4J#UCKM65e&zqV9lp\8PIEEkO<v,rS"2$%>>j*+2l{4=9[^oafmbU];Q>ZfO:uFjP02DXDhTFi<;GI Uh'~Ey4|2*Sfv4mOGXv&z`6~!BGb-m9OMGOb8p
+a^;[T=09X	"r`|U!My9AI/>L'?L5+FB @+Y'yzWTnuk
+:0Ze	`CD&TrH+HvhzJGAn7zIH*,i)w*JU`uqgh%8=SGJ.<_oteL^sC+uM2l(Y<}~fl0yt}Co
+G[!S:F}h	~R{+^9o2)v|dl]h)o!B6;e~VE@0 I.Ip$#4'OuvN+tgx?z
+bJ%9nf>5u.pEH]+)xv=JC_74^Xl"|wGO-QIZAL#wRNvp
+|n}nZv I-SH%?>_;oY&.|uZh^j;}fV6o6>/zsFR,cIqysIZ	l,K;?{Pb g!"w;?AjOaa6k1vgK\/Zs~Jov^Hs${EVG~JG~w0<[*O<~H@TqdYtZCgHl!Z(&<G#0S5P7-e4&5,iZ>m8SMJ|N7<`=wRF
+&UD\eX|<Psk<X;93-[t]{~'~3qz'euu'']eaO|.9AOa<-^uP$UBy|;bF8Alh"A+MGTK:}f^-,c!OT;w`5a;q
+Am6wv{td{Qd@3(&<Zt+#7,g-Bpn2%'SX8{"XB0"si0bd3wzyf/ :rg!h\{1Z0}~W16tXDxl1H|P50tfN1;<'8oF4#)p
+AE\>X	N+K4'^3D47"\dX'\G^lEO}FkQ[O<uz-Z]ijSa	?iqLH$8)|atytHF`xS>C_2TIra%&A7Q-`
+n%2?fHawZ:g`XiCh*oYz\3~xF
+c~l,<6vq%S8qldDjjd=uuJ>o6Sf7
+.eo0~m7)w+iwfYu!CV;V4 =lyN8YvFXaoSY[CRF"D+,aCauzWJ*-AcCL*Vn;18I-T
+xP'_Go-@*l_q#ar|tJMDpz]O)*xI6\`(:2K+JCn?Mw,EEEu"cF5MQSlxblBZw_hK6uy
+*n7~~PccA6 a)-Je%AM9c+v?qpo}w+uk.Ac#(pz^pN-E+:
+3ytO$da#+W4f~t<\j
+3-thngbHDhXjx&#N5]>oAhd+
+u2qOMR?WP
+(WI%l'mHh6%|*Io<v4tKrg<qvmx+l~	<^v- uai=%HT1Hf=Sx=	u1zDqsFN9?ci|1{
+A,iNG`0hT!<O&.Z	S+OOZl@`wj S4rq`C~Wk}=	IVYu=
+h3+=p9hq50Z:DP$C9%u?^	vPhf*(K!2FmvGKY@Ap7LAp)9qSG	-49WAqd'`JQh>Y'hCm14,U[9a2w]o;$IgMlZl
+~`<TS8Yz8GysMp5O?LTkcLO/xc){LBvx``r'Oh3\FH Lq1%ZZl'amzosCz;Fb)+6\}4nB<gArk>RG(EJSYGH?["97\$X+H(F&tSUo}iX~]>p+6|#a"x-DgvXpIT,hD*6dx4XJ,DGQm"/
+S&Dm}*-J>SMd#N3+tuu7}u?xbbaB@2Jr<B"uam/8up[tU+ Mvgi#Xa^~ yFulE#6O&{^F768~ !M%4I "%>G[v-kb} $<|j,6)Rp^k)nT+SxNZ*&5e4v\)%6EMJ ghpuA2\ W isz$G=3sU|o?/tSchM VZ$XvY-6T\]z[qLWj|+b;wU{vh2?O[yB\G	F0 M+B4$Y|YU"Og>G?G1~6Ic"'>.%
+>re&q)M|aycw{n=XSkCFA"m\LAg4GLjGA?0rlNWMkI11MetH~}v,r"Duh*gt(b_TWQK&5%lQ0&=Xq->%`wv(6R8dAZmhf`vV;)j%C~8<w:MpA!T$j6.yD)[pB*6A>1a\R@EDS&(UzyqMg:uZ}ZB`1
+>mI&kn,NgZpWq gX: jiS"J['EAXm;!'|(6(h~ff=y>Ak3r=ae\iPa92Of{,tv?J&k 	g.-l4-qFz@G`w0(oYTF.J3,ZI3+|!'!()R+(p>",(e30DDE{W>pj{[YEN,qWk5.%WD&3%vard&XM]EWTGI>QD`.=ORNMx40r+	6y$u|hv'+{K,%ei-2! z0hM\tpF`hXlKq)+a'?m-bM=99ITpd]VokaI3?q^u|Dhly008geE@$;#]V(NgWCS_$`7y)X^/:V3+2Cze>GJ^'Z%Pv<ps.+eYeHJ<Ef%d	x1&f@*J8VvX	Hi`<&08E8>xlsubt'
+:6{Bm0K!-5+FU,]b kT{q4iL8{y
+sUTgstGz(i~X(1r_JL-\!JpR"[vj'=:()9uMYH<!?:ON7N^{56bKbh(
+T~K]bRm['2Dt,+=IyC`?q"}/^HkL2.["(nq!-v80+Q4.LeK^G4*Zga[_:0?4%7!l'{%=45{~	IHU~oheOgz\mAWyH))wy30t+c`5J!MjSE[}"<\::agh=rsz		>s.uz"4'%`OV66_--{Mwgv,w)zj^/.F?lfti]n<@m(3bB{OS>N)H^A]"/p61!vf+q$//8D/A+nYZRV~z a6tZS]w $@<]Na(v!FMF+mdde>fB	u=P8iq<l~lba=C7DfJVH]]w y`l2F[Z.86
+ +BL!h#[7Ff*[T[HVf5QNHjpcnE_\tKd5_dAMBOdKISFI>F\A7pcG*exXj5Qk'#,;l t&K
+S,RUtcz=/qLZ{[c8]y}c$O<F$}l8	fDG.+lB^#yKh{%X~}Q)H+ltmm~] U@J9.H)'rY$Bu~`Xx\y%HQ(?0aVSDB6Vqv+=UG/:MQGYpJkd+iQXY\e
+rATcMbI 1)* ;b2)n)Mub3In;)LM>ndeb"1XGA>8'3l/^aYdeXu
+Gj|Ym4W?
+c@h=S+8V**	^S{}T/hz]{g5F?9bx&<g$')'+R|'OF?G~xnzn'f}7Jtx}aTx4}xSn\?k%
+\WS7geNokfO_^:NSd&`<_Yfa5EXZ`hO{P
+g>")Msr8Ai1bEU2Her74p-'C$9j>[H:%DbPme4VG2 -tTG-^\}HN&NTb.x1MhN``*0Gvc}5TT,+3ueSc}=;(!q5W;n]LDIBU?@	$tE,E&,"+:1S03	
+pJ
+7Fw5#zBq;p*yuv5K/pC,jgm	a@q%}Iho&+W6qzE7\
+++c,$C'$HF*KZWM3fQ]|v" =U
+>LAq+J&1Lm\""Rhg%+?j&KU?Y.YatWBas9{B1-->># 
+)rIX.=w@z8U%G:1G}1*$yE.=/Er(sO,VW#t/=c@,!%ZIK7dMjS2JDr
+{J9K{GT.jm]J7>4@S/2@)&>k* 	qTJD2V_*!ioBE3K?9H|cUuh/>5NL=>R@Ht\DMA|h@=sfE ';yL$}fg!~WNt@-
+jaoW1c0xVnVN<yyT{'rUFb'ucRp(G8!#&!M8yWEDn7r9K}wkQ!#L]vmt%m/ZfMdE2}Tvj!uP,V>#g,y!)/;+atyw/~wT5No^l-D%[@
+hY3O3[Ag+ S<z75JpD-A~BBD)T,JJ'W{na$~ZnC3O\ri]h?l+Iu>-!JU5E"N3iep3v">V+h[$<bIe2wS)$X\*	QKKc8(d@k]*pAl|4v@Oo	o&pm{J`>f@Dai\ #Doxk]}OSi??wBqm4xtFRlJ{?6)JN}}"t5lT/P6vXy8sA:8+`"<ucsew9vt2U1GB\lEuWY7Yt+ dxx+MCgP,{+U(v7"jLU+EcGSWWjfq6V#	0#v1^jPN$@bo5rL[N"/8xl';9)s`L-YAXJVH^'Br-veU]zi^f	MS)uY	fc\ l'6={lE@'&'hfI,)P}+8eY
+;)31
+bJ[mv~x*i+L<dd>
+m$~nFk(6rEl/b?%;yo/O{A1q-`0[S8t_~a$~#j?BXO}n$lA.mmCL4#+N"fAI>8W,$;x9Y"dgz8\ZJI'-?:W_q$PIdmw!nJNAy|dG`d;N,AQCPl>xAgK}:|PHwx@iA)y+em6x/(Y
+m~gC5&6b(L<I]Q!DK@&!"#`Slz!}=@lo<.rLp+l%A+#(!8@oX_!+}]@s;!Q^+|Vf s4p'P+lCplCd(JyS%J&!\%I<,.2Q)	,)(~:mF/(Gi3.+jp]/b	?O\|`$>v|z]?/L-t6:WLHE&!+$}4 '(~US8(m.&!Q4YwP#[:d+B!W1mUii'w?M[Cy bpuJ.^	GASy4b
+sB8y*(V!D`O\+JLz`m4
+!WO+H1S_J}\dBE
+_?&ZSff	|++Zz9.z~:FIPI<}T{2LB[<=D(e_PG+Q@Ur":^qEAH6Munem+B:C_h3+$q5AH66B-5_Nb->|(p@3=x~'9g`:r$^
+YM9SEzhPdHDsrrpQy|w/tLLF*@Sm<L{nF^m~tezA_/l0em)o	!Fl2:mOO92f"BI!;bW(uYp)OYQTgp% viE2-!a.bI	8yfri[gkN#*c6MK|! q |r?42V%>pvTO0+=N-)")V-@n\/fnZ5`h8\?5"/hTM#N_TbJ}.$=z1VCw'}\dxBB:8+@sEOT+]	oe"A%q5Jc`D3]ESq
+	-@N+g4X${bu9Zg:Z$l'r6_i.~?}Z_#b7j^J9&>dwX5s}Fv!d9QG[1(3?A#;ED#^LF5JrdW}D ELo.2Z:ARMu*az:/oDTq@PBf 	}hrTRk
+{p=2+PrX1aMW9^%%V_zu~-cj	ZrlH[A#45qQb\@!1/#l*Zsw@U
+N}0H()0\ 9vB< 8C`j@0"m 3H[z2	;(
+C$F+"\}	0H&pk+ 6wm}#J%gUZIz)S,J&B"e38~$M)*GE]$ KN7j
+WJY|nW5]rLuwctywj/_%\[6#c|NK#(,?L~Zm}sJ,jgZhnU[V@L-	/fCBoMAD+hx(Q6zISGuG<EDJ==I==IT|i<FP\qj5W]{-{SxYrNbiGqdt))Y#@.	!|_&a5an`3g,KT;9zeWl4fj@^P>A2ALfu^yuMOy6[_T|Eg%Us6uP4"Fj]u!2[#B&M\):AZQ}N*,^XMYP_ZlXD`lxA]^Tvg|1X4vubs.85bUSb ENoLnf/qjW.M[VvfI0(h
+
+:K\GtR;F5}zur6jc0"pI:+7~N~m[NU	n6$uxk{N;^|e}Iv ckn	~KcT*~\cM[NYCna#!X-QZ+A~x}}_n+x)|f"#+|u<t}/g:\&NPc8I{8;-$cdbQ|5v c&TcV|n,sc,+U@*m~
+;Z|V&4dZ;jj^b"^!($A# /UR8OB9jo5o{OFD+M upE5D(?++Ezyk9S'YmZ'MsO(Gb+<q 7zJgffGi*!RI}[rINRay8`IL`gI6,f]Bba)KX>>T(*M,,
+B!&hR'.	vJGh9L+N(ceiZhUW\uo-@%o~_uku}]j1,oczhpctD7!1_5(+48[F(aQ42p(@[r* ^TXfe`9u=]%q&t%CQ>ZylRznJ{N*#e	}V_EIrA(pp~j?s}5K
+|GZo;~oE~O,:1Xs3iYT++;TaG+Y2ysD-kGW/8KdN1[
+\n#.(PT`-a?	0SX(w w{]KRy'wK"JD@'}5'e}`^ILd]%&+J"fQtZ30>
+[5s185
+|I7Q?YfR)r]
+,Zt.3ZEJS;tXG+T>EGk}^lv\)O}j:N<Ekmjf6r5.l)5mz{$as]dn28k.&i M,;V6\59\!3\{ ^Rym|eqE9K:]Ok+zq]xrlTyDe"/43 )+HJ?l}Wvi|FUT'~xitO?a/gKvD]si!2u-ztu
+Aa432Lganx<'Qq<qfMb'6n6j	hJwOdHdp{giF+|#&Fful1@O}S>,2e
+A[CBGw)qc[w}}W2=3jrg+<({0x;nWmiSG5#Y_X-&8TF*68{3c/>/Vvu~3GARM8?+ !DEZk2lCoc.:P/>C80RW^W_%~`L]~^;Qv/~Dp@={;JcGVDl"-H,r~`;<ISt;0y4-I=egu&[|q}Z|qLlr`rf1Pr.I3g-?+.QnRoic
+N'hNS>35.	jHU3Sqg~PQ?9W[u.vt~8O82oWal5&kU]5LWg]I_nmSB??=4#?$+RN+Aos??<>(@bd%^0++(S)t	)Z<:c/s983U3?+NR[;q|)b0 *&gV/zP3x;kL&9Nx~^6iX_~XwTq&o8XOTp>B_?C8fOZplc@qfB}^-v=(NP?R#m>:;Y SbEa
+b[f)0ReKje9R{_Q=O<@ZOF	0CR'T;u]KmRm}]~>**f4u/s@:dp\<inGwQI8;?0=H=#o7pwriKcK9+?),3J;0/&4;a'?:L]L-;4CVH9	-;4?Smyuv&}DnVG@*&+'=+y?^3+i@J+Jh!}<Y08
+iwz]mL@s	Hmuzg[ei3W^}y+)/]vrp_ \iz?_SIY/}Z%( r#/;8>lPpH#qrX5e^$Kdu+gC5 $X*O[RJxf6WO_[F|++-	<LDwYWc5qozXm+Pv, `3mrpRBl2k0[;`m@dA~Z^9L?H^i\'
+4)ZH#Z_o	~hc')H`!m}zS+PnnidYqCOk@!O{	+k%hSNO;+t_G)+O~!v'mIWT;L.;o:Qt7\ptQ,4%o~{+={bN=KH?:IcUv">s5LgJom=w!c@Rz4F)">5#3|Mi?Qs|Grkv`-llxI=^z4H-e{TLp|z<%MX7kQ[( ?;=O7~+Sk7g+Gbf
+yh t6i0+=y{Gn3Xp^]6e#)R!cL|qgyD}sG|N~=tr~V<OT]~Eu)VgdFDJX?#8qv}$79}_>y3>G}l
+p[BK>HwN<(\Kd$A7^}_~^:382 3}n7PGy&=E4LL~	9+ImlB)7P^G|J{,?s@{[K{gcWu
+lC<0ARGj!B@JtDw$ DRnAaJ:J(&RC0vyUN>\vMgU{uOFbTwhIC/Ll[w'nx>|+jcV.|N(L
+c$
+e{<Qv~6
+2$uX!Osy\en=&dwM?^9m+I~&L=PYL%4X$~><_r_6&!4!
+l47lYZ*'0A9Kh[#S]wZa/2LG?3Wr.*VF+8t%x{k_}}{oMwy+Z6i2z<)exAEJ	*=@s?xFSZ)=9m^*.E{`
+;.+i:${G9ioQnkW*v*V6S`V=~g#Xu7p^q&yWk_uTVMHLd=hefY?}t2"2F%2|^.wm2+I_?!r+B3vY^vki_(JgN.u]w^Iu'z#K="	?Fs+44!cP_^zv nV!&}Iu^A^./#<+
+OK`1
+N1pS9?(;@2-$f$B
+)(yHn8X
+m9IP?.DR5;oyW~^9eM.3?,v|[/F|A-1|s#<LT`+@2|P_$\uX@K-MZn!=?W/K@Gv.CEr_%T~(mT9:zh~[>"<s7`Wq>-G$C<!c}y_wn!A!xIKu)*J4PjuAWaNR#zB\gQe>Rh/d~Qgg9.;m%7ab{~+*V[1/M|	h#^%G:J?O%?ysAIw+_]Fv+I)bSTW-.92Sk_iJyPO>d+*|<O6#G$z1 Utb{/G+V\{	[9.#z6Dm;Z|i^{?~_m'2N|;G{oo.3<g^;{#+NYw.gpW_+Xy:yV+[+]yUH#}
+myzzqW/1O_HZ<w81Y!s=G~+v6m[/A8O9f F<uv,^IP#q3H`'niy9;q!z ynX@+
++]3_g`#MEJT^nkT>f9^zz0q=Lj+&1mrPCy1km)zy	vaOv7H^zz@:33Ll	}j'<	?#Uu'n>c:7r!7mt6[nk7Y]'g}-_}msY-x[lr{w}wqM7tu]w_~T'N|P<zOfV9`t g`z,;0<&^&zO|Sz&S>>S4IxMGIP-s&%MLMMY$
+U[tpNt=\{7Y'	~k_/r+xQjn{3_d3=tnET2hnoIOzazTMg5)	s?HgSj-/>>/?/_.rRDZ)3P>z~C/.YL,_?O~}GTMgi20me&~hoTjWK'^_F8	]G+/v+t^v@L2EH@=?5ySUgkvO|m9tB(xv[n^z__(rNuUN->.ne3p	zgg-n,Mz<~/_>|Coy[>5.r2pOR'&)mEg`@{u=>~:n'jU!poo}yQG}+ wV+PCg`we FqWSxUy7=qicD~ c/_o>|G 
+k5Ok_)N}=+6-;@MUKNe=vI<x<OtQp-;\MOO'ExS]_SZlEJ-[ugd5KD7J&1aBhUG.U?mi#7jkZH\v:|}K{8Z`~~~#f"KCs>P^v?*B/Io	+'!ptV*;k6)T>=ZYkhblU5*	@|r<57rAzr#l
++MO>%/yJ9 qOd=@6=@M]I*&}6nx>xt+.8;j6eX y*8FM@6	>2r	jP$?lQ'GNW_-^@ }DMdwib\l?@M]]/zf8iO{Oh";SVPwwg>]oUl6$g(i}Wh,tt)-JLJ6,V1U=+	o 881\g#+9kh&wGy'O9uJz"qz.,/?n.%^s9]$SeJX.G&~^x;~<Y;`b_W5Y<la78c$*<$lx4mlM12/JL`Z8fOkf%dPi	.1}ehX6!`!rdXo_?hx'8v	Z{Yw;;I/: u@^ze7]f|7?U	=wNM	{w3/wh
+Z'!ZOLcbLWYt&]k H}9/'1l%Nd<%m5bV{:]3gFs5hM-JQ}`_/= 9KKup~!=S9\=y^O	V-}}9KYgx} _5_;|=Crg+:p>oU]=Mq&&3JVHIk&BI\,DXK{Y[avS%~s;[)G\&{cr@LXZcS4	~#:]:
+
+Ga8tZ}j<w^G>'[+HtsE"(`4Sw^7?=^v'qNeWVEcwWI3&fqO4BW^zN2j>n2Li@eo>OZ$@I5IAY.=+W=-(SgF`n
+
+;+Z<pGa4$a(eoPNL7}#VAMi{7]~;$
+{k3TRhE^+Xc/R>:AX,1f@""~>p)W9"NszG#ijPESi{Nn.dBm-m<$.m]vR~nGGxpgj)s0cLB0X4Az~1| ?sd<9E?/989h~H9!HC6
+PEA{e$Op O$UF@=s?"=f ml&;a7j}1Iby>*E~;	+!oM5b:L"}>`?$@8k)sX2Ex&DJ%+s~@f*>ub5oSP%BdfJI/[-eTrbw.],zw&CjZz*1){%>[c0}FWCBQ%\=q`SFCOO^; QchA0BRh8Pa7J"k~e:g?h-No
+!
+-/8W?7|1Q#pc'D:M<7i_^r*Sxpf%[_;_ds9/+|p!M;K^DCnW?DwK)d>]=_H5:Q@0b:c][tD0Mc{B*T@{IMoCrF;pv$
+O-u!`.>	IYZ:*9T5*/q:hI\JpKbvJmEHA7d1Yc" mDLG8\Rs}JHhH/J7JPwAk-+@^}8>	O>E6T5~tS:UOc&434c4
+SX ^#U)[YL!,#b":ceT>qo+EoK@'e6xRNc}_DlDS=Q
+ks,m$=B:MC|deWlUjKMYn{^_xp{PnkR>;kt0JCSm~oz=7M0r5zqX[ca2`801i,Y6l*K<|3j\+l6D`iohS&[^:iN.V},^nag9?#?!-g+ej}5Ol7s%-hWYQx4|%>?x#z8pK% }"NP@ceC7D0y;|vdkwNHw8`T#F}ezBr:/@h{FYRmq6}.Bhy
+4_I$"d+zp.|YAJ}PihfiD<.3A;Lu?b?DU}\+MhE4$oBBVpVJi1j
+6y@,TqEl0\]^}E,I>	kFa .6@hZE8;{_h-5S3_8c;4H1@a +.Erxs-?b@d%q]jpO~,LaOX+[,Ab_DcB0`Pr@Alh*?[$"qBs0E)fvK4X(d>i|$GB8K|]42f*fe,r.;~nDoU8	A|d o%A>/<^'i:	xl+uLOC?nW	{yW*Bzle`EPaz6=F}__V%0Dt[]Jk;}K}=y-]  hn1Z(/6Jyf!5LIC0ja@IiCk 7P*9an_&('$z;)\g28!A^*S=CXk1ii5`rvgpoP7(eO\;B!SmV1`oP#jKOft&{t)+~Ok?~ +^r!OxK_{Ew ^Ta@PVs-o>V{nu/7 Vkz?PLf,5mdT1RbZuM5X`gpY&fN<U;C]I>EQE;#J!T[HBCGWsANDDlXGRNJ8
+;8FrO)c}:tX#Jt5_xg)Gt5A2p+-$@[K1qVStVtv3!rx\'p^urx]t{20{Y\=@mfIN+CWkr[0EBN!dFUeF]	]Jv:KVG8R	2o|`LfB}iS7,dTtHXxALl	F,Q;+9Nfe@Wux+
+8@`67"+Z+Ni@({8;	taG	|;[Mzs]|jnWDD\-0[w9>ZoF1JX?IveRNBnTU>+qf1@2ao|sek}	.uUs3f05
+m\;S7M"f]M8i_Hy?AO
+721nfaWg:H#7#?NU;&lOGx+3l$)w.rw+%"^^=jMa^54=K.^}&
+{|)u8q\e+:PZ:8}e?yjMv	]vOp	/V{na@kFzWPZg4\-!{xviMF#?;&kLk@Fq2F(K7((#Vg+8%cX]w }0CwOXw;CF"Fz"&:P-vZ%#1JPW,Uz~O|1cc(vUz
+{(!=et,mf=|s'z+F9t;ps^}d\-[rLlbDQ{%8=Si%G\JvKjWm@$="3ewp>Lw]ET^1Wi]s54Oai:3O+p1IA@Hvo|^@P*VOy8Ffl.+}wyt\M7ydY|c{y?n&HrXheu/{ y.5S3~{>_ou_~AK^3prp{f0`P4l	''A+,W$dA(9#."b1T7[=X7Zb4+Ur_F"X{#V8A;J6lo
+:}Ss9rszW@?	y_wt5u0fI:p_{]T8&xE`h0JfLN^'rMwXxrK&S1mk"1Wqh4`.qp*+rxEX-f+=CSgG:>YHj^ O~DS
+NVq
+C+?AH?T3?#<Y;:Fpo0/~i5ROw%r]+^!my&rV'se?YNKOV|xf_~B#z.x
+}KDMY$R+_wX	BUC"4u/)&K*xOe?)'n+g{~:<@0xgBQ]NP1#gV`Y q#Er:>\~
+TGJ+Nccy,Tq*x(zo70WX#\*=U}3C$@'&ZDfgz=hv@]aeI>XuRS(G[M^ '@kdDCOvclUNc#l3Z7N"+?Ml)Viy6e9W'*^Q-;b'+> -!U,/[)`}*=q
+U?m_8Z)Y<E/'G-~:	-[q@{'=(E!r^vabB5drK.Q/9IY+iM73<.N;$Md8;\T^7wq~#<,:`k~zEeJr[[%5`13jla(yh%F`([A?mwez+K@3[,{|!MM61'':7&1&"&U26	z(baz%qem$*Y42~
+nF*bC	N6D8dG.5o;
+uU2U-@>`#zB!AVy(GG.(_6mV%s=IO?n/4w=+S:v/XVc1]:f'm$\eW3xrxm2ho=|Yq4I{[w8:@\T>#]UW]sZt+udcM|rb.>Z>a`ESJ&|\H]#&LNIFn9g>?L!%r6(K~F%UtTlO/N+{hQd"=aRuim|Fq:%&1A6AWa{g2b1K"p^Dc )^1G@1`K$T<OZP5	ra[s2?F0Zy['&YFk/%KN6Dv|p+G0"e^bt<U8mICW]E?'}+EG&&Q(Utv?pj8!taDHpuo'0,ftaCz`1E;O@	Bl?7n5(g6Jy,2J	+EY9`JemSXjT5P.OYi~^]I!<AOq''X-/BrdZY]u"C->qse{b^@&l16/qOZJ]?&9ZF`*&Tm*9b]Fa;$U'WYI/)Nc%HRv#_=Aj/+%56>XtYT]cO!{0&26Z+9h1RS,T/)92>$n4SV=qO71pPvc*E3xcY3th`O*5@W!ZQE3Y29(XpB@6V)73=Z-B"L	JUWj*lWTsYGoxJclQjea6Ns(1'0/oVQNk "uX\cY>DqxeDw@ur!Cbh/" k8n(cSxg1tPtD+6L [6y.{;X;t!E3FJa	(	v1&
+m%/-_@:aWJw%{=#X]''+qPaBFLDoV'3LRpNbO5Ylf`bXQ26/Tn2?O<,	n]FqOc~v+	H?Xn"kH`I;m1-/yuU`.X?~2{gP.Y+2=1]@v!P~j7OINp(vV5kc8i~O#vk}
+G:j!h9WGT;+@5MA8}UNs]&+QOVt5x[jmP+'M7'v;Gbz<7>iO{]vewHw,*df\QRMl^?iv~1k~l8}+G)R\M]_dB.O]U.=g[b](vxibp18Nh?}`or6$bQd	t}xd{4lH0<tN }A{>~Hrq+\)fH|C2hTp=07G1`D|?C|jLr``7VLLT,F__0CqHMz8'6C|"O(8[5N	6c]U'0n
+[?6PQvI<Uyt;V\[y`9zd\xd_ 
+:9>6at2)#:r+vL'zdr#:?l]w |`X2WaH9_Z:\i_o>1iq'=	 !]te2.B.]88K.)&:[H;jmZS&OhKDp-48#xZ<[d5D",4"Fa"Pzf8B]Ge>2Qz"(3=YQ=K /(YZd{Y.M~`\uDbyBH>B?l&>~Y3,SC0UMPGIlGK3"fPv;>@T)SMO\Lyf:26'SjaL4DN2'L>Y?0@@sDE(wX+a[`2[KktS|X:cU^Vl7,\sBg%?{bLcJ1/~lx[ cm;BgC-V^g`sW;!;N/qTfYMw:[:>t	n8Ep>f`z8cS1`W1eWMt_mPrpE=^ &d	Y|^F'g3'1n`]+^K+.YZQ++5n7sclkL1>D?\i.%rzPdNh"!QP
+52UG
+5fSg"G6 { IE5v60!LaMBV1	VaGhl!Pp~ o'ad=D\M\l_{::X'$SC6_c)X=	sq#y^@#]upo}E?kv:pp^%+>x~OtCcA,I@PEMMS35`YY)3g`P$y1kWv%CFaJ	i`9g@y@eXx=H,]TAnew,en#Zv+(b-"a}HpK1:%uLcSGt1Y\N}`NC]5t83suOXR}*~\?ap+Vj1jp^8DBDo2y;p	=84;|ARg$G'lO`Kg^jQbXb2I;+akC	/iZgv['?2$c(%,iQmL=;xC-"|F.^v{i|EPsvX0-e_p"GR$>ab"Bb=b	~YhlJFq|\Elea$}B 27+Gj9QP>j	#vHp_2vM2N_AMr_l\1	wXtKOo
+{|Rt-rZcH-W=w=mZD%3[@]j$a}^7owi%zFq+RzH%+/LnIMig?k;{<'(8V]|3oTe2Y[%?)L2MLs3 d	
+|c3[lK][.mp2l*^VKCd<kj!X:jcr@K"Q6)re:h#n#+|Q[,JU}Uji
+9F#eb19I4JOY%cCZr;x<c``H3e&VZBcy9IT'zY.bi`#g8~y-	U@W,51Ck{trp
+emJM[w?zWM3}{^Yf;9=`,~O}{/9UO~QGu,X}t1&)SU}\MK,SBf%gl+v@j6J-F,$WwV!<	p/~3C^wn:?UG^b^p#"FF#|CH	wz~N+FR;eZ>74Rk|13`CE6<>>!Z4A@IiZ0NEqm+_c_0WR|>rAd,A-!,!mnm6Vht(N'+Jx-*kV[Gc[\:#*d;aqn E_k	Q3/Na{EzYBL`Wjq1`cX9n6;,}!?);<+z-2+-]i1QRG=%LZ 5 !)5F-*wUEXXY+C,V}oXCfN-QF|F.ogAd#VSZQz7UPi9Y+z^&giDoqk`m\o}i&e*3A+SyY8-,uQT&=mAWvh:{`2|}{<XtVr^ Q.0nAlL6g)C):I}[*
+~{NaFb9a{E$Bk>Sbs/ Ui_El8U6g8\$Fs5	}!ZZ+x+-&JwFDM>ug|A~zNuL+qbe1+X{D+hd1{vD+lG ZJ,E)|pFPyjE;@RHjHp(aHY{m@ccCGZaaqu8V"1/lvi4 xXkKr9k7ZMcAkCp ,7k r:JLz-Y-H:fAi8'!3-jz{D:B/^E&db^&u"bqWeJzMzX	A	NQn<Ed98*n$b+fM,*Y>)ZzN|~cK656Zd@[t;m:ve3iC'<a2i>J~<U{BOvf5Ol!G}4?'tcwZ3;>Vi	UFm6byNt%/RhXf=kk<!&](C/E%kHfcBubn815[%7J;wM{sq+E>/XO>oO]*REyI/+<$Pd?Eu
+4}t_:{$	>Z=]ya{F3yB~Kmg4\Wb_Fao5WE&jSaYk[j>.7m"yb VTDBW*A<Aq# ,nXe[\#vsD96=OZ;ndl/'+JxjDmDKMw-YYAE/E1qH>d{&+~uEskZ>t",O3BWsOLw}X,gs+~?8_6/.SOU=Bc/+.p: F@+C1X(
+rR'p_QzLF3v-_x#@+k<kO6\]VMYC9}>p}@ux-|+{^To1|S.3.N4B"!-OR$tH-qq;eDQN$OHG
+}UkqJke<6	}0/~?%{"1!v.sv+FQC]5dpf@Q6~*yHzAsJ
+k^_</+zHb!<#>'rM8`h2MzZx]EL1LH+>@_?n#!eun=l^)!8;D8F[%dLQr*v"N}_)N3|*X}J<eE4vs=h>cY`y+kY280~!c!H>iA.zj^98_msdGP/Xm"g[m-5FW	9f>wD;SMxNHG<T]l?bS,y+w,q~R+3-,ueD(p,9Wc*QM1-a7wSqnmgH*_rA)eJy?qM[/DLS]e)|{b8r2Rr_lL@p+k4DkSWc:YST6huak>8Q%@S$ _a2h&(|6iN
+.Y`QwM;o1,~^qA
+j.8+iXcx\]"K?#-d)Rk?;q2Dj# 9+&=j7tg	iBd@"u
+k$rDY]h0	s$h.BS9A#6l4-i=gW^5t.4O60-.^[XB?(.hIlHC
+<<hs
+w;TWA\(`6jBua}.w.D_b>8#5K]g_[cEm@Z#U9E,:-?&? x,9ekw>iN>BnUvS',wnHq;>>:|.*daKcn!Ke?9hmbpw[;KDrHh)Y5jf,:QJ50upWp.;T]Sh"$s5'pa%;a87%2W}Kt1~t/JCG2Vws33Qn" r|?iK@a~'NLL2IC4|&'BA<%_i=iUQvrf.D:.iK]B5D3gN8|;=+f4m7:+p"^i_Xe]#CO?~j|x:p$lJOl;&>eed<WX8]++k&\=LXj:mC7!-kcnh^NEH2YFv%~:hnb"KY_!uWuUZZzg,Eiv7oOI+4&>i/<D#y"z{V|saiNGejsyWTb}:f1'._Kf^<$M
+zX?G@ /wt$)yb45X`J@nlhY#&9K4'`\CZ'}(/>H,YY/$|ihy3mR
+|k k8ZQH<Mlucp0&L%C?vE%eUxvZ=JMc>w&	ehtgNW\vtyNtFww|Gkl'I\1W~ls/drlyC|]i,(TS1/.
+uF]TeM/31v0"<MrG}D?n/A>AJCcBqj/?IE*fwRq=v"v$?B}L6U;Wo=6Uo9lQ4={][a7\^{3VB{1z/?MS}>jGuu<3=;yIfL/H2m}w.C5}ds^bA\smi,d!K_B]EQ<f#ixVJ^(5Uy\45=f0#<qB/GPV>X,'R,:os[''K 9cVQM/{Kn|OZi]$w~nomuK6Dn@]gZsj#/"/zR$VX=Uh,@.qlLgpd-9F)[spM:Wdu%!Fw_V6:"&=F1(!B
+]	2'+
++SQ_l866IWD}'ewwy]Sz9X`=Zt{R1G=QJ>~ILG(Y.;4\LY1]XO+.'R5F*obYz~]5>H4BE/@,t|92	?o+zq9gUJR/7~F8VY{r97z/Fp\>x%!z	80x%Eyjt'f'K|>\Ix^4"aJoc52Q|k?GR?I;N1)'0r1S/Ow+_OjN?L+N[/vt. N/2FyXYV;j8cXsR!(<Etk;:YF%
+:cl	N?KQ%Rns1bcnR-x+~J|/'f&$)Axmyia3VE=<JH5ng#jS|}C2x=F:NvL9U|U65+W<vo:Z[wQkzg}YW+Ac0||ydJzbxVFbD~)0&L1`#Jua:g%cDjZ:hR/XHDnK@O\}ARt,E&<
+6+[\/$[MQl2]K"G|DGn?K7kO>Y']<O<w[~J|h_"7xK;mqG4UXYSI:9Eq~CXG]P!*,'kSlb6fM /2zNcbw1*r`7ha[%G[H
+p5K.$s+A`>QKImA&'Y8(?TDK_nVf?pd<wzK/}+/5r>06yDUj-v'V1X^m,Ct^89+(E_S+875uEzkiS]@cQ!6&Kkj+tS/f${ *?7X9cQnFQ)py&|[eK.;/(rX491Ku!NJ}"Avu4M.8dv}p7qRoY,=/z?K?m4;!8t3e[2Xxu*&:}WD L]4#yW>gQsR1f9TwR7?SCe~.1vjkf8 ~"y=Dcd`8IiZzkz99[7#`v\4hgSc>~zwzF&=gh`FcBB\\0kb[*8?.Otb"Bc[AM1/U*%ZFbG6-j	Mp86rIV"o1-}G:.?Ak#>>_SQ"5xp6838/(2r#_b!JaO3$rK
+%3Mfo?{4Y@IuQSq`pPR9	w<n_)]r!\~bjjEM>|8&#v.9Tp@|Wgn[LgL'J2_+K_#Bhm-sAHM1WrfrcmS/<7z:G$Iz+^V<uqZ#10K-l	y|#	RZ+_r +mEeq_i4`sLhBk/Ycem5?cn+PSZ_)mEQY$5+I,,[FcY[uX#eMh2M%sY|*J
+Q4V*w,a`|SSDbIWy<vzY3+1O?3{v;/+;/{CG'n2{ZuanJ4}JjbH,+J$jb8
+:S8>>N&U\c gWCrr80G~chV+v<;		09G"ERjK[jA-.n6Oee%STjID1Y L$u.A(+'RbUso> qWLoKXG\p^=x9+9r\43%.	O[gX	Abj_,( 9U:#l}88@P8(X8g6[nYGp=RhWA4'PKm+="7is^o<Gn?N|	=:RB	`
+iQJBV5++GB=1ckgn	t	wm\d4sO?M]z7+.O&P[ze@@G/g~2<,roR#ao>+L4+/m#V7j]X,9P%U*&K3(`PD6Zv19
+yU$LgdDnv2>5O5=ucDC\M5=0M?cwY9i@ml_770/~p_.Ae3t\ES;kqSIGj87j#[Z-mex31#3;L}m.MQ)m{5-}GMj(h,OWRFE3\Uz"\!S)gW{[f2kC3Gj}Ni~A"zQm}Lz	yA%vLDW_aLI7m`o+wQ`y7#lee#d?2f19/f!!dbh	^xK(A4+6dmEs3!}PF0)A@MjBt'##?;"C7?Z>rPljhl}'t_QSUOo{+8!U0e:LQJ3}@[vm'B;=hRHA&/){-CJmb?n1"Zl	+@F,.Za'8AVFdJWv7vXZ]V|6	i/~OeY!@`&_O8X/X1G/!.Zd?0NP.H$XqZjPIFW1#ThZnx2.tSX9t%mo&AcVz5q oij9g!WH|@yM6r)V:d\=EW.Li@qL'+Oj-0uBLYKUlN6g<XvtFuY0nu4P|A)1]@_184/,U^<iN5yi	m7KCU}xPL:$tU77<rmjE_\_8<'Fm^%~]^**3J})%(bGPm;Q5<^9L4%2a0cm"jy1*s?gP#u%5vS@66Z5wJ4(0'/U0j0g<^b})9t"+e6	ggrv
+}M9UCD2>'~ug~T3EOXd; <ahB)oY4DOGRuV1\s}-K.Aa~MG-[DQP`Q<8
+q.9_{q-8B5HZUQiue}B5x3h	6(r|I3y	o[87g8sAFKGbF+gGJ!Xjf>~PJ`1V-Vxh?P$H$>I1U$=$WEJIk L/L+o?Kb3V:wHgoWg:+P}$_\'!k9/R-A/p[y>6i^'MXoVj]uhrE|\v,K%[r.G__{_?;%aU#J`/4VqzVf(d|wYo EtA++W+uy5ukG_zFd(1wI6Fq]qpU/g\IE5l+4WhV(-Thwo<rygySWb\yCuzr]GHmCk?|9M7YzW__-\5~iGi:chbz>NKzxmU9m?1l?&V2m'1m{(*t%R@NX=wc9.zLi@rFx3
+ZdW<p.p B`#'gvS7dA)X[+MEu/kJ+$R_3B20m:%+nkq}Gb30<~@, A= tqPk!>]J,SM;X[Tsan4r8k/(g{MF%R,T@47LFFUB\$yXB~bf/<L3}<>shS{%Cr0e"oKE|kph:v+AU_7ap6-6W3hgCQzUW^=hs	C4gb<%>Kv!r42.>`+bqHVRxf-,<\CGQCpbO>SOk
+0a9vMCMy3}ZBz<R{SYa8k)]4t\<H'hV*il"(0knEeMJ	~u$+e6BsIQ/PURur&oN$Ar	~Dfs6I|vP(:m,Z`KjM2paJ&Hdz0<_C?q'cRXII\8rLP{xpC~dxmw}E!<* Fh!V\bnSS~Z>Y]#^1/h'>^Fcew2=*bo#E&Qi9E2|K+tGLb{lxDWm^}U,>|>tPdPzpgk} /]!+Dnas0hx>hKxis}VE];[e|]vh?)MAk_N:e*HmciFm)g
+[Go,&mP$j`'sO3ymyw5<qxlxg#a?E~?5k7{p'[uu6mvTv(	~&Ja+6v+xaz-4$Dv[:0H6
+;d.VhmOLlOzPF}A6neLD(s$yvz7u5l5V7o.M\Qw9+EX1qq=dHtGkkDhZ+N<S\:nrhJCGm-<>AQnen|dlGj`Oa)W38j3GSl[+;2m;wB|{Vme,VN?-o-,pD?G{__}X_(?`&,_4l? Gnn~d$TJ(lxU|L{8!sQ0aO g90[*)8z<pg x^hYK
+t?K]zkZ#G)+;{|_qx>iS.32(5h&E$)df'l_Dg.	FD
+<)Ek},/r}Qr#9i?((G)wC__xzMP\MflMTL.YgM9vMIBjR]_0F@f]#YUa#Opdtm_fR/-yDd><Y\rh2;Tc: ^ciAU_x{.5fxcnuW+5z!E+/7_g2?9y<>Fm")R8c"UPbF)W4K(dQ:Z8_)d#U;5cYbkj_Q6+[c8j(WuG.]v]
+:FQIan*X/{t9Yok_S;Wv^zhNz~	,>B+",>E5j#~<2W%O7-x'j
+UGb6*n+/k;~bM}~FW.>r&?`_<}o31yJ(Xp
+8;rXTDJ\X6fO<+2X,KVk,D<}YJ0DtoiLg+>G]ve2d'5*qC3-SbE5G}p`]}'+tQ	c-U{/(YIG;2m	l3m4_qQ;o+Y)"
+hg\d]=v{qqz+qqm6+eu%7x!|ed|g4	K\^\jC1T+;w1^8d.Gm.e )g@R  1gH	U_0R4t^c5eZdv}fJe<b6)=vdHyhpw~m~_vG~a"9@U[%Jl$	:^|qx'-Ii!.|2tazc{<}D'{2$VbZc4@N]"2>F''>1%6>D[^}h<3AM/02+FzB|85[^tM7\ w6RUH20	NXeAiS|J1+oTNCP*_%m'Y62$R|m-:1OmEY$g+"{e+#/@0mUOw}Qu(	ukSNvI2=HKz"[+Rd(EV@C|+JZsOOC\AxR~cbq
+'9{s{XPLe\bk]hk R>d@HM:YGzJRPj	ImM
+-_s3Zx;E+?oAz`FP9[G$C=W++$Vm3xhZgt{+.LoGW|u!cP\l_1+ 8=SfIxJR?<s"Y>ZvjKy+z%bZ6S=o]L&A8"JZ B[Wmz&~qo)_d3m|sY*vhR5s Pea"n\	 8>X	/dh.:R}Af8qV98BM^hkS9H0+,+{dAc~X~;}wc\8^01q.7mC=5vqI8`XXV-a5'?96ooh1VnuS)v#re5~-!NQ3/w-i_l#RvYm6y8Bk1>+n+G"[Ni1G,UxP+lA"X[+aHU3v2&H_$tl^6MiQeH& .2!tc4XNLj8syx%VcO{7V:]^=5BhA=Ft,R5>.8Tx@S5H^/,B,?g,xCj_IBJx#"G-EezO/V[~o}+tM`X_oWlz+7 J{38G7M9nwp++co#FOfM-KuCuUW]3\|m:uk1	bZF" b~k^+=5^W}P%l!F8Y[:ziS9
+I0&Ps0]Z4A@{.+o{mw@f:j^|@{`$X6v#}U51<P1>I-lop+g|x|m@N1\mj8c_o*q:bnoKHj{8|y	p+N3d>(EH>Z5,Q6ib,CmbxyS@bqvx1RrKNE6Vu#:g5/Jh.cTW87Qa+)9b(e8R2`$p/<cp*2N+j&#?6%
+,2(~L6hV8R}ZiS7JS?_R>P/Z[X+Xb"1@q(:?!&a6vJrk]{:,mHm/TAt?g>?S}fF7nK}NC&mgcga|I-+ 7?w7M!???V/LG/YK6%22'XT	/!s,`g[0 8e+|BEjc'j(oCLP9^+s%W >,tW]*`+^W[jk=<[;l8lmsuXIa]U7Pdi8xM+z*)xSN>x&KO\>ma`9g>6G)+
+@m )/r7s+ITP!DrpQD^*'<R	~dm0$(rQErliI"&$4*+tck`E0t[4[+t#6=J#s06rvm_	jj'3u\NF~te[}3pAA9*3v6nC|{sGS_1V)mwz-/IQpe:Ks/G?+9Mr+QaF^(LMEa[}X-/}zpX
+o> Db&n;2,+k{T?R7)X!^^1his5)3S)IH-n6wyT>cT6(D`A'/_<e	lWLmjxi|%F>_x
+}y.>MK:lJ+K\:9HP`1K2=Qjd4},dnU;RO=xQqFj8x%I x9.|<sBkY:vR|f%m~C~.m}}
+(NkC6
+KV@,+0MK[E8k`7~;Z!%uyo'#Mc,M]A!|5BFr#|@z~N LCMXfm`[/	:o(]NN5}@:1;Q/#0:0/=]GzIlT5$ nFt 3Hz} 	k&ia~+k#lQbE[Aco?{zxF*]9_P+lf>pn9>^G@4?X.dOOPl|@[0	4xhqJG-`@"
+JgtNktmcc+hl-GMalO"/62tWY
+K;TNiBK^;d'D#kgjZ59
+Dl)51|~c8WPB=)8Z0>4xo}&qtL/95mrTe>P<7t?&+g]_"|,lQ_rsbZD;L5(=P&|6b`[09C^,=VD@'F7/_2e}?~+!;2bYzK>z'I.z)xIg8&u$tCW1EPHJ:<=g=sq)9mx|X+a#vV1VY+,l>7]G51Xh5=7yG`qy>|W-v]0TT+Vv,N0Y4sSILeDV81\'_`E;@j^1BD(mSC)o{7})pr9-IRIZ1J>IXT&#78@nNCcl\YGG?{acf/RcyS?syQDb8Mo<|G.wq6>~DSSl$^VvBM5\WCG?9n2g^x@04aqNQ>JGB=(\G.O|k	LAba1 k	6?V0'LE(G`+DKf~$6^[\g,uCv9
+F,b'c1f"h1)U&c%D
+PpuG7MPrBb"f>'7"Ad/}@e'l{wq>,W:PoU+UC2w7^&J+ H_B|)C<0rFc	;c|GK_?x/>8vs17|{#cGwUL1x&~L8b4ulPwi{ ,BH Srx@\>ZS|xCbGu9RS~c?c#FA.M|y
+<|Voh??Py+cR?'(-!2Qu(>c<r#G[#*4GxF4z.Jsyl&v#vK7MT~o[Sc'6	?3NFiC;l%k6@wD9t?:HAL6+GB{3<1
+T?x@SiOnR%gKk.J5	z(W9juM{g.3G~*|I2}W+O 1q!'o*sK'@??]yPGOrDeCyYv27XoJr@yr*9(hSeUq"~	v6NPa+E0:f3tW~:^ubiN-=:id^UO	rC1%C>BJWT;mCR(O<;1MWG3}2Lr
+&UNqnQ;^8+2@<\>R;{l1_}W+yX/
+q0J}0_@Xk)9;*@:!Omj1c.C7iDh.-vo|ZUk95=3ZsK*_	zX?1yp {lupa"1I^$"1G6r*Rcb"368saS|e"Lr]*>"!LTE&mHNlC^c*Q65mdu7'f(*iJq,y!["(>!6AD"0
+9@~&
+Vy^\Q_?"0!5nMGz?q\wm]paaoDS7=v77qOXhRh}zeyxe)^mhlDKc!O},vQs5]r&-i@mAYI~(js3J3&6RprUZh?GcfKjzqn\NPMCa*:Xg"vB+OYE;Not90My}JWcG>	IGI5xMX(==dCylz3.N6+1eLujJOWMgZ0#;y{iB}AXNd\Y.q\B?c`[#H	wpW~ygb~g(wn%cxn#jF72Lq.^fd&_RYO!XX$`8=p|Di,.OWBOLB?+vN)C zosn&Fkb?&zo@`	+/pE-J<=MuwX:e4=-9szRxED\sQag9gt^O[cr"|s1GOmC7Exd~>6QJY$Cl_G+[4<Q ,>g|@,.IOoGx
+MAfp~L}yv&:)_my8u]wcy=O\uyGw~;o?pg(~[$d:yf,8n;"F6m#bd`'pL?huVikG+S"B`|#vk."wuO8$vT'?}xun+5=|\;^HI zP;ZFFZ20+\Qx{2X8L;
+A{/
+lNu:b ]:#v'N`s1"E"KB,q9'O3\._=o#Eb>+q`R]bQAE+Z({H+S]>}b?OXdu08e\6_CdDo[^vev}G~,^P+8h[PSvxLo+&v#,?Ne>(">R|6;sM/!L)yc'<O;?!^/w_u~rg.E&R8~|v@:@1eD`5ZL/VO)Oq9|o.!%s&.`:(GsY//wyXCu'{o*}>CrXk}*Nkh4gAA@K]Z>*:T[5y@0JG
+Sb6+7to(mz!34fJ};P];_uapq5/ee[Ajq2sn+q*oz:cji7MA=ruS}pU~'GbP)6s90BZtH]ZZ/Y{]a|@!N:9/:UFmIW+O^(+6T0t&`(F\BCoqF+K+c3DC+5S1kuL0JsRog]O`x\p5f7}wD=Hak GQ0)I&{.o3yrp )1v|2>R+my\<+}*:\eS[@JlS<-0}39o>Fj|p,o{J^r"i&qKs&L+)]E/%?vBm?!-d{+n0+Tg	tr5piDc=8}V|b	W25<}F@8vW%+l!\+%t+~$%KzVLk#fa	*B=0n&Q+tA%t:4"x bSle`,C,PzDtz^3|{V#i||9fn*Gf"^U(:fwx?W:Qoh?b[wpkt5vX*sXqpVW]T_h]ZIUSlyA<vD18CF|+yYA3[g\DJw(1x_,bK,)M7SO(Ehywx,irNV	~M:7Z7:~hg
+L=TeBZ)>bu#r-fb'?|rmSB5Rfl>6}mn9@|D{-m<@(GL2V,0w|A+ud0kok?\zWlGegx3A;Tk6xbWYEulf>7oS>W.8EI}C_\4B'&>K3|`7;MDM#ftSsE G|g~i`UGB6e re_mR\>.N D9H5E#M7'#
+k:'>)OC/sz+R+kpqQ7Hgi@Z]>v>R79'Xxmk(')wCsf9Dz~xGid>>KTwB~lKY87 S2<h\D3KI&2<=SMFC#dM`6xXet [iia..Zqi[e\6&hQF\X,t|3R>	8~s.&pr|>|~a5w}vz`6ctjYtJ#)- S??v_O"GFb-_}o{xn7&&9rO)5L~/!XDaM+VH_9kCR?sy<RFD90`3}MAbZ0H'U}]ixk'Vt8`g^3`]4M:Z[::X&5*	|.)1H9^"p`G~>'}?z_pnV}1q|vO{!Vy6^#`^f)/46JaXH&)}$4HfJ i_(Q<kNW	 
+|_de+W_t"B;x['s=%$2;.^kFSgc`vBx2Ej94Gfl$v8hhkSjB]=b;4e/6,eR8=XQ"u5=65%o~wm{yTv7qtI.SV]xXW#m+c||o;.>3&gB`}B9em1||)*
+p}+i/m#YL94j}{>/Q
+9lbnn6FIdQZf*0CX+yb>R@{`c9h|nz'dx0in#nU!buBh Z{A2y!vP6wk<0AwJQ58h|m|jh`^|jkU/!@K]w65~:g6]vqb`[3{:aER&>PFTOjipi, &(<` .{W]+Go/HW?`+q$%8#vd:FvP$TQj<b<EYe3,-:9UN @C[<rr"z.Ob}iPaA.^sp:	4~_vYeM"@NsOgzy<c;|2kQAK<R8Ec{\weh@riY4ok5+ 9i@-@-hW29WWk#gIUvS7F/(lQ3+ym8U&> ->Eu}Q/F%*Y7skdto}[ogtsAl{[cC<.R6}9Fy<1$P/iq@cl4-m.i&Swe<Y6ZOutAY$}`uWw1&2/y[4p"0~zz&}~G/'&y>_!{o}x]}$F}l^k~W_;S8rN0ETO.H<v';i1B}f#)s,-2TU`S[-p)t!_#j0cW8(F%+%{eL/c0:
+i=~Eb%0VIp+vZ__F!Q|M%g;sDTm5&*6tOI9.0)&K_Zc"Fl\b\8U|,@7CT_;)2m/b4+zplhc)d+c>[Ng=#5g+EE:%|X-h4&z&2<cY+>oug/(AU<r1W	h18npQjcFj/'Bgz>3^dwy'm$f
+k6yb8vB8"`g?L+22@p_9s{7Qvm[D8)}l#g_?{QG
+2z3<BH+`Fd#g,}cf{dpP33+62rz)!GoLZ-;S{a.wN.U-]rp	1>#utn)oyof6I'.b~v7tQX_O4CAve[F{w_:
+?Nf@F!dl[l)d49r+_9'8r^ZIi6i#B|"Ow{B0q+u7-R3vdY+yAHX8sjSW9c };Fve@~0;{Cd\T,f=M7~w~7,VnFO#f&`,5sAu8_RS,8[Dh8,O_-:#*BEO|Nkeyl	"7:Katk1pdtD`sM\hmv|F+:/563{\Xa&L&Lv	RLNp{fL[p\rw4HlX7zIw	d(+kH?-+PPSc+Gqs$GPwZq_4$4O+5v[IF@9Y%)./qbG2N BNonlYS6__
+xJnuF".-	\*1W?@NN%Y3 >`BXCphcpY!(dzscJO{l:z>X-+j0\av+"?uTS`1C/-E63#%qx3 /%c*tQ>=lGITm.#$:_)%=C_5EK3tf ;nC2GX|#y
+h657;WN"Y5xEI7tJ*;ip27()OCYPss9B\dyS'fv9w^.'l 9seWtUmC
+(Cao-k|	q.|ILU	9u5{soH*w^azF)9y#b9698UXxIke}Nf'"`g	N(ezf;o-F|Ih/KWM`j?le(s9OKY!?e'.\?MHg|` 3ib1KbHIp>/^v.s3a")|a]xIISi}eO*Yo"S&9}aG@!^fCAyXae}-(P@xh+W5bOFnJ}[;~Yj(~d<di[pho/P4pGAYWD}6/L7%saW]D~wi|A$O]<xU.hb5^DMW+?=A%a9R*fc!+l I_)Ha[/[Pjm+|dJ6Nmc8\JzCKrVQ|c+tf~@g0X(L@u@b;	2)ICC/BN5qBI=]:Q{3_Rc6rvJZO@yh%Nv'Ej]K>ul_QD?Wuoch*Ugr7st}*MO(77[Ou8+nbYWQ 7}3n{riAL-!vj?yW2OR|"377m=n{o/{hUyeO}5GqcS&?',zB<a\R3jK/-G0,9|k+7@TuMq6m'{qZ\0.2nyE2$4*v
+}.m9bd1.e	&~+n.g7yW7n~`{lwNPRnMo}vi>-}#Kty62o\ -0@;&b];+y_{#<
+%y,{_d/"_W	~-}fN|\L=_5bc2J.	^2DlW-R `h
+qc7a!38Am3'GbwfJxcptrQD1aiHuMm.Z;?68^SnGxzpKctK=lg>QK3v2f'NxXXm59g`FD'C3	Qgy7b:ODRdk.x'(<B){+F74R~13c	V~X|&1o7@)h`(-8(9sO7\G.8`<OZ?,3+y|-v]3(>HNf$JXD!mX4=eUe)K-dToxbKTzB)e{g>]?sjLD<3o~l\.^!G,Nkn '(SfH'isx$6M_litoq7-.>@3k;?zj_OM}G&A~??{u\D7B4qM?*v(T<4+H[o+.8|*7Yagd'|o]Gb?}JKq:aF9-`20Fc\vZ5s#5]_qyF;t}|136sq=K&q@1Gq-&eFi)OD{=V0#=z~
+[Fbm7XL+O/ya+k*HN"ka56zYG:yA3skd-Fr.G*_zbz;3#E?0E4zy.X.kQMsWlw5WoWm]w]^Yo~c98L_q/]K	X}(>cbQR#`}"'@MOd0.ipRw5kTn
+u: <z=`]T:<SE, "?C/CQ
+c%{0+-'7R%d^-MK8D]/a%'_SCs3KaH!B&8AWup7k24xmKCGz}@o|?Og+ee#.'F"~sa4pi%gj	O#Ljb|GDuUkcqN9NiHOWKF}'@@q^2O[I?R>}t
+fF$;$fjC_=xtx@Lz
+4k8mNl{H/
+w"MoCo'=FEF
+bxBUn<<P?HUM0&G6hLpH/ZO-5rR'_?/M=TMa1mG81rCn@A9$]cb0t.E1hI`/>mn4>-	?bo'|D|*x_1FI1&\.5m1_hV1y+(0Z]	#TO4Z{bN=(cJ*\Zp\){mKt0l>U:C4x[++RKX*Wft&=U>m|}`WDTlz9O{-<?|_J?_I'k'Z,drm+n\NpR{0b~N#X~2>5i|_m|`T6N{)p0n`r?ic{0+Sqr=t;{ko`jX	C`3bd]{a+c-kbS[WmdUiXzgRBoI+4Ob"?P`|w~P|o/|KM!#}[E"g$ )c"f$ @e$W15?-&w[&*8W@Tv>1EMqUW9!76W^}Uv
+@q[<98VJb9"iFMO\?|t;-<S&Vomk!6(`+:L%e~(k9V,WHijuA_UDr5/e*B4Zq?{"tq<]+1Y~T'X'mPy1B-_i4X4a2><"+sr~3}[:c;hj8TfK&W:NJtNk/p$@yn<hw;rQiF'
+Tz?I4+#RDxbOCG`'Xa9/865]:6s'td&}a`q~6s`w<{;:o[?`sXGGnOsHn.PK;@s}I>s<(=LzZB_NY/IxlL@m}xU{^!kcx3M#+.2#lV.wq%hW	<^,s}o{=4
+^xu$t/DL5"91{1t \u;cr	Wc0u.KK]o7ZllY{N."%\ G/-{`2sNamG(SOK{Ov$HOx}yIqRhZigsbq'5+_s/j77pM/lx5xRe+b$k5nu+Z?8Q#YB,^ P{a.88g>+	)r~O-$r6Q>&254/B5cY>(	+4KNN1mH&,,K>L<6U|*vc":a+<0uHK+zpR}q0@aV
+u8k*&u}EfvOB_BW][Sx([G:?w{m?ou]0$8g}.vXBeeq+2&ELgYJ?P][e9iZ:+};zFaG~{Uc<;unie+|o~]}Fz"2G)p~~>.cxx/go?n?yj_B[lV"|~jt )aGs'+9YL6k8		?R	D	?}|mp]Z9zekrIrzkzF^}F,<,Hm\O&kb
+{P3@05m.~!9@Vvw-;EjUs"c~?'C b?!"> Dckty?z,`!y1Llchp~7#H:7'8];rM@"5b_~^4~nN"xd::Qc_?ya[+)<;
+t7)+O!Jm31;	kie&^d!F#7^>HG:.:~^M++]pS[>4xb;_D+8|T(kL;5}4*meHJkuFPG9kMpjt (
+uoa8a.x+Oo]~m|Fy%|qM>@n;"K^?xNZH6|e<vi>;Wp1~|5Me-bj!Rn!Y>]!t2yZl*U1BC[0yP@ +f0As}WlH_8K4[,^MyvI.^)o|5pW>xC<4w\@+vR]yq'%k>`nD_>,;wR+Hd,[p8M=9ao~0wNPlW_{mnc+a4(:b>s=I2"?yMg>&2r%G\/Z-(|
+pf_r"x?6!F&_m&Xv3~sw{>#*:XFUxRDerH[r!9g,NmX+p]T7!|I\4\5_q<4nx@(iYBf}kv3Wv,y$7y?i>7oL7u='~/+u#mP\L*Rh'mju2O0Wj;]SejYp>jLv+i][4s	tW>j_i>mw+@|.iTo#{Ee o=)4'x`@4<|n?oO"e"
+Tq7}Lg^TcU'\T8G6]>SqL/>I_::3+<h61FQ'R}8d3e^!4wDG+aj
+H_ct=4V!H3?8bju9I\25'Rf,"`v#>rYc`uc<4x}9`@-v?+>jn^k#<|R4G=Z|rO+$|,Np5/8<K'Zyu:TH{Fv {[`)Kl}X^s1tq@UKqT7[+6A(Y*1nNAohIN`NMW&=jhVG.Dv:<0Qv^})p0,7w+58gXl1gC0XDD +0	25nt]
+ze.A+TO^1AS4f7-+rGpCt']9l#9je[YgU+O+r+9M"30Rh,&
+WCdoaU#D\K_Y(buc|?LjFO}`\Kz-Q4+[
+ U7w'OX}aW=co,8[s-9P{7h-ij3@@M}ALtYiN][Av#^r"d/Z.!a.Q"qiX	*<s(2%|?e[Gim'N}e_B~"CZsGA<x+5CbXz!M&Z+cf=9Hs(+BBU'n.x.HHJBLc;ms<lIdu>9&YygzZR+'6uGEAfob_mw.";r_>`;Qy%YT=OdF.-k$&z:][EU36e,tH|T%;{q.p$+l|/iD9j+Mp=_	3 0=Ylv\#a=|U%j{&1`EGFn%/sLB$LASG7z[b C^;AJb.*^k^	h@
+'o^WC8RH}o5=zW+s:kk!q'3d	Z"?+<O/-nicSIPwo_s'td{w|pe-t|6WK=G '@\u@"eBN?2|k0MBY7`BWW	Y#aZWjAj~S"rvmgbF613vtH?O8"WMv)]O-HwRF6+fL6'SG!ZKAW4Z!LK+0$%bf<	bs!8d^J^l&imF_Tv0@+(c5?B^Tg+Lb:OS9++>+VgOqvgKr;ihf$f|F_%/okclx`>= xYdg1ROo^rmXb4k\Hi0:Fj=f3rv'	"k{:%>@T'F6)99LO
+@5xjDxes_;Bd?=Q-:Jl~`*:1J @Z#dh\\~'+#0Y?\}zxg	T6||d=#M(t<J|wmhQ/YRN0^yYZeA6Ra<N2IY^+^Ij("#R kHpEX3$[4}`uP0`|?l30/yG#Gx~T8Qlh+%}RMm-.I.]?tv]g7={c,8-8!xm " /~ ZyYc70E]) 6ymR8}0A&Z}nQZ+Q0IvD,?e1Vl`ecZ9WdAt=/JN[wlhtGJjgOb`nS/:B7H4sM+"B*E3SMbmT%6/((Um;vN?qm$lcI9+ISIvv+^+o
+;E/1Ol(r^DAjhK)neFPM-luC!Ry)+>x%baSX`"Y<R%rmQ)(+Zbp+J0-Aoq+5af\Zz2/-2I+)G%-2FU->q1mB(Pfv0F!* WJgZ%8kZdX0k,+5mEu>H477W@D1">>\rnI,D+de}_3ghEcG?48fW<<(FGBG0}GfL=`7fu,<_Z2!WmJ:_}"H{U%ne23*Z!\,a<@q6oWGXizcj=n(y\2IIzz?6+I2u	]DU[U(Y{KJyO=uy] )_`\4;n^N_Y_FMMK6?mCi(jD&r&Ad[!VTyY;j`nLaB ~+	G6+>+fAT/E.8heyAh\F+
+I<mv= a+`b/K_v*%esEt@@6U4.lse&>PVh[b]/:bmrg=nV*>BtESJgs
+ It_C?@uG+vS60hYq1c\E_\]c=leG"?UtmC.'d"R3v+Mf}824aZ:VG+:?.
+PycGOu+M~`4Ips<yW<	paJG\Avd B}&CKm|SRcx(c?3z{GxSF?o~gOG\nrqeju0Q3POxEm0)SL:VlR/Q}K1L3d;,9doVN8?)%ed|:L9}$rq/L38
+hUoEN^u!6E:ZaVU8uny?~ze[x(9pvM5hY}@
+
+z{o"vFm{XC2eU?[hD&q$5zqFOcmLDOm&TS-cS69;;v(sE-hcgRni8Wac`]tZ%#2;uP.;Q%9P8"\g+C1$r;bqK_r3t%_u}RC']AR-fRr>HC:q:
+]AFZ.E>Ex
+Gb}p	na('Mz]J]/Jv~hkJip[jn+"} dgBm%V8U0(GA\	9$pdoJE&e)1D7YpJBvnQ=m.a_5(u1	ca?F&%98,ZJ+Boi06md!^1/BqulyuIg5tr])<r8M'r^ga	1%~pAz2F2iY,zmpH;Xhapv+2n7>B3R^Y?#z@90ea{Mw.lP1Ltqgpl`Qr#[M~QqtrcU2eM1=Vr[vh!k}?d*4o6?,:x__}U/mJ`QtvC< yU2l3YOL R}v	+Ik^>4=c6":"6WoIgsONW\z n
+`l@aOSiL{-XUS/$60(E/SciE{6*sM'Z $|7mX9.O7yu}DJ^2X\5EP./m>O?~R\@S>C{;vL[kJv6wc!W+Guf/UoK_6{z&lT4\h?]z?|o+ .9T!k/5V1`+rd|i+9`D9[H_qik
+^A{O:~_h0?mb`4	]-v}YWG%%MB!S+ K+_C}=n{)tiZYqv]6_5L7~V7=2(Gc9:G)RN?zpk^71PZ2YD8C,\D`H'}KVO|`OiG79=%_8m]*.=	:m],U=Hh-%-J)2V}=GTHUp	j7|t`%G-M;NWpx+d.)Vx-{&}rX^amGu98s1&?1?+!+V7+icR`%[kY*0G<Fy/+]%&k\1N`1s5f;G?_k+m!lfS!~fy-K^t2_n\91!jV5P:K}GqZZ`WzHr'vZE/3	tkg$
+b2vq)`$SQglsX"-mVRiK!lyx!n.+Rzw0[X<_`spT-?2tC}q=U:-cyd<?D&\n7iR(L+j2-e7^u,]]:>A=[cU<@J;jATp	F(1<TPvpTv7gmdY2/lJx9Zs2sXo'tsbU+x7zAUiA
+w"@iNghSbCclNkMngW5IQM1Wn|V1){5kSx8O+_>\{9bV>K0&~T<A	z"\gH6b;OK W|/cze!X	~#Iwr7g+O!0U"]&<YT=eW {{NG>HU"}C\oFNHgV;[U_?FYxEo|u;xJ">EbtetmkMe=k9|T{}Kk^#c?Tq`w{-}%6(-oL 6I;/*d(BG6|m`lbb"+Hsg:}1!Gl:G:3&uJ.RD$	dV[Q?"$E3Px9Rq>-![>|,MWA#c\E)=tpN	f/?J%go}Nf6@(X`6dX
+-S &MDomzFOg|SdT"eWmcO0MRn YL(>D'%de8h8~_&!R:3^-c';w	5__YRL]7xCR+pP~V8mlFDoeR?~=K/`u#'w6"nZl~f]L'4OGyD@)0^TDczI
+3P;HApGEnM/sD`
+?m3qyB+ae{f :)Xw\3r"6LjeD^CoQ=<Gq[L&,eu=a78E1-	9HF&}MN
+o=:o}<@s1,+m0	*3%|*:O|^KWg_ZWr-/eNxXX+}.?#5	NI;6qy~vS5Q`{
+j?Sf8,o}`^d:@[N"BBLl#Wx.dx9 1)(b/NE89q+2efE'tVr0+=LdI<LQ7nY?M|<UHXYu}W\'}w~sS)kD8Q/Nwv5alZb:Um8Sidci\muZIlB
+:ue"2W+Rzbn'lHNkLS]8'AA!u?Od+w~.%Rc'_=7r>}b	)@]R{l< /G[g$+g#<K=Z4+%+S?e{L
+q^\r~CCWUDqlMH}\/9z2!}mmia1f+?g5ifr	e"&.IO:LR)qQg O#YvE|1nPwB{DX2>O[z+kr-`1%p-\qW <p .{
+}]ZF$9A:}+}i-q68h*;kUW/2+>+J	cs&S~RKr<RA7:	xAO	Zz?xG.P1D+u|_?)ir;p[ek^bu?,C<+<;t+@'}6!{<+^3u8j"vgYtu0:s 8gg5[NvM}5`E"q>OMy|@3pml'}WH|x.ggr &487gF%-c\fRoe[y>pD-$a->t#w'opquO}zu PCX@$O'ua~oz?2}K_;&:X?h+Xp 4ma9`hw}uJpjT9OY}+rv+CEm,`pm~(T-hc!%=h#^^&#I8}$?sOU7]%.~{UWmyk^4
+	lP))q!8rm
+yK6Efo=bX[|c)Yte9Qw|c>2=}8^@y~`t{&{^c&6xB]72Y+oKsY+\Myp\cx1}psW4hK_{^1w"9g51`HPG]811.}LS)v	8;;vOL<=vT>+0|[DEm^{O[N+Z2}i:syGDV@pn7nEh[\S#1pxW5zaP+E@N2)^e}f;X'q%NEsTYSeEB @A?&c]3x"]7<C6qNngoC7E*a)DNA83]wTdk pmwEqG<JW?)?&_cb3&tt A?oy~oc>{5|q|n^uw\-)/+HRys1yYx{koa	|AL(y8G8
+X2n$d]a%/W;?s%?3wgN{0^&M/5\}2x9+M>Ea,$y+t0SY2c3jv+ij_S!d@T<`bO7m>bQY6Z83x@)]yQ+0&U-%U]\u[O&%o??odO+A9dI D!wJ@&Ma>XEd}|_{I# uMV|40M#~x7=u?s4?'f{i]dLyH}aK
+!4Yeh'?Lq)A$w5{l+htx,W,[0`$m!dH89{zOGCh<%Mb	/2MrA3DnM#S^v,~$@6bI_lkVqUm^R&qmVZ)kI;nDm+'v+g&KP
+.7Z<97@,'~Iw7+;myU"OeSE3BVyOIpsl|lgKh4A4]@`|	2-G?I77^xWu'#2!D-d[LD*!'Xc37U"cNz+MmW4.*~+0hn=+o.?G*Um?LHg=`|@,v,194c(F:	//R*kPFxe?V{|=T$wBN%H	}.ogb_DloV[S$M__Hv1[7UmW>//l
+P6S[(j	/FC;gxb7`;\3NH@9^p&#oXf_zYq%1uyWuH)HI*LSaAM$Gb"+y!z~27Fs3ixtA48h.8Om;v)+,?{D[W]X}w_)6#^]U1i$FC;O)[
+"S[Ow=+kD[>vkwL++"lSq:1t8DcP^"/Ae9JoZtnB)K:l!l
+U9kS/XE3"Nud^7_dS$\jzW\,/,daI0)7~&4L"a9`'+xyomI ~S'XK;z+&bH?hAyvByIncdld\>B{|T}XA	iluaPhy!~cA3\w~^Z7<g;"xs_J@E3`+V,*R*moYaB	GG6Sd]nIWgEG&t)?gc1``4ncA.y/4] `-.!g-[~G(7E(*9U/G\Qt'y1@tYIXNMz.S1P8#x.uvIAPowe.' h)]{(fm[mkV,2y93piR)P3!>_Li ES%<fc&HcLK+PxfUjL![D#|FnNu?Bl91Gxvx'HW#u)V*W%Cw	>@#_z6=wa4|G`B4XolsVd&1Gs_y[}-tMY*
+y,/5
+MELvY))el-aBk%6y(oq>QulOapP$dP$`u"%J%}Y?'}|o<L6?,=k]hWs?wpzl
++10guyViMzisGq]XXds34N@%_7E!1"ybPkiFa:&\!*C|?}+'mrGTON+=RI_V}&/xAXi4#OS11jJkukM\ROu)"[i`t22r|U<]lYqp~`{.n
+Iy>R.ETLrj^.^(>\)m/E'Ys*]+,.w=bqc"<E|E28/DN?W]U,[qZ]\JPytMyi7Wt^JwKX=_q5,o/zMg1pE#9PiB] g'N6|\21`EZbgNG
+N46:?sLkmW/31xn?|~}73xMv72R?'~pq?	?UW^Qn+F<nx|~zD0y'zgrSB 5r
+M^-Z5oi^=OyA{K/8m?~ nhb]3:Fd&H+!VT;X+0*(i-_F1_8!VM&VjdPw~'w}7q}.vYC'C"yOinT+#d['KZEbQ^pq\	!O{WclO!ep_>+o}zm.nvn/s{q>xio{4Y{!iL>%T3ibYv*1_G1S5Y0ekm
+h.~~R!XcFO YFeE|0?vLoL;YZDVkP*-qLhO}tL!5tIw}/Kw	[ ,#zesz	Csb pyn"]c1N+DRU~){E+E8*H
+yfCC0e#>WHI{3};4wC60+YIN)vS|7MRnS(I'mvI)RK_6lje@JGR52G<==o{o	@V9%ttpAmWMXQvKqMm 1jrLLT%|fP~b0~Rf6Pw4!1'FezZ>JK0*3+.Q ?A3y]FcQ.U?38dUrb26+'F~&M
+!AZGg>7xs|i?!$hx=%D[Pg[Y>BD/aM#-eH|BDIpDVR|h-\c p?TqepuP+<,t/?O	,o~FqEjA6r$APWyI#>3^
+u$){IO`E68K,!U3%4LJI7 1?';jg}M=r_/}}jU_b:.OROV_Ze|g%eF{['zNF3u]tM=|~	3+0M:,;*n0!n)IVIIouEiM#+O=XvV0?]OfE7|~0\6>3CO>L	UUl'rjq46K:?:Ql:WHXDSzH(Mp>%H0DHM<**v<Xd>A-^/+%w05\-G}A|;xbNo}&UL>-.m%K.76zpS?ssr~QKkuP+!Mm#&-z>hqK/wA}a'v]zoh;o&p)y_/9]F3ydOb"GG'?gyD-Z&=Q+H[@kzAyP!&$CcQ4lJ>n)8wh-QpI_' q-+A+!*~O,ZxoiQP^+K,6[AV qu(?Iw{10a|}hlP7j h	#-_U*BWnxO}G)Z1?Cx_{-Z	X36p+\wnDY^efl^t@@*
+uj*vX
+QI&p[f)RR^"l
+(g!,q!d.M+&Y~|u7){s+~'SO9>u*8.vnT	xM_RU?X}YTORL>hI6-Aq]I#GuoS0qp7/D>$g=0nGB3OQFFA8a=XI:PK);P!? SH<`	&@!M^2,c2S6IDZ) >eww2mZ~s	l>>M+q@kIgO\[n{u.S`SP{+, &7Bf&FAcAe	-`"MT(&"M~d' hN(hyPYBDK&H'/,]l|uS//ynia|bYbHD- <5gMKzyp=O>S80g*1U	&EA*$-!^)(hyPYBDK&HK|:7\#t99<(g^xQ1qVuo6JC{[2qkR5ul3_Y-7+q$")Y@kjcr/_O/rZKdL$H4}&y1It[ Kqsk]|Wxlm +F7GY3-z3w}uAKHa%Sd|O#~lDXZ?-nq`.;k4= Q	I6%XSs_g&IW2"& Mq*Nyo\4	:1hz;]g#0\7+[ANU]I~vbR Ci7K{	wt Xu{TSnhwx(ia8ysT!Z	Y1?	=8ysSy>B/rIkse>zbbZ?i,ic~=M&\:b)S}5Ci#mOqp}qzGGEYng!%qL06+N8J8W>^ccxGB^vd5g(nF4_s?O~?)E=M9m?>x	n +v	jm[CcB;qwnB!38iy_%l
+[6Q[n'~JMP\#Pe\F%}7{8}kx727!v_:h!<f@1U}|]"\w/^	h]gN-^f?t^@)@{5Vuk,jk?s{T8Uh.0-=/*-\2`7l(~|=xC=qPr$Ywg;{_1}kjL+V^N?t%dSc8`9IA%*auqwv)sTTw_s5
+7+']1n" H/++Rua5Yi3CrQ99`p0] {7F
+zx WL>7NrYB)(G-m8xcFKjRVBj&/Y_~kOp_WHgdx|+c~~34|~+1{g6]Rf+Ms)L-1<hl(e2OOfv@/z"90q^'3]"Z\[E$=|/j\ ej
+E3^;pC ~@_(prUbWk9ooaN32/_WXyD
+*&kw)0C}>kSi{~G>N7Az>?O"#qz)h5/	5/yg^T
+J;vVe}ib['/*C	#$gA Mu	S0DtX?f0L-Ygp)~&0F<]\w3gvWeYx_@t:QsD3|o+\@j$M	:FN)uS']<f;-{p<[ t-M
+%)t02rTE zg
+\_.V>2o3ys]w[uW"odkm1uuW}fUQ;kKZ?&9owIt	+,#_yTwmb|W3=++;uPR<\	 Rw.|>i
+ASA`(IMO:*"VV'_eO{>#_B:s[*}wnc.*8<;+9{5n<=D%=o\cU.]V%o82!~[?O/j.$Nm'y"|~*?.|':b#,auc}DA]	v ^ ooc'd:+GJn_g]oU/8`}c/!tg7+ij4iO{_~_tE'@74ee+}./;NLW)"eiW#xr*#2W=k*^9o??|o|+"PhYd)b9ROl'_Bw"2S74~-H		#Qg3 Mi&?h^v+P8ap(0S%K|i.[0[Yf?K/t0K>t1(Mx;;7Cu_iqGKzF{z4a(7y	tMdKQ'O@$9;geEU\XSZ6hDs.(d!CF<Zn:3\?g6l/_0_PAm+Fxr<>#k&ezX=_*f`{q"!7Odi{AD$s[BKW~{_s-3pXDst	'<m}7x#r}o+PGU;IN)!}AAKQq~;O}u|iM9 pTZ#H^]+p+MwW.KcW"+Ly&0|;m@&qRHU~FP0KRG	u.pa"Iqr0l!@PZ*'kG^Sc{|nMz~PJ^gWL~1SA~aX#O~GbE^g1-EfTh6+1Dk4<N'\ji zDeDuY;W\&j0FI@hA9cf$>hfMW4G\S*)m)-?L$'zevBY-7_I>VKYEkPx-yj_'8~'K_? 8b	v(n+O>y]"rt\d&m+Yu]gT=.M7P	{8< _*r!'+91	xWAGJlc!&~Vx;bA40^ciMN&hbpjFn`)|k|-s6A))</q>Pr+m23aKB^1xHSzzIAb2T	"OO!23!??C=#iu]_tz-JG<[zoGz3<sU2m -^p&C|Fl&iK</\YekQ7}`d9%Lp(!# P{^w?XaP?rS}n_?<E_P+M7}m6kb!o+7-
+6Th7.B=#Iuae!7.D[l'>@YB$J=?vbn`b>$/W0r[Fe?z|J;4}_W&SRlrGGr8"+-UQ4pS$$	.zi ?VaC*8N"?u)FE8`[L?K9Se{rO%$#RuLik1"]=4s +vE	E_=Q"a	Qu8Zg&H5z)aPl 
+vq+2tc8$]V>1g2pAalpJ/^6'N&4F|G8_L39>Sf$V/#eWf{mE)LLAb,Ba"pb"`[[xdZi{Yr+_f!Ctm34Vxr<j}k~\vJag6[u10es`dkJxq.yst{0dHb.m#3%:$(=I95	)7#FDQ+JyuY_;wz42LCG'l3=i0CT,R@W0`++q!`C=hUICbH)bb5	nGVU4Y5x}4<`xkV~B<_|r&T+qh?;woE]":<xf?+H>81a"}7>YxL7kWc{oG"yw.x_^wuG^7x!E'p&~b)'N	4y`QOh
+	wnc18e:CANw!/x|X+t6mt[	gW<O7@FZ'a]om&C?1fDcGD w7>N[] e[9)41cXT'#0:{&v#\	}Z%wOXl&4`b$9i`Wf<1=/U|yh|6o`r<+kPtf^k;{ARSlRml?\=0?+m#}6}[n$eL33[;_^U;ArjshGVZ:eU'Mozv3vV)=+S{Kx5bx	MN*oq;~o>>*oRLRZ]]Sw}S_x~Q
+66Nu6vc25v.:yN(k| 8mI>0y~@N'	]Lk/}gzK'toM	:LJ3&]??C+Kw4pkp/g??$}r1*2{}-oS^[g1\&p5i-"U9rcp$eDX+	&2}/1.+(!~*xY&0X.+Ft.|otFn}RTOl}+
+ddo?uat
+~H9}{rUym$"#	'(=(;	 +xo"1U'+#<x/JyS}C:-oyesY'}eO@Ga	 849b+@cg@zLq	wfzOw]S*o[2m;w|n%?/6RNL:qoi~XFs,nwAY^*+jW\q	yg|
+MW}?EBO
+e
+>*3WM.};aSIrxXpLOv2sI,Z;tY22=87o|7|o9TGBIuIk,bOD3z9Y@y54b;x|Ts9{{{n`'`[,Lo+9$!ICF:v05dA1,8\}g2lB1{,&ac]OO; ^IL#
+;<m}k_,?<<|P^7p==>81V
+h+#dd;m,Ek;ii!C d~1T@cKW]z9R*k _ h%uZN>c:O2?numYl}Ra2=}$|$R@'whZOZc"Z#P+CB<;yqQK-#+.t%2d'q&+6.KXR:_\/[Lo|;zO<w}%o7/lnM[b7+(xdD$Kyb+O%j+|2cyM@ZcKwH09xNt~GZcK/+.+X	B,UY6l'O,@'@#?+T~<-\dWn^Nwv/3GCRH9
+n%K&Wax6y?bHS#p"I#0"E[:Cb|r+e4+?k.0%WfN")x3O2~ 8$I{P
+pB'ePJb/p`3!yaI%wx$v$y$|EI*K_y[GG@O@'qo#'-M^c-eyh{Kb*;,FC$nS9{hr`+mC1u[[Q=mSuIw8)dtRF=%'2	3AiatAnc+Zu5)+i}Oy;I%M?XIvM	h(rbtqhR8OK
+)"_
+<rEX,>OF]cMX2+M[*2h"(?be/'_)u*m;x&\=IL+:X>	{jlk"%hkQOytUaM IG SEfm,g:ikV^n wxr"p&]W;RNdZuezm[D/tn@tkx&l<]A,1Ulh[WIE6y<9Tgx
+"I)Wy<&UnVIJG#P@nG#p#1nUIKrG#vxo<m#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#B?p;OH+
++??/}QOxPo<(Bq
+P~VxH"@rI`Npn(=\r_W?O
+q<QPPh[}m|B@! rt@d$B+! @x&B@s^>cw*~V}K7~N;1x	k},?WFHAgKQz|~/~!2}~|Ma[qqjwqW]uMkqb`WkSt%qiSvB@@0B@! 5x}A{,yE:j;N?<P?WOwYSluYHi-.e_D~'~<sz&wwoO'x"O/ !zVq^B`^#P.5B`#0A/%Mq=WJ>b9y}x2NLn!c.eom?:?;?kxwkI>o ZuO(^)}uBMB@y@B@o@+hYmEO=sO>O,diG[
+Ps2UVytx}DG}[9oo'?y>7	u" dj9FSOB@q[LjzB@@g~5.eAGO\?3V/=I(+?BI]]E%?+k}~<D_?:Z<F/kG?A.)8)p~W^I>c kW&sXii:B@!hynyuWc[/CN?=i5O-&
+Cm<\~T8|';w`[pwLk.~sx+
+~>hZ_m_w_w]}uunk?+/iSKS-|HB@!0#XB`~#9]Kg-[zS?Sq3VX{.`E|sx]Ow>OoG?k_=oW_b}=Q4els*3XdB@m%f0y[myG=QOSP*+PX6Lw.L;#++>]_3 xC}Iq=rO! AD 1B@ y\Q<B^]~^_[W|#y?x&B`7{_k}u6L',P/J))y51[
+! "i`B@!?q=GYkO[9O<k}6
+objbs~>9eWo_|q2?;E:a4wJWIzB@L/@ B@q#P6z/e_qk??=/~Oq?qdh5n4p,<h.'=;?Oqq@KC(q&S@,0\! +! @@Yt[O^/i~CNxz_Z_WZw~]q}5;j<kj|q}5u~_yy-/0gt|jB@!P!B`#P>Gt9^1K.Ia~gb^8Wq}_Z^ky=ky_Z_x~-~-k_kyW}k-jZ^~__
+I+(1]q#6>B@B@G 
+=Sw=Kp^ba\pl}uwMw%oSdKKgm..y{C}|_}lW%4[HB@y@,R1B?c=H,SW?)OY}+W>z-
+V'sNv~ L78~l<GnzwK7~kc+Q'm|>q-@*3=x!_tK0^;|Wx7Q^dkl'of?_|Mox2`/(oC-_/g_B`N#9=IMN!P!PG:6'~sv*Mw&z+7cl:7L8Yop|k^O; 
+(z	R`o8s_iRB@?b=Hk:x?}u/7n|9&kh
+taxh{LwNIB~*ZW<{/w!;"A%a{4[-wnz! D srrB !Px<=ub^[W_z:S]j3``3?^j3=#_y^U|U'[].1z! B`Js
+)MF@Fkg;s|;\,N(g! lC+.I}s_n3&M$7~_b7~_IoT[o._m-[|>Wzy"'0S6/e5B`V"B`#P~=q 5h]v'~/*}[5x}}G?|g#`<>'3Lw.l;F`t={T=P%u7>="ta)SB@*b!<VB@@F~tGz	(G?<1[dd.]KK>QDe8v;8.@r&7V3{x<>{?-@_<!1mnOms.7n<S4U_4LB9eV2XSY~mw_|Xw}??ix+z^3b*\R6{ Q$L]q`5#FON'	x`!K1 <Y[J+mcHTOx}x].?pw=wCs^rB@@<cSbB@3&/mt_	5Gt^;bu]q4__m'KZ~-k_d^/gvQ"lGK+ty?4qQR	IfzPuG1+9#]r%;S^lSmw!e%wj}ww'/"{q](Mqhq_{mL9
+oMOMvH!,#|!A"&LS'!=X>_*FSKXlCm/0Gpg+pa5Z:|"t]bXe%v9n|}z<)c>|g]|Nym4yls*oB`!P~6{^_{	'+g~oXx\:'Z?:0ax]kZKX?=So:)L$j^,&+YbsUP&J[c+Dg&x:hYuk.yW]~|=?/r-@Ps/&",FLj~<,y=~'|-Ztldq"v..yj_M(w+H+*s]ek+]+9hKC5Tl~\/ g_V~:}OIsg}e<w#ay	0(\'92(z`L~x,t[5F<NW	V-7v(8'xD[yD?_D7_|w<+;p+g^i7= 
+i-+}H
+ly?o)} E,',-P(0kuR9&f?=X2<QNw>o]2*+{mj+a
+NVV&3ab^R/Jz~2,YD\ {d#I#6\"-\K<iO6^/#>;\'+! @9S1.{eeOc+}WdpC1hQ@2fHFH'44f>Qr`'Aj6+sNzyJ&uzv?0NH$.4Ob0qH,Db_Gv@1` ~[	8s#4Ac1y-AW;+d
+%"D^6ZsFFLmncB[y;$R''DJ6aKds1;
+\mc|/+++=]5kb<GgtY)+d BW 7T>$	X&6;;@]l<vbo/D16}(la$f6y$|59cDm`L1cY7&",l"7;1d1H|xI)W&`q[#M05?$;?~8? 2p4n3\{LM+&"zhS%q{('.OiK/[!w=|s*z_6/v+B4a5^Jsc^q\:niE=[Jzqf8<C?M>" ;Vx+9@#s!I`h{h'$B+fNk/}cn>"~+TYvaKaG\8[	OEb]Sa:<+[k^[W(Tcg{OO_$CGm4u?@@t4m2Ue=X.Z^&]}W^3O+W96YBz< X=CTP`+5Ysypj\gk&.HR:VG{iSJ<KF)v3hsQ`oW
+,N$	oq iZ!K{ c+Ccc?N+	2EO|;4{S\T|%fGg60O
+}@ b$Ou7<c+5;,>Ol~)#:e-_kZ~o~w~>,kc5! @'&@t[_Hs=nX[lo]v(P-TjZ^z\4:::4qkGP0;4sRZ	Y.*0sZ#,Sqt@(fqNv5u)0xa*{MM$/QwCP9xsL-8'>`99+p2PY.I=;I%G9|3AH<n}+}j|ISiR~=Z,.^Qjg21Lu5;?8TF%`9fls^4q>H0;qgR
+dKdTW~K?~b+:iC_$Iq.S>ke*':	&+jB@aAKG|so{O`~>%/}(9Y+IatG1BsLWTM-w:| 8e^)~<Xa&Je
+fb
+\Ai|bhtz-Jmd2^hOZkPcK[+#YS%!CmRd@M|;G3;wc+Vr+]0vcsdKHug]6+}7(xxW'?vm1r;^7Q[oH<6^&R!0!<Dm<5?	On9/|"FrAF.]_xwbj}c	f;31,i!<6s|_V%n@y+^<*0,oz,Xbxvz0Ls7TA&Q,5!vF{JL%kG6g`f.1;H
+8'?&1hbxP) /uoJ7e8xb0/4j]dAw-toi7!!q&\tn)l4i[+>3|17Fr}fM<*0*<&?7lPA!fs4/=]<v=OTx!kMCgkSQnt`[dec XP
+rx22IV47IG>`6f9(L:ZR@0']4C agBch
+!{S}&M@,.~>
+LMd<[&h|E8}>!O;E6mQ#B<g#m[bA)F5! 9
+<?+"|MGk07vcwfKtv:gD<<G'\~^nYI.	IbzQ1e
+>3fh5Esj5]|&idY={#/&Kho~XDN0>a-/N,nb`FZ2]X6eU];"3`<`1mJaZU$hO"zk<Wdch^kqj{23#S|s-Oj'x/{p#R3@rk~5yQ~ 6+tmW
+dPbn&M5bG>u+;&/wXNCaM[SB !P~tJ]q_~kN:_~'YKnJe6=s)C"OS4>'WK/H(wwG16%qSn~_x)%-\n[&#tT+<M(IcH'yua6H2IyNW-->B&cC08H-3J4_S)dAXoFn	G]DbY,!9aaOFst%_Cyf.\)o><2"	os$rx.['x99Lvx,U#\Ohgo?{{_x^QYN-hcE_1gRG|]5174m<-w:quV\K]is=lQqQ78g-U`sVQPv/ddg11yWrf
+ilSu~T+S}%_R7t$ME
+}KM8A@"->&+?Lb0fA9KM=RZ>(l@H6hfEXc"jh&uyRCcX[)#7{@q/Z~~Yf_:Iz?!=+n*?O;) kV0b46sU&S3^}cc_`f+4]+-v#S/fu0;`k_k@voD3<i}c]\OLy/{	l+yK)E\L{M@Ic.~C/gy^xqMqfKcb933JrBqRY=?`.)A.+"9ol>M-;r`= -Bh&8c'+E?|;P+#Mo.T`\Q]6/h<}:vDN	*
+!)5`(<i[1WCP^M@L&<p;Zmt*iS<e~,.^c q9TiV4RWc1<_#:('%ihXou&%tRI~-oOmoGr-m~H<Tq9_:Xqiq W
+6x<~5#~;	z,/}qr9'm?HmL8P%sslp3c}]qte	'&W"=lA6k}IMIz1.uJ:}Sjcc[RK/Usi}GDS'6hK>6RoFC_a6M	{$c(3/dnEQZET01Il'Fli;6Q)!r~S9_f%DS@T<<fvq`cc7er6N{nmQCRFls\&eZ~L	\h.|KJ$Z7l;E>#zs@_S8v63C\&Acw\c,'2Zczw	?)5/wMI+uJ:s)g/mC?|l~2'o?j\ xDB@#;R{;h5RlK^?baN_y^0ukym_}OyG*?<^HCvP8I/\R)[cr#(<L/P/-16r	(r<32r-,&g0#aHd)bi/r3<E3X1
+PPqEZ8wXA~xw-%YWZ2O_9r$~MvHl|JObyFy\ha~oN4H3ea3"?sZ!-]Og6_}oW;xMI1i090hr._~=%$v	:og_T*Z~-/Llk~nx?+[8r5:n+42>c=#xS8+{!`yzslzcLAK~z+/nYd;~KsxacA8@c&,QyV/5%+`-va|gV!8ABXw$!\q,4W/U
+AwWL__;0[@=f,'+7nxW\G	Pm_wx~-uZ#|]x2T\6%4cnP'%65_VX+f/(XM+eJ9c-(tkMD:;M+Ng
+4Tf`8,>h(zi48 #_Q\DJi1gq,M}8=T%a&1Wi'Mt<4Kz3)OKgfN*FXo#{_3
+RgQy*sJnR.P{2 i>+m8S;T9=f{Ml"{B`c_DX%-#:*'%9&uc(H|?F@j1q+qxT|6W1lefY5)M8WPk^[6r7/E/~:wBuEoOtenWARHfD&-(xd(xht-"P=fi2q(is1Jg |7LnM=;na`C,ii2xFE,;,^o$Ln$q
+~6K/rPC2rqq!Om?>TIP`qa!uWs)p=N;B<OiWMsg?x+^66wF+X-Pc:ZqFZXGL'AI1DT A&lBp$nqu_f7\yqy}?u/:+mifI005 j9.q>Y^p11h[>pGVI'6I'~ND=l)]D|_c?-UFNO7;_w>?]s@
+BQAC>s8#+@W7L2=Xo[{yK*-yTg7f._o*`kc?wYD^zz/%l@\/-h,\5D`/~6?q.sH6m\Eetlk>|GxL+8-9q _gR%B^BO3<iU$`Cb&4$)!6!m&syy<{na(>H#E'%Mo4*2}3EmH73
+iFz)}nn+0~jO~p5wa"Ob($&y~_}.ss	tN^QUw]sFC?Oxp@
+wuB'_/YOP	J\sSW-o|egY@FS7/|<SEu+l`UU}\>q{WW?'O?!wB~k.LX^s0Yd.YvdsRO[ 6GI<c61{5:lnXPZ,Y`mOL]a&xOoC4r$ayA%6LG-D0H&*6rp1y~;x7zTgC'qKbR#<|T~xx%h|A6cO[rs0f6@=zA94t'>4sW+sUpfbwc>.h.$w&#s`2T9\H@/VI!t&}lS+S_05Gd$kn{|tj(!&qCw,(+u$b/+	dS
+o8*.{i[GAROA-/5i6:!OPc ->Fl&AE<B:{>RL&0Xsnk@44ts7m2Y:9)3M8!ncbtInLmyN"\=;O8'F?7~XSnn\s
+S\s
+|u\>w^J1n(w1E-N7dxlu>w^,,/H7eR:)>Ep\ `(q;|d[,1o[1gXNq]g-PQ=J"]faAMop!ixqI"Rpyg?M$y} Bx.[x/u'gnZ)!+].C:3|"gnJesIG3-|g,bZG.`x1=L\G0s/Dug\<--N='.o_{]=59|}ypa75:L}Tr35+bob@FxrlF5r8`P#]zm+~-$g5\af0xk-.sJ9ktwRmxf081?[|Az1n]`)(ls`6c`v&Kv GT@j"b	z\z]N+\T8E>9W~U?gv~n-G2o:?v.iv\U:_<
+imA-8umQSYV,)}J5+~f?Q>|<$Dfn,^he1+]=;"d|	B&a.s@;3zcQ>1} !W:@G~&mn~Zkq&Mb:8X:eO6%%f2<p3/tjvXY4-S>fO6Vr`~&tA?5	.x\m&uz~^&gr~d~yos|?SCOr`]U>rt1cOnPlDcqy+`?uvsl2G3{>tx{BFFz1uNJ}<[Z-]Li:+fS/od_D>WZ\wx2=+pPYqvq]|LT7O?_/Gn tov|@
+pG4{;?L"=+eb%=k^s`\N]<b|&n%KkJ`id.//E0:jKkE_q'6eaHCHrE	xhkBz5;y;$4	k+PN`%:r8d5_SeKxJ9v##%Ql`(NSGls@JSdto7zAGXK\LFqlJ6&V{# T-%d&|3PKgF0a'v&5+)zU{LArL[X2a?/<p+ek:/1O?\y*a
+O1MElZGM34ah~c>sl<2xY_kzMbRfD!{|)PY?9H)BLH!
+N;J";nv"JF<LN=^j:8R+X;	G~4t<Hu ~]hC]q	SRGL3Yh-py>aSga,,8^}ck@Uw&e|Bz={=o<$jY<|]}Oj/rN{q>EEYFYzt1=%\s>FE(\N_1//~~^W]}N_LH)**_E-~TviG	TLTTiFQ6fJf	X4mK-]Biv.F8U;c;f2= l-\A3u$
+6C.Y
+gd f	\F$RmfW'L!p,<s/7	M!%W$Brh^qT?
+\_zN9C&-Nm1z<Wb,6"VS&Qo4(~gr	^s*mjqOKv|ZpQs') 7&D3$mw_3!9Vl46Cu1F,DBr^t7%I36Z6c}fsgx@/sx>mvp7<'qx8ks4)vtm_//{~u{*O ;/l~8W1${z;W`~~U?c)OrIG.t7j/7??SbXmm+<XO}\s
+Ve>@Vfp*?y{}??/z@HSSV-w^#]Q6l,~4r,8rANF%sh`M0Tu!$0BC\twiK!+<
+w>W
+++Ma,1Al+V\Dw-g!f<;QJD]pN[z%rx,^]=&|YD	+-1 Q%iZcX4#tI3;g=8"bK\D`3p4<;1(#_0H[ZhB`V`>VC`~D:8zR]l9u%.jOZe_23bU>$FCN*WPfj?93mMGI$ gsM1>ALbis9T0G-n14v/HUc9B]8x#VyJ\xM~GL0J|}8jH#vlsc7M:d-&iGs1]f?2>q<Z;}/{z_?H;7iL9[Im__s'.++(*QP]8W`*iOe<X[47e/{_|wqFj(hA-.~A/@UEal>7PUs0.__Ul~at5xz8jcXqVQ#dcf"}0<oBm<1bs:&m8	y&a1a^{'.0S`3oCc,1qW~H+D=qE}f26`f$dq=vE
+bW3X\%|>(6+D7){:k!+g68<twy}p#"+F xP![6qS3(<O<Gv|~M}3	W]+`#>]TCzD/#rq#l_9l6(Pi$lR(d $z3oNp;f+v%OS8yk8IW}6b'uSwQ1*)5@j!\h2`QnK:R][S"$Z{aWBwq+bz-DOEs7yp}>;yv<rDJQ
+P30kq?tIsyRXCv`@9h@@PFfI>!Nt'^zC/|	yg?XO{//}zPv+NI\8CknR2cwpe"v)Al!JpIw\j[.|K$'g</{#7++p8+\QK@*ooon}WdD@E}U.HcrEBYih*->;.PIoIrtc	aVw0Bz>}8:q${`@#"+_X[zTS5OVbj}F6'Wc~(%|m"K(9Kn9Io65V&5HWY$,qk8:	_A<RDT#?r<nQ-ZDIzl&sEpcPK	X`(%i|x|Gxcf8:Z=,;R]y=n+l`s,.-q1m\98:Lm]/0M|&;x;MXV|P+Sgf$OUI<E(P,O<Ol8E0+;DbrS$_#:8SGB?l;a_	x?0vN3ZT_ziSsqn8W
+G?wIoz/}7kv~
+zN?kT,U=
+:p,VTeoG
+WtQ~WDbwxr7J90,}3v'\ve|*X}B-&L!Y
+30YE/@'F/rL\o+<LM
++OguVEN7xc~#GkgNW5^MYQ.
+:1|k5u+a|
+}(Ony=95@S:-d5>:}si4Clk0)~1V.GFL]]>e}rm=gtE_D7"m^U9l8o0[%?83Z'f >6E	KIKt	j#E@q9~@8U:*807\
+utSwqtsYz}&+i5.qTW\_O)HUbP	<<W\*pp>x
+/$/WWo'/va;&ndi5Wez^w\^?K+6rB'.@?N1/v=!*Inj9'`'4xoo[sc~pTc?GPg,o[Y2NK5j3q,qwy4?3LLn}s'F-z^5>27&wF@M!3wM>C= Ka)X9Dr|}+>8e";GNf_okvukj@XNlYb=4gi8f.(nd=I1pOu^p6suRb:$<FL2W8wCweN!KA'Y92o.KD&ZhB]		kz/OFB_ra3-%9q>?t>LnJ\w"z89uR&/Xq_Jla-#qM1<Y_K+
+JF(Q%A9u3VUC!jz=0WbyxP`t?'|owq
+(LC0#D,FxBII/o}Is`/N'!'csJ{39W>@f1HXL}:PD<N92<]_Y[$+p;)tQa.3I>fKQWrJe2_G:MMil:s[6<8>w?q86[+(ZMMgw "TS?!^A2jl<@7m=4'>="g8t4oIytD<Ra:N(}<S8'?8y*a86cz;jmoP@#4Lm\s.Oo<fPWrJ+o+i1}Ry4Hxq`3G
+cHP 	/`w87E~Cpv>@L0l~}3	sY~G@S~\,{Z9c'Sc)c4>`.]+IIs&o=c4&&gQr'onokC3q8hsZKn6q<WF]e%I yVYSsK6:|\S0MEZ{M\ba?NDt_@d01+"@y?^*/`VOsw.?/C7eqcQu
+#]g	Sbi!dJz[_G]*B24Fc^m?8wa)itQHpnqRF58Q&Z2Yl:0GN5.(lt`b'2m><&|H[&i=_M:^sDOobS[5xhke28&b/\$d:8{<X{:;g".,}a<
+9Ed?sW?y'07\Pi)Z|<LB!gQA`F\e!6<Ll3&+}M]z*)=M'(] D0=.?@_?s3m
+g\+$.v.Sisz+'=W=xIEf/\?yOh_Id-Y<FMo2\.#YEk.J2:z")2}GYY_nXLK+;+
+G#%n3iad> qe_.]sFtk?blZ0PZ;C~N~e+I{ORYGO~n
+68In)'zW`?+_`Oo6=rkl_Us/`b~k[%vPM!,~]z9Sib58fQ7{IOI@e1NwjPfCSKdq;hT g<	?b-;
+CsM Ck#9,x+DgBr}JqH-,^y3
+TZY0}8y8xy2's0{OL?XGB$?/$0o|$q=}HW1}~Nc|G~G_G@E!uI2Wxb!>JpN6~#w\yygL?_zQO>}?N<^';z~B	(eTwCf#5/|{1%_)6k8,XP5;]"1wY<:7|w|z.4h9gX{n{ry}'Zeu|l\!Oxd]#,b^6nq#m)x4Rre;	yr4|I`{/9)Z2E|q.1d2HGC]K9zxr!V~<.y$#7z_n>4sAoYs03g"u	53M=j|}|q},D0\?OC,0L-o2Ce>i|#O:Iwjr?tKHvM5$xo~+Utz/Y)^OVYLXyB*nV&CC?8p2hCES>vptZgjXQNYO_bxGW\qFEuM`0B!GTru	ey`G5Hm*W_f_EKD;,ZhqduD	MuN|u4~)^&(>>a1x0n%te:==E0gN?`<8!J;}!7L R8MOoN Aq%G1fu:K?/5:c'?'`.&i2?>lsRn&BgaIcbM9\-]E1C=QyHS\\0:?F5N|5	K=l`3B:sX..>m>y7oy[C?hCXR`yh4vlyr
+9rez	o~ii Qc,I[]_sz,5qp.y2cY\*`iXyDi) I-C8b>5FN!/#A0`KqS|*Ybbww`<gc&6 CL	*HRGiUuRT&J+		"c\ecu0O9~u_Y{7g`=\~<{;}`t0T#*4(+kph@~83FQVx~1>s,P^--o+,)(/&N'C]O
+lg'lbW`_nU7?O)A=('rqxl*A~1P7r_)Xf	J&[z9]	A	=F unr{ccKQ?u;+@v^[A&w8FZ30qdV~Pq&wM_z`+?A>G;zd	`;CyQ8^;]KMCvi
+<!+$8;.+4?Uy;ys^2o:P/x<;n+h:3?5fK6g 	.e$TWW4~6u+]YxXWV>sz6j6|C4=Z_%:]	,B0hXnLw6r0g#+o,|pox.Rk@<r=`x kSNV|sQ'piK33Cl+7_7BBs5Wzgd
+u'<a{P!?</crX:5kH<|rbzi,bu1:i!U,q	Ay%	k+7E[=O|	s1A@7+9W+(7CDu{*,CX.9yHbMMVf
+w"P66o;i}jcYbLr]|[e/FXkg6+`Y[#?j%Ev{GI9+k<j8ai!49ODTH/d`E^3:K8'5 >ku_"+S)#mF}??kT`&h'r*Kod`
+$C%.xBT8<!$q\7Swx\K?C_Wc?cF<?wuqu^legq$&oY>ne<q0;~%HOPtp"kq9JcgCZ|)e3i{xL\lMB'2>yiPLoxp3&	0xpbJ.^.7{MH&6yIrah0;qs6yM=)/5)=g}(cP9EH4*'+r(	z?xaI:1mhbOlNl5D[H]% RMsp@?^9.UtA}k.{VhBgbM?|U:&~,OxfN4$\;\Tt!\"a-j+^SZU;f?!Myx;.d^+Z`.}&{o<.P%~:^~r4+yfv	/ZAw\f1__??Og|l?}4d>K%?EhiJ;;$:5*yA?g /pL a2JUh`:5$^V86f=k&cT#<VhF1%	F}1TyVV KX9qu^fd_lA+6`O =dZ#1sNbu._KvV+<n*py+CtD?^nMk|G??xv-OY^}DA7$yO[ra'\b~ncThYx8<ttOT%~ l5>l^?bhIUBy%^+
+P;]~"z-c;7mEXz4
+|IC_D_cdL[Jfc;Rm1;gczH+n5g@|,`R;nQd88v'A|S`<3IiubVl/ p-v]}_m_yC$`92Z9#1v7S\6-}toJ3BGf,+ 4|4MOMi$`b]xRK=?cZquPGS<l<*VCkL1&Le54aD^mx4:{lAGX#Ke\78su+gy3n2&H?r Js4l++;\b3Cc"4wT#:Ic6	~lbn2|py80l{};$i{ukl(oGJ+$k"E)?>X<qbX$Uj7GVm^yKuJe/{x:+IKU0Xh(B
+&@n'1tf?L%Vj<^Lck'XqO<[}H[k1t}#~tSgN8@xh$e\]g>n,;6?9%_a.*vbzmCU2HL71UgQ3]O](%ir;d[IF2!^x{\1:<Hah[0>s4O4C<nLKWscL3+*gAzOwm:;CCcb$=?hc~>'9bk2k%lFVT'~JGk p\v.7[}[4pi/RUt{}=oqqMn5`p]<T}0^Zzl(]s=}@]LMIXyxm`[ZCb2!Fa2@K7x{?-u0&c`_,V_O@ak7cTgpQzn&gVdvW{}@W-WR7B`zoT!l+loE /,tz^o^@+~J_[(6n?Xpehl9tC>v?"nVrKMsQYpO\cnGgS<0JQlpG&{+["Vk<&:MxGGld0A'RFf\ 2z`M.xO?PX\0K>F`4>[2tmOzv</yO4+^j%V<rhNilw&3X~o{s^bz."~]?y2u\")%qFY@o*R>w5*8|.;$G8,(yv-$2rBfI=^B:DG>e6<)/ os|amj"1,VTt<S?|0tyIH_S|zDD|,u%lgi:|g?]#??z~O7&]<rW]*x^K<O}?bXCsC,TFA@/,`6E<D+V0lpG,c~x+"HQQso`i}$+6N?S6Bb]`Bk{&+<nMfE!+m20'Z9>bGdb'o!T9G]~vOT(YupGTkccc[}R|<e>~[)o0|9X9w;5L9Ru8mnDY(fu|x3?D>aR/@ha8\qj'`}7nk1+hO2yOI?5f7wv?ZGdMF[tG{8{ <.bG{4c>e/q+pti
+<*Cn'o;~";}3]gw'oZ(*5{4.c]8ufapX8B&>:,
+K{iGzn0aCNHs._L-cI99HZT]D0LLjU]iV|SNFeoI3qD!KCUSOm^]YU|u}}=<)5v}&/.|pfAm4u6N;?{5)GsR^S:)#~NotM1DkouQsn-a8U	pzh,f%A8Py+bmX+qvq:UZW.4BOrU#Rx~-W6qGhoWg?F),a>r<zVm,?Lc#	x8(g\&7tCv5]{GLpONZXRqzzL_T=Ua]Zk-EZN~nk/?4w!+<Q=J|	!T_/17{^|~/4;}3^w;o+]tW_T?[^yUz/mz&	Y-}Gb#unw"Q,VF![x#pgt"\A=+'nbxxed[aE[u5CHAS7YLVo"%a[Gh8o(,y6q@L<^qE7kr|bV0#p~"r3?Fgkmi_|Xv?<aGF\nu@DMxNZx0HnKF X`CgHuHXGlyd~a26?bc+J6>1:0;kd<1P'D+FG9`{X#34G1*F0J(	~4hg|&m02DZ')\Cu+DWZg`v{Hql?`Q2^%H{0@tyP67\.3Z^O<+>lb#qzIb4)F9%Y/z^(e:,C``>Mb;36d>HQaW') s>YRZFN>nX;g#;|dxVFuOYTSbO"w={wnvG\g/Py;}wMu<9tA+LH@.r['e7~}?	m	{a-CT@6\_r=$%ElYys0<h6<z:\m'{JTjQfi$+e"F9 Oc+&34:s(0b%X	2,Z6:,Zq^Q#naKX9adnUu.Uvk=7yZQiY\p^m/h4>z5)z85^= aj iF]W)L}V:om/+y!=Xb|Jlq 9cTlz;Fn`$I}. fj>'X5f+oXpUo@!Ua<747)HHHu.(
++Ow]:`?	fWd]{	{+U
++JI"#8W:p'8pbG+e<{$7T54/-s8+cj/u~V3^5XM
+kPA0^ 8x'H87SweE@oq,)|u~j33i6t%~?:@87;rooccoEmCS\;Scai,}<1&o!sRk+&vsc|<'MJMi&[vge./S"YB5z5pF"'3yai9B0?Qn]@'e;]W
+V6Qvu/yK?ZKN/K
+\+H4$?iG\+d5w.K^#b&^})ZDHtw[80iA,z;eY#ksl'kq?l@-(B}r}Y3xz14khx57m6uz0(k1>82^Al,1$6~{4'xXvzoB_zNE6xcocQf"Zl
+}\[=.,=>EV0H0<->S?k^}4]W=B{imS%w9qNp)Be.+}]1JwuKE_?S?o/$Vz0]:wG+b53&Rp<4E7cS++~f$'X`fM+(2PoD<(B89s<&_9O<XUaOrr	G^+1/2K0<<"tO5a`+ /gx
+bea$kjn2k.:YWJi^bk&h+wd]O,xhJ~qg^?xS4GKt:NWaNy&^?/~=Zgj(xB_*QG'~B4=w}w}}o:y?[;/wu}?f0\\%b#z.|rk}\Yon7""rj.m'MRYx75FO:uD&r
+wQE@x;|p:8:DS^c=g]Q`D)ko,N{by!br=f(r>LBmqle&]V}2_[2n0kP|<"&xuH=1C6|xi	 *wN@9"M3@FfDjnM;_&=O]@-3&p	2fb&#<lNL{w>+	by>j6c=vM L>4iZ<$Yuo<ivyqOF799mb9DZ?Jv7&(	R|;Hk'!'z<r|r6x:&PeI,8&';C4Y7f>_Pd[G~N[u9[N_<+eC??SB!I|N''u'c6n?=mwYc8a2"&P[pYuAo%+ip6~`NlKI\GWnb80~[:xOWt0~#_tlSyvwK1w:icZ(5p]^.ew30`2y=9@,{QP+g?*?MlIl/dYWn'uZ}'qrAZY<Lh5)IWW~Y??h8+W>l*9)V?A#@ qbwoBBu5J^V,|blFWt)`Hx9^B&NYR'\mC%oV~`d,R1z0qy5>F|j2AZkk|jaT+6VlR}s]qqG8ZZc\$,h94O|aNj0E?|$C(D{n|=7)kZc8Vfr+p;oo[P(^~KK>}{i
+<Z{utWI7	\=T_+'7\9novi=cD<\nk+qz3V|k_f'hu>wUJ?ptf7[UGB7{}b&Lp4DV9OA
+@S?Iv37+]cWQiC	D?P_tm*+ =AZ>C5=(q3XE]7ox<ABk`Bv6r+8-<?Dr09Nap8`3gK38CrA/S+':R!o f's^?J3XmEo s2.8n@|LxcXdO`Tdt`x
+Wf{fPO}u
+eb7c4R7A:^FP FfpT6f}>1-+:z|l2?":s~Ds)<V2,]5&9[AJ!N"Cx_j[rX*Gr3b:f3X{OIL`oV,nA A.%k`R6:	4z0A95a0{$t.2pm7:1+\+sB1l=	G*e<lqGZT!$\",\59{-vs3v#6>fge{L_@8[-QOf?%uc`!Z<H(XMhzn~%#%z#Vpub>^~a?lx1s%=kE?K<t0Mn+g~`m>q g"i`U.}_v>~1K~8%^kC=+FsD78s51JgmdJ}?{W	2&q\r[l8rIb(xT.=?145utoQSyP[z^jZGV;\OjBfROly6AEZ[jsj>"eb4xy70C<_7^rUciRG`*FN3fw~/=|wPyw&vr|K_y=zLX[{0(r)p.1dPx7\y@.H67[.L{;#q3=QF$h?uW=L'
+fi+wWKP{~tunaNwN`[I17GSWxo!s*X{tcFEV;rnK-q3h{3'ca~Y?$.y<+U_MA%
+.x*3#|*u}q{/o{zmp_ nwrsH\bG\@*eIu8q`Z+\&-/9(me#m1U.Q=K}3<	17^3Shko0$O3^3+^+34X\'Ek(z<L<;XhXls{v#wx)` 
+.t=:+r[c8T"LeZ>?<z*6s3bdZo|5bu6}/:e~tz8^v-TP(^/{KTaV@C/v_W}}]s;w3OE3OBsa\"\@r#*,+a/w{Yg<'01M	(!RQQD!AH*!m*Mi8J*RY&	6bSS=|k=}flL}us|wSpk O7+B,'+0AS,r] XMy@J1dD0RIuIrS*i_{	z:j)yk=s,PW<xO#o799&Ecl'#fhKzP]l/vl$:q|TH4/d(H;P&y}{dfchCJak\lakv=Y.;
+
+X,c,C	1H|f<Nl_K"-8kPq#'_^\D66T3A^;	uK+ozk^OQY{}i
+|*p%R^*Jzo/|GR{NNG2oc=?,9FJR*_u/2pyF76dBtm.s4d8M=YXL$7?[|RdF.02Z"SA	bu3Na^8{W1_`</m3A7zp|&H<pD+adE"k2FUf8+zd0]Kk7blE?GN!\c*P/11c! zLv1jx%EO|HuD^R0+%yy4n_50`bs6-kyt ~xY##?oLF/DXsZ?Ur959l|q\p>?M@ct9kA<Y~(e1|NEL@+~:lTMklMo;.?=+Eo+}TLBSU2	bbP
+=DKX#MEF%|b|en\!E+s.T^k,HWsMdz2~fQ7x.7=v3/c^CC>5#
+~NK{dJCASfw$Og< /`,0k)kr<:r'd('*+nv6zC	8=1O-Tt]D'X0CZ#k_j#9H40q^t[LQk& -Dv.&T1*o`?Z%:Unp+4=#<Dsr`NX;I\?W{//1@qqt\&,XG_S>z."O7Sy	uRrg3^''MAPH24:>O-hG^(7VQ$&>u+xz"wEv0vc$'`+p2`t,GZLn1_q05hd6};NDC=XViiII\~q{lnhFBMC.*#_**kCo?c?|O;]98O_8N[[:\8F4.\"hA
+;A\CMF*e@H{E07{bh7 {XkcEvS(k\t8yp(S0H4cba+px#v5NR0{hh\0Y\/.S^$HR\/"JkppD%*+uy?r>;tb?
+!:3RhX9o$N"*?X!@<nMp+8`8m<0$gMY5R*lG0	 \CIgV(+ANs'=)E["R<oM!k{	m'Npcar*_^)K\oK'xb&$",^jIZUb]J.X~|oQ =mplZv?t<>![-Vz/'8Aoc^Z@#Z*`
+n4CUdK@'6P4Ne|NV|g=;4$bG/{aW[3Z{)cxuD*z-)n.
+\-zlz+\sT/+_(pt'!?
+Sy?M|f*<PgfcNw|9%jR]	OI1x#7Ot,7_{'Z<1#z<:W*7^Wzgug-Z^?+l^k	E!4Y-:3=Zk|*S(&yx,N8Y>"??;2Y?[.LHb+,;:E+;)ko__&m;+
+<
+\*E
+t=t7_?5gW~W3?tbkOxJzS[+g/q%mn@)ikxyai1)UjzxS[b_I#>q	q3]GFoMHM2:^UA,?Z~`mMFdt?'c2	sA97JFh%oqDJ!09YV+re%aup&<</&754pRHVrPGnKk?tt{s&C;/1x+@KCIM+,/!,k}S\v&& ?bT+S1>''/aG5AmYy,c9R=/\qk<&:(_N-z\nFTFf+JddM%I%Fm'>c;Xy@_WO`^sa'/s=&E_IF=<JN-0	C?p&sA{d.e{{}J\"MR5pJ6<Y._.V=pDacZL1	/6D^8?mE/U|g{W{Q_+>oGS'~::_B4'r+Lo>}UD:kQ[CH=j\FCu.L]gV6ikzCUAAI +~dvlE$0+upXwsk+|-:9u1qg||mYCF0vYxIrJd4TPF0UX:c'1??D\[uzQ10#k"+4
+3^IpbE#ntA &n(v{/IvYkA>>glbYC?")[|GZpp	m|8+~S@n<uL^F?	8GybG?S?!EDF%]\D
+u.KuQ*uCNsl_G~G^w;]zxA"h.\LZ<\
+;0P.x&/%FVkX{TM27I$L`$#GblziCIv/Dz_UxZVMn<fD{;r^];_-dlCg_Wj^|!3wr1NlNv,\ MqMK#&+\[tRGj1N2UdT{tYeS]G<n,)ouKHib:eyyGYA"\=.-n]/RkZraj{<^]cWY6:5~lK"SO2D4Vb'!e CO]rATZj/IQ<\'Sh3Wu>J8$9*6@6WHk|[!h5,G%usz4>x&"DuySUQkQ"n0c%"G2yy4j9;%x/3Wc9j~urYk<>co~UG1UHz4Nkxi
+];@CwA~g~Y8W3js%2LL--9m
+~>~if`bx&^47Zc{HF
+%D,/W++&\]3m6(aW/c|G;wk7J1FMTd]+j+fuA/Z/uif;kt	+ZCG#bYM$fMPV{O?9Vqr7Ex~O}1w`JRz?o|<K#9R!e=vqb9pk5`#yr1O.>z[Z0>W*E{\(-#3BS^4Sv<9??g"mc;$.%qTFT e?tORwk[MA0Y{8	zY_}|J5K]/nV	u 6#\<=4.s<g|^+Bo~c/`Mh<twG<&oxdXWOcv7(B^J0OpHN=;MYTaN!Zf!pmsTghs '/tL`@GV+M=@Ez}^=K=bkap=7=M/Obha'bchllyOP0)& Pc:}i{b=z}+p"K.Kd./+}J'5HDzqNa1
+|W9Xlh8b<kc.t|lq$D^v#|9F0o\ Gi=coDn3Je6szxI.0M2n5_U_M-oyGd8]e1MB^*pZB9et}NwK_GtBSq8V\2?q'|C}F]{m:XY,{EO<|S0N~h`v#8Y.Kw-N\f@0v6r4|iP8;zM2,eCe@u$3y`;lfW9EpmY7R9<(n3Mv>%l_t9IEkxcjbC[ahPO-pM="sI_{9l9;N(QP(=lmiyw'Doc7]Gg!=G36F;D.bw+_&:^P73`:7{d8Ts]J>al<f~\/dCjy5\;3}a`@ikGJ\	l7wC7w:&#E's:Nd31>5G5>	Z}\?<h-9C<:.c5\d'=C/f|?!Em;Su}Aitrxf?_[`~7>O'>u}J~W=iWzWWwc5W	zKLs>vinD1jib^4Vi8uh=vN
+]?<mo<DW.4zx+cv`oy/1929t@AysAsoaK\#9x9zp@,^c4[8#\0smF+]4WUx{~w	Q:mw?;WSX\ONf?iB.Z@<O.9GKak{<H 0e+qIOL9Er8k3o>(Q{Okf]BV4-x	o++w}$5l|[9&CqvmQa1;u_
+~>yW+|@VEg?to9{wRa[cn |DJUqTf6W+hqY!csv/vle${2?ntPszCrP&QY;]~rSq]1~xLF"l"?os+J>}7^5yc:asWkYO;3]Ny>sW'b4FqCL`|XT|Utsa>>S>}C/N !CKwz5.?5un|jgtS;<5Ma'+G@3/P_<k!@<~$6Y3	W`58lG"$q'T~}(a2%/P`|>!b` $/oH(>4YK=?O?.3Q;%cWGzvz|\os'O<//]nz?i}5yHfxTG2wE#k =?5hp
+[%o8=k9>@@m;~C."~_S5v}BA#4N46[)F
+4U|FG+HGYL.iqs?`]l.pilXV}`0gVV(}i`s{Tozz#G=C8jv(8E\+onK%_|MO]hV!b?|6RF)J
+rM+?%6V@w:?V'-tw`F08oTYO\'M1/Aupq-^7?z>W??q`KutR76k]RwoW<?7-h\kJkT9\s(|<O>[.K'_$6!2
+'T]B7\6:vg"J|\2=&{c#}' Zq;[1#[.gG,gM5:Q-uy(EVg;[FDvdTkdfq=G]O@?@:c7Zjc=Y~kj0E5v;`sCx%3xQ?5OUS~v=Bo=S8k+*G9M0)WOST`%ZX5^y?FGC_ci{]8}i~ZbZv
+{O~.DVKb? JrwmEX5l
+8:}hL]#{r;y?__T+\|BoxPT0OM4U2n
+zqP[_7@@
+>7H{}#?QDCv~39D36NrOU!HH\a?si!l/2(Qp}A/a&Le>@,qf"&j!Te-[KHSlu_dnU$8%GBp'mr]e=}CI>q8l[{^b,P_x7^s7DKz4zPLeD`~o=WO@__i.[}K!QZ1?tdZ8VXx6Sp4'C7Vpy3XPExKk:[|K~iEERRH^m"\3
+L$EmS<[s36wM"S\~9b=4lkNU]\`_T/`s44h8t*6>1fA.(a5:[P^''aF~pr8`~Fo9C5k`OC"}D2<Y>	ot\ZW~3;|R9'K[[}>//7nO~?uUkd$mFZ>]{y*_mo{'4Du}m?\82Oq%^%::a'Os57wGxoMZ74\K%v"GSyQ(hr#0r3*Eg QgqX}G#:2:oO m;KUOVb/r2`k(G9Uo{.XfZmbGnxP9.64K~a!k:2<`ZKlRpkP/VqVmZ!2CzNn;UM@cl=-z\$'_Sq{?SWo[u2${tN=|Q\aJ%/?qitC y@]OLax44u)Bqd]ZLarnQf_^[]F.I@bZ^E)S9'`c2SI*z3xq\$jV{i_sC[YxSQX#`2-=Oz]290bM]M2)u=mz`reey''ts~SvSn+}sK`54^G,Mckmg7^c W/1t?$q|w}_|^~xl]t>+-^}b%NO3r[Ke+50OBHSTw%Iost)i'@~0'0QjQB15;]KYYgFWty^q}ythQDixX7E},6]c=W_o]6<<[~~?xC[B_V|0{{h/W~}_{g[-q{B):z<=\uYQ+hWGeA-{_~?"{+eLd2+]a^
+tw
+~y(p[ft0N{>pcw;J.JRvuys_A	eU+7A0++<n7jrm\=vI*oh'qB~WFX|d55K$R'zMA,1EM~}zmBicWuFQo$:x C_H{\
+xyF__{_S;2}CYZGWnWXiq?J|g#Q=}v{D0dn=^=-nYnh~Q7-wl!!D`^P}9m3ZxP7)<F2J$e6ro?@gT@bC/jg]b$Mg%IwIm%}9&8C?r4	Lz5',QoXNZ&=?pAKInG-[$V|Zkr3> -ogli#ct&}Z@I% 0"Q6Os+['2xl<|<}+<^>NOdtEN4a(qVTyX|_3cw/wN_+gG:6*MFZy}}ww:/lM)XGAcgsDPsR:iAqSzK 
+7COmBPpD'ry`
+e,}s{AF Q<ED,~6#ys6Di.[y_U|}Tdo"n3S?<!8FCEo~[}&(zh^Y"=qY$P>ki:
+?hbK1=1Ey3%1O#Jc|tl`x*1jT5/E)64?_ NoX;8VY'+s^HiK+]i]Sf$U#QubFY^za];Ccdb*rb$(tau&JH&ozm@}vX/Cj- R\Hs~	O	P^Co^^&\.`~Jtwx;[JoTxl=4
+Vb%hul+!5f-|jQKl\/q|+O2E4`\yxceU?ZKS2|i$@O<8B'WBg^K]r~\p|2O^w8aY	(RcX9'e2zH|v$w1L"$7\k&"11gL2QB$82+;dON_z,q|WC[PZRR/00ej\.8/9%c=v_~{JF|E|pE`k\-t=PS{?#B$UoW=/GxWSr}Uqp+<F'~:B/%dq&]W3+p3qo.25=+^/qS6nc47]lD"T&>/S}d0YKpOgb7
+xvJM%ytVq.I$8\,[N:HT%p2:dbZsgDh,+_;d6]>	>Mx.`qX5V0WE.u"-f?Z)?A0X3CmN:5	{%@J4z<sd;1Q;#Po0";\IUdf++O|&_kmvl/cVW?o_5z=el{,+hC?hCJSP|x57:-Nzolqs'uDU*nFL7x<?u76(\+j9$xeG#~XQ%@IDt`f]{H>=l&}D/<sb4dU*"Qx+w0&M`x6qf=N#GP{u,$=yI:h\Li(;AtIlU M6QLA*d+yk?oQ`+tHGbz~
+?O+C`\nd^uz^wkkO/OM52&dngQx~Iv;y_*+{% 8d*
+
+A$Y\jw`bMe13dT:1r?v|dbYaW4<o/+CruEW-CpOw8}cqH{Y+
+\JdhvmYy(zw|w|NnV.)1v|D;MRtg+N2B=Ie';>1
+@sIaECjb*7~"pC>1X/XgmS`TG?0ag
+N,Rg_
+&:}2Gc{+u_eT0P	[/m7~?	/(#31n`lqG]-"<m14TOM?QQ"nj@]!G7+<l{\rFem_YAwrLj[NhcDyX+6V:uo:c7Vu0fdw__4pwj3c`Wy(j|	~~!CE7b&{L=X:
+yV\Ce8w-tnc{a4rs[ey&X	fYj'L>"N+(A\+L^l?2J<e?).Rszvn|[J?$ Lb[J+R>7yT`IFMdj`vK{+9iUj5<d$:!sb5
+T<:8{ndXdf]'6'lZjZCKlpEKG*n?bY86'GP/<Pk6A[+8ykx/JtMSmopo
+\pNH_=}Ex#q~HZhH,Mp"ek$<zm!iLzTrT+lnR{s?sC162s)Q:3#O-U 74y$dJ,\}H(>Ft]jXXvA~*OY"bbLW
+V9_<y7-zx[:'D#^VmVp:^roxS`gM-4Fj
+5fu\rP|C+>r@"$z@
+i'_e:xd<O*AG2+945+>n?6:rTff>Sett`qG8%AzQ8dS<:JSc>|aWz\<.RqpF]W.MR$FJ:3a&?=W+/|GxRJ}uchOcgbbscA	4jE##^
+gN'7jC_e;j:h<C1HD_vH5j7uvW ;e2s}=ol7!xJRGwQmS|jL?q w1uwllE u^NY-v"5_$RNk^uk/)-gfpEbVG'18k(y.ArdD&y"5]g~|8X?,:A[];l2z::$wis#9#4wP?7L
+nc@<+.rbK:F
+QXIC^jgeZuh#me5|mY_<4y:U'B&	aQ;q?:j=/[8TV7*A:JG@^iq/O79:A/2GiNoA&Xm]78ed\]F6JV`hrH."/7HZ!GfNaaOQ786/@L`VIcej`wvf=v3HMb^hne EYcmPqbboj3(|\rT5uV-lYf1T*NA&!L($a_Q'f#>C|mNdic2>*(=FjbWk
+_FKv+z9c/.Q	RuwSTj
+t2{w~%y]mt-:Bw=xlwKgnxrS@A[X?*ET2k&BNw#yGN58(:12g?<2mb13PDq!'Lj}0R]]$3-V$~gmI\E`8bp!3EO<N`V|>$Q\r@:!q2q?JXb$<6cF.tM&(-i0<tl"yKZ:#?1%j 0xP><@OZO~*
+rYJxc1d|G|pr}-2N.?Tz5r/{?1+^%m=?Y~``QYcw=a&[
+8HML"hj8FFYcc!1 +{K_l/p? WU~XHc6Ov#}Q01VE+m\t\(eG^LGm'#`O6R.c9vd0.4qA+pgO/s(RK9/JsF`2n(~|XU8wA9htl>ilZ^i \?+ysFoY(K yY[(EL^dRZPHU+)?.>I1-51'c`Bwg"z1Q#":(@iw|GVx:XP#(}dOjRoO
++6q0D:a&qW&,VO,4>!d[3t[f8c]awx%5o_/%23exJ9wzq]{F~(V+}t~XK].|	N>>9wV%Dnr?1ca;'r#q<8l(16/X1>o^hfY;	ce Vl"N\F@Ju'U)gg%vYSvegw_c>	N9GdJf"<A8cgk*H-[mIXI2Z$1HQk`AX74\3D]	_(54+!>osD/{b!'zpSv7@i+D!;aDp3y/"iF&1YW' |h@=3PPM::5/V1PFVT}H)QHd5O~4(+YwajYeY,|P'miF+!32p]#r\0=asYmH%;N3Q_$,zQN^Bc+@c@^+]+M%C:->V.6T?o_<=cDImh}nY6c;h'.#$"o_dy1>jl0_La|6[|K`tD'y\C,p5Dj3	%Y^gV&sY#^lWR`#\:RSru	FF<5{~V.%_xXG0c[+@6qBwK5XoPl5mhG'/>-_GLc5<s<xFu6gFY4}iu6v}T&`Z2_GwR{j7svU~!)oo}wu`;>;V[E6LQve6G9[	#;x+y2mVAu?x^Pwy&>qK|&w2S!O#t+z+]a$@d9{tylUW%=:JF?7yf KAC~6N%Nm&+q#RX_F+yG<!"	Lj46O'!a*4c	V3e>(w5Z|j:s6{d{jX"WI>m:':92-zmm\bA'^$>WxVM=PKG.uLgM)+	~~UPG6M|U?j*yB$t_<3~{,AjOV1r~*y"w6Ro^c`*\$l`6eYIW#)m(%#4Wi,ziO&\&:4*B$3Hb~mACt@Wu-j} @ A+Cr>;9DKk.P]i&>7;vPfdnur\_E%'t`7HAL?q*%v:*n,B##}YC(OVj(vXsl?-\!D
+&z$@'n'b/>oz{^57-/X/01Z73/&d]F}.7@o4&-.>_ZL}Zi/|/??r_;vHoRy	lYG~!*9/zC&{|Lo+r>o}[]o||v=z^P3e`3zk7+h\JR]Cu\78}a>vGBh6)sQ`E`6#Fhb#1v`F"4e~$f[8FZz*!2t*ge\>+~1T:N09
+!c;
+a/+]YO(He"=MYV.:S~i:)w!x#&6(wW_=lR<~
+7(v8_uD/7/e~u}oK;O~sW\\diTqNy<70LX+c,yCB Z3L_}Ce@)<+Dspf]&7F7`0DPxue?s~kS3L>Vsi`>UY5P;^%Jsg~+:._><\{*0g|`{Z	+Z,$fQ&5Byi	$Bcgk[4zeo^IAJr:?y|@+	{4hps%5&>"i,t3f\gb3lRL^)ba	mHm7!)*q"J)62zOm<If|T<3	kEQg|mGeOO.i/V;E(>CXud$gW}@`0;8
+xyyx*0_dGtI6=yNoN\H?66L~}wReCD{<)_qc6O88F9c_?V'
+A8a(Ml;9~p,e+:9RB5">;"/|8Xs&?q?{A8PPlnbz{/ENR0?j*E5?6cfTv2bA*&sp5MLpr'
+4e-%&7e%hL\4)ZgpHNCxxvZzF(3Ocs/1Z+$u-3~?Y@";9~FKSC7^3O/;zI<St1>jC*{oB}^7k83iv{[d~>qr3O1nI]@IhD_KP|6-?(+Ml .:;aUkO7*o:s!",@2(Kg@z}vf|nFhe,saGQC1M#>>zR@29-m#9+1g+
+j^a&c)t\"I]c hd.1Njj=e~<c|-]t(zop48+eyT\9W.n7kb&I??_\,OUW[sl*i&fr|o+-zEk-<+nP`DK=^L8}k}m}.XLx45Lm_W>F^61!d%|:B?tt}zXXg?\W,?4o<|="}7xRICbd/\r0OX@oT
+3cl 34?,hYn7htR0rb~BR5FOZb[0DzB3dL(DfDWxFbulv??/{+G]W0h^Rw0@(d%&tiE:<cO>T??:Q
+m#z^n
++(E%_;z:t%q;vb~ Fa<j5/*Wh^{{>6ko)yxOd{sGo+ e|u1	XMx	k'G6hM/{	\Y1pgWV"+L/K&^rzr+ia7l`D:3
+it&G_0k/]Okf,b+Pj
+^<Op~u3|&dcwkTC=]w;CwDz2csq"74vU+%J!U2hCtgL5crL=$wi^3O85Ory%mqi{j-oy~VH'}Q!s"?7~zWQ'h5DNuViYsB	X*e--`u/1%aP-tBs&=/}@`@*lyl0q3=),2d; 4J]/u5F
+fb_aSeuU|c{eh3aGhACg3JM;WpMY6+Gc.iRAD7k}!:jv-\X>C+f&vk
+A|b8:RmHZ`qjFq?wPnNcn\6zoLM{W_[P6Sr|Whr8sc{Fox;vcs`a7;>?kG	_hm1N7r+ BdjM7frlb11lv~r/ntWPc7$iQ'!vRM`;RY5Y=PM f{1yY!U4uhD8|8s' ?Jd<3`5M?_is}R3Mk_)p4=//j.Xno^}5z||}O<^m|?kaw#':{|K_<{	<Ya8X:!/VakY;>84R$5j>vyWv5K:9J]gEg[#lz[xrh:589&smBfMcC'k[}[xa	:km.8^w'LQME+]D)7&Qo`Q,IEE&?tdGv=T+R+6NEu4L2"0+c8jsX=(=-wur=DKl	Y{Y=mor\;/^;?	Q|/.gYnq?1.l9	~]SSuxsH'O_^G}dBdHWWVgp\jdpj[[{L;IQ,E@B(AE	DEA{X;Ok{8PgXXU>	8bk}lV+A6
+G3YQgVLGdul//_~hn\}oO%O*-d>[u}d88h}A5iKOkVjE@60/TF~bng1S=K7)gej&_;0"Z0=k=y\v,h5Np9ykyi~_uB "V3a4X--ebta^(>1!	j\tk)cuZ
+9QRgpNWaX,+S<~7^s;sqlXp>@HWBM^m?4m'ecKl'8goX']>O;tLuX:&z}>%GZG(vrzX{Ao3o^40hVy1)>*^BF"Z*i8.Kd>l?T)(8k#	&,|s!>lo\l: sIug_~&(=A9z&>pz%G9Os']k-u^|Tz/~~#M+nU"l1b7++T.Pv1V
+!,,y'e
+:V\?cm/9OX]!t&nzDIrg,x9O8
+0/y]"}~Wkt<^K[`0-HuaKVa+M[:ZlDXO~ymA'sR$k	].$:/5nj
+N87D&K}R8'Ed[
+{{6qw7m%+){sl_E@>RfZ&zmnt\Za>Gyts0_wJ 9}
+p<jgVz=.s0_c?cmo{E?_q)in[2+'h6c6-B`~|s?gKo|in6J!&0cam+4.[TqGn;z'0DbH#x5I(w,P&A^ljeG=hw](^7Rm%i1(QL&{FCOo_)@Nuwtme>p1iQ{(}CF3@IF40z5?XL
++ZSk`en_pbgat`yV,\U7LqX1/7tr%y;k<-jm'zsM|:cU"eK]-7M5kWK4Cm3`I5w>-1q~GFks}KES?fYq4dt=7)	Z+u
+;]_6{8ky9k+91SrxHN3
+O$X"fAi+^t:oCkmecUdk91Ohj9r,:!)z~j3lK90PttQC<:P3$-SRu\JCF?%+pfMHiKQx8Mb~|~OOg7L/_+ZcyU J4@8|/5={)"0o}A,/y_p>|Tv
+iH!iFVM^zOx9_x^nZ/`W `}]x$J2E}_znlP-'VVq},2^:k^QIS*KDd-w#xPd0KjXkx:A6Et0h>S`9L?}$;1WXl@RzNbn}YX1#)mqPk7MJOSYI>x@A-k(` `McjA1lubX\t@2!(Q<kW\KstE[ 3="y:__1;)}TW0X7+c!ZcEs45|6&4Z^D&_+M{bubmX;~te_nr_\pW}EK(V3&rS
+7@F_|z+Yp)pkcd&_^x>n~+/rzgft91s)5>eB2nx^Tp95?K>CQ:=0Dd{oE=1E6h5zLzh0|OO|A'AlCmz)f^~~WMoe`s*|x\;VHd<+/{>r-)Gt+*("Lc:mkuQ}{h%Dmj\J<gjVl69*zmo3cJ'/+0}(.fzn~x+VuZ-7HtNg~C&;ST9YVvxoh*}xy`c7<7DL<[WFmVh~&&FNrW(u
+_|\7p'U6'E*k4+T3^7+>7UKI>oG_scKZvcsJMxKG:Z$M} \~]r{|:51,7^DxO/z$A
+T{<Q{H%524d?>4j5sH}1[B+_ In,k5?7	1uw6]>OI7 +F;'+|g//_oau#&\o>v5}_']$;iQ@}Q0mMnd/5yFFCEM7F07Zn,5h)GuR
+p4%OF3~y_	Wj ^Y)$PL,	vD#WA:~"[+6uGEKvz|~@<L|1{1H
+9CZZE\=Fs
+1v({d3VMy(.Amf\GC1jb:o,3O?;g4>hsV?zYx#nt;Obi^0/pr6
+V~z3~Qo+0Tf|Xs2t8HFnEjM
+qg[4{v~F2l<K:km+akm l8FpKo{gQBM:]S{Nj=xG(M;Fs}a	nmCj+miYv	_9H);XOA!;hB)mNx@#sW'4,}r
+%u^"Vjr'v^h!67/
+n{6Fw2#Eg~OV7o^DU!lM7%54xdm_HWsb[%U/{iC<Fm0t+,@VP1Ot-G$9;z7uAdKD|ZeDxd:V`WM+(Q{*pT7z>o_Oo/w|TG76oZJ6TC<ao[E\a7x!M_P!75(9V2myG2\X 9acc*(:9'5A\CV-6^}&mrxI_|SJ4J
+bB2zsVg!.}];hPuNi~Wcj~Xyvsk#^L0\^0juzn+DOj5j`\0i(9/0+QiQ5- z(wr~'>llJGX\+43c]}y`X]}Z{?<2,}^+;q62t+f&+gmKa?8DM`q?2qAi=bIw ?eDC/z8e<M:/ 
+A&7p6R@]nzQ1a5Nk'qzGuO^yjJC0
+3_+Yrh?\_m$4l<$&ev?0(3mO}.1etP;fr"nZaxEQe7YcS12`OpS4[ziO3N~{O~4k?.s~6S3X)Y"x_|zH{7F"oO$b}{wzKXHO]'f~VvLO955
+1|ni++&#+:yy^X-x:!#O(u>^o0FKoG:%~__zxw-uxlunOAn)(5.rG+Ys	-1[j`9\g>B:%t?\7xRgY`+6	s{}	X
+QW"@[f!?Ozojd0o=axm%DnrIP8W:0V{Q+Q]^hSq0e}d46sw+
+ou8u><wJq1^w8<u=T;rS9<?@$o{c9^~_*JFbvJ0Qy=i;}Bs&G+R}
+<rAZo~7}w|*^<VR.p/~ll !%Tx
+X=*63^4zlwpm	PllD	^@x7A?5FTg*#Rc!e/^(`_7-dOf#	y z=TrMPGi;@o^c/xd:`|9+{OFCJste?sC4SGAz?ox/:=i!2%
+~Tz;7lO>wots6Urt_q7Ff&>~e(/iA^j,PW% jnXMSFiO&Q_k8"l&E48
+vN>ee|({.s(^9xst3'#mo,+g=6h>d,B|b?1``oMx@SEm9uO;;'d&'9TLFIB+KmXb%7~`,8pM(`zu,7}?~eo|n3RZpC5[e%b/q1}4S=P*9J>7TuS0YoZ:oG+-mSDI,?]3+<^gTu0KAR>FU\lPQs	{FzV(bCH7?Ea0	D}!EGQ'E7"oZ:)sj}%mJ{0;y"F|?A$NF\s3;f1oEyW}x)[+Ko>	s=O>+kqAO@M@zPJHBdOD4nC[B3%3^)xR~\TcL;Nw?G>+t%mNmo;}56aRo`mT7v^t\y7!ka9uQz;>a^0XN+l1rf%NT E~0P#xyF'c}:*yS+TM+e^{F0a/1&*WS||=,@q0+s.n|5g#~.C`oP#K29aco1i5j`Cly>>:reO ,L50p8h;N_
+<oEOqoy[S@wID[qA4xkOM}	Y)r{A^ndh]>DHIMfE#<q&7x6XHdL	Cvi~>99rE\@#]yPK7e;!mht4Y;?zI\s.*{LZ&AV+6]S8G97=y2rIN@4aXwZfMWk;tr@S5]/z1>,:phM/H2"[06XPb5A3A[9y3r]6&#_=FH;^s3_xJ:Z_g?_C:7;n?V+%7@{?1F7^\K\,=W^qeHpX1s	e
+]M:p3v>.}iMGm$A<djL.{N'|*gF(T{9%P+;Teolmz-OzA& [Yft|d}M<:V)|UT!QzU~Q<+NALMf8T%>9=JIA>?(NMmrs%5t*[Dkp"5uHL {:^9h;	i;|s..Qmt+(3VxG7;<tw7fD_it{+uL+s@_C6c=jcIs2c"\[F~o[$T{<{W}oeK4c;m)fhG{Ok`-kC!CO?4G!R]D&|}g/(Gk+~
+
+4s*_(id4hO1{
+8Cz+Ze;nVIN@BZ#XEDjj^y]$>y89)=@]k-}as=B77*:"ff6*vv~W<w
+s3DT+pakoj3#5Q>(mu_s~]vc+Z*_w}_v+S	<^M/4`z1N^w|x8=5>686Cv8"JRHJOC(k0.tb+hR5-RM+j	,,5{99Y8Gp
+S+3`X69(clW|%o9oNCsf(We>+4Z.R`PEI9'%c"J(27_E/y0=UFBO;yC?}^+oz]gk>i7K/n
+x1n__^X{{
+s6pL7rE|{i~c7(s>fi#Ia7w?:8P:"xN!F4B;U8%P|$:wr'IJ|~k4Z$ojU:E	%.Pu$Qi	8/@tR_j	";S/4<6@l
+w9>5	40T|e+6Ps!3D4w^~+eg=6q.-37bq/a8@WZ8 8L4Qq+rfU1%&7S?-!M[A+6+c#n|\#n+z*/Q0j{RC	,M+?|Y(x4e`rA
+MDtyTPln1py PtxL]	YnaIV8S'^+]`K4c1o4l6rRl<y#{W75?fm*:3!C#,)s%Z@587c`PZxGuNc@Uf\A{d%soe9d/dn_Rn%Zci*}g^;}[q#]nG}C.coj1:u|5K%O/E&*
+
+Hoheu7 	`o1.!
+i_y;ktbM',(7~pL[pD'.
+/9,UPk5hD)YiXrL51bPZczD_ b}_+x|%IV	%@:"~bLHoq|7C@ujX(Yl-dFj,A}6jZ^<TN+qBml"bua)~`_p&x/1C1#q="Nvj\+kw#K]~mx_-or=VMF"5>t_Sw_7Uoz]hE_v'/?*_~s+ryd![jU@
+DMZ~XS{8&G|}G551w+v%XkX*P#4;\l0`6,|Thg~V&fk74q;'o1+pa:y\hYS@yr=~F|}7"^Fn|EN!5K1D0h/[9Gsy,j!1^'k<vfi1p9MB\"yvZkrz:;Cu,i@L[SJGS]^]~0TO]0cyAOt`/<L~_U(of[VK#uPZso(0z[+!*1u,q~S<Zo|k\:O^%m!}L
+V\hub$[k!+/hLt^i$b+&}URt|]w~w{#57,|SG:y/_q%|bp9nJ/jy$$<b{5$,Lo6:4v N75>fnJNml|%Fz+SxX,z	H/o$qE{c$D	!vRr!iew<FVAW7X6bRr_nO)~V	",P1X+"oxczON8G^"hsVxa?o6kd{kaui	5@Skun6t~5:nTWr9z9+OU+>*DvHI@	;,#=\lzjuNUpwWhev9.x^bRpc1)ZhOx9z5p2;fCEc.X),	mtF]@`y873[DOWKuI5xFqa8=GNo3}8;6{nER#^Q"uH%?@TA1+_D+5$/Zrf7x_*Rk$X	R.!5O+8FYKuVH|o._b9	-l;Btp8y	yq,=Co(#Zn?3?'=8|d-l['?{Nw:;o+/#E2_7/7kBlquM07 G,G]5'LYo(>2isP)Tmr|SG@AVLn3-BZ5t23m5Nx`m 6Cvx`3*/?<uUvBP^OjDl"NUAk(yzb!J\nu]+rIkxq/6ws|Co}-:+42Hiw8Nq`0S'a9!3>}E;<<>E1g|H"x|*WPu`=./]7z=p"TP>;G+`c:I?
+f!r4X}p<0uzF#;-|:9q&?y1 tRV	.w!X{9~~|^lu>YgJg/3H:`,O:2bkNv5: /7QN
+9<$t]4	xnY6+GK@<>l*>0b`9WF;N6|U]mmXku[rLJTO&[oN<UY@~ee.g4~F4&`GOm5>lxhMXA+wbh3'"H|/D}W7u3+w`#,ck,kYG3H[{=^{xhu9<`+&V?k)P/C+`^q[NOOrUW}7zq;c,OD9EBXQ,tFnl6EX%R1m&c/{"5dpBG>%SwtX +#,v%5^dgH*Zb%	F^bN?6`-mNUzSRz0ZwZAZD}(3KUS`T]#7s^"ql2=RZS"\K+vB68"BnB`!934J/6dL6	AqBCcDu!}f]+#_1]ZbHA0kr*3gJ6VGwk#=G	q
+Mfwt[}tR<*qokA7n^ed=ya=FpV lncIt-wHJki|b.L/Ggl4lz'|x0h	f;`L5!
+'va(m+r5}
+0	GC-5d5`+?^HkW|l+[)6L'6=';$H0 {iWP]T_Qrs-pFJX
+^i^}R8+SV`Ct)/>lENB(Ao>V'N|Na^o:NYn"<IZPC?4LO*}i(Y6E%Q+"'g[:Xljz1}`zkbHy}4=|vh#*O:Sj#j.PVZf>Y2t"Nb`koel;	zF}Ysb,T'+d@=y>q{? ,6e+?:_tu810tLp<y#%UE$z9z4F}rK0PRjx%	->@[uQy~3<qI	,sugCrf5/./hxclOe~(9~
+`KflfE}@O]OYN`a=r7x5rx6(-
+3}>63~9qg,$Q^t21B`|qcYcrE<S:|x,R[o\HY2Zm/8Y*L`W7jpTn#64L8Z^H?iSoTWXso\Rr]Ss=wmdedv"YvuK,~U8
+5}Ep>8l"*(T2u<l:Rslb3
+{+7r2@qEs`@GM/;5!
+.N}u@Cn{xTu/sC*qHu+P}q}[l:|eE)r1mN$U/>lW^Win\?NF<%6G4
+Chu_Cw3hDk.x"i[o[nfkY*4=XNoZQ1U'?>+}</8c415GvqOtFXx )>	m|	$N6(	{bjP-/u>^%^^Bk+"XrcsamC41&5%>^Fm}P#>e!`+1LqR}Vbbgp lCmA}:6uMcXQWIA]yNf6D7P1xjVIR2_AT{PNPQ??"~k;+Ecs{>z&:uf[t1@LzQ^G_9*0O>K h#uf5gWOFY$Hza%n~Y(2/X-He'BBNz:!4\/c%e>hNn6rBOs,9
+#qt2EtShP7-Cv5Jr*ULwxBkDt&
+;/@)#cP/w3t8I.4)9_2J<s2w~K47Vx7h-]^4Kh|Z"lY+G6lk5;E)1%z?}gO#Av v"5eloz$r6cYgZ<
+}@y7vzw=\xs"v.&}NQ\__0)~hYDNI*9a" h&9OWs+sXiqs#H|.lSG#.[t[77$dMSjUEf7E|{@~OXq$Gnb7<^2x.l&<n<B@o,JkPsphU7yYHd`P\#'`9927d3ce;?+)sK8sWl7W JOl5kFM6+`|{aho"cJw}FzuPi
+}/U,`WuzZ^:svg(*eOK=O-|yVx={^Yjt]{P9{|8d5h:^Z5z50B)uU"pGZu0(fz9_lSEj;>E<V~'6Oq@lMy+C<1H0CZo]+^8+"a`<Zi?`5"Z*D[^&?>opz~#ja^Hl|BQYf+>nx4D;#S+-2phkmReypznSqk|;)o_bG.@9ei^|7?<%7m/oXXHBS>E'Uyo>cFD>Z+/WPqz7N~1h;?VkpV,q#hkRL>uEhZo`dgLF,ydjF-gS'?x*Df05!"X0S@je8A4z?P(Mm.t]s<RJc|b({yq05]#T:k+Tc))p	_a+|_wo}Q;G|c^w
+U@H3+0"zXyJY,m47Y1:=P[}'}3]/mz,k3TjCpbd[7{6*{Dfi=/?moyr+HZd5*uCrlubXW$Y;IkR R(7n6E2Dkxh`(gcU-Xm%>.Mxm8lT=L,+rNbK&u9,x4V|k<G6=Cu7xiMf7hTfx_>-'g9i `N'VP_Ei%P1U_:~Y^w|8:Vi0_tcnCRy=p7@]A_v8yMkx0 ix}Pt@-mf17c@?_$zwnXhXtWvpf<t"t9T)>1l
+7[8il.b:/rI'}ywu}	ZFUxF^y!S_G::`E|5l!.UOc<0#kp&s>&W[+=frs%<_T: 1yZ}iwapL+k[AO9mib 4VAVPU}W6YH1jCoZ[x0,WN;?'"P?RK3;sW@nyOkC1O!Ywk9@[_|s!vov*V\+A(LME}Rt~K:=bh}+&^	kbSSaW4LgY[8lq^#AOxa3Xla;"	}e3@!%F8NY3Ox v]hrs^0zjva8<o	<>|&dzu$q^i'lJN_6%J>Z#AFys>Hb$QY|+{F@4Mpthz/V\_Rt_mzlw_qydyd49*IY-Y^$[hI0_[)>v4c';6x!s;Y%
+0g(GkQ<9
+C7uQbQC@G]C\Up97fAPu1g6uOI`9WHb&n;Fx3+em!l0r++UQ.Y
+?nz4|%zki=tqt~
+B+IzC=ms3,YH8r'2N^_
+A%d `R%v^D,QR#gL>yZ}?ur35Njp
+r"&N<]7B,M'R@W/cbIc9O?,%Q+.bolmT3^Br16}JOgdWx(Kw[YXq.y_:=u/.gYK?EZgDcgg*a>th}^=IKcG.eK5w/SaE  (^>zRZU}8]oc~3u!XB=o\TuE,zy9a+pwB7Ez{>+5IAM<jthT+vmQ&Rv[p{!e~8<$8~W,Wuq_q\d$tC/8s3-d
+?4;X!hyu.9W)GaV*m]*{h&fe:. Th'PKkN"{JrWiq:Eq-l}+}U {TTCowuWr`+cMQ3!9~>*~FbFmp(J/ku3~7{ulk8CD5a6VHhEnR(9:?"}@liVcjc_M~-w=V+8N-G_rL=Oiui_+ym#s)fN3e
+6?EQVFeD;xHZ`b#kz%Dl#hbFC=s>'JON	9NY!!Ik,`g=/)^;TA8K[(_?z4J$|*z9ygRGhC)O+
+XO?Jq+PAX\f)&kfXkEFil[RTJ.pxM8vIfTW6hAVw)JZt'wtO1:rj;,F/QK89W}tlFB}C7=|V6;PP*2NwRpm=+I$YLjmwwdwj@b7WAZ8+z+e#jbiu+?	E\
+>1.0'e_b!Pbb.dK+}Zkrax=[?Hy>K*C+Q^k,++=:+8X:f"r)\rsi+lC+RrE^U1D'A\	&dSGy0qw'?ulP,h1D}QqS*neU+'N#28y,HZ<HSv]z:K4,aDLlF-23i-27{,4 cz.fi`y6O<_X~Kc\kSU;<aLw/2{5;v_NSo!OZ~hyXW'?")D%LEhBnP(cw+TJ\YT41/e5loK{@Ka
+Lknx0C
+0HuVtu_EC1H+	,p.7oXxBW	x< 	*+>/7p13n*8Y+ja}ZSo[t
+k-*Ag*WA$++`s@~n~NpEQ^'~pDk'hz^<?9r6k /o1($Kc/Yj1.|Eun^xJ"s29(c'(m}k9k+sii8kK+`qunQ1t@w|k~>r'oIsGn6N>4'o_~=PO\_wi}|d5?2qn/'5]A]@3
+|aol#uy.	X+dw+9/479v}HxZ.6~HspXIqtqi}>}|w$w~n=XRrIEcvX|o}.39*v"~Dt/jxTzwM	wWPu7vy[|W|1Oc>oIk^Z_W^bS~m^}-F+S"
+s)bIgsk7u4P	8Gr)iz.Q""GM!n5W2xy$>\oz`.u+p]#s6nhjaYon9E)(9g9a<AE9J;+dwHlR8[hr8/(2==runlS"ZcRzu%[m'WV)Tr(,GTjg}6}68&X>I1X)>m89BSs~n"F:9~zo3iId%N@|:_\>?Yx[Cn++]<y1pc;T5V.+}%~h,W_?lbi`j*6Z07H{x/J1/a#f\qdesmruJjJL2a^aY6j@OI'-Wyhm9pa{x/
+%;o~jMnO4~fsFNXmt5@m<<AvLoQNo?_ruh]{zV+3js	zfbS4oIqk;"EDbS.`C0K|?eVSOzh1L5Y_Kj;}VzM~5{UMl(u4R?yW~A|-^CQZy;u/3?^i:"<H9l\zeRrwi*{'F-inWtb?
+sO?;o+J2<GtRa5C}`1#zu;xK.1%,Z|Xh%r': Tk`POi(4Y>w@9A'+m[cQR+!|zh\ exZ7M'n??;s~ueX>?'z>;Om)rup5{n{a~`<Gigsrq4<sr5W/:	*CN|~_/z&5ZG3./hctemc"hLgl|<]{3<y_Fq`^A)#Fy+lm:	D 7r@o00O9:,8e|m5D?4V$	d]RcG
+z2PiQ.v]UNZn~Xyxt8;FJ&_Xl~bG}:d/QYkzbnc'nV+-x$pp\dTNE&<p4O"TbRC:Aai[JG(o{*WL,c=ac"M'vs+"?v@ZI#+.H0/1/ {(`7
+{&ShX7DEN|`?23.'V|>;Z7oN>4Ixw(.;M-.Nt [#e"b;%`Q":SOHEaZtQm1\JupmSPC,ON8>T|2XOI}z;Xed,IW?iKgcx"xt>i*,<`9@.lZIZSl]plaJ"}[W?+m6]C}|u{8vL$]orGW$RRErj]kUS;s	SZ}cGn'T"cUcgAc#|q3Zj:e;>>!O4fD8-U<6gAqe+*?+Y>RK^QR)A0iwRn1X}vx}*j,n>u<SCvrZO+G6/&PRX/	%~9TC4A Bw,&:GwOc":`u'EGI-B5I!!b(~hsRuB~V9@!eb5xm	2Vv^S"rtK,z)A6VC)v>h)(X$`9C+8vu7-
+
+$`rerrE64FSI?SsSGh?m}uj.5G2HTZ^FgGEBE<Ys1:k;UHsYP CO>O>t^bkg:v)i_Sb:MpWN|sE6&1kogsn/O_ozFGVk
+25LF/dF@nS|eo>L\uH-!=a= c;f5	z+|"D+y1zv	jt; 85+'+|^`[GD H9UGAs-pfQ4u>t6mj@i>Q0$chg {Rmm}g{G'@{	4H#z 4c?<xiX;
+X_ill-2#rSINX\	q/bAN"zh	|yQckBWaYU|X2)q	I+{}T#]dnm,}-5PMkXv[^y~%;K>~ZX"/9{<!Zz4	g(fCo!B~a_xm=~V61`i38torWY{b\n+y@wG~~|S_O'}3~OSw=]_ 8xh?>u|pN#oND#$Gk+`^	n"/e@wL*c+I6;+~ftEadcIb6^do4fl?KEKGS%C)SdXW4wf[b!9&(g+2
+Xw[']|gg
+c2=kY(]o+[#:~^?>N'Qrt1eR"+^e	*}] P3:[te&okl
+bU-.aRT-mZ:7T|DU9gp.-r	Ql,A6	11!lQ4-(+^6BlY`[1hk:z$@+@nrV(k983
++`54_duWHdRTOd'.7	1d?zG[~)e<'G-b
+?ww%gV	ZFMvNu:m{lD~_?=7L>t}~'{+&7pA^nkm`Yf"4\?iy?\tn?<]~@yunqQX>!VUMN$|ddj_8BPWm/rs	.7J	y /\0V^Q'G%QkLkcoJr|SuQA'TQ0I+RbEi&qSLx9G^3BOEcCflER=sVY9UQ<"D7[~ww!~~w^|syt,.i	O?!TmX_;]vw/wO>v?m.FCT/#G5G;(>Nr;:{xP={L/c:Yyi+38-\\?Htm^`?FLj.uyqLy{uP!>e#pN>pzHsI</h?u(U9_<WLDsj^Vm?|w8)Ojm| Q_sxJR@5l7Rtlc38~zyo1/$s>Cx~ADO4n^%*F$Tx/YC%6[	fo~gOz2M*5 gQ8Om/C38bYt}u3<sM}_n/7uDQN|=_->wwy/1B2AE^I?$?m";]W[^tZYj^vF4sg?H~HUZGD?8s"+Q::R#b}7~'n&V8~i]71NVY_/UK5]tuNYS ][oGn6a0B]8oz3y3g>sv]Y3oqRG9v1K.uSKyJENC|U^DJPmHRCs_oriDg(*b,u=q5GcaehX5|R4]8|5it
+8?7Zi=\<pm74{CiqF#@bXoh)K~w-75A5*Ti_yk|-x/C~m:M7{^Ws3ZzgO^l~zw<o"<"vtD'H6];!~!X4#l9>%?f~,~R|{k?s.KGte_aZj:2%}Tm{%Qy]" @3ZDQCM-1e%~^FqK
+I6<5,q>E>4.}1wmU?kPew*-|,7 O0"hs:#Z[C9Z#;|W>07mzcb?X[=9+n+#'I3W"T*|]9($p`q-lgpv+,V^db5liKj12-$ragCgqHo!u)Y\D'n!@"}}jH9Em\ncA\&@FQQnm8hT=iim3\G}nMV`]sZ#dDN)6-"CU~/9$+2m#,w+/+|]Z9i-Vx~A??cSL97h%OV?O5__v;etsg|X.XKk^oC.2Y?JdO<Wg E}.yt F~T'Tv& -5<|q-yA?Xs\x+XEk%^9V}?FRQ<4kqE)NM6L%!5475Gv=K_L5e&+y)i7+,o,Lhg^@;,+FK\887/:OLB0mssJLPG"k@f+ ;Q(GGuq=+.BP> v4M]H!cnEk6JC-|d7
+>8o/ohq	hI/rY"xU$`:ek:(gPzFi2Ns6Jc	ZToc3K%NB-dXnX4kKzppguOd 5D=g4^45+bm~]~[DhR7^rDMb*KBX^-lZ gt
+],w9@*WS{mK^8>tgY~mX9PxOUtS5=*K(Mi"S1md.(y-yr\5$exHhV7mhc@Eqq7",2=
+TwldUntF!+Z0?z+F]6m4xyz.LuKD `{e]\3r3o:KvIc4JCa$0"^6fOZ$}j"=DZHb+-s<?m^TD:QOK:OA,;	*ju1ax_|T(d*}x
+EOfzq$";/+kTp>tsy1U{+~nYuwD3?uM!mDYK'A>_{upxf)\2/uX__cN}Gr/O+S<yBh2CYDR!JIs@p;h0a42qg?h
+':e/`SE]X}r[1X6<dY:^.;NxZawL#KB1\x $lSEjeW?\~.Js'?*4FlzGj*st%M]yt(~g(}F&>[(;=tz4T5; {<dD0%sOt<_064-''xT.m3X\tHE?f\D5)_,v]jytzmO;|cS/N:<g-1v7C>9	<vFU{z_ztW':
+;}Kl~G^|_}#m>c
+:McE)8(J?De56a+PI(&=PYKi#/:31Gax7$1=nSRl-(Yy^:And%,^)3]ZEGADck_5_B0l5k</3')6q-Xdw>*`\kuj9+x>{O{4Fd?j18Ad]#\pyE:_^t
+2ghs_LT>=8,5IhXCKJRV4ecO|BH .R)};^kkilRxp
+~'z},[y `C,bb|='nD/K/$i4|u+]7/.}~EhfK9RM41/<~}+j;jGD|M_yt]X%%}(bNh33=CMma9*9Ri$I0(U4y`5vr"KeXYQEo/9w1Zt%}Jx_g#?rQmVTdN4(v;[Y-
++.Hh\,bzKI@3|qYG	|Q\t*O@x71`?46VT7d
+gYuus5#P0Q>q`u7DI{G?1tkcxquw#E>mI$ MJ)l{C/8.N(2(*a++/Dx1`40gMX*ft;z9p%@Li#>k	OI09u+>h+lFl@NRXtG=A2cl	SW8`!m}uo?^}xQmW+g6.EYz'Ii{Iy?k{TZTLGsT
+#uKndKXrjXV}:XoU*[gs""Vj*d,Uc!Xm+78r!`oom+| @jS
+c(9nmrzh~=#e1mb^jx;_D)#zQ]Gm'hlVvk>"?@id;Nd3_%t	7,@(~T)6}%utD_[}&vRGGDjh-Kla_n<7?]"7@?S}Jb?O?{yI{4h9ddKIsJI2ds^.#'R7'Fq+&/+bU7lkx}x7!:+I:~`5ksEmP*x,K$@e|A,XgU_]iU:[#YiA9IDoO(8Qz 2r; $?FLgJ-`/)Vw!\@aBsia-=JZygR[[},L 3m]lg1)7`/wI^tW'Ab'7+XtDTM9Q7Zl:J,xjg
+X=I: ??UZ|nS2hSxyyc~]L&iK$"qA8?'GhB{0S&l5v=VV?m|}xhW |SVlbQ:e#5=kweygL:f]0Nqk_?kD$%+b,q7uv>lbisQm&feMz])-cGVQQ0vh`mmPVV	"XtmYZt"wB6z}[Dp+acY)fR~`wW$~P	LA8MBj\T?3_OG?.}U[@?5GO[FOSO-!Q?y[*>"=|q?.a]nn*J7C43w-+18LlnNm}H.=G"a7y{|yO;zwOc{0>XlS4grc>?*L]={0..`+Q[gl-xRY|b]X1CG&~L?~O>KRyIt=#&d}|/Zu5YO7Oc :6z&N6s
+&F>O~pU~oA78afvRC:\636N$?:)P4.qN#8 sInQ\K>+yb%/iz|U~r,RmEzwV2>:p"PNe,AgZX"{|EXo=,Z=s!P;R''Uf#D'/P5,LI;AN_K-#g#!Wf.3F	|E!H8o6b=bVKQV6M]=-Y |bEC:UdO|0%+WK)dZi+,_/QsE+6K"BPhR:bZc{7	w)O}'nW:G!=#a=j.Q5fv'/pR8m\9_/~kz`YrrMC^LrtgNbr!"6F34C!oX)G6lQG][	#].;1E7I2x7aC])s+'qb=/='yBBc~"f<=?
+QN.I+n+7UR)LGK 7$=]sIwcd0J'ttwp+sH GQm-+xm;Cjo|w2]wO{p6cw|;vV`ykk_+d9dR13u<<=Q<7NB;.>E<L_`~=qD{+yw(Iy/"=@K`j6@}\cl_,c-=$;l[<\CQu+]0R6;O'xg}sodv)O|h
+]+1"'e/X
+o=#zICu	w_xN/n'+kJ?<
+nsdX>h ZzKf-K0]0"d0>@"OV*o	XiG2W4&4]Z&	.IJ+.cAE--xo{tcM'K)yVGS#%Xdi
+
+x6n/l3zkfW?Ly5*@Q1:sd3Y	?r3[PRC|3X]liWIUS\,2~l@)(<gZKVGgit
+9\T(ybF/lSFjnEAW[t".?e.(LY/cuT9Z=N(/XTDCm5h'lO|N+;nk@ht-[7_mKnL*D#uE`c:<bmn2ad{2:=z6x3C@
+;ww_~Ka9N_x`/co4?iYgNsy#cO6#Z^t<ne8?,.y-oYVa@p~fl8B	%_zX\+Xi3t9rQ'$vNqv1Nw#E5dtm+)v1c"f"?mY
+OwlGc$mIdvil#.U1yeyk^>ISsx/=1_9"~!`O)t>zOVBG?aM|,V
+z@q6v-xK{`KK.\?0m|Mx{][sHFG|58`i(gkT~5RKcT~*)z+u$7
+y'k+c1]Y1=8>}(k'`:Y[~`RF95J3OW.h{
+f_lHv%j9+r$#dpey8JhX
+ae)XY[jO:[Ens$+,5f;-.{pmIKu__!Y:gXUvRC\6u]$c:)~&eWH~`}@]~].[56f;r	ya^LaS{.3,)^L0J+@+(r9RT}{tx:}mo~y@+s -Q*MMYC]ghW5O;_rt}!YC29_j~zN?[e$
+S	x-h+mKc#O+x@	.=_%{Pq_j6B&w3r;)X1EY\hA?UTZ0Z1G|fu+:'Jl]Rn=qBrt;XHGcZIkm&:^BcjFZy}.p}w<3y	be1j?p?aeTk#A,&EyL8>8z^
+TH'NwoDGt"wJv8wll[q1Bk!<7pwolmk9R6~gGX^V@#F<bvHlN2ooAE]p&~;>_En-+y\U%GGgIX*jw^s>fp$|pe-K&V`hx)m5jo~'+*"
+J&u0BC7T;%5([IHsa8r^Dl;67*{9%o7H=tKQd z,j#/sZ!"Z.t'cnaaGO48+&@@6D;J9=]yss(s/:n9+.
+<Y|-}opO,Jrx{8F~O^)}(q5	dgST8"3_PCR#r4|-5?CQX~|VoS_7RK0O4O#*KV_2s7<[s'1"y/^?ET@kj] h<zuqwrQey?s_gM6<:rKNODN~@	6<J1s1=-;?aKR$GNt;5:;O2X_t,4^oH1Os<!^9K;O/>=|xj}nl^	vWH*ut6U|"-LKtC*Nx7}fKa5r,LZ+k~\804LPnzGZ(mLG>/|vW$gD<RC6WM|yR	NX=OIF'k"X|bh
+TLV5Z#"7`[su7l_S&8tyu~x?w/ )Z_4;)bMCj0aDIJh>7~U$YQ1%;2N]V	$.gux	kHuD=i'#q_1'l*:]zyy7ZizTFD5f1&? ? 
+7\obuMi+>*FN,{>?9K3.4}u{XOp>n&;^?Wx+:Y#}#<}*o~-lz3-i{(G>	B1eml0q O06]&fD/"`Kc#vW@6*XXGuvR4 n<2W`#k]M![_hSzZtg>B*OJ7Y}k3*mr$C'shsnzuwwc`s/saAe{0N_A00VCs#b@&yV1>hv*hzb_D0>(jhO0Ev'^+?t1M0s8?c%}>w=LQcg]v.n+2_?~>?[<Ysk&6
+?y|7?7!y5@>|^zu]%z	MyKSbgsRH5vyn-%|Z+jH/8<kE~>r:D9O4jiN3	>=e/c14<mMZ\!.l1<EtK^<u+NA/`E1I5naWnj*iCtb;F'zEBkbly5|q`@S?+GHJ^C4v.B_X]/qW.D<PBf80=#~Gom	.~g~>1LVV9y }boLC_^5<u$=OL=}'+O&ojWa:H'+^xNkx'6U&jOC1Vsg]d7x.'N(4*fCz?..^0o=d4-v+(4}Q~~Mo0s!Zx'x{J7{S&9?<%U'dW[!fY>7}hq^+k%.vOho(SuEj?st@>YD<UO;Y\'4FcG>#pfvMeAj^^:C+[csnAf^kmV.$`R#Dv}ng
+o?1Rc}9elAs]1%tk=jHMsFAuS5Suu;j eMjhbGlj>`8p&8tw:_X^n}'~;/qr5hh==,	czw_tw\w+*T}VM07onbmG:xj WOn~bimJUM{^Rjb+Z+O'EM	lHeg1AzzY%/^A#:bU_7aZ}:40/Q+-8&W{E_]jq.7Fbn9i/xSH<4}WG~_:'~F{:j8`^o^g.f'na,3$KZ,kzoF:LGZ|qV]ylmi!FHMyHo}.,'PW_}]!(O~O+1qe1ln_d=[@ks@L95}\/gWX#+j;1XP{`YOL8utwbj4z8c-}r%]`-]C(;\3c'}h>996<"e;^O(Z5tW,1G1x,{?
++U_6hkDI*Z`#d!+c.,,{2]!'x`y+*V5/A%kd_M4;XbF?3,J,%Efu8B}h}ox:(D?/?=*Wt1E(?o}vQ'_v%~\,0,Cgm:Q GsXi[r6L%8o+wkoWz}:W	JSe\smZLa3w3rl0f=F;\uw'+=r
+//`3?<}Hb;W[7ZTc+j"gN$bhQ=*O;UW(`Xt2G=c}xnD3{+;>o'xz\>K6|D&]'5CC0~_MqMyBI-ZDxTu>ZF<h3Z+ewWOm7>Y^+)e|+6tt6IbNa5D-wax<ANeTe&sFR_PZc&b=.:_ ,\Pz]tG$T onI#Bl98
+2<0Y\}7ZMX	3K.t>m1?=?GGskza|'b9eoz!~V-Sn+'WBXq%[	Bz8'b[iM	(rB JH6QbT+%UC[-cG1K2tKe?3Loi3[Rvk\GfaG&>@hp#_GRuw5+u2<AwZ,
+`</^?7Uyl<u'$[		:E}#w
+n<S
+\oT_}\zV83zv	K{*7vsM?1;OCTaR.yd:>xH!jXu^U[1DG!VrzX{t08:1JgN|oAo5R)>_y9'rH,V+]w ]+I8>@E.nn?$D1x{e7!Wny8/%xG]c0k@bxZ+9ukgOO||K_z~W zR99?nxqvPgSG4+cXUlo3
+_7)A[o0X+vwT[f')HPNXjEo(=w4p`5J h;l_T!=g-WdMcs5 x.ox	\HTZ"[bV7p!oZ/57&35>n91+W[:VQ{\mKj>8oTD40fdJvtL[`^tRqS~|v(P{7vf,8R!4+o<#q >UGj@?wmfu1k<1v]yLBvLIM68QzcsNFD|Guo9F^q,	*+_q5#VqF	+B#iz#@5!rN}
+Guj2^C?&)qw~]tO+Q2
+R,cWm#i8:&'+"I]EvDWI~~kb0h#Pn>0gCP/RcMosa{vj{+0Ix~-w?m=h@!Z7U;[i*6emSA9:.V2e?>SH|b!v0"!]0l1l52y\}C>|^~pM9>`a$-Jr2Wp1Yx"VC P/V68a^'4|qrA}@YY$&prFnWxeZ|[SkK?q4LPu=YkI<'K<6m6~W<kV1OB{{n}L5^ySgZc(yAz^) )+1Vf8D_<'P'N/"CLpTU%rIx |.Q+	UlS;+s4=1,
+}e
+kk E(oB|r_dG/._Z	:YEHe~_'FRCSM:>y:+!^m	We7xQ(^"@'L`F1/aX+(<>r1mW_)f.5bp(eyM=YYt-&I^~j=b9
+34Xymp_lkZOZ^H[&+Yj!!5Ky\z3	,9S[O"{?Cs8m_rOl{<A.t:"n0Kv!Q(=:t@<;~3XOoAR34h{Bi*<#NA76+u(2+v^cNNs<bbb|LWI3uW?KYys&~_J>]~"ds/U$Z,W~{[xw|;[\k+)/'H]s'qT]:	oUPez&E{Ycc.J)Hq_EhdPqxRx=G4\eH{7g<W+G4hGhc\r2BiVA=3[VgXs	e,iz4.X^4x"	[:^Zv3u._Zhg;KK89l5:~;?On~!*bHuJ5?.(4v(i::@jzGu[Vda>^9<<PvbIQU6SW7?zA_^>P
+=O^] rT	"co]UP?`5!jOy9+h=X%O]vJ[P@Tc@A+N*i4n%i5#\dk]b 9//APB^4Zrg 	#>5h	x+Fk1"e;,/kzY[Q0'!v/#oMB}	g??[cw}kO]j"o}sjA'
+&vd#fu?zkVT<4NA olH&8W#Mr/Uk,o?}?#8o?-}8NDzNfh&`5T3PO)	:n}H;A3$C40jBue{"kAXOb3`	G18y
+@3:L,x1~&U15VZ`sg=S3	X_;Koxe0FHX}uw}<gsyh g^Bv?__I(Q/MvUW#]#H%+F4m+`L?}bO*jG!1?/Y'^4wTSCFOn,	r/+_jq<u/=1}hj_[W7G:+,fl(G:S^PlqD|T0mzH^Kdi=}-yHL.3X.1C[	5Vsk	i\fdBtt]l7-=$=+;o7Q$,#Jj?GRR?j~		@"sI[z3<+y.17k70gla0"\p9I:{.~}RVi>lx>KMV.V%+w7e6s";lC+P7<\JLSt=QQ]lx=47:lz^1.s.]=:OWN/kg?G_jlF-$+9xD?g#fZ#o}ay7`|?{A Q/pnQ{d {n:AMKQZ9N7vp57(J^
+RY|:R2{;N/(Bko|S}#Hvt})1vSqea1{'h&<}rE9]e4SR`Gd0,CiGiFPq? Y1y?,7?
+oZ!P%yx<cN@Dj~;^^^u<>;qtp!/w[7Llao&wDo1}oo=MNf+jU~Ff/o~^Sjmu\e!s-xrE7XMk.!0[mhCusuMD	NdS3;fm#Gh`661ni	<'$y7Y9+t1!z`}ftIP`j9GC]3iA6h8%O0mz?9qi0<{#<L.|b?i[VMau0c468C@ ?fk|rT6~['B7Ey>+l}Gpo:BJdb9.MI3vwcQB}!GoyoiL;Nt8.SUrA\'8[@nWPt1|*r5?&):%D-"cc%3/cO~WL^G"R7;b/sQyW:L;u#3g1H888h!1^YvTT@#%r@RT{((}}=wN?A?$4l"L/|_=/}B.%0m<0f/@}QUP'"w"XP/!^7+MXi~1|+4cwKO7`KepRbsEfz$j1hY\}'?O:k?e\|l~:{7(pMflZqL%>9Gb~K_5j	l8O<Sig{KZBk%1P^au3:H+=|#=}JsBM_foD7zy=uh#qCH[+
+K-?OY.Q,7,HIH[QE#qN-'>t9ct:>-:$zxKVXN|W8|utE?[s1duzX{7'X|DNG`M?2DRxzij7`kf:q'>?~:$'cTS#zI!O"B3G^7`[tw6<q{}*xF|:@S>< j#?O\T# wbjD4IM:x|}	V=Z0!J1Udgse3t]bW#>	?>tXz/Ab?1u?4fQ@TQc'1	z3|opP9_.DdxE_v(xR\XjUsoy%*^JqNZ6+4a^`m:7 kDGhwX^G7d\d}O5wy;ZY8o
+Wg'	I`}1OqvY<0D$z"k.k K0{&>u$4?HR\D`c#*I>DT<cw+=FT8!zyTx[8~Z>6.O<oJ8YsWF9jsa7ya4K-3<+M|7(cdw#~}0v	2U_I
+'+ad	u/6h_#+OMv\'o8Wg?`XKRZb7Y~7R&v'5/'bQ\kd/Dv.bN,h-dB*zX99h;l	q3 54D%"W7GI\7Msix\c8HNYg4fIll+5 .k&>jFUSlB+ilM. -7qOt>[A.=(uN\, 8Ko*9\@'h|eR#s;Xg],vrP'Y[IGH7V	>M.5]7ZW5rz+y8=C{]8^Ck4;q_?GO6!uX>F1O+Ar~1<.b`fV8]!wp?<'d|F=cH=yl'Y'`	5W!4He/FMqmAR_m9pl=ut$3t5D?zO-Gf[JmD`:xB#^+ic:#r</PS[b\<-2Py/.|Z0+>[:52~48],Cxvd>Z+6bA**&3ua}	j49Vo0[}v`|-[kl1O<s+{/vv7s3#3w?[4.>&u^Z^>o_kQk2-%Ii.!qkd	vInph<H.0CC)]oD]@5lb#HGEdm!fb_<
+46s#=q\#?&p#2hnl~+ZkSScnACeC!|{+p8O.
+MT,kG$fQMRjFmV
+-%x GlS9wc4	|d?Jjx%a}[u!PmTaZACV_0^Nqbb`+,M\{m9??|?Q+-uq8=Ov]2OMl6A;pE+bJZL`W/Ae5a!EV v`P:{;-`0fh#ZM{uAqdwoC9#tu&WF9~)<7/SOJj	+"U1cSOuC?ze%(K.KV4e;6AP=wG,^v4p 8\Vz6!SBL|[c?<7jlx'd@x8Q?cC.tn@d:[vkL2p*F:"?{jN^
+5e* z;*gHuskL#yL[	/5'	RMK%m16n+'GBFutGu?pf+Uc@v9k[o;6],?zEju|I< >"Q4,Ld,^Am6pC>x^=Mf'42`.=)"CfkS}/}cS{l	A1stn:^D	b]&^w~==<m`
+Xwg|Emr32{Gxy= \jfU3r^U);csZf?;us&+o(&g^'i7\e^	~i_C{{AU'+o)1@$KZ0<O[1\Mq^vzY[ctnm(y53')d^=
+](n6~*xlLu2P1Vh9eX^5OGiN%T}(>fr.1m-GU?j?;'7~ 36)x-"~/	:~7q[.Phh#>+"3O0|W\,J|FT;_%I5(m;/BDkty}$w)IJ:{|j	8%+t`7}!g%sU>7[mC9p1rCr%al0mMC84UXw;yK_=!MP{|B&-|Gc7(>K+ 2B8yWRY8]W5d{.qo#n*{$XEl;FGrDe$T\TTXR #0
+gQG
+&7F!Zs"fsd,*Y][fX |Hz88,H,hL]?e8+{VPM[N:i'm41r3[JV7y.s),]*R,4RTj-P6/j/2PB/cggt(tF1dm+3yJ#4~|ykS.:61ebF1*@}v.+^"ys.9~8orYH{`6 r;G"]G;|	!Zos=rE'w.GMOq<@t%~)ksGfYc&CN6okb:6C- YVtepSK9v.G-`;GE^X|YXA`$"%}C,dm~sV~]MKXXQy]][7_Q~~R5vl:v8~?)+Urt[?\WK!zfF6uaIWS1#+pFs^\S\l#eD9v9D\b)/d0=sk}O3|	>N78VfWY9+qY+
+*:rff3f+&+lnZXqb$@<oay6$bnugZ>%ON#sFcrPN9PmAC4&STVp'.:8y!DXjM5,gKD}v)=/A18v[~o}+l6VClhWu1W>O|r6q\&9"0BOmyVa]?[wl3cOHM#7}@Y4tM0E1yR?"+Ah{(	rQH'D?-}+|?uym>'~Oqa_F?RM:%O^'M'O,:8^h=Al|\=K3j(T;_X7Y0aNr<d1ol;1-rb@nlkn 7v:f:,fyk[bG>HldjqorSO^z[?G{SFEYn0+y:DsX'GZ2UF=8/0F^=>E {%XBvbyO]
+5/(3\9BL`rk(Zr"o,fE9>64{jS:+)xp`<lm0x(xKrI*R~ `s8f8rOHR0<6pp[CR=6#*sYKM*X>{;+GJpBZI/U~qwiNl0I\=Xj*<d\ZARc@84pTCl"s_]9	3M~xk~ius{7OT/nuK?~Gf0b#oNDVkmb#ax5hHp`IQ<t crPd){,-YTd:z=^{O?M!<971i8}R|+y;g	z0nhjjg '$sm/	gUAu2T$_syXCTcsnd1wRc:q3r&+f`@=cltq~5l.t3}$O%"|xqh10@UlQ!bIC+v,5@`i{`?5?XrLi/*cq;oLMUvZXFF4jNc`9} wcFxj+crdM3.}z<N>`|\><H>TQy *d@N<gOT}l^_tqO[WG~Y2p:3A;?V[O~A1\CG, %~39y$1b9JL=
+'*ePRE,2o=t[%SY+{{S"])O|;Cy3HG'dA}"CG0?=E CW9I93165*F{O7Lg:,b]@	;>	.SijchkYbtC9?Fbg'u<b!|"zV`QL[av(pLNX;gm!c:gI0JPF||J=H2`NX;CFx@G_?&O:M{QF4_zsow5'+	%+;"V$00K	S:8 &V#yCo]P3jf95!p`Q9S@eAPH-\DK!ED|395QleDfCXaq?4Kvkc;NOldw;!r$xJ;}x"gd\){gX~yGO}o#qS3=aCj6\r.}.,v<p;&	2\+xx2ws,K:%[f7%mcpt)L;t:Ia
+-Zee2iMlddIu~>9tXk%cDJK`+?<G=Nsz+fo|nEUvTLjy}zw<|=2382^h>(`0N_$[.%41F{iG'N&(cgg]x;f~g:GUwQK
+c<Y`x#Q9@]Am%	xaqIB#.^|E,;Dy)vJMzI}[ctDn[Qi&Qo(]oP(=!\`HQYneFMW.%fxr\t&Z5W>>|K/
+Uo-hx6>N|8~.y(`v0lgY	1O]G{7#9Q|P}G9C=${a|p8@"AcGc{	Cm0GilR{^&og
+zgraL*y-F`g[!\%qBt{$!\<}-pbYmu[P:&@ 0rPy!Z1_~_ol'I56H{991U'
+?OB<v65>c[Nr,isa-{Jl^1fbk?+;C<LRB\<4pv[ FU<]?,= OP,ck3Y;mZZz} ^dBa)e=f^j%3#>|ravIE.2m|lg	Z:,6/+4{ eqqirEa<(Mk+54UY~reAA1"X(5]UpNCxT3x8rd#7CLj{y(|>""9y;5~63Z~=V"bd=Gb1hhTmhrnxr"9g_HgNt9I gOS 17q6vx/>KC_>yPey'	]8yV|C9?VJ}qgq`S{aBqC?-S7h7ccR|C7[
+	U[}p+eF\&_<d;Br2yK<wB:_wgAdJ<6qQ%Nj+h6?z9BQm Wn}w\H*opz[0oaDf]zQfrDZS<=pd2J#$'ov"x'RbSs.qZD1AX.~};F~bvF6S'G;fnZbYP>i++cC(^qcXX?IqeMS73FOn< A`V>$iT91q'N?C?4p\H/$y!yV>J$~6:|$nl	{ 7v{x4n;;=78iA9){)3;7ikU8N$?DHf])_D-W3SqYjT']	}3;"k_ta+"Gx-<5Kx?jGd^	czvq({d[Klkz
+qlNRXR[#1~Kngp\;m^1S]"hj?xY>,nGFL<Kc}g;z*{*z^:&<xwxQpAkNHn|\Xa<QCk-(z0kq;0b*&!4k6#x|iGt-s$`KZK~+l5cNDDA$=q(A)+Jx^>_0&:yQOA^9 Vp9G(jg`5VQT'9svPl%9>_Wn/f_<dO*Mj/R'+78M|<y<:4z$|D&/a!4^=`='V|RSeis^Up'Nw)~|+q!lDlw0lhT`#w,dGt|p?NcCk.-mjh 2yW0#`;yP HOKq1ccOR]:_gZ!|K&cS%?~WV]g^1`Q2/|Ju6Gw6mupc9MsxoT!D:=\T0v4Uh`hk7?\u%z\4N?Ko$K?v}G9&9XP<?yQV}&CcQ#=1kru PZVTv0=FiKn.;o5-UXc58c	4c?r3X4.mQn1 f
+2LZU_ZNeCwe<#}?O)4D+~?=dA\0ek^;=~=7Rs|)w+8qzO0
+I:2Pu#LWv,&_f<rVDIv04Z/+j_%Kem_nC}N.lVW> kIE$HwG`}hd2#-bG#T#P${2`c72FL<w|cC4\c	qljCV^G7qFRGsj4b$7
+TGt,+Wa;s~0Uhono?_ws}FD3K~9"lz!s7lE+~kJ/56USvGlz_/Q~$Qw;=`.|%qH
+9":KW:{Z~Mqg)[[KyS8f&~'Avs+j1uch5*|?#i|,	(cat	pT9r#4Rj?L3#>pC.g_+EG`={?~h#ra^@Grx@~('lP6P	
+^mu9eyuc,#| GbtgrtQEi/Cum-he'GxW{{c0(vJ=can_QY=jFi6C*eW't}>oWmYZ/ojXHZN[3+I[k)?Ya[[wc?c|iF%.qmk+X?{;p'I+>Iw}Sw|6#:pT*0["nc?!9h:%"&fLL<oF+BVG!X[FVuMu/&J%yi)Gs(M>yi9V;H02+-,0[
+S+g!c8E[;h<wr<"OWkPKX)@q+dPR9,#0/mj\tp{x+5:DN56(@;566*=}qab;.0o>pzArux[_%nms6r}5(!__+w3O`QD_Iebz4#xQc?>E4-x*O+9<gt22={>>(3VHMs^xX#ohV
+W!ejbth0==}J?93JL)5yx3H_;1T{Y\fa:&D.~|exR,^H+YIbhNG#~V=Nv55l:yp\e='(@G|0V}=	x-0unh'=
+QBiMRB]|K_0nrf-'{N1LzGpA0@>3o~[@rF]Ernt{l158q?yMLk/%=0r4g4Bi}68`|7>N.pn6ouLx]xK[)Zpb	\2VP9N4-=Ae6%12fN_R 0(-HL!j?2*|h\PR-tV)KCu>Pf?S+VFY&'l$qPt\oZ:Qq}VxdN^K"^";}>AJ~P O.m[#17y]e6&E|>%fGbv^L$,:3t2pR=<`d@M>7]}JbG>F4Y{HEk:-}9#_w`21{?6^h\$\+}CDSJbHpCF|ExcQ#.TgOGRl_i!G|]0x'"6hh.QX[Ue+>1~VR9\'7r&8V/}K[TUs|9F{+-)S4jJf:WHG{}\xN,IT.@Zcs4KxG+R`!>%4V(KT\wS`jLev([x,U(B\/s-uo{|nG)tl	>d?\Dc;1joLE$O?V{'r"}8B$=I+ZP!*>9zW[r,$@Fx'?t.3L+ sDERy00m*^F0C\v}XA{?UoEh8Og3+_~cDYy-@wWF'h9&~f4G\?qCd|spG\#e}T<jnJ,=9#*<,$#Or0W#$O8&y;~|=,cGME!{
+2Ox@`%oJS|um>/.xjje|@)?xf^+|G}2'yHl/U+{	XAiX-3%$v]<eC<bq{lwt]coSR#=xdfw>d0'p\bTyIWNj9&E"dDA0?jz[,fD)VK K;OP])m0kvE#0=y!]8mss|QK&9&6!emM'8D1}F/v5YD#Wht3tD<w]	`:^uNbG""i~:_L1&${O=_Oso45wzz+H}duK&:j%zPn<>zV,C2C<!Vcz59B50kl750m|+HELi`+; .\#`,9Xp=6K C}RADt'W=+%6L6IhL^Y'@@OuO=?/ebT@NS}Ad3<\ /zZ|'j^GA9'k5<-Kj3dDBNe~')[.M1H-ynS	cp}pV7\ bZwOT.L"hF[-nW].$R<
+l|bK++>SjwaQhikCSY:^GON_z/2tpB^."8#KZ0D$h|%#	<Ge*DPy&'kWV|w[GgFIev-Xwm#_x#Jon|v7#7wbF7;l6_25_5?ftD*G^}y.EQ1hj(kd}n@8CO1)\9k*kK*j!uaOx<C`=O5?M})c/;jd+ XvVxK.??b"RKKs[zPO|t'+]	`Seh&Jj.L#1cvKD;x4:Eu!'1`lA S.=mE@iv6)9N+v$HNg (8V	  ?NM^V_znmMvOc9l{"k=sS(q}`H8,(/XM>iCNDuP
+Y~sMO4
+kD,Kky)_q+]opQdnMxN+y Jx/~cr0`PvM\Wv![mh{}G?15E?Uw>}`obnjrHiInp'Z^n\Kh)jX)~%A;bMPtggkKw~k)9/EEe?0~w]^!U@#8<J[4ok@othCiQ7T=u}r<xWoUo~59$sRmeB~?d^I_O#\4Y4mWiOm3`~q8K8MrmbMf{WG;p<>$Up*~;c%ZHn{
+~\]S9@P{Mb>23./+,5?^cz6X"lW2_dKM{l<ruW/]vY@"Wz8\>Ir=9w.a.GW>+BS%M?Q>J,S%VX;h`PVhw,2F|s2JE+:P]V?O+^q]<0s!`Su-Yxw_V"uE66g\@]25A[4	o{|HbJJ)(el2PlD+^]&,E
+<=yr13(PmuZ/zKlY@l B01B%MUJR	6-#~%YnY~>1^9}[fs<c9k}=x`)%ls~!J,=sXy5?4>{i:Py"++cw;mDoFKaSrgWpa]0@2NXiI4a0ZFFz1$T)XdDoq&M>t=n}s\:n|03xSN3c 
+9E\;V}$TQ6@h|5'F<Y3+eBta\	q{hEmyN+=
+?m)<4Os
+,V|6>;~69_&!vtL4&=@ 6"uku/&<OD^?s?Sy2%VRS3kl#7o|vOgG9Gt4{1m&8k*\t)E"9oj?~T2SY*>[7Scc=uy$ADL+2pj1+Mu
+T{z&r/_}8mLX}>vyp=VX8V{xy8oD3#=A X|$X;8xjE08O67|kjhu*9>8NKmbY1U{xB?[vK=D2|s=W1WvF:Z<
+]V1Q`^qnY*O\1FkP/PN5)`h9MHe$oz'+<\5};k[bbu:
+Ei$_l4P<;p1NK&YDj2>~sz!2]_;6[:ce{ZY3W+9M?6tq:.AzCm1-K_" 7+\qqi`E=1?4r=Ia"oP^lS8\
+J8j04&Xa:	u,b-vCo+)/y#u^/^%Q7-w4<+|J@@9-f4cj>Ad)+CqJm+=}Mz&-};?
+mI+tqc;3ex>8kp.0'fP:}N:R7AB34n.#DaH'c@+f5QlY07LGY@a-e]q4\M$m'fF{lk@vnC7j?f<cPK'F~la<MYY/*_,~@.2f!Dfl0[c*Xs2Nc)	%^GO<8~*0go42<qnJ69aQG]_?ykC:mNxA<
+pMsP	B3,zxyMa9*'E0vt[_YTlW;H\D~}#l-62[uhGN1=f=/6V=6P=2MZ}Q5K+&Zf<3v{+:|&+?_	UGjOzEw`
+9LN[>_}gc2;+<dO5R;W<lNx"{dx-,\ge8P0W54e-:/l_(zD*1,@\7^,>nd"&g+/-gdi}+_/x7&\y9E=!cO46p'+ksR0}H*
+=mu:?xom)9Gup8-fcMccC}G<_c`|9GN+yPt"*g[\9IlMo|[Iw:M7TK3;T^;7}SAMAr"{.]A0LZ}	n}n{ePA)|,tdb]2l&=CU\X9^r+1iS@GJ^37{,4L+'7hHh2zw6Or5j=bkPq=OH1+b%7Px#gPr_O+.{kEs`VoMr3?(.t _(4<Uo@	M{i]bq /0tZ,|0LM'
+zc8nX([P2b%D*.AN+wG-/m`T0!fwHZ\,u*f&P;>zZ;	yuu{bh59l+r"/Q5<6$9 ]4?(.Qga;, AF]~^ Zy!(w'6tW._U2@612h?ub:Pqel$^md=8l*})U"_7'iG.G~K<YP"u&9AyX}dCr:"#G^Z9J	9+&Y8Lsx_E!#jG7bvmC:!>FdGk4Altos3+c	NyrJMc'6zB3m6Wj+Zx`np7zc*.<#,F"l@xOuec=;>bkcTdI(?I$o@p"tCkqG'w#-U3@9	j)@A"_4=}O?Sc8J)Z(>1XZI7r:+<O{6ow=&V>:`0#Vo8vl:'Qg.Xc|
+t~c[]S{__Wv-yuO5VuuOw_$WYkk8,e,N>ec|~%UaNe09F'dNhBH;5zP@_(]w	ktFN8Z]OP$@ZW,Kne\7}5}89^EtCzw$Y\?1Y'?}t/\1XX=H\"quvZ=3v[c2E)+FNqc}X2Sh1)^;+)B)cNh};-l#oi>ex.=$^+{Wzb7~kZMnkr<!]?H(_[l{^Y(Z)y?@M(!Zo$]Dq<oCY|G'|JOy3~_"7}O\^Os'QC%<csVFsD}ybe<<S8RpLZ}764nc{$t9ABF0G}uWSq&1
+w1"$<Htc<o
+0Ti@Sje!F8t6MlNM+?3{a+V sX:}4?fK&yrs+m|q |mkq2:rJ),4%pc0ZC-]zz&!Gx	v$;SXw1L&H=&^aKBY{s& 3ft<B>0'q1WSKwMB~QhrP?iPci7
++Tw2Y5o~3_8/EWK+7YvW>l~7L\]\@ml5.Xc5s<s	Mnxs3m_7X.99cobSI7t"'`'*be;61;cMM~oxeXf6D^RLA8&cp.+5')Aa{Rr)~`!y+.u|gY(7&>uUmdS$VK,.}7WX%+>XC+I}`Gq#3	M>s^wfA^~4+x$Rx7/^NnuD?^!*rk"Vc@p @LnA,M|]zXw#M9o:h[/t9s6bnf i]u+MGG\-U/Q[?,^f.6CP'ooWZ^co/I)])XN;x[nBOf>$eud/_g.or 'fc@ag~/O>*#g S/rHQy?(X[?{kC^\	,1(m_zOn*<WNx-yf;+g-}qxulcC5fypnu7F%;"NbsJtF|Hgy9b(mlf`n?V5.:_|jZD+\}\znSK/X://zxgSN77?4]3_%9i4o.Aj(~./m{xoP8t@^o}5=S9u{wZ38lRHRYY?Z=uOxN^:?t[8xF%f[3:,cXy(N/mb2
+;\4)
+O`ey_;ln<+C-DjdT+;?Ra9!k!,"Tu=YUBnqwU,6Em)*FppkoMk{N?x3A7Z~}qmw039u>,8sq+@\x)@aV,V|	R76f(E
+O=7qSs4D+\g,5?oP!w\V6YkH*\	G2o8uu9lsz.?~\=kO8_S}?t^I^
+T*Kv9|]7o{%}C?O}^j<w]~P-=]PMLcI@~g|]-l1EQ7^?
+Xq7>8RZs5q+3c?h>YeNbc-*(S^)Q;]F,|/SS~bi'-Sm]GzmOkY["(m86/x9_y4b?={1E?5ic4Fb?f}H=gY
+_X.='O@CqO]&L7Ts_W)@:~?X/Z\kg`CL\z#<-1A<},>Cs!j%avh'y;[|X_2r<0R4;?0m#sD
+b7ze39u<3JYKk\(KnKc\GL&xt7QDN[!J^?-u@,4cuKwLWgm;^G:4+o+8S* DuNlG,^uI^>(F.B#K!]2#h]o5v1CQOuZ,vM<Z3g+'t=y@NxhuLjtkP6g2mW3t"5Uc|0N;+*^0k^e-TP9xs[u/J-A=,o/2!6y)D$hA9(zQ'{^<wdzH-fJ+1`nSdQTk+;1#Xlro:q83]-qMK"V{C|A\r]+2Ft8h4rd	M3y@Phq:	H9XLk1cQUYkrqB2y4h7F4wb$1!LPdf0`7B;, OkI#b^5_ssXW~.G'I_m6^~?O?z
+5bM'\a<_z,ZJn~o>o_{KC<tVatY/a3 ccO
+P*|BYPFdpgt}e)n[<dr+1"5#yNRG 9f?)}o;YZi|"8RsS8f6d>`dcJ>4/07@m+8P!c)&W?QV
+@Ru[qT;2wOyXOcq9>dAdkr$wK0@t~23k8|9/\sZ/v0	GAMPE5^Ue<Pq@],oxHAy+ZQfQ/xSxjAi
+r+w=;yu-H	}pOkl@#/V?$fn(9`e"XG(4f2k~e7Q?/hp7pS?8'<lY!+y|F?u\q@oH[Z=+yR $+WjZMm+~nao1i\3sc.@</q%x+c>*9P3/83*/t<,+L`ol<;qg:!5;[?mRyRNgj-9O$S`6DCiGks0_|cM/N~8C7Ii5X_=yC9[*/}
+=
+kwd3bj318i(8onI\"8F#d^.&cj9307}WvH>(HyQw'rZ3qstiX)6948Tf/^o!~)agA{(IMoriYt9G@<]='1([}u?0p	5Q5<4m6>D8W-u!~>gCHIpaNQO57b kq+10Mc8,`&bX8!1#a	<{{~?96Kw:U++q1CF}!}+o~aRl4Jlo"tBA;|!Nh|Q)4M?VA*=g_69>+'G"Gx mcX1go-[89N?!?4-JA'_+^Nv8<BjYzp(O+Fog~.o^cr:Mk,SO/LLN+Bv41h>@?&wuQ&gwMy8xM37_{hRHdG/`vx;+Mjnv^9#qmbu39-Zwss'uTGOOU;94".GsI|<zaC}	A2|+;U \	M`{/z/Gn,>+	8a39tDt-c:L+vf@~kV|u2>>_l@'m +bWvMs#Zl^hGx)So%<k8\+ur1g
+`KLkCRi_z~h[+fWEnX_?g0,9k{_kNItm_OYOO">N#^hEoO0Vbk}&K?QYDXi/CZ.7K(.@>HPgJd7YCE81:8JxG7)|X#sN|KC>g~/TyWB\rZ}i6CI	R759xdF0{#yx/c1:[?m(7BEu|{ZJfJ"n:|q]U]d++r";:+IPk=#J{ym,'z/pa-4D3QW?t|tc0w4E]w+2r#3j:S6=UF>	u@'(Z.n;A<X<sBRaIr*/h{k>^Pu^"ZZ-m~,b[c<}w)BPq~J;^Qzt=51T.k
+nMO5~fe)5yE7W>U03?< >kcwN!]UcP@vq@jFj}/#)^4BOwd>c(	CA}hX<`S}64-X3p=X0+
+f3Tm#vbfXX&Iq|gB]m(+-y6d>_hWb-= !#?paQ`&gE%^l9)Cm@
+_?>]gEX;g:v~|q~?lix.df'P#4$sulu'^MT<mV0Q
+5tl<dM~#t0O?)E|[jZF4ju`%zZ~?	`bq}6.64}kOq6Oy7W`t+{&ZYtc%&U+vVm$S)\^+Dx_QI%d_i}*6]+w}~{<xm5KB4H5QyXro(]NqCx	;tPZ{2(Fij1huC)'c_^ows}W#sO!v\)|O/>e|S7gbsotw?i,gExv1XwdFJ.}s+-mmO+3. ^m02|L8"hL/T+.>>i^|1wO=L#fV	a/P{oy~BIGJAWxIS#E}8SkARJyE\_+H#G>xWw9,*9< 9{\ #nkh0f,:xd+/}.OMEQ]$|{Xk9%=:X>aE6e|tGNOd'txX>e/Nv 1iW(+Cv4!m/'}8S6
+txc])Cuq3'OO	B9NP~.qs~<dcC;mea!rkSl8I;z:5c;~q=
+K,+8QI/CXD\EGP=?zZGgCOR$O$*~9x*?E`>}`R]! zA8Y@]3Hc<dpL:d$>t;yU[+0mnDlX|w'Ov[+&Pk .d=<J1wd'}?v5'6
+%0Q4\:5b6A|22V1sG	psg `)>Rg813#:iOYO}d:q{+8Kp1{j-!iYE/,`aCMcTKdA]jK?_mm<5856Cq*2#|cb/`+!`>0V|s0C,79
+ }<.]`-ap:>{yR $_{^M>?
+y}#11i5p53>t*5t4-y?r	J;hl5C`vf;>j3VYs3"VAbj%~}`n57I8F
+`OnuW+=&[o)Z@&o AIDT18f{Q+0u%MhZ^*}LFyg}^+kUsu~
+qDw?u`6g~m7ck:/rt7wu]?o+"6b)<>xpspol%'Zl|>]P)F<v#}7^~g~rikf4EMI~c\8'=/lumgj*'7{}'q/8+%km
+;F]GJ-P5L	M^`.L(i.u$3^8Lk
+k<+xir-.h#ak^y`:DXm9u"&jXHa@'b]c+wn?bC0ge`IgX8?DZ;'{^+?3S\O_%BmCXo';O1:|6@s6y]\Ia`h$k0+L,A}K__wkrk.O<v>r-N#1u~Kj+3;Q7/]fjF>yv{olvo<9+|V]Mr]z+FZ{b4Z{h=F1>w'l4KKc]p>BDHq/_zW7c+O1zey@|e~]s:?~Rl7+%y}o[8\lM|/~21&ESoyD|4/0	7qa
+>XBWuCs+`}E0~k 9qEpuYi8y[!j?kH?
+6,0%1h3uX@dbLzAzkgHL5hr$&}Qu8`:66{V8Ovy+x\#G/sm?m!{B?p0;v=:&<7WY<rd:G]It\4`34^PdW*B<bu2'$4s$sI~up|1`5up#i&h
+mE
+_0,/00W yiBQip#A8G~@c'f>|6r8#7	zkSvCxSn8IM^~m]Fs_M_F+,
+mz9$Q&>zj/ByE+wI~d~)QcoC20Wgj9`x4qV1*y"FMLD<;Uy	3vNx:<{.E_9d5/_qGxE_N=]^_sf|*sii[/o/HMy}a 0jGehrke`V4c7JB0+|Lc?aq"+2`~Q:+{ID;vxcw{.WcCyh)i?xpP
+6r?
+o#skjIIcw2#u}o)HkG
+=p2xIQu+Jk{~GUx#A~_//sk+^'0s9K>rTna"#~^ !9-x/)gMps0sRfSq?NBGNQn^+P+?84vB_-
+/?<fs>x=KDA/4;/&yG|((sR9{}PB5NXM0? 59j>n8mlyIy K+0;,\>Z&8n
+<SH}~V8=c\l'3 `l;y"p?4^	}87:l&>)S!8#`E|'V$yO1Dup-+n0S2"Y\d7\UO	0isyOW"+c?:L'n|$@.O<"F -jKMHBT<Ay\Y.mq;_D	g>~G_DaC#^6Asl?"+'6s\ia<P)%3)g]HBf85RjKT1$~J+!@l8e 42\-y{o\}a>WoE0
+d
+s4=7MsXY+J|Q_d8X'#A7^O%+qg7[4R"D>ao}|_mu1Y\GEG-J?Xl!&\lnk-1Y]zh$
+U++$?6':`{L._
+$9Vn}c
+}FHUgDq"}p2+e'=	.|Nu<uXQYeN\~n\CxJ;\lMinfOKi	h87GqYMDd\;y7700J";Xg9b'\tF4(u@E!k?4&J>	]	EOa9zV0Gm61'uYyQW._o4)zj=O`^+oc`3b73+4<)2Qsv5}@kUcALq+K@q'QPr)xxx@Lyix<Y?[~P^Y~cB?pC_]?gFH:?y3"wvs5s7/;:OJ%!
+2vc"F !H!yKHP:;<=s=-LMm*r=d|Gch|0]=ymXgZI4l#MNMr1m)Xr=Fo=licMh	s_"URzA#}6n]s?7p(~udZ_MV?O(Vi_ti.FkSx6WPaK#Sss=2reS:d3 `3M9mAP_Wl8OkCk3ztsOLXV
+d"
+7q^;hbcH5i`5?G=qx!*~3HBAgb4osD9~+ +C{3?-}fi8[a#L
+l\twg,#9U"E3@LjP.DiiKnm|l|LMj'8kZH*UHjy=qA7$r?[&=Nj`6DkkPuF0SF WqGB(zGJy~aX`=e[R)
+8\{gF|( dPN\/,15"N^e;_bBnq-sR[Ee[IaoWm!d\+u|"=mNW>:|@2rXkis2swO[\W:Xh0%C{r~X0 nhw}}wr(G;:k'yUoN]/b~zs[~271lV+
+GZZR10M^T4;47pc`8UEjK#sr$/90&S]J@iP&Iv8L^}H.+z8}*3BN<yKLVc'xUY
+9{+h\{vjf?+Z%)&c}1yQ4|2{.;9z2#8ufaO!LdDZ&yQFoj0yuCdoK:`Z1+t~mmN[z16?SC2O|+6k'21GO&{_MEhxsYr0n6Qo+~(h"k|/R#b2Cr+DfDJ[|lraA:(7zp8)ir
+?bBPRpyO)>~|x7r.=6E:;Oul!Ab"Oa;&Gvj']QE~lGCaW?=W*,&(	EH0m7GNN5&9NWt@c*2/v>A+_x-/:q 8+cuG`!Tx.mhb!p4>S[iZQgMY6~tg]QLshyrOkr.w/'|h_}3KC;?Q}h$%f"r9(NVqhE.a?803S#8sB,R9G|1
+(a1%7U'GTh*v2@b>6M0&'{2IE6<kE+zUw?ADh3[hAdc|*.\J/7.Z3;vq37k}XYg(%lNY#%/ng?{mRtM8)V;}lGGX]#+m3+4'X$.|gs(/JmuaGX?#Kc3KK;2zG~K*'dh:GX+sV7"[+0?L!@rB|&&`%v<96}7~?>>1'D^{sz/;@~e:?`?{3_y!pvTy$&PY-pZn:k!NYiks_5R|X'h;*]*x}FXkA*R_+/}k	l8/_,#HF9D0x2!ka?3'*	z9X M1{u|\}dQ:c'?d+ zQC#E9"<+>PN5>gG{v7gs!-2CgiM#"2]S&mtk#(?h"wrO}Pi1!C,AQ3E>g^U&7z^5<*HW/ )|<y`BBN:_ie+;2Ubo`Z!W+]{E/tiN!x!7M9vGomcye kgm[+|wn8^_IG{y[784z?gobE;rZXi38vJ_.&KFup&??RY?)O=l
+
+Jm.6oSo4[;MW4;tQ5&4(Rq-:uEVv+^'^mW:S\6qD.W9/WC:;U$ BiNXD&k +12+LlG4}4~ku|Yyt|<;>{_+YtYRJdQFGMiBXtT> l-'!{C>ACP{l/g#'nX	jP:Xrc
+*_t)]!75:g.D]1p866=+e|YpOb*9$;<M\45QIrlct6]N /WU(hn^?r{+6A&G072g]~&?]C?Wu!v`e[[LN=[m\SSS6wykVzn;/6c	cC!s\IkG,Ue59gc&/5O|>>]nlOS'^>dP*pP^??y67\bg7}:r%.V!~?K,"5Y{lsh}o6jsm#o9z7%+rZNZ 0kn# 4{o+8,bMNM
+yhg'kXoTMnflR*zQXEln1'(e/<8mcwg3?/^IosqYoX	.mdb45mnC|2<c_g*/A9lBhZ5_;MO/|wS:z[6h^?79";+lG|}
+eWkgLC%;']+%5+UPje+zaiKLm3<bri5p)`z;Rmu|.VKU<R^#&,q"9?hbED9{6#_zqCOo^mEkO+0nZ6sL89!D3o"y&rHz[#y)M,SxM
+5vTp`Us]DK524	!]o__d~b|)*W<1oQ+wxSyk|5vA57!2/-5r)wFY4?>K~+5R`e^SN7r;Nz^.k 7{ o+%uEJP~48R;Nk\$c6Jw}|G/Q<bCP#C,ho~p2-S!HX;?;sWAm{xT$3GttOt??WvR?s'{R.LfE/l{9Y{~CNk<Nt8FF53M7"c?5>Ik_i+g<Gq+^_o>7~A~#xf&A8fSH^*A9#0G8`otJfkx&xaF1\7%ic}bHUWtxO`8arA$8T?i#hi0Nbd=ZYK{j 09u(cWAO~u >B(lt'';~q2B_jH<bf:wJ_1KuLja+pw(WJBk <^A%++q ,}Y-1or>e0mY]gbBDo;o\d<p+M+	7!+1"	lO']}Vcxphc+2zp;59}@1`KH+1cKBsM*Ycl^#Sg_f6b~:d|wo9|}bd0jEB#}ifX
+Mx-eNQEtP98): 4tNiY%5V1XwlA*aC~"uKmj
+6k}M$\y)?+>Q 0PYusnD'1CS7)Qx#!&$'qO@iP?td.cqu}Sl&H95Bl|u'(7s7</+P+cc/a|:3yiK]D^4-AAhti]>$p(Edq<S}],eor-6v%7H/41P?gy?}8?y	G~`L&fKeF'_ O~bseFNCG'YSS9f\? A{52gY_gIp+Q@x	7&&NP}lqO>QA"v+!,E.x.9:F+B0|[FfrSFBCF8*>w)h!68'(bF.H:j 'ze~SqX
+#5y_boMPY]jJiggO_:;v!cN}PFF@h|w3I++UTf:nEt}4WX?~Er4CZI^y="X+>Y>\dyMnA!cH4	6F%K8K	?&,.=d*xx]5{@c$cgD\f~pq||3&=z)k__o.1G	~myN;r[/*:d`<n+)?-+'(Rx;P+G;WoK/>:g;QC>h!%afqabhN"#N;qkX)tZ<_z/cb\OnqqE<K_8ks5(
+M+M>?SzWkT((0@m
+ii{ C!0T7
+g+#?3HK-Hzk?Rb"h#onmT0wb?qU(>q@(l@|P1o|C6}u!G1t-ly2)JzON7>^x<`;te9&#3e=`ko*7iL~R1&3~S\]Bs;-c+nzaNH&IAr=`k? )1[y/nBG{~o|i,xi(Wam-\ffvBi&(>8t ogoh-j.oT](bz@!HCob[7~p.+dn*l;5'!'N$geh^ |/hq|{Sa:o,3d^1vt!L[KqZ4'rpHMRR>lhEphfg\7VnGo?1XzRB6w|^7O1b{e+'9gBL>_)dvZcYi,m%V<(-3[(X09	c/(9ux
+M1
+5.hJ`D+Nxl|hzIy?~7?)l:Vx&):/@7^_+_O;PH	+3yBg*SC7#&|F~ESHq@0{}GnXO!~9142B3>+j4~62C:'0f/dy$oEbX
+0?M$)3#~+8p71g_o_+{?1zml%ES_Bk+/'ohV?]
+/bK+c$n^sHpkD*n1W<,q)1ks}h}KJ?k86.>	sXI{Y{:7s>&wrc4>hY=SwG04s?tlFVSy\1>jk+G	0+|/re`\l]du&uR{8w>qHSC7ZA]D2> ?JO{x$~s&qz1up)n<G1E(}M!@+'8<E~k|7iSx'*x-:62+DXW!Q>~g~vbAdmqm6<W?|;{8ix7#e*o1r$\E--6H.+akh|m)$q"u>O9)bI\H,?h6{}`<Tk\!E\bDLtIgzq1BcmM/5y/veuL?94|a8i/gN!-s+s/n.g+
+
+P ( "Qcbaw&m$tW"TxE	E}|g>koUMU:g9<s^{9=6Oh9fl_v}JYrdmmv6[D.0u&PpBS}O6S`k1C0u1k;M>w@Zucxo1b^f;}*6VaP~o.?]6N|/T5M~OBnL<'7RSWnTrmX&!=P;3auLg,Y_/Cw^T5?s
+7~t+q]+hA02nkmd@f;Iy=j5}6!IPs}MSNg^+goILZ1W\sn`L-YL-#eN)c\O?hY+2YE:r3>X
+1`iCVYZN!c&90q37Si?YC)y-cRB9km@+RMClpK}hsSL?mI2{3:	f>D.	,H6K)]8b*a:&t"eytwzkG5-o/.U#T.D(bXXz^VJeRzohlK>0aS
+l6.EW4<;RA!c7r~3"$|d`(!83qPOdQ{v1C19:q4TW]KO}H/m`+Zeqt8tkfAFx^w'6~|$lXJuem6i,q>h('13;GZ>Oxmv56Pgs%zB;2Y[c eCg^''_\*W6m-l[VZo%p_v`(}hc+|:kQbvPZ/4y+9=HMEm4(cQN=}UCwm;U>_xb0In] k*/LN]?dh`w;b{ fyfw:Z w~vWkFEutDh{Dqd:VH5_1b|Ej]/R&EY2cAA)^<&\(iN|+
+5co=t.cod+k+aqr!8H.>iXPiKmp|7xmf@Y8lL{~oLE=rqwy#j;'"OUo yhD{BiaY%8
+K+.<cv4`GJ@qlgr ~S	s(Z,PN'dXx0L</o<&|\8JoD")Mt7IZS}1So}mH/1+12Yv@iL$qr<{a|RoGyv::6fZi4x>7ik};i?==k||lXj)_ wKz+A#T2>Yir
+Y	nY;S.38+V1%fH%Lx2gz/R|y^f<AZ?T5P1?sC=*b"z4~i';><w?3D?t?@E+)99e/C!c!'51Kq`a0`dVl'.UZ[xh?ADB[Z)cUL,i[8j9G:/]hT1u+2,J[gCuVJ3&	<fk/=$fMlO+DQgL(1
+W[xD>L{!a^3Sdrc/~wf$Z/^dE06jg%7bA+"|?+^2=_Fmj'.*sgV'k(\7;D}zA&9@WS0m@yeW|$O{3Ooy~OoEOc>a$a_q>O(xgT\r.e!M|>cQlX;NmOce.<8)(}ykldcjBd=(fQTYsy'II3='0})X?Y;wuMo{/PJv7^}H	z'y*t+Zh[1@E/aTs{N;P#*{~ew"S_P_c:&c}z~*X2vGL(\g8ctDnt&Y4$h	a#,~wR|R9MGhb3X)*	m
+.#{^ddy[i	[1=cG~T%-k^KbNysacfXWJ<(B`[TTpbVX>``:D(jU"y-SmvbUvpHYup=X5O9]7+8.xDjr}u*|z\ayzS(p:[H5N$m@>y&}_/`qA=+a<%e!bT|D1+% 
+kY{;,xW|y[kkA/+Ax"$wSK`MiohkY[?\>IuV1ks+KPPd	]A:^E~s#k(dwCktw&=@TC}$R<oj}&xYm8]7d@H9dqTqo_6s<ol"3/958$8lhSfm UGj`D81`O4n0?U@$|9p@HYIuo+Q#0uJp1])vqlK{'_}2Lnt4>ba+1/MVi|h6s-)>9[/T.9hldB9lOKXS>EbC8y08c&6XWt!%86+E[Qv%g%jFyz,5wM[zY=4S<tB4,chd*=#7HCxRxe~ 10"iI<t#gw%ft@5$c<Y1JKda$*?fS!a4s6;c^y)mG0#F`	_[Cjs&&@^(8R!~9RfYklBgQlvB~d>I3+bs!{S?EMb__Lc1q=}|@~Dm(|]Ny0xC"m/j37+B0soBK#D2<e6\I%y<Mqa~9>lcMYU}G\|(v"7;&abO#4<3AT,m LNFhR5<eSr>>YS^d|l6a;/H&1?2_wpYpK
+DJ'M.Vvr}o`+2>).| L*O|-kG\F4|Fslt"k]cV!-
+'3'g,Tabj*h42>zd6HCx;_RXhXS>Q|{d!.0Xm=n+j_gO>`?4,F+1:AikWAUtj9-v)g:~HL|:\Y_@m}8yfo]O/X
+mqyQ*Zk<"[N|kO=G:weEM!FB2:^F7awBrA;U?T$ ~8N4U:{*eE=e(it]T8Mb&EMX_fbl_=ek=M	^na,Fu-o)oV8qQz< a^vhGT	,y 9U@mM(6p3&>F:yynjS:+iD]loM3v)n-o`(tfC~3&d,|3"2f`F#Dbnse&=;}+AyIqq+}a9Z9&Ld
+k2X9}?>8=M_EA=D>q^o8w=~x2Y5u>?cT}Hd)iqaws}42u15t`v%^5RcU)VgrCuQuwxFo=m)G9'9?&{
+P;=pujHisz8aPrr/r"$NvIz~ql@L=~'3Ml)St&>>h~8R {ws4Y#LT;q0S!)@hF		tHxu<l+)-M.9.to"D|Ah5#UE31nunAE"lc0zLil`%}pyZgJ`E;[eNtiK +krzb'6ZgpG|Y L[?0XotJ<C~|`
+$65"HjFfvu+h+qu0gs}	nJ"
+yczq5T5G:E~EUoH|[{O'+7nO(#&6 6Ev#O7InicZX2}}njl,BK!{I@x &Y2wGs]'qq<ej4hY3smwC=qLIqcr=8^5go?mo&tbr>"Ti[c.3&ZCV.|=+mn&!X\Q8]zk}OJ7xl>v]w"&9@issEZ+?b
+,)<F%=L(}skd=E_,>bNs=2;;t~ <]gavQ+<CJ:,fz\dVT&26%}z_}zio+0VZ#:$	,+=}~5iCA9hCt???/8$Dg<p>-r4vI!Xz^V:/o+AJ6~pA#e,HtBsP?{tx'dh+_Rv+yt,Mv>o?OOO\
+7_R"|&Jr]eGNzhPrgPGl]yWOfj%fy"5WrzLN%u:"k>PZY\C}	N-%
+6cX?h])v{]e:E@C]s)!GK0\C1m+;=pLot_'x@\#7cMYysI0_z:'>c]9_/,HrHnX^??_f -IZtF`}E.H8I\bm]fun#G_Rf2_U2R
+FYi}wa-;{}{;_I/
+4sl>g'n+on'u2RbJ!8Rw5nNz>)9QqhGC&q;UM6>t?{iryxH`;fRy(A{r; uRctN	umLGcqBA}8#LA3,n)vOh.Z:d+#i?ypb1oRuO8aKQssa5^A{fK'4\7|OKmW^jB'cO^_I8$o9_5+1/ZMvVJ`h\Of5~k":Zcko|:Fn5Klk_J*AowRa%}_`%m]O,cVkxgp#?E>~lqHs~11YH#!^4:WoHc|;9iZme<R\^f>obmY|!w~(G4OqOnZT'>@/"_6.uE;dmNe.tK6w!HlIAl3%y`MOAC!N?0~(7]6lN.\)7^>4d#y8lz[5HOG6hdJT2k0t2>r'+=gwjb:rry.w)'`[VX0h:6_IbXAWN!O6}A6znN!@%'7.)Oir@9h+jg.>2JvC1vI4knd_2N8Xp+(y$sHfs9g%*iaMN2|'GO:[Q^0eVL1"Q;J;bos} <SP.8
+OjL7;<0WmvlUtvfO(fO-NP{DZ9r|t=as#irA{8	)X*w}[jG[6nJNbj&bq4HsX j)C^ruY+f3o &7pM&pL'Mm<QTTU}j{6|wu
+Nz
+z|HXcJirqw\*ymf-jF(s}gc!?WNdZ)Ezy@uzY	8%g}R#2262~qzK_|q&_IR[c$_?`o(q[	p<\q{?cZYke:e(9'9kfKaj@|2#`MG>2<5y%#~|=CBAEg=b5(k=GKKT*!~]'Ns?na./dR{8Pa/	2|__]#sG{Z81Ts>^ObKq1e#?J\|(h!Q/`nq`0'	Bq_v|hr!ju^o[_U?s+vU#Gz<"v`D^*faoMU?`0
+ddu#!e4}1Ijiyc%cLoH3>,{>xL`5S:s.([+#4"4OPlh|
+`m03Gd2UAG<^\3ZnS?6gtI#?E'4D|DMU?Yu@%p&Yv EVfH^:QANhs|yYiIg]?3PJY[k;vB^ya&- Z5k +{G?p/>TncHT&Vx?\pB8o"q)ySp3y	r@R*)}lY<7<^oSAo^CIpKXG["%rI.Fr]it?AG@
+	&3o5}Q1]b$y'9D?~^P4s53wlp2vg[`(o_Yu~c(7z\I_d0vb40-z-=_|]Wo$kX|A+E"|n<A$,'C]v9a=bd<tU^e458P\H#1)`w$b:qf6H	^bcGX<m	x!7~yYC[6{cTAU9OvnxcnhBwU_	?~Z 7`F2foW%li%91!45'A)?#QzO+Q`y5V`>?-zOWN9pu67~$h%#?.UtVKCr"2p*c{G8]g}[V,d0`b0	Ta)cR!1Cc#`Hzv$$1Znk1c9\k9g~g}8PR`GOde0wHclF/5\>V[ NYsX[cE@N9tna 9bO,>"qRCp	slm oC^?d%z$D@F,p!=S	ky9E|7H+]t'}95X92ix:FW`a-Ic6f$&q'1@_k6*c	dNx1148Q?qj6ybn6t$$]|>I~6BRz5`9:&K&:F&zMP-v~~j?vAhc~r0iB,eUg
++kvoI8M'_iz:g^noqwf[b]kF!/b}O_|+.W5]DYKnb2nk^q#8<?Ab&lZ^x03#;E;{7%RE&.D]f1171T{0/2?h`u6cNU(+Cc2Msvv.mk;'s:s]^|97Q<x!<+Bd%/AC_|~ev|dfRx2}_\z}cu+5w.cWS`G?P-t#}A=x(I*twy~0>`JR{Fy*c8>`($|\A'OJ3l?8
+Pk1[m]K69TaZ(,PNn '~stLc]+lvh<\`>a13&Jy Kpz1~x#P<+qiXpWffzM?k*}xX+Z5&yjM9x"~7?o&ejuIS41+X#3`]}ClG~i4(/?e0L5&=.lDDgW>>O+/~K+0y`v!L[NiAKur/qoZ3l&	mLdaHc3GftO}yNLF#BK}Jj|"B>Www?ys"Q7/o{{bV/(@t-
+CH#{?p{93.}W~O~Xs"&;y+(DVh% db>4T>yqy
++oy&?G6`BP]fHf_]h:7yT_d|F`@&-S3>hoK{Cjku{)^fTrY6S\a8?h oWX;213 46;zP1q:K}#8oTOxuvP;_	_6fPyKqB^oo$i3P^=z??UaQ$J}3uLN,JS
+4h:
+37s5>!sbQ:[l!0ia@A5P^Qw5k1u-BdN'^5+V6Xm}++ml"m|Oa>tm84=#i?}8}>gjmb[t!,=8Ghm$;vRCC#H'xzA+h~+k+J>y?NrF55;W|c{_gH+2/9wEw(
+,\1Gp7b(rRgv(:h&&<shk}yl8m8+:_ik;tR6;K&T.J0	|=yGmDA<3Jdm?3zjOyGZ;B/tx'4,3/<3(k[Tm.=#Ho[:ieAk,K/jO+\mfw`!)6oK ~:--YNESblQg&%<o#S3TaD}Sg	7D:
+Miz1'dp=zF\k}(7c;78IlIn}z6+{y|69JD$`Z!X[- ,a<^i\;~c x37N9P/0^32. 
+Q?Em.s$HdAeO'S.8]#^Z;u{?c&K'|`m?tFq"?0&
+sYftKu0-1kKo/5R
+//+*kl}q/^pg!eM;2WEP%94Q;(IG0bGWNWM>ro91i{~W"kx/s^-#:.
+=cH`p2_+
+ 3?f tg$z!8'0d{^kWz{!=otVrO_sO?w7
+(ZJN)A'cMqb04t+tK:E+u\L1YZ3gbaT4;Y>#x2Z)2,FFh2(2S;l]v,5N
+M@t^[s9j4c$r<sY@$7b&>dysJ"2h:)(2LbP!Yw@1 ObqDM@B5R75tx^ o*="L;G;8+HvB~,l>}xRc/bLekZIDP0#+w@s?7FY+SN[nYrZc"+n)?@\
+vzK9wn5VlSu?@2}7&+\	Smk<~sm AvPM~Mm?h2~g2'
+)R-MN[S Yzz%<>B;h)h]*j1tc=]'&<Z
+\1kX}xv8mticQLQAI(K4O>hn0S05]zI*tSdt	A-	YRA[=hQT9aZzcAtu0c<E/Ad
+]6dhsY3hi9xg.@F-#,.+_	Omi{|1gX2wNt>]1>+?8573HPAr&xS>@?7_G)M9@[Z;|;a[,cDu&$`avy+A"-27vdhv&O"#0l'-n7+^sB+Q2Z6k{uCi7|70	]o>"yq"=8{1HNx[9_/4=pg.\&.w}	1xF!oN'&9hR@qg =Uw_0?x=Q#vC+OfyQ#G>|s?o_5xkCw`TVm1+5JQjw8%=$k0}(+x)xAB/4U?]}1'x#n^'Q|+miK</uy 4rCh
+ii+;?Vu&66[r:w7pxH}I1M(CfSkDd+vd&qjv6rhY	7r>+D>J[[n;Kw-]A*W{!	e4w2g:)VM)!F^_70}<Jtch _s+{d3CYV'rnv)r3G
+N{, JE9Rq\)z!4dU3f4	7v9pyiwU~&FGBa2o?'08"&P#CTXR@{G.eR<^o[_(G-^PoN2O|_W[@+rEcc7:Zy|2zUpL*3~q,8
+PG=$u/?ON>$g#&6m_)]0d^CQzcQ?o/B?~<zt:	_vfN[	'+rPy|P5E^K:u|^qTd'PB+YnnFDU~M;4T+9sMdS=!Nrw+8&N?}!p[R_nWvW/Go?+Bg<r3\s,[mh+/uzcm$.w{6JuX+S`7FRa"XgGfNr-"kyx,"W84xM;Fu7+TU}1j9KH<h{Kd;s)`*}&	FQZ] tl{Ymu_N~z!/]"S4>_e$x%9/O'v>C]\+C_[GO
+OKo/]4atr""+2"CPxgiE+I/H-VL}}NTdly(ks+6rb!\6h!;O''^S,jB2o{LBdOP4	iN=	[bzQ@96ZsnZ| XW]_}~CiT@^yL=5GUbUuO<(&@b3TA,,L4+"Sz]u(	z>o/n)kXW{z{'xN/b>$)$ !nClO!QyNq&9hld$!^xR!2QeC#~JtL)tW\?,kxMl|.*B ~p[E)X?t?o&Wi9,;[qP%Llu]*BC4wF7#?k1.LdO}36S`/5VLu=1:}t<FO{ee^S)`1~twk~D8k~p)9VxqqN_n
+gd8l~hxF{5=BbWW|@[l&+HQ~8@7D`YD-kn<4B@l@09W{S?4 E,v'N[vtH#(<qxplUXKYz/(k1FGX}jd+2jKuyu`Wq&vz7O<i<=N7eWz3!^K>
+(\__EtaCk"a;%gn%li=(br,G$/Si+c\'1e8&Td&lIW%cGdVnk-%vN`q#7SOEygBCFFf84go`w~[m`[RH.waGoWXnoklT'X!B7_G4_)joPZm,\=T8lN;g]StE:_L{o{~+!9D2 2;>'mN<5	xQr<z5yf?Shxb:%$2X*j5OB8y_%^,d7jY+W6NW9D63(4Or+8y9kmW++FC{350mc\fqp_^+7Wp0 6nyd~B!C2/BcEX'Bi&!QAPg:2:DC+@+@!yUd{+fIv|</A9P-]e3~5}>W!?fEdH;T-:Do+KRe]^<G<6ThxZow=y@Mot
+++5ZcCR&l[q]N9nmV~q?Qy~@?CseCpJr/k7xubW+bCysi3Zs32 nF~U,<dDcOWo:2~~bUcNp|+kWy.L\iK:+I.$<GVujIG{Bo`|Vam_}/bm,.mv.\<^gy=9Gb?c^r{_>}2TlgM-YuarEGVeO1`GLfd$*]%4$'bC6KEAqlXdEn!}=PHru}b/|;^C-.(SdM6f6kv`%fKboG$Vwg(eg 8D_+L$UGN(pKdU,Al/G>[u(RY:foijP,ukWH^07g<~
+W/a}O+65UljxxlcqBSw3~o&G88O?=G%u;m<Nq(I"94E3@A~P#`.<~952SLJ~W_hxGIxco+WQ#<?NsN |}'|oyZljAIG@Qyqq?F1lXj>s$b5'%Hh2IUT^S,0 r`};|WxGCYbZG"WN1o3$?bYy9'%0WPZB.Xq6v;pj7T@!qPCJoO>;Y'`x1C**;"^7|>M;jslrC+g5i]4|SI!~/AmzbN{:8R9{|+T2fDW3tGTv\C<9lc@|cssCc dV*o Ln3D"$};:7ua?Hed:^Ieg|I'c
+(K2m"VF3I4)+qYvrv&';V~G~> dzy?2#!-Q+[K+nUohY%%OVy%_Y/NN:X|aRU!=D9ql/]>'\[55}}^L+k#/s>>3m+MX9'gLD97&>+]8q8z6;=@S|7+)Szuu_|{|B|wW+ SI:XKdPwn.']I7d}%x7yM]=Gr"2'Wzh6-Z|$Xx D7}MotrC}utoS]HporHI;>fl_+^-bM0VR(WLHvt|"SoXw&:/J(sPno=/2Cy~+.l(CXy+sq*S?(l]=~k)_Rk)h`<B:T5x Y"?rys
+?!@b?rJsF\glb3Ay~99$2my_`g~boJIO<qL'7|.
+n";an0]'1sukjRYCA@G}O.HBzca'|{1[g/GQslu*T
+_r%]lX5 O"Y,tv@ZuvG3WuS,	z_Nx;+.O>3y% K;+	k*wbN^Y];mv6`@Z<t?$C`SR$aJN_m/y']4[~HBbY>+lKKIE\W-rj;oz{;&Xn$.z2A	It}:Z0+CsCHJnrqCq%U*P
+^h;X2JWX}HldF;+FB4~#xk<&xy8I.TCcxSq128&(m5m7+'>VsZ+ 9ACG=]DL,r
+D~{5/V!3x(-GepS']kvEhI@=TL'22N]$hlr
+^x<86dtc|<`TRkld	Wk&JpGbpJ>XF5]b22`o];vypdFPNX
+bRGQ]se*xyN{<d;6A*>7Y.:Y;7	|>4o"DO?1nFrdN2qlvj<c< cA|tre_3x1$g#y0~D!"1/6B/79\Je;_]gpjrd;M^uo:q_y)?O.`i]-\Z[x#B4(Qo< isn'BN#tgA@z*6c@Ps<39A	DWsNfhB%4mTa0'l[F;r;@y_&sa<s`G1#i8'8l;W/A'~>	;T;8mFbhECZ]L#@WdGr9A
+e+C|zs2i|+{u:APz0?}?1Y Cz]~1$Y(Qq4sZb,x9<)bi7Q..C+sfnpmP:$|ps`AjktXpJj79G^<|XOW5/Y~i7|'PxGal"_5g{rq+v$[DZHP,)/jN7:9c*r\1P(S<J!`1<?Suef{xmuDqj1[9h@[7u5fj7]o!V#]twnriGF>:s|O	o"1wl?|B6VKz_a]o^GLUP/_.e-kX@w85{kM~rLZO+NNh<j8a1Gg&3ZXr!oJ;u5\<
++R'H>!=u,	[pe3F-.J>/o;4=w^swe=yMxY~/_=?QH_)}":<eHQ&sImSjiE,zax9&MSd+|@Zhik	URR$jYu>
+)#NozrNkW
+	$?8+#<x~	g8+?unh0ad ge4\gLy14+l6{nX]W<.>;5\]8-v^bbNX^}7W(vc#'a>}W1SRC-a:~Wh0v"8pMAr	wcNfAYQ6L~}:+QrA+Mr+V2:`	>{~w7.O`M)Pp{V7/2'b!D&5cQ_<kc6vE#?i#7$-v\2rCLf'a@+Pm+qqJX_7V8@Alh;%@%ucG7| kAbbw8#]T|}\7va@X.MLErF:M<~{'+aoF<TI!Ph42%P9'VXY9IkMr`$7/bvN	g^~/}_^VFj}@	!Vrr<?wW<w9>j-ybo[n	?5HOR]JteNTdlZToy#&_	B:bR&+BRrDS9O.0%7XB5]3+B|[1'>Fl67k+m<gop>RR>=Wqj<EkWef`2r$/^F7W7PO?T(`WFj8>)mN ;_-M+Ccn<3U/>(hc(nvz}hv<qL~Gs8p+hkG&Q;j$h)'me6cbLF_9)81w4~0{L&Nep`H(1fDv@a,|#xhqJ+1R1	j5nE}#FAsE(97&M"w4:+}j7cWO~)Gwd&y]}/>=++SiO/V{_A>5_1(B{9cQ3u?M27(91"Uk+0(P FfqjSCm7cq+hPv90E5&Ru+.0D #iN+> =$6V03pCw-b&Mec;J[&9(TLc+&X `^}_/sw?_8\?_9|~z9}z>p?)h.Vwu(rIIwCoMk>PZ<@2O|ZbDP!lulWx?zt-mDfa^VU8e5+_RCw|#OlIW\-O+f&fR8@w
+uAWC@|%Ki!XsRM dkyPA|F<ikvqv,]cc;uKJ:77W<7cel|
+<c35xH?REZL0di8cyoI=j#CGTM+2fYM
+J;OW{v`q{d<}~C.)IDCF+x{59v_0/CGb>lPYlCczu6~Gf`}@l&HQxZ7qY^~`14uZO`cS]#25]+	{m_ojmkFc)
+DTjlthQj
+%b|<*f27<]~yF7	oUxG^p?u;uZVzOR2m3N/m[sm#Mp`$ERu;(FK'8,YJ=Q5/qf(Vqr-'RR"Fgv;	Ksj8zxg}f/+MO+W~xeub4Am~Lcbt&g6r|F
+~6Jn8_++\0hO4jNdq	&g73ansI#+?7gcN[MPZ)7(StWY+j_49R>87Z3&sM]\Y@Mcp#mM4K@0,\~s_0mdPxK5O)v5"O}n|N.4Q6JrZRFZ|	8`WnJ5<Mg07'qHW3p'O9=wCnC".6;_/{D+z{;}9>7mw8|7w,al<]
+,z7OLZ+H{n	]
+r;X$sJrrJ`AazT@|gYIjEhj{,C=g<yRH*aqRxmc*nPf^ro5"mDU~g_T\jM|?&dFZ?7+~:7:<DzQk8;Hh^OZ?On1shjN)eC~?*Z!"C2{~umcPC|3&8Q+556]f]P)Aw+vijt	!>Mw
+FqJ1;yJr>%7invT_}n]5&	>]@6JUebgo?zW^)A3P{RVL@5MPEu:dP]q'(/O3}eqEa:p~Y0x2Qb;v@[4vB#3TDILQ^)X}+&[W	E&6KGY=V>m87	YK]zv8.F>D+?)VOJu~V3p~XuB0Pg>*CM;h:0b%(}&TAkmiv$p=j(LFZiz{liW
+tn7ZFy/'O+L S#E>f.!?:F\$|LN	>u2 OO-c'd.JW	.!glA42u.j#cHrq*56#i|M@ Nj,3?\F+^b}7 +F+xJ+Qg\	xO_2$IsS)@58Hh\$1|G-j:9T Y$Zjqt|bfzh5^DA\,|+yh=d`A]eRb?>j^|s0PW\bfR8f,cMpb3_s.]]>OpiIJ\dq5(	?B/	MHx{6P~7[+0[>,u=bc0
+2Sb0]~1~|Xk-1}Z"('+VWMx'/GT_NUE	x.JZ|k[u]rOe-:sDhpu{ON,nWYo;lF
+.<[cbKY>:V<(l,&f8x\tOsXcBi +H864Jho\NH;+q+eabDP1^Cr3#U6X/FL(U8".W$p\Lr^5R
+vN' ~8-e!m`m93mS7S;VN~K3+xvE?tyO2nvt?5XXbW=L@1's#xW,rISa&K3	SIIx=	@^xFM0@`WASxiVtx_	*7:v0)3"Wxquub'!Wv	ZasxgYd,2(MChW_c>"&Fw&95]j~A{8C%<Sf3Xk'~0d`}P(u:d>ttvT+*whe]5w]&zX'!Tj:,'(~c~9lX[:7i
+;t?-1E *u'b7bW-UEnz'G@_kS^ih11;{kv_}`t>p^["C:8l<J<|1)aR<YY=X K9X.${m-9sZ>Cm_M{9WzmdW/jcZ?y'\W\.8gt+I^Q|@Zw&!)}~Zz]`W[(((6][=Ne*1ckCeUDa$+:8ad2d)-{L$(bd>Gf
+RpSV~XCSwh+'XF}fa;{G+24.Ojg`}i`Yy~=S;'es<ydbU(98uJ+8Z(u	U/~qe<z]ot.Xk"6~'q^:h{%5bKSC_ =17WE!+Ncy`(3N8evB?Q W,tl+!;|?L7-_wf~my<{?^[e,b"/?2~'s7,qQQ!!'l:Q!&9ti>x%\3$I?[zI-RzlEtUl/%5.?d?#TLKqY}A/Y3r<`>0l\05\k8Q!v-EgMMH[0lJ\m~|#4?0O!``Z^=j,LE:
+=% 'w^"Qu++	V#+2FZp:CmAVImMi3WN5WWy" _c<`g| z>m_/iK	%I80~@v~7c>97q y>76i6>?8g*L4bY}Sk+`4V|;
+3TT|Z:{j|8Xjci\C.575](cqq7HP%Z? ZT?.XK#W@FueUG=}!gPzn<A-P_}F>9gBGtz9)a_K'g#_Z#}f|?6L:Rph	j^P16-g
+y.NR 3'T9wbnSwfj9']gK*u%t?n_L
+.dn[=j&`)z>^?Ceimt|#Tf08dneg<mbre-&)/}KWG_V`K9"ZG~vz7},gFf|=c;pFa"z>p~ 
+QsbWkS%0^M6.N)
+xmho0;gwP?4sMn>ONTIWPH>9'.%Km/8cL5-4Wl+E/xvbA|r&IXtkWs<2z/@c1W_0bj*zP%_.<;	PZW\V2,p#g<rs~~0&@#_Rvh|Lwd,;6<Vk>I\(6FZd\"zqhW=H=P:Y2NhsIk]TwS?8N^IEM
+2a3X3\-bgs=81RPs>K?+~>a	!>Lm1@kN: mNK*WIOzp|tk~Xi=*73~X&oD/F_c.^{Cz^+\(HN u^z`!rqM*C`53Gsl*Sz#jYGW~+ZqMi4/b7c~;x|>6<U
+gUwQ_:a:Rr|xE2c+crGG\'o<-,<C-20e4U}N~mE=l"4>xI6jKV:h`}m[F
+8WX-4znJw{\	I<zxAk5uH_k&
+18B?j+QO3x~U_Q% uxB@Hb;N?@xQnp+n90 ;%t_.;su{{52;]c~^yqK2J,+rtZ|@$bIY}#Pe7csPrOn~Uy!wg}$<a7oqmn~<eLR?O*_xr'{K\k"`C0Vlu)76uwTy(J1*ek]\ktiACMW/=rdDT?N2v:ODO@ZIS}ZSG;5	X#X6(
+ZFCVL}U&lT~q.oj\|dIZ=_vN)`&S1 ~mo[0 PG\yn{>b)=nb;YCvk$4Glhy+dM+?)Hi{N:_rFe |Plw7?w3(igv7;{9	 <Y>'MMcQcvYz\x.Wr h+f;$_`T}
+4}s+QM}1lS8X'C#+MUW\1]kz=Ur>^O lu.OLO<Va{_	+H"cQd\&|^s+v!by?g:9mA
+&l"+:bc\IXn#&u!R^ajOo
+#kc&nh
+*N)Cix}.8[	pG.~1T>o)9.82l	O.?uVv5Pv,Sg}Z$mHO($/t=u2&9FMLHGlmBHr?w"q]^+UN<kKS;Y5(du12H(|c'y@aKn4S	??WBoV_rn*k#2>U3[c(}B;vseWBXW5'jr"mlm%%b3Tz{?+>NG>iMHqoWu@ENkA>_~Stqk>Xb\i}Jm.\861	>\\#wHz/dNK\,hEx@cY	9\qc>|O_cnWomezF]bC?K\y3#s:?F{5"6K	ug>{86mTy$:/+HvQ-2.SOM+F|RXn~$<-<T_YY*<jdJCtw7M\xtnz	}H'NGf|sW;.B*?q(+1b$u!8W%V+Ny|L?+ho[U(JKb{/|a+O:8]sR8Ucz%zA^c|
+2	nQ~.J#{R1tK+h|uG2&%hZ~MZMtcKwk?@6~E6>./rsoyR\yl}EW+N2n`n:w4et#Z
+.X|!ZW.%P8r
+onsSL?kmD>keI%;ScP2Z+|^?_}9{oq:_?7#}@Pmj
+:=^wL>p1+>2bYfoT78b/:xjZlH>c 2+gZ'FCX2qf$(r>$87XAO>OsK.t<%vrox[xU-OlcGyA"*gangu:	dui{qN,lq]kZ?Wf?wAtZ`/NJ-cyG_8O<C<r[H<`q>/HUu-I<:aqr*Q4QfsFi;vYK|b!2Gm^+	[;,G~
+SZHnkbuTrvX?o~Ki7>;aX|[ <>CMYE_)/+52]\4xV\K#y_"2G?o{zd5b_o?>?XDpl gQ<&c|{^ *4oL?a;ZTvyy5(R8qC<zF 	?#`t>Z)/9uszGX)Yn9z~]s1\lC:S&O?:;4O71v	&cI[_u>c@u,lE.o9dQZu!}BgMF:NN+}>_mwm^\iT|e LGkJR)9|zo8/-lD"3=5N!^ %Dz,s9V(|CibY~>9Rc&NQ;GC6h3]q>m}FTz:c=vBXn7Q
+Xo;+R9	=En;y173K(BRM3T;k(#mdf{m/?~l^KQ|_Z(*i]<[^8K$ld,K(1@_Q~r;|kv,Vd;O6!7{2bBl{^mbZ(gXAz~}.WC
+`?0z:0O075Nb[[PyQ9d)y N^$#R]926_w+~'{su-E6iN.q}r'DyBZ"Om]~m~U>Kx2N|_(s |G]F>V3zwI;HsYCm`w*B}t_w/{GX7<o]y}Gdg]A+m	):udQkne8Efd^5sTIy'@#(#*zYi=V._N<g? ws-04$h'N
+GkwkkN.y#B5|s>pByUsP|80}s}m|$N_&/sNSz'Z8_~,Z}M/`@SlzCIf5x$/_,Gr1l,c^^[+Fm+,xG;Ik+M>Nen:YzVN;6r567Zsy;:Q=*B]k;^yePfc!+zAN'??Wc @fZOz\J?*~/ttyZ_Sc.+F]jf@y|(g>]z`,K~(h!+x`]w5>-<t)>~b$n;o1u-/c@=jmiF
+Q}?/icXA}eW+0	YCmxYhXG	u/U%{:_~u.,hG0iW!e2hjJ<->	+ll2G5>2;mX2o4>uFe<;3^r2++<2p*	se ZX#>fwNhRt\^yWZI>5FrX0ron8Q>P+{rkb]InNZgIjlcjwi|7Y\EhiWo[%QO$=nk;Zb25#naMom{bw=.@If=\
+}V|y[?{T?c%k.-S2%t]e]+ib +[v_\|^we1Ru3)Mz9tb)uh!yBwMAwCL$8?'A2?qkqCFd~Pwj/<&-tOn%.3e,Z]6G3.oi2%mG.<:nkYY;'>9Yt%}vS9H:^`[`<y zCI|OZ#=|I^?(k+T9O\Yt4L[	tc~fBTt+;Eu_'04nF, L^Rj,kh5j++,@N1`1k%[[|2b~xy)B7n} E? #xh^d<z;"aXl(+u@slA(6/^c!Zxi=r'lz>xjif~o$oG5jA5]hc:fy=wOyu.+GQ9'@AS+2qx(eS'<qw6F+Tuws2s~2.ht.!mGxj~+ms1&YK7)Qm42/t|k>}{?ON-6.6-WT{%+pch9ua~^a=3O+xtbC|j
+Z1(m-T;POhMcB}Am\?8=~H4_8i]W #<C]7?Cx<b(^WB;>7=wf=M>6Cz0i~s1~r/qO<KZ;D<wyLL\`CL=Gq!W05'UT\NBi8F-%.=?c+,NzOMtk+OydxN`nPN$m)+sM|+-]d@w:k7]w0s~|N1|0
+P?6w2
+m_dW7w\.w<']~gSRnf}gkLA~j9uUB&
+?uw;e4Lt#}6l/iKZf]yWxwkP(.y`0
+mC3,EKM	"D551ny`:t[~PKZiP6BG[zwVF~Mi/>'|rz_S%
+tN?8=4f0=@co5^~6k,}<47FPV)#GE&=uM/N}p[|0B(,3!(8QP6Z(<6#o{3?)J^)/+2TEPlZ|=~/&YZ&v[{|IG7|2u.rv`<bnN!EV"kR(JsjO3/E~|c`Ip.@\YD LIN^:2*3
+~\]K<'	1Y<{riO?2e4.UOk5.o?UUWcQ0X9gTh;<5C`94|?tVqjYow`:y@'/ONIX^cA<u}%C,6[w3~Jf5
+tF7&h]f	]\1_jt9_TG8,t{/D0cf!L9{8P_~]u2	+T.C3+LdZ>FwswL/\8)??/_Q8,ui\J0qnqp6H2dl+/3EgS{A>z{_#n.M!}?&r6)S\A.0h<'Lh.+ gMk*.AY|W%tbpCc)g1t:{nV_x7.Sl^SG{7DHJ1E;yv>z5x?wh=8*/hec}q22v2j57Wk<ID93nq$"w({co@&GOL5?A|o{Jkfm|Y6Q/Z<c56}txo~C
+_xv!	)c&\Yl#:^|zg:Kx]lf+j)PV0[W^eqqF~'_le IF3E6eb[+^+@TOP*TNtSEf8uhBGORnyb[x_X?On\P*OM=JWn`~H`jeY"\*MswOqxrl&d=|x#~Nn(xdVR^oY@_6q@]}ja2lwI3;4[56`sh%+v6fZo8XGlQ!Ppx[%USL,iW	jQ>)WSo~_ZMr$<%MeO:&:[h_Z=K+jxp<GeQe~5=t
+E7:>\c[/#F^M>cW=''+<%U+p-m?|pG$RR@~<2
+n'EG0w1wL/C5Q|:;}1qRK'ONw~V7>~te@1sQEfJg3Og|/m'sg0vh9$UF1zb2FCL\GIa]=_n`n"YA.+9D
+mXw|m72;x.<M; ?t0f
+/IW594<8t9]1Ivv+u-8Pjo|\p;Ro\t`<?TTjsP\?mO%$s-{^f~\A+aS%S;?}tT6~bA\VM=:6]}u78eWuO2}z"(+M+V
+^DKj#Y8ax?#E5u#?:>HK~R0eu>?>}R?Fo}lV>84?{}gy?zbb7;cw%7/ET~F2N76#V,V&/Le@[:mwaBS@,ZG*@TsWRJ*Eg_w:hZZ`2v55;$n}[u#q]$witmUdeP7g3'WX>q_u#i*5?SSQ^IFyS2sNX|?s|vW[}K`; )Z"Ec
+!F61UbYN({V
+y8=$Rp$Ae0}|]y^/c~1+q~7Nk?4"wQO5oj@F~%tROq*3dI[4^l0"n"@,/:9!=>l?}bUA<(mo~@IOUMm7/2-	0`bmOO_n r'EZq6xuLkRl	O?8Zl0#oQM	O+0h["ooxJ_m	}{}+m~#CTyzVPyjW6nL?Dx?:HBBUYn?,5*?	ngn@Q1+Lll&Fu`+mCz$r;+s/dolSUC
+Fzbc+bMX^|#N(VJ*|p+eEUOox7WE2begJuo1:f$@w	:`*jp"2Jsf%?)W-Zo33"X^>)VVX[%W(?	=o?o|
+ZLIJ_c>hjs\?xbAoD;g?8aVvr/>?KoE(c4o+e'*6@GzVy*x}E(' F_}62xWMz|_VjhVlg'@JeCK/-\*b,)m[hw]#+}mzX<mtP)LJike,
+h(mKLC+kX2x6uxJL,[en~15l9,+#z_[1+x<m*O<ydzLVErFV+o_MG6.m6_=(Jus^}/=nBzW@Bkz[5OY7`1G>M,;4^;RTv3{rg&[e#v
+|A@/ttRK!HS;yCV${olVo2"TT'E8Q)zi3;EK~1Ob?P5.ul*%gu|tLR,xP!4@vh3o>39/[t9kgG0zFr]dot^Faj,)"vC}BH/Xh2GOmGP# 2XTXH58vfi YyW1,X2gw8<5}=b7]+>>f5g!{+#Y:(8J	V\j3ir@_o~o[bSOqW5Tq`i/AG~mtrO(PBf{X	r@B8wtfhd~1c$@6&|.t;"\F8Ehy}ni\WNxZA	.!`JLLI~er=NP+Fx Z1eW.`DaGrPV=[u|j'Ns#+!k!{\/:pnlCO^e
+eudE<wML7=~/_~cl*TnZiK~C(s+R-|nM_	+o.i*l"vA@?{<)_?2{y	@#[[oF)ra`1=0<O-}NnQNM\ MK%@j.gnz'O4.ivZT!?#9W\i^I]C0+~n^T]eiu1-NU_6b+1Iu.Ujt^~$P"JFmdqq~3ntVu?GnmmjAtCt	'9}=S	T0Xv9tp{K<n'R9#nB%^n|(7vSU,gzKCvp+-g `NYI]1Ab?6KcaXn`1uhz<_pRhEOqD,ZlC_8Hx>U2Te[*SX<-Sd}2+t:
+?I%_rtnz*L^rzk<$#nv<EN DVRR(CAO`{ofv-
+~-(ydi2lh5SMG~Q%2[7q$;txg+EPW~.2-l
+Xz\Z-]RR6'^\m|7+j_~?omj],v[teh/2}V*`'Qo15L0hi:J;+sNpbl,O*7Hd9hKd|?lmDlROo?;n#G*K)/tF
+0jf^z+;61A7RB	-p5I)#o#HePa*T.L5\N=eO=Dw^s[
+DkNO%lFzEAkN#	Xn}fq2Sn{/{Vl]Bu0PS5B6~@PUXO0`t,'9Mk3	d8ks^KOBT=3C=+c	:si>?~t#GdH Vfw%w@OhKx$uh)uN2/rb Y'Cy(mvc9kJmimOGV)(:D.}O7+s#utI^NBXU==rJSnQk,wFkaZH-5HVW~x`lu!L
+,->OBV]ziw%N(+IqW;['S*[FtR+;Ai:6	8
+j*_;Dg64`K/BMUtJf72-p)Ia+mDN+[I50f	t}56]9Q~+o|w~Z/_'%'7Zgt.+b5=+Mu|QKbF/t	}{|*R+QB1Ka4Xijhl,1dX#]7q.~K*^MF<)QZ):]Np}gN.Zw+/.+3&4yvb::KlGMBG/bvrN=!}'P":XnLVD_{>^_dbxh/Bk`ss5zND8GVY+PXsQF^+<DE{LmMz$O
+op1VrXPT
+ydO?;O>~DR`O=:z~F8^//unRBJ:E*}%+-=ySwnbmibee:8CW@dq6>@o:L	_CI/b1A)UQ+|R9r>IX7]rJjUa?j/cyN89pj~U\O&$O,wvb&MMl!;+F-?~+jo<k[_=QE+9`4M<?0f=/@{}!5>#o0o+	J\4z$F\Tj.D96XRvVs<Wx/s^`GBX+<*=]/IR
+*[TGu)b<|Vkb37l/Z'-jWi	]rpV6FZ9J,ZY,6]CvtP)"{g39}S+Y8l-Ce- ~QeR@15_(ziT~N8m\MQ<2xk	t/QOFEkm>9t+~SLr\CN8n+pC[xm^p<k,	!s,>nx~=p~n|r!/|B`4}>N;N~O:G-'.B*jN):i	+7MKRS6_c_n~3Ac+'=1	hez	CU[m+ebkzr@X+T9FL_w@KP=<s%SuzX
+=HDg*r\smL@tFpwiA)E|!
+ZC<,/rTOx%]2(+eY)KTVk./OgFdcQ`U=-m=uSQ+7um{lA`X6ct[f;d]^+C~
+HB*51]uQVZ;W_C[}->[kaK$>|]ZyZCioA*V0r|l-?o+#FotWU(}`_+XV-h9lv>S?}vnOWB)9Iz{izk4p>x8 m i2x:X.Zpl::/GOSbY
+8?]b,Tl%*8bliDBZ:6R#K/S4C_<(fm08\_Z}@q19S _vKyqssVj=Gh}?+B2>?11BHs _ev9hP)^.{A"7W+k~gnV_+JVNBG~ fq[+`DI*ydPFmS-tQ
+biS/zb6*%5g+#gFxCG1NkY;&[Vt_x-/EYI*%c'v(#_:W#`UC"_bGR1K.9V*D>@f:|5z83Kz1roP,^o2V1.^	Z+QFQ&NU_yyVPTo0v'OT3	Y]"=,ZK_9{Nl}:&+hEe.nb$C8+NL:uROT;#}#BSAYZHoy@U8?3?7W-}"mn0`YECbw~f4|tz'GAtbxO^7Wt3:E8B{EyS2h7
+zfl4smugNV{
+=S.glbeOLKl_mPo4BY'>oO	kJ>]hOW&uJ+pfGc4.dV)>E^%[/}mQ~rcl:WKb/$`rvKOxICr6#V]*DDCQV:R.tK/<$4-q.hx+yt{?x?zbu3JqJh|tIV@&v+SBWkHFdZxfm1m=OM_L]S.F#keZ/.S_fvOk<l"gz[@x$NjK2+>,)eyNI(<_$h&ux2Pm5}RD>	S^wuz<eidV]BS k?s/{`80L)}:1l]Q{=G%}+=d	Z|alh-l;o7N?mc;m?]J/Q^|-~Xf#ct_o;w57m3RNiop+^?=T#me.`zrJMXj[1b3j7_D8Dk9?Jj-+OqOjs3I!)xQJVm~kba?o>ypZA8M,8t?q}3\TTI}.}hj
+;8+9I~_?|kov@/wyvga_v|wBLM/(#/of.hB0y8?4S$_JBECs
+ck9*_st?d
+nGo#_ms.XykrD+8\To	OOxtix4EVYQ3KMB5|[Svbd_;o\i,MqK^\@y)\Bke9V^h{&[dEw*0G~{?'[I*p<7}.tJ'bu"o8*ET*8EW;!-mfy~bFY|Dc5Xk;0'nNLO>!8%<%-xh7@dP0kU-x7S1=yI}t%+
+i
+>9)y/qQ{tEMK4hF[_PQ5'ycVNlGgka/zpyy>Y@e#Q}rzk'147CSE*.!{:_<2h%%{-&0./>O	qWHe_|\/N'45R$nF/2nE_x+x,&nb?<hO?8(diHNTUwUt;Ew[nl0lB[#,RVKv w!1X[Mq:73z"2C)JY~`GyT8/X^fs7HI$Jhy< <p'c{gAF	e@F2Dc9,,Y%I\D6l[~sn{{-{S^u%^.J_F'+ *WbFv >IdQr-BQe]x46t67J_9fYJZim|j-LCGv|#YEy@29]+i*w[vh0
+uFiw&J9	|B3qK?`\\I,Vp"+_KVHq+kfashfzN4w|X.U`vH|
+0kBeX[q!x80ANbN(Y|:h' 0
+8Way5}?{3)S^a|lo3+g~1;hL#H3<.K]G6-$uxnu8/Oo	g,>q"nHcDQ<+nlq+Y1g)gu[@`#fV++d`@x*wl^g>nQDY+C@5fvE c+%K`a96L8`9IA9 "xD+>0X@Gq;S?<|HZp~IKI	9wzcu!N9qP		u:~by&KNS:"'.]RY$t54AN5V(.{H}'}GBCDEax/#Od+c:aQ(1h Wm:AHf	%m?V UF*0tE+TeX,W^ye?]goy#_NWn.%]?5pg_4Sh)ca9k=kV^e(~['>QS1RrsziO:Y4/d<pgE3g\tb`%;xibLm{<xz~(Mf;~)i*%b5y*u?iC_.l)^pFpvQ+.	|UqT3|+0~5v8'n;<n8+|9-N<6|,1;0h8TNF+5dxWqJvr8r+z8DXDxrQFc'q5n@}&~#q&PKZ\@sPwG
+at=pV7,'}&Q>:Lm0%cl9hn(	KpBj	/|I;g8sm{OcoK|c?g9|3T[*Gps2V\m/"M?	Yj3%oYj!TZzlfKW){}[o	,:N]IYBNC0L|@9p4V/.fmC=o	+e87[afLmpRlF
+fkvANA M]d=Dk.-
+@: 1qP/}5XtX#D]+'wG#<,--f+U/Hr}&0nn<t>E+`iNvk?6B7sY\m\js5^PmmxbVli S8#N(	Y>>	+@l1LM}(=!r16y99Y`3>>t^Qg;o+y+qn\bk%a@yOO=l8:aqNx|:5<[0e:-Z~?W[`aT_!:%g/dsc<O~_~+<A]$n(}+@?V`#|)YySP0Cdz/jqj?OJxR(*Fx)rQY$;02	# Am4DzO$nz|-E["F!s3_<z|=z|<|t4~)8K_cb+-(9DHr2~j-+o=m	K~Y~xw5i1FjFyM}.sDh1asy`dmO;ds>_x7DV+7]KBx+C|";2>DMk|Qw<;?yv,HJ7'sZt!|<C/OmPET)J;57i[?G^Com6EF'+}e
+;Q;`N?Ik>j#=pF?c%[p&D?Sn76$`\V#`~,P'r|r#I^S7a$A<IGa`$ QIks"lH5@Cr5<MOs^	k[,ik]XlG'>"_u+xk#+U_(,jb,V\NF/Oi#F+W.+@+{S%YQ~o,N4|8?'~)_8!K*%qcj(sj>0N(B_h00UVvx8_|*}P\y$.Zt~X	*8mC3R6UF'+_i5n.D_6XUYBd~B+6eg9GCZonKole+Ou
+riiUJW	Hx3kB.6<lwHbd[`={|N:$2X/r'HfK&h[&v?[_5o[A<I5PmCI#>9oJ+oG.8ivYm.+qA%_~r6_D`^h0HTbHz
+/{Eg}+x<TbS$*$PKDDS/eDC8\e!&uRHPa,MW^z!i+./$BXi7P4/wARKRnseP-04	txW*W[-W-Er"./2YO;Q-B6FnV{d*
+]oQ/S~'8`@wJ[qVP(F.d%qg>6^=/[?Lzb[7xE1tSF?KVQ2 \{Euh.y<qXWa~'mooE|w.l.;+9<{K5\?oH.s&?pr|<V'GL0+nn q_/k8wuWZu59c"2'\g@trb7Q3\\QuXkJpV-+qp<3]M7b|2R[uvhV@y1*)ti8[EC|,*]yG.3'$N7%hQ'isE`Nvoxt-Q@w:i>}+3AzpOSDP-)/YggB:t%&:$^/^3Kt-XAE*^>F:v2mwcT6":+Ib.'`4-e9&+8@#W!1?r-E-/=l<t%pL+^u0gjh;N<WW2KR~plLAL6DaTB]X/'	alPKhdO)%q=k1 [{oL/,KLG]%v0QMBuZmxz\QOk;>?{xU<r=y{`H`~paQV_LRs@Au1a	X=ZSN>_+1"Ozw\^q~|y+1p>;kg+,uk7c;K]K~j5V[Kk/uvr@+!2c.s4SL7PImu"l<yE	Ev~vgKKN_\sby80(ij2PA[~}]K7:~R[	832hv{$o	W\^tf*OYN[gEKz"8pSmnTD3V %8.B3SK<&
+ ? '?hZ0Y$7	Aso7b<CF&OD_CGCqd"-d'"C2^_5=+k|7V[#>5Uo%A8'YBVK<@7h44xI7!JU5I-g*s5sn%}Sd[=qZpai	,Ve~-0%hRH7'TC!s~a;pp'h6uI$<8o6,w?J_V{g1vNV?_|^AjjEuQbLfS4{r[[xreB~]+VY[6$+*kiF^X^M[lEyg4KZvw]oLq7YP%}+<+{~7ge|_SXx	-}'H@*TN8*d`$mv4[Z`xg?{V+X~k_`/!L3Zq#XndfDQKGqh[+_u9^Go	|MW^|1f::q@]i/w~_vCjP)u=@Dam{WJ7r5iQoE>w}wrYngPB!M8Y.k@[!J6=r{G$EX.+y-[?H/]~OT9]Vekk(%dfWWZVZG7^9zoi/:+<<]1{t4;wxyiC/9Nvf12J8n,3+]+OJ>o|r^&yeSG)r%WGT{64o+W[2*p2g!E#@u	PyW]uo+7tTh9#nyTPL(b(.T4	=v4Unq*pa_(hD'o2.QQZr_`khZ4	YMx/N?$]+Iy&dG+r)*2mj{]'>-YhS\v>-yMZ/x1MGksI$N(hDE<Qb<u=z|8g>=OP=_<	w+94ReXp'mRyl6*6NAxvd#?78s4=v,=O}ovv\<o4=i9 P1*n=Ua7+5UYBl5C pM~7;c$mwUB}#_,|}Xa
+`"q4F<;.s8g02-U#ME c5SK@K;p:h>!%Y lWyny0,WGe+#~wUzAE70El]F2U'&8>	x\7Ad:&5D.dvQ}0olDoNN\w+ig9FAus?M<#2J}wl?6c;o=-X09357'T4XEDr|1tvY0$X>aVaE\%lIs,M}{p0B7-hO@#_C4:VaK>tDe}(i~.n^q#^RGvvnvlR;q#%aH[+rEVj.si+FJMPA\6^rYZ+39~#P9xQgan'25(=
+!2\qazkm,DLAS*D'rOOm[S]PIfSL?'R?
+.l`}{ruwon8 |tmIscfbWI|vkLTYT:Zl5L>QcsANH?um	Mbl|Lw}&6O6{+WpG_;mSxS>lW[3"XA6Lof}4}1tex:vJ~N%Yp$+'y+t-_/1zwiNSVE+=nS,h&KK_!g5kfZf!=#>wvK#X+H dt=1=_sqru7o'h9q@2PO/~&>!mT@Qpg*;Z;+yEK62K!b0n1Cz7>;36Z`#G$^|t)#|9iPyhG:CYv;ECU-/Zr|uu8_V]/YKRTbff@O}t;W*QHmaC_.}u}F{#w
+j_{y_;WZ8royr@8#O-8Jetufj+g+=7)396C5	7h16FZ}KGO=2mlx?%K%e+V.-Y)"
+LyPU7Iq}X	Zcy`*	|}G2rB+"V*;(!|Pq|oM6eX{tI6 Mv=.zOFmIPq^2}Kyme]l|?=?@7nego+^\-~ ',XBU3+v@FAnM+:3p"0)rW:/+Ab<x\ePaM<fFopafO%lLb@bQw\T|V-ugxIz2OM@13+p$d8tye;~gff39E|sMc889}p8vK,7%+AS
+)giQ0.QH
+s0OJS~s[Uy8>^iK~KcZf5&!tLO]p>6[CGQ9hK<U]N#^/^g]Wk+WsfZ.S@5	pmL3ABivJz88d]8aoi7N_HAm8L~QM3ob5h=<p:6VP
+0'_SKR9;Hwyp5[wV2+&uh(+~BCT<H[`$LK.!PP_^U*JQ/TB16Cldccl%Y,K[{Yg}_YkicmCA>vbOKN;sMTT:Qmh1''U[RJh8@iKah\0_k1x^/tB<=7pOy"va/z2^We#O[bUs9SO}Cz'&17?k1_+N*ZG=^ um_izo~N[NqW/
+3=l)`@icA[1$5UCCLpN2[+KU?%<>,Wy]yS~V%F9m__btHK?#y%b\G 8~7}!+3`.I/%_@m_{N. K>&4~hSPOqXdAjp7y9oV+9V77BHmN{2u	k$"x<b	X_:rFFX3[Bw#8,D.aps	{<p`2`/I6ATgO1G]IJ%^]5t_>Ct<e
+m	pE8FyO	*62.P#]$2d L2U{P6X5$Nx=*/cBh+LhT arg0:P6LL 2WX<sVJh!A.\;EZ"IccvCd5yhmT" W'[<SGl4|	l48\{b17#+1'O=UDGprP=	+l^F!0cnqwCdm+mV{SRbv<)oe2Jb
++Z79+up*+hD<*&&d]?.=ypdd'{^]R-eA;Y+c|;__}p)~^/Zl9=io:a~%c&3uyiy4v_6^c0|:o`1DV18|eD]ps7U'ZzPtn<7s\ T/0^/WN?bAb{ZzqA('R&5!!hb6#xgJX2Ch4kOFAu)g7v1'm %2_#aGs}8|?SA$Rp}~aX<sc"-
+Te,&6;a[!mPOt2=L2<&q]yg]wt`cXuA/T&@ebp,QG+Sc&#)jHcq{A{g]s?6=9\yea7G~+-Yg.zYzX"8q[_p<	Zx:th//O8]{,#1;lwu!yI,Z'B@OfNxMza>n-.(Xh& (($'H'sLj*g:23b]R1;w-S_rB	!+#_=t/4v$	\yuX~Js]#;akTu~}{4}3u$N~p5dsOWrQ7|W=J@hmM>{Z}4DW{	KIim-O8Uj7n	6+Bixa*dJ.=#_=|kk;j-Cxbt2}t%pPRJ1K)da#&0)*]u9<&sX~{U|sn/|Ri#_ I(/0M(+&O.oH%KgylmT#9<Q>sC(ip!{pWvs	gPDhTyT~bbB\a+Fi?YW"=R&vUgl/UQ:^lLj	|Ix@/(N/ebJe+Y^|<qV2zu{iw=|__>n+pNv%*@DmV\S+W;/GZQ4&O|akL</>e4Emy<lz}HmMLh-{}V_9wiecL^='Zpds
+|aNJ=m>(x <~;ro",+M}	TUAl:162Li4sc!.vrLCUBA]-=}?p+)6u#	_g1?b>?apwW',j6c"6=1|k8v-|Jg-/\cPt`_{Vtc'9LQ5MFg1LjB0uJ?i|7a&#6!QAZ[ |2C|Ona.h6,'"rmwm9+qQ]*?3|%~Jos"|YJ'}#GGOxNS4G<`:	w]I!&Q<\cjP]A}=-}kKODG%ltg'L[DLIa;f>U+L0ujxf-<CG1)^NJ*bqH<%^kcBA:."H&f\HkJl_+w:t0|C? <U|qle+\/`-[blv7+d"vVgtM&/.x#Pn+z-#=-y>6P+CxE#k^9#mLuk9/CJ9b;	K.EK>{[&VU7;oLjoO^}6yNj3cBPhWYksb36sG/>GxVM:<M|3Vs]PowHc@p!'_F*waOI:;	M^6~}Q8_e^nT4cDX'7%L:GL@8=20#]cs9:>[C1V+cc5-oYv*_9qXs6aFLzu"+<yE*}-QJ\'g*}\V-p<O7xLb9Fl0K{z>X2)c{auBD24WY/8\Su:/W}vz//}k&z:|"Pn+OeOm74cq`a&<A8lo+A<zx4|p&
+A2bO{~4&x4O0J'mA+Z=X_v`mtp^3xj/\`35QqH\V'e6$vGW{5x~}t$_n&wA2bOwvF+:Ip?"p
+?_7d)1)Ge<&{	uY8(<ANU3>_cj<	xx,Xm.ilZKs_}&Ar%kVE>-lGxOKH7H^_9u04<^l<ImQIvpx9?M&mWr4W	$/=IG>|ouk^^7|C.<h| 1rGZD/<^%	o/,I++;vx~nA6bcuaOoem |"Pp-\^4HwM(|D<n	OZ!=u tzW>)/x{U_+s>sj\VyfrHs2'5Ms}apI4tjgM}?U:l2HE|	o]ZS>{2egn\G_)iL :g^sl^)]4'>bYt9+rZr?C}pkf9=r]%~a_cCl7i)B@=/L?_EGWoz6x<yZRq\8su0n&5_phn8<>159ioe#nfp<|K %bO{s+?"\gcQ:q_X?,h@=??VW^y__*1	m*&\D`&p:>U/kX/|S2O$_{_-,+n+hF:ES1L.HuEq0?&i?V*-tb,(3*c QWYU8sCSzL#]47l$*1_u+~0?w#'8/oRbp__797wLrnV
+7=9[{UyC7']4m,AL,L^gs7q8Ry*s2;Cq?ccc|={<Gb+h2y@6h+mKUtY1S^h|8kET~?(C.fG+BCox9eV#MNr$Ur[DKW]w}]=228uQ@zIx: s'9^Ds2!lHz%M#A;-
+F;L;;YH|a71$Z4U\L_<t6&I?#t4U|/ob&I\n_UguF;:|=>'ksUkO%_:;:D?Q1PqZAu{Z<Y{F<HF;L]zI\<KE~f]]{vwc587.O[bY|]X|aeKL<-S'mcJ	)pWG:kU<0u}=m~|]lAOMyy6GbF;L]?6?O&mk_t/^4AG??Y<{7]7=t"+[7?}FeZW9wF;L}(..+YiB!-`1nkx#>+sWG__,^w]{6+@0!5Ao_%<zho ^f0xW1)9xC*":*pYD0mU7yt<vOh21R'>|8EKM/Nr6]PiC=r]O"|C-7}VCqYW-nq[<_
+ J!@._{|WTY{:Ul>Z8.Qk<r	iO'jxZ%^NI?I|>t+S&{zz>wSP9/IIVY<'1I~V5HeK8&?W\qdcA+w-\mg.If369\++0C"`iKiF\5&HmeI*^{}1qdnM/}ok|FZRrbK
+SA+JF(dd	Q3q7O-\d7^]a{5x4 y d}hUdXWCE.[[<j&&/UF<iXp,[lujw$~2cccAOyiUNuSem 4NbxX`D@+?Bh\={n4']9H${-0.yt\`B]B{Tc2<O:+Fp,5vbd:$)Mx`+s2Gv~-W3U((0KEV&tEhXd:`JA[1HvA'f
+hbOWn+\QP3tU7_5p6vd'
+
+xZ-CX+zI
+A078mxJxg%_;)daKq0jm/klN_%Y787CGFnr^}Y>&QYg}O!;,nY{VAfVoSMe`+B"6{"u~#ahhh	BAVn.OIo!  v/.aeM
+hb0	"Uij	Mq46^xB(*ZIhW)~`LmKr'cH!75AD2o s lZ0zPjV0Kr=r$<aagF%3|Cxg00_j=Id/ VS<Ob]}3a(TRd*yk,>C#KxE"LY{iQ9xugO#e	pIi?kW;]x'zMLr>x8Jl.Et7++Nr$c'\_18l!Tz+Svk|~l\M.sL1(7+~Ykl"ERF,[`~X+w	r?p^]pAYMwsgR06h*4~mGuv[~,8Ve*wWD?|E+1/1/_fv0MG.fEWyA/4~X_gN:Nu[i=97&]s?sWGD+o{{,(cth%be0oP#[3L!#]G[p25ocmCZx4'b92'.MZ;.@Mx_?O<f76&*\efp<8i<K/V2<snWQ|%OUU3)t:	>5)GN,QO]aj;`uJ*NRKclfkbGYQ]bG;[y4zx+}ju5NNB7=M=*O=v;06#"{.++-&&xyu$ ?XO,'qa|2?Am1+oVx.mE}OL<{8=dY{)i^=x@X;~(v{7lp>6}O%(`o(Z+kxpalHAyK<-D0_=/!VSWfsIjs9v{j'?g~fkM1gfDUZ11jOgr3?3~t?v0inOGNb+l|4V^w}x\e aQ~w73yN756"5[nOt<A>5SkT(55w[^|rT_Ww#Y;gvqm57Z@^:9@d&dZ(H`}?y+O>4b}g^uuy+_YuS	6NYx|pB;opc'		1{+=Be6],|c#OPY1nvD fhkie3;|?EoO|?w6t,X^wWG(Z_ :1%j7HG}_!Z3jOW~5au	#':W[)[3CS7w#+Zy=/k-_[24/W2B'<A??@~-t@|*0"tY4/=_7t#O~:1r'Y[8h&E N1Dqjjy%Wu7]zUhARk8,b?#aY0^v`9,Q	[ k/HHVKms~_/nuUy==|}u#s(PYTffR]?G!HqMm1ySS_/aumo=^6RmvVt9k]RX+Q25s?J,_k*
+R?xa-_v/So^83oO7cnhLN"'#cYq +fj$ g]`c}X3NeG3f~U^?$P#-?w;oMXnChD+q(n)24HF+E'Gp7M_z)6\wbC?K'w=%Mys>6}SZ;U~7?DbgR_1uNob&6
+W{M~>~o\yiO3m1h^B6hhm8Wl]zGl{z?K/870H]6g}OIk-pS:1"TmN`@h3BH|df
+AW}m$RN%OOGrOIx6FG;ccigU^o;A;Lh+A#rkZ1KV}%cSN(0+`1+?M3{M$=(h+[nyo~%|$&H+/m-+;'@`bAMp`x#"Yc||-}go=O5huK'Vl'I"m4xm'grL_mm?(qt6A+ib4mW}^m2_bU=:(=x>{C??{/O".T+1Hd9GzxX^C'VxWgi_-b~3*oH_j8SPVWIK^Voag/^6nU!b?zUW'!%)8:S>y*`QFeRp1s2`^Y>m<lmj[_BQ
+J3Q1,H[~ml?RT0prXL0+w+*Y?5?o[\w<0Y>@Ys]*+X4"4.+`H2O/`Gy5z.X+Any7X~>/>Ye}K>^/]/O*7y%9Qh+(?U12hY]`mBH6iNKSG_Nd]QuLmn*>#R/xi(6^/*;&fyR*+<KwS>/>B M~^Hl1?cgiRm;w2&n%J*;&fyR2;,%O_3Qf&Ms}~fffo6xbqS+PNp}(*}nN8<[
+vo=4k}q/|VOuZqy7J6I-84z0l nSvKA~kdg]eX NC)lV1m78>4M5M0Ke1mVr u-ua.V48w?Y~$@?r~_?*WaAEUX+a8X) ,*]Cu[B~pd+2;5DYu gGV+[lB{i`+svO^}'ST|2dL<^B`y"e@ L,nu:0e~;w|R&uB0AV7;YLCKfXm.+;TT'b%Sk>Yh3p(*yp7J}?8mK1B-d-/JW(Hg'|2nUmd=} +!k(Q_uD qk+0+e}/e^[xN7T(]jy4Q=^]}XB]t%`~Wot0Gwz@b{tub_3;]7Y5?uk_M;S>Kt@D""]8wEQ>y^Y__,/\Y5&6v<K3?/<8^	}|E19+7H1$%^:qRZez<|,$l::-kmr,+W@a&O[}^RO'`(V:k6L;6{U3gVSx'T3-	CE.P-An	n"-r+w>59:Qh_~=#&H
+ay8+bk&7%(EkR|;!L=>o-}B&/w#As1-gd=<ygCa>{S:O}'/~z2Vt%l+(QsROOo{j;GVMlK%@o@oBDKa5HQhH{=i_)5.J-Y4!g $pT
+F}y90]}|SPWa=Wlw!_@.hMl- wi
+}O>x-\,@rG?#/`h|$NHkG@D%er1U?!{U.!17l,}w~ka^|( "0|( 4|g,+{WA@b/'2Io/$cs+gK:	S<<6PlLnxPtiox`+lk#Tc_1IH$&1Sc>j;,#t,`B}>}??Gn^OC?h08
+"-tg:Y?xMoz+W<
+=]n2,~hl}4,4}SzLjwZ6^FUN\~V\) vj%t6V;)PSxI{Bs4}'ad=V?Xi`
+7-I=@J|dc/!58gf;=Ot04{!:JA?4FLc[O}H5,4z+aMyh&\X%sC\t-|eh1t;v;{^wLX'0-SoX$0!w,=`aXiS6)7dLUE8hFd|D3Oel.u`RAq*+xQ)+:x8"N+xf<q<LazefO%6&qB%!ioy&orrrSHA+SH"'mUx[ibX>~:z^<66(O_@']m@`K++?K$^+&0a/kSD#J{`Xjdq+)<Uw2`Kb,kSG,?A~iboSC?(pu&:td/I@>"x+lyR3Opo;{=#^-qdUF +n.2Ah-=4HXiaD)Vn_mm#KGoDB|`1cK@BiL gg[9;]=X73Xz|S\>d^#MLT# lz+++Y	s(b)n24%:n2Cy,w%@d_T}1?r:[,)2[&eK96mRq%|\]yP/`l[,)2Xw }@H9X7b~?mntl-=|$Yn2+o3t}ee6O,e/5,?lC	C4YrC>W/|	wb{?|u]"R"GLQp$nSxM[6MNMMm>W+7n@~,@Nhy+p`?~[|G8.x#E&x<+OFuaV4pysJtWme2<o*9{w>ABIxFOQEK$4A7o
+;]ABIxFOQ{N0Lz2%go=[:y[%,Y: "pE p5I#\z)K.9pI'A`A+m[_Q.QiWCgigAlm_iK?E2'
+?AWoJO:},"#+oLl=PLK +M)$\fK2_W.$H%xd%2e}8@PBiL>c3yBPt#)1(
++4&9Ekp1AJ1c\b#<aZ[+P~-Z~Iy.1*E!=J9;Hv5T	=J=V\KhliY)O?\<[G9U@Xp+k+H`Fp+l,4d]<L]2wG.;crqn:SemA&jG3X6^!C	n)p,muMBWs@NY|'`9YWy*LW}@>Q*x0Hhl2() 19
+c*=3XRwa<KS#'&&~]=+ed]r2z)@e`#FuzCd$O[?i?i`o5w*}/}=?E r[! X%O0HnoRM\s
+B.'oA:5+OsTL s/x.;	[<^O?w5$||/?:+>"% ~J/+_}||jx<1]u~yU2TOArd;;DN268|qO>O#@!"B@q,'QOp[cv3.??Z}$lRU]?8=pW7?;z-pah$hnok\6i+OuCTI-{#~9yDf#+>?J|;?kd7>}H,"YL2$pn)<e0#M6CwcmM6mn*plOAYx# }*0EH_	{R)|)_t (-H>I
+=7gk(oa9al0R`Xrp 'q!lO9TL0C?CA#l&?vx]B<)G_~?}#E_?MQ"2Q$Du.;~4x2f\ttkO?%K;}[moMHkoew00i+g"u771+TAXAX&)xOF0;_+'G`#@@7L^S>iu.7Og2w=I>Mbh?c<0mN3jBKI7@|m1!:P}%O>[U'[_%+Gh8xWf),X/W0AI.
+h+0flPl}>^x.l/OkpVy<h=br9{o3]w_'{ )X(,<l<9B`tG YG`#Y&)76w+8+A0$0?+LCb'A|TB~/)Clu{;?kdqlgL^+< =y_NoUe7WWQzU=O{~eQ(<9@+M{
+$xj~FdHPa}!}FxBLlA>'\r0/h7Fd!&/}HE/DBGE2zgB0kj,sN+'+4(eTL)R>E*?RCm/v+?fyk>O2dk;IX0d;xhJsL!<(Rz5)c?G{'o[}THX-6R}xc	}#"N@bdGgCQ|?K]aO:OG[3z|pyWoD25o2H85'+_"mrdiII4|0>x[
+,^9GqC5'"qoB^Hf_Dn5Op_)[@-/ eP$=9('+3HbsaZ"m^0#D{upS	9(GOf>/8?^^<+n8w{u;vJ|d3{Kk?8(<E!8= P{#`+,kuX|71hgyO{/>*5W\|:C.i	Ek{zZ&F`[`PReBaIsL=>G%++M[xRd[7os9gi&ISOZFM?ti;6>e?81kdO^84H+}#SL^U:z={G?'H\TA6Qdu6~r>[Z/Kf56M+l]{_FdQ}`Vcn\T]lN+R	LE>~'G|}?=.#*=^u(o}dnq+fEn<;+5o2I4%c2@[_~z'tY4R+xS)e2pmlo]6G6E*{T\&P7+IcHIICg){-CH(R`ej?kch*cER(
+.EZmj:1F^\(R`ej?kch*cER(
+.EZmj:1F^\(ZtiyC`z=_ cG?(w|M_W]n:~x\MezO~,k{@-Oe$R8AGS8)SYe-cYSmgmu9n-[D)JzV>UFdO'NHjcZ
+kpn
+zk{}}csvnO}?L6K	%<&"q*	T"M6]zwq"_/7O!cSTB4z&SpXz5GX5wx,iu)mO=hJN)Pny{+/L)2m+,0
+HAJb5532cZRl?62E?c7x&Lv2>#0>1c3{o h:
+MwSG[k7tb<(vG9E!vz6,"Qu:8E#8m7,yPSij3e<)eUu-Wu^9s)M/e+G3Gdc@ A`aC5yP$?{mi.^No//r^oxrzm\<4#P/!bxFYF@"OKY=9m%<USY'ydy^P8u5@	G@+tF}<Gjzt\[ko?gxR;>)#Su@-a2,<(|<9+p<x^3cKZPiMu[{[zFBpwE"HVm0@`vx1@{}VmCgQ9e=u0`c?Z#~[{[{[[+grwIKz/i[eeYSH8G08#zr>|U6@ZWS)xiW.Y|OtgbaT`
+#gpEoPoeq!`D`Ty2@mI)avq|JIq.v7&n8T#E1hH~toG>-jy>/nw]7m~ yH2f#37Wmi1XGGc1i2#p!\Za:@&QFFsY;v'>$\RHvZPi7x&koe?#'M=`SCu"^aSn+t`_#eMCk{>[[}}C/_Sv6)u2H({r#T{G&jy,v[9cex+?~J:P$@z\>mFL3+wk)ONoVc 6y$^]vk^;$R<hyKH8,<9D@kjyu=EqiQ^:}UX;bpT@>\9^ON*/_gDzVp+:'r;G6fs|G_&YT|WEW}CCC^s5W~|_oS<dwP}PNe75<G` <MxG |.sZ[Xe,;H<GH]6.hA.^Nou5~)g;]jL%nA
+Exo|= ANgj	n-7GJ>zh1|;sWW?;|;yH$)Kmt)rYL92i2#0A+	#"5<:sN
+xgt^>u/_~bnoak;]bi3Pat,$9e(/\Rgk*KO)K{}l(n x	134<X w'S(K<}ykZOD9yM-'G``p&;O^Sl7e#NNFkB/|K..]#h
+l
+#dJPMfq4b^H4X7(mOz?@XHk,?mh<y9-97nX~<?'>qiu"OvR27gYSNu,kjy=9E rn9@@@(deYoa*kYO>#Dp^$Bar!66"Hi$/oxq4$S_JLs1%xL:@	S~w~3/W_z3Z6E!+j6HJp@K?yM-227LemlLI+_UzE-:c>ywT{n}y3kULfw
+7ml:{-S}a2?f|y}3I}E`mw}s$HNm|:YXEbG#L$wpRcY6e:mX/x_.\xjsAM(Rn:KFdSB8CR\)4Ym8%#0v>S][PI#P?cd8~<?5L|;R8;'o|Yer$PzcN^S_5uOu)2#0	#8X@^S37ZGL<7M%/gTw{{7(O;\=uL+aL(A.~XV>(ROT}&r#;?]~@%w?sw/SwLu=^o?R?78l(k.[qhkk5<G`!S'Gp=Z;l))e:Q>N-oy^sOHzh.+4$+iTL~0p!d>;c6O1.1o;Jc?O63vmx+O]={+G><(un9y6kYTUVFeLp&9Rew>.(S)bRny[Io{|9sY[kVa(mX2n)a`\-O|($FUn~}x7K&1`L>bN+TR|_i(yjg/pwTIv{~h//+w~lr1/?w<[hl7]{?x 7C6|k2RXN,S	zO#!PrJj#L^1|BFSS4%+g|`(g^w>5k@eLklVo6^]/W>o~??(fOb^80,2y0">Jie;v"[tG{2D$Z}AL
+ExvW|"d@|s?le<-A"yP>ok\N}??d}qvL]deM
+_$ACpG:DA@+kjySuWQu=BJy/w]OxtR bdmK9[[ko?go=? +=41$rL9r~tFob(Rnh/@VihF_/8=C)FWJW}9^;o>_
+wb16y^XYC^SH8@mAm?wpG@#%gYS7LQgu}R^he^zx3?!,7cA{$YocL<9x@q+Kv84&:y}jKH=SGF}(K$.qXq.^N_)MEy`m\ym{~n>dm$.6{%,lT(|M*e=1;uGkJks7tG}L!Zfn)gRi
+{$-+?b|!&!$l/|9?$j+{b9E|Yw]NZrYi,x_SN9sa3(/6k~Xcis?monbuo{?"wmCSv^V2.UdHOQK8aB+1)CFyL]:vGWi3]wq'rK@(muL
+grxrl|[^/W7?twwzSjzS_g|Gd;)E)s8aG+l]k_7Yo[[o?go_W,9}]|'o~[o~^Gw*`kSu-+JgaM@8u+=9#0Y<Ix5<,en62Nk:S
+x3g.zK^~SN9s'G8g=b<X_M-*C6&6hbmCfYSH&Jp	+tYg]|08Gr~wo|;c\'rAZF>E<c?Gp!8sG =2*
+l)*H1)=e
+,	.<dyxwOm_1poc6~mXyY-[-/uD!}[Dm2ZN^pCy1S~Vr:HpI+.;Nz'OrS &EoOu:c_nwou[oo<CRm,*C2ck,hL{rG0ph^tGH `LRL-=. U<S 0O^ x|3W~',[lyNM+E{\zK.=yQJ:s7{^x9okr)u~sokx}d{$#-Fagm)*;~UeRT,*CpG
+#8.A r<'kOY76xJ+,<9#@xe-EiyLSW2{+/+k9n!?Sy+,.xZ`t$#`MA96/gxuusz}BP~im71-?o^>7*i2~V_Vf(cCcxRT,*CpG`(C#8@8I|jQ#xl3}t<GYd# 0s9.h3fq/CV'e]d}NY%xn'rxfm7o;}lI}8d0 _ES:-oMk9O.ee)2M5vjx$tG\%qG(Eo" yPSe<Zy.&kK]}JY=.+J9nCCC;dsS!J;6l{`+
+r
+~\/:v]\wgcZ[x|7o}H/omw}oymM%r6m?q_qw}a[7z7m719gs6_55+{VXe.8Zq5 pu'wB
+~6\/cm^<e75q5f}@`?(?olQnx/jof 371x=l8}PqbDKX/-q)x7ve=??o=~n~ca>nox}ow#78I9rY{Zov|[xZqs2j=k\	 @+ @`As^fj-j{,zN{=^>nC[xqxSq]G?-<"WlM{<y79=#^oc\H9rY[{=5u\q;z,Xs8jquf @ B+>I @+
++
+)QH7$@$y=@or{~{.gdu|
+/k'z*,*Lj`,8SM9On{'KlXMAo(GHhS9tu8m_Lx*oHJ,%@[[e9iw;/:UR>^DrbeTD^/{f&:jDau;(w<n\P4;
+~YfvR9O'%cJ::+s
+fy!._i`f{{QRT6$*!{(`!}z"y|DyAGb#LX2X$Npq`\/*,BH+wOrXXcav~Zas^UV$ca2KEkL.HN"sBpG09+0hXq>Sd A;vua:%t3+hM;O/}A{.EteO+>yM0c1DW7lX7L)V9	^*@:6s;`q5,N-Y&O}	isgB/^/X\RF}}`qeSMd&Xc'O..6
+DO{q`#l[;v`Sm8so%N5!?Cmm*c=i%.1TBJ)w*;]^-V\2~pu`l#nb`zzPBy=x<z@8%h.ut*qQ{-dw6?!f{@b?_Lv82Cum"M&DJVfGL]+5-lpkp!DIy?D+Wa?Pa"iJ`Sw_a!>I<tbC*3zP7"O<>gjUm+W@&l&s1X'GpJC#s>ZU=b&5yRW;^V?,1xU!^L'7^rXWUw&:Ud]K%)^	:^hK{!11%s2i"ay3lydeAW{*6;3/u<7}9/*Z~j\8q~?'/Q+
++VUKvlg\kgv:ngn(V-X."
+A"bBB		~n=}vwfvEm8_+1r- 8+{Q=N+(C#VU_JOVxs'$$x\~!Hd "t555y1!SQg6|=l	B}Qf8V-EL,]+ S_|kEEE\E:BQC9}*Qa>gTIAVBcc3{+*8fs(!R3A%N[lD#QZ2cY/@4IH5y%:u`f8"	YhFAB*)g8b+?kF30CB,_Ch	gT_/}UG40Oi2TzG$*KHQw]Frxb:^xa"o#y?t(#13Q\<]_/l*	QLa*Vh-M\l5Cy,l
+8&7ko)U0x<G3I6
+d{s5[m5x+/K%+;[(/ORPdLF]IOtM\UE;vZFLQt@:5!kp*N+X.^"$03uu224(U.04_5%"vyBpiTc	eee7%ly.s/gPU:l7f3t+Vimnts`WVFozU|Ku8GpxEa	*#l1:NzfC'B+G
+m4B	KuVK& I8Up[P[#PxO|A!:"b
+8jQ$dyLY5.U+R**|w{D@+juIc:'G g+ oNyj"@S##}P~.'[s9"^o.)^ fF8#:vkkV2f\`vTG4&[*_,,)4^G7A?ZDDjlFiQ&ESQ'vbXFjZ4\_{gVTGOGTp+jsaJZ,7/WJ+TrIOO/A,Ks.+<I_Q0l"P,PGkjvh?.|m@Y !c]v!,.=F ]Ug#$n$Y~Zyj=
+pgd- y>kni%I5:$eJfa:W*YfE d+.)3vrhT7~$ND#)5T8fO.%%zn8!9e)3*tZffh-EM[Fhm+BbKKZJLDp$C\53Mq5[8ah+O4JYR2]Z^,x'	`)S$	0MhA(\c el,'&}Eh@x^|{W&yXW0JKhjj
+6b_-+c5cfED/I%3^|+?^+ ec*|Pxyn!jN\SFP2pp^xr\n'Dq{G?>\n6u!s:?u<
+ 15'"Rfr-s<v"ez$bfqc_Nh
+lE}_e>(tXH<VjuzG>DgYt`#"pU0S!*~m8{uf^V0xFfkL3w'84]kA!mYO%P(f
+Kl{d3pkHvK>[hl&e[DU~N~N+
++WWc.Q[5}	K,9a)D:jp79M^ewF7?#ek$	r&MpWOGwy777O;cO>}cY:.-J/)jpo}o?}W	B.Jy.)W#OOs:7O4L-ObRx8}7zc}6lS_&D"wsCe@(^TS:~<?3fE3YGQX8hbVYn??[H5l%y%	b5u_N;s~d6H29{;-~2<v+4\?M_>-C@QQ{)q[n	|\^D]t+-k*Wyg/^QF-i`_?Xy/?t+W'>}+_	5`BP:@M+WhUoVKI[nNC@P,\s5uYf7`7"vqXQ7DapYR0^Sk\eucwy=DLx!"X7wq}.N,L
+hJ&PDCiCi(w7nM`|UWOmwp`*GNL{4vi+0S	7%`CBRD3L<(e=8E#de=&Gk";mE$-PJ=@?{B+GN:P+aFZxQ9&}{MKH:`+s.+%boNDYPP!pfJIf*Ypi'?yCk;$zm8{@(K+]
+
+>FU)W2T`|SAQ/]=%!=P&^xT@9j6"i71L=awDmE|R!~8'<0FN9%?)34[<*th:OjN%o%oh?`]<GZC@G2+jS,aA!mU#6+tJ%~gzpJUtMGldxfce3QAt#9D24sYq#UAQOAC
+f%:`-/aWX	y5^H}EM<+vDT+&V?YfX3U}t|R9=@_lB
+/+p5+Xu+SW #KT<FN])BudO.Hkz1lm		_+!|e}j~xF};Y[:[}?&D`,N}o3Op-Wi_  #"8\@'Xk H`99#y,%J_,[y\CHH9acQE	}'95K^d$?a~hS#x)uF0je}zu-f}uZ	XAx&wk-j]p[o/&NxO.9**83+oe6]h A^*I>h!"z_bB}ud`nQ1r:^U-`>uaQq	36$9a_m5pv#{[%$D%
++0%K~uTkj}}Uqjz]vq@`CP!A2I
+K%r}"W	;<DQ	6cd!r,O@v+z%:7/KP)[`@%]JS*
+=|
+"U=xt]U?FL
+@1ZT<:TW`9OOe<I6Y?C$%GPTUIv$`Rm@4	rab/8L0R0^wxX
++
+<YHV6E&	H1"H6D9[mVYfJ7P)6X>vH>)_`n
+nr?}y7:~:"
+%eBJFZ-; Vt=mi#VU.VqY68tu]KPQ[Z}7>y_Df2q,P_$2ylHDo-^6e[X6<-@4%L]6bP"Q6jVCU.fUm3mG^&9\g(?~6Qf*HvbGL+hZ;\Eoler2I
+4W1KQvXr9_}g~@-  %qG/X'{E@LED-a*CIcYW-AxOD:K+=P*D"	,I8	&>t
+i-eWTSSfM|%.3J{d]4&4y&0K%aI5guTv e0^o+Y9l:c@>F LKYm_
+_
+*!G{t !PC	(2;g3ik'I#PJ"o*kQ)BYjeRS3*hDq{R(X,)R?~1X;U,_j?V2Z!/U9i'6MF6N++lg\5+/mF"DY\Fn'3$!o_m."a	gsi~-JJ2PcPIk.WXBtX2!!!/E\  7e)t9\A2pBVP/Ixx<\'&i5y,YY/4;vj+>I+:Coa;cXP/6VEk;%7uQZWfS)(8oUUMWUe9+WI&]X7Ov]#Me``:qE	F`xn$!Lfd^%jLLY]r '}vbS4\wnIjZrmo:35l'7U_S*
+79D8A7X)k,Q8z1A !QVEX&:eF2vu;]n$+j+\S 2DLs=+)
+U	G@O:QF],dokA!"H5Dn7IXkY%;Gp-nv#s/J\9bDd<_fqC=yXvk T<!*L]TP`FQp'b>*JFdhB=%OI>3g]ve|a	ZdW;c=tuW|cdm+vaNG(8eROz7#0EoAd^7|zmr/;	74joAb#Fhf;eLh@7l1aH:r	G1++!l+Oh("jB}s2`y|?n)'vkxT^A'WP~W4>nfo<V&[ ..;Kg~D^Gm#r"T0@ 
+J%5LP
+
+"JTl%LLr\U+0t95m%}ims=7m+%4,5V4*v*~$S	(n,	aM5r~G5[US'+@#W\>}rN3lS'.{@t%QPtlQ{+NEE-,j>d}g;ms0Xr'"U?l	h/Aq;20<n2,~vw(WFp=CXqDm+Fu7q#++Ja;a~t|3Wj0t[Fx?sRk#SYx+h=zfW}>SO)-W@1\3+G&lSb|a_I+IzD<,)F.[w'X#FXm oC%"<6&--"*Z^T (SC 6$C9.cYy2]Xea|$oov9WHJ9.9ef?Htq7yUN7~1~R^WEn{rEE5ZzXY@]AihLp]cJg8)Pj=l]z.,="|ngb)G1n>zebA0^J+IIew0Voa-mDDc~f!tSVcC^/
+J:0NG>?
+p!9.:N?y=] k,I<`< ",?'@!=U@4h'p(P!i';8a)Z,70WO,]}U.#)Qr^s=[Q/EMO%Mi.(hqz(RQ5O>y[.lV
+H"OEP~S!)Qe+:z")LcdtKd"+K"~	H\w5#GK{UW7#J>^oLNSN)NC+%`yeI="m_
+(DBryf
+t"4BZ'i?	te%3q7VGWKqoxbOp
+[pm+Hw0C`8r"Pujj<g(T+#U&d.-Chb1LuW^U'-3J#V+*#RO+/[d
+d	Bm2`~]+pD03$	
+r*|s\.+JQ>V8x'*,9$ov`i	=-4Ojr+xXZ<Ej,yLF^MJ*|z4J#UCKM65e&zqV9lp\8PIEEkO<v,rS"2$%>>j*+2l{4=9[^oafmbU];Q>ZfO:uFjP02DXDhTFi<;GI Uh'~Ey4|2*Sfv4mOGXv&z`6~!BGb-m9OMGOb8p
+a^;[T=09X	"r`|U!My9AI/>L'?L5+FB @+Y'yzWTnuk
+:0Ze	`CD&TrH+HvhzJGAn7zIH*,i)w*JU`uqgh%8=SGJ.<_oteL^sC+uM2l(Y<}~fl0yt}Co
+G[!S:F}h	~R{+^9o2)v|dl]h)o!B6;e~VE@0 I.Ip$#4'OuvN+tgx?z
+bJ%9nf>5u.pEH]+)xv=JC_74^Xl"|wGO-QIZAL#wRNvp
+|n}nZv I-SH%?>_;oY&.|uZh^j;}fV6o6>/zsFR,cIqysIZ	l,K;?{Pb g!"w;?AjOaa6k1vgK\/Zs~Jov^Hs${EVG~JG~w0<[*O<~H@TqdYtZCgHl!Z(&<G#0S5P7-e4&5,iZ>m8SMJ|N7<`=wRF
+&UD\eX|<Psk<X;93-[t]{~'~3qz'euu'']eaO|.9AOa<-^uP$UBy|;bF8Alh"A+MGTK:}f^-,c!OT;w`5a;q
+Am6wv{td{Qd@3(&<Zt+#7,g-Bpn2%'SX8{"XB0"si0bd3wzyf/ :rg!h\{1Z0}~W16tXDxl1H|P50tfN1;<'8oF4#)p
+AE\>X	N+K4'^3D47"\dX'\G^lEO}FkQ[O<uz-Z]ijSa	?iqLH$8)|atytHF`xS>C_2TIra%&A7Q-`
+n%2?fHawZ:g`XiCh*oYz\3~xF
+c~l,<6vq%S8qldDjjd=uuJ>o6Sf7
+.eo0~m7)w+iwfYu!CV;V4 =lyN8YvFXaoSY[CRF"D+,aCauzWJ*-AcCL*Vn;18I-T
+xP'_Go-@*l_q#ar|tJMDpz]O)*xI6\`(:2K+JCn?Mw,EEEu"cF5MQSlxblBZw_hK6uy
+*n7~~PccA6 a)-Je%AM9c+v?qpo}w+uk.Ac#(pz^pN-E+:
+3ytO$da#+W4f~t<\j
+3-thngbHDhXjx&#N5]>oAhd+
+u2qOMR?WP
+(WI%l'mHh6%|*Io<v4tKrg<qvmx+l~	<^v- uai=%HT1Hf=Sx=	u1zDqsFN9?ci|1{
+A,iNG`0hT!<O&.Z	S+OOZl@`wj S4rq`C~Wk}=	IVYu=
+h3+=p9hq50Z:DP$C9%u?^	vPhf*(K!2FmvGKY@Ap7LAp)9qSG	-49WAqd'`JQh>Y'hCm14,U[9a2w]o;$IgMlZl
+~`<TS8Yz8GysMp5O?LTkcLO/xc){LBvx``r'Oh3\FH Lq1%ZZl'amzosCz;Fb)+6\}4nB<gArk>RG(EJSYGH?["97\$X+H(F&tSUo}iX~]>p+6|#a"x-DgvXpIT,hD*6dx4XJ,DGQm"/
+S&Dm}*-J>SMd#N3+tuu7}u?xbbaB@2Jr<B"uam/8up[tU+ Mvgi#Xa^~ yFulE#6O&{^F768~ !M%4I "%>G[v-kb} $<|j,6)Rp^k)nT+SxNZ*&5e4v\)%6EMJ ghpuA2\ W isz$G=3sU|o?/tSchM VZ$XvY-6T\]z[qLWj|+b;wU{vh2?O[yB\G	F0 M+B4$Y|YU"Og>G?G1~6Ic"'>.%
+>re&q)M|aycw{n=XSkCFA"m\LAg4GLjGA?0rlNWMkI11MetH~}v,r"Duh*gt(b_TWQK&5%lQ0&=Xq->%`wv(6R8dAZmhf`vV;)j%C~8<w:MpA!T$j6.yD)[pB*6A>1a\R@EDS&(UzyqMg:uZ}ZB`1
+>mI&kn,NgZpWq gX: jiS"J['EAXm;!'|(6(h~ff=y>Ak3r=ae\iPa92Of{,tv?J&k 	g.-l4-qFz@G`w0(oYTF.J3,ZI3+|!'!()R+(p>",(e30DDE{W>pj{[YEN,qWk5.%WD&3%vard&XM]EWTGI>QD`.=ORNMx40r+	6y$u|hv'+{K,%ei-2! z0hM\tpF`hXlKq)+a'?m-bM=99ITpd]VokaI3?q^u|Dhly008geE@$;#]V(NgWCS_$`7y)X^/:V3+2Cze>GJ^'Z%Pv<ps.+eYeHJ<Ef%d	x1&f@*J8VvX	Hi`<&08E8>xlsubt'
+:6{Bm0K!-5+FU,]b kT{q4iL8{y
+sUTgstGz(i~X(1r_JL-\!JpR"[vj'=:()9uMYH<!?:ON7N^{56bKbh(
+T~K]bRm['2Dt,+=IyC`?q"}/^HkL2.["(nq!-v80+Q4.LeK^G4*Zga[_:0?4%7!l'{%=45{~	IHU~oheOgz\mAWyH))wy30t+c`5J!MjSE[}"<\::agh=rsz		>s.uz"4'%`OV66_--{Mwgv,w)zj^/.F?lfti]n<@m(3bB{OS>N)H^A]"/p61!vf+q$//8D/A+nYZRV~z a6tZS]w $@<]Na(v!FMF+mdde>fB	u=P8iq<l~lba=C7DfJVH]]w y`l2F[Z.86
+ +BL!h#[7Ff*[T[HVf5QNHjpcnE_\tKd5_dAMBOdKISFI>F\A7pcG*exXj5Qk'#,;l t&K
+S,RUtcz=/qLZ{[c8]y}c$O<F$}l8	fDG.+lB^#yKh{%X~}Q)H+ltmm~] U@J9.H)'rY$Bu~`Xx\y%HQ(?0aVSDB6Vqv+=UG/:MQGYpJkd+iQXY\e
+rATcMbI 1)* ;b2)n)Mub3In;)LM>ndeb"1XGA>8'3l/^aYdeXu
+Gj|Ym4W?
+c@h=S+8V**	^S{}T/hz]{g5F?9bx&<g$')'+R|'OF?G~xnzn'f}7Jtx}aTx4}xSn\?k%
+\WS7geNokfO_^:NSd&`<_Yfa5EXZ`hO{P
+g>")Msr8Ai1bEU2Her74p-'C$9j>[H:%DbPme4VG2 -tTG-^\}HN&NTb.x1MhN``*0Gvc}5TT,+3ueSc}=;(!q5W;n]LDIBU?@	$tE,E&,"+:1S03	
+pJ
+7Fw5#zBq;p*yuv5K/pC,jgm	a@q%}Iho&+W6qzE7\
+++c,$C'$HF*KZWM3fQ]|v" =U
+>LAq+J&1Lm\""Rhg%+?j&KU?Y.YatWBas9{B1-->># 
+)rIX.=w@z8U%G:1G}1*$yE.=/Er(sO,VW#t/=c@,!%ZIK7dMjS2JDr
+{J9K{GT.jm]J7>4@S/2@)&>k* 	qTJD2V_*!ioBE3K?9H|cUuh/>5NL=>R@Ht\DMA|h@=sfE ';yL$}fg!~WNt@-
+jaoW1c0xVnVN<yyT{'rUFb'ucRp(G8!#&!M8yWEDn7r9K}wkQ!#L]vmt%m/ZfMdE2}Tvj!uP,V>#g,y!)/;+atyw/~wT5No^l-D%[@
+hY3O3[Ag+ S<z75JpD-A~BBD)T,JJ'W{na$~ZnC3O\ri]h?l+Iu>-!JU5E"N3iep3v">V+h[$<bIe2wS)$X\*	QKKc8(d@k]*pAl|4v@Oo	o&pm{J`>f@Dai\ #Doxk]}OSi??wBqm4xtFRlJ{?6)JN}}"t5lT/P6vXy8sA:8+`"<ucsew9vt2U1GB\lEuWY7Yt+ dxx+MCgP,{+U(v7"jLU+EcGSWWjfq6V#	0#v1^jPN$@bo5rL[N"/8xl';9)s`L-YAXJVH^'Br-veU]zi^f	MS)uY	fc\ l'6={lE@'&'hfI,)P}+8eY
+;)31
+bJ[mv~x*i+L<dd>
+m$~nFk(6rEl/b?%;yo/O{A1q-`0[S8t_~a$~#j?BXO}n$lA.mmCL4#+N"fAI>8W,$;x9Y"dgz8\ZJI'-?:W_q$PIdmw!nJNAy|dG`d;N,AQCPl>xAgK}:|PHwx@iA)y+em6x/(Y
+m~gC5&6b(L<I]Q!DK@&!"#`Slz!}=@lo<.rLp+l%A+#(!8@oX_!+}]@s;!Q^+|Vf s4p'P+lCplCd(JyS%J&!\%I<,.2Q)	,)(~:mF/(Gi3.+jp]/b	?O\|`$>v|z]?/L-t6:WLHE&!+$}4 '(~US8(m.&!Q4YwP#[:d+B!W1mUii'w?M[Cy bpuJ.^	GASy4b
+sB8y*(V!D`O\+JLz`m4
+!WO+H1S_J}\dBE
+_?&ZSff	|++Zz9.z~:FIPI<}T{2LB[<=D(e_PG+Q@Ur":^qEAH6Munem+B:C_h3+$q5AH66B-5_Nb->|(p@3=x~'9g`:r$^
+YM9SEzhPdHDsrrpQy|w/tLLF*@Sm<L{nF^m~tezA_/l0em)o	!Fl2:mOO92f"BI!;bW(uYp)OYQTgp% viE2-!a.bI	8yfri[gkN#*c6MK|! q |r?42V%>pvTO0+=N-)")V-@n\/fnZ5`h8\?5"/hTM#N_TbJ}.$=z1VCw'}\dxBB:8+@sEOT+]	oe"A%q5Jc`D3]ESq
+	-@N+g4X${bu9Zg:Z$l'r6_i.~?}Z_#b7j^J9&>dwX5s}Fv!d9QG[1(3?A#;ED#^LF5JrdW}D ELo.2Z:ARMu*az:/oDTq@PBf 	}hrTRk
+{p=2+PrX1aMW9^%%V_zu~-cj	ZrlH[A#45qQb\@!1/#l*Zsw@U
+N}0H()0\ 9vB< 8C`j@0"m 3H[z2	;(
+C$F+"\}	0H&pk+ 6wm}#J%gUZIz)S,J&B"e38~$M)*GE]$ KN7j
+WJY|nW5]rLuwctywj/_%\[6#c|NK#(,?L~Zm}sJ,jgZhnU[V@L-	/fCBoMAD+hx(Q6zISGuG<EDJ==I==IT|i<FP\qj5W]{-{SxYrNbiGqdt))Y#@.	!|_&a5an`3g,KT;9zeWl4fj@^P>A2ALfu^yuMOy6[_T|Eg%Us6uP4"Fj]u!2[#B&M\):AZQ}N*,^XMYP_ZlXD`lxA]^Tvg|1X4vubs.85bUSb ENoLnf/qjW.M[VvfI0(h
+
+:K\GtR;F5}zur6jc0"pI:+7~N~m[NU	n6$uxk{N;^|e}Iv ckn	~KcT*~\cM[NYCna#!X-QZ+A~x}}_n+x)|f"#+|u<t}/g:\&NPc8I{8;-$cdbQ|5v c&TcV|n,sc,+U@*m~
+;Z|V&4dZ;jj^b"^!($A# /UR8OB9jo5o{OFD+M upE5D(?++Ezyk9S'YmZ'MsO(Gb+<q 7zJgffGi*!RI}[rINRay8`IL`gI6,f]Bba)KX>>T(*M,,
+B!&hR'.	vJGh9L+N(ceiZhUW\uo-@%o~_uku}]j1,oczhpctD7!1_5(+48[F(aQ42p(@[r* ^TXfe`9u=]%q&t%CQ>ZylRznJ{N*#e	}V_EIrA(pp~j?s}5K
+|GZo;~oE~O,:1Xs3iYT++;TaG+Y2ysD-kGW/8KdN1[
+\n#.(PT`-a?	0SX(w w{]KRy'wK"JD@'}5'e}`^ILd]%&+J"fQtZ30>
+[5s185
+|I7Q?YfR)r]
+,Zt.3ZEJS;tXG+T>EGk}^lv\)O}j:N<Ekmjf6r5.l)5mz{$as]dn28k.&i M,;V6\59\!3\{ ^Rym|eqE9K:]Ok+zq]xrlTyDe"/43 )+HJ?l}Wvi|FUT'~xitO?a/gKvD]si!2u-ztu
+Aa432Lganx<'Qq<qfMb'6n6j	hJwOdHdp{giF+|#&Fful1@O}S>,2e
+A[CBGw)qc[w}}W2=3jrg+<({0x;nWmiSG5#Y_X-&8TF*68{3c/>/Vvu~3GARM8?+ !DEZk2lCoc.:P/>C80RW^W_%~`L]~^;Qv/~Dp@={;JcGVDl"-H,r~`;<ISt;0y4-I=egu&[|q}Z|qLlr`rf1Pr.I3g-?+.QnRoic
+N'hNS>35.	jHU3Sqg~PQ?9W[u.vt~8O82oWal5&kU]5LWg]I_nmSB??=4#?$+RN+Aos??<>(@bd%^0++(S)t	)Z<:c/s983U3?+NR[;q|)b0 *&gV/zP3x;kL&9Nx~^6iX_~XwTq&o8XOTp>B_?C8fOZplc@qfB}^-v=(NP?R#m>:;Y SbEa
+b[f)0ReKje9R{_Q=O<@ZOF	0CR'T;u]KmRm}]~>**f4u/s@:dp\<inGwQI8;?0=H=#o7pwriKcK9+?),3J;0/&4;a'?:L]L-;4CVH9	-;4?Smyuv&}DnVG@*&+'=+y?^3+i@J+Jh!}<Y08
+iwz]mL@s	Hmuzg[ei3W^}y+)/]vrp_ \iz?_SIY/}Z%( r#/;8>lPpH#qrX5e^$Kdu+gC5 $X*O[RJxf6WO_[F|++-	<LDwYWc5qozXm+Pv, `3mrpRBl2k0[;`m@dA~Z^9L?H^i\'
+4)ZH#Z_o	~hc')H`!m}zS+PnnidYqCOk@!O{	+k%hSNO;+t_G)+O~!v'mIWT;L.;o:Qt7\ptQ,4%o~{+={bN=KH?:IcUv">s5LgJom=w!c@Rz4F)">5#3|Mi?Qs|Grkv`-llxI=^z4H-e{TLp|z<%MX7kQ[( ?;=O7~+Sk7g+Gbf
+yh t6i0+=y{Gn3Xp^]6e#)R!cL|qgyD}sG|N~=tr~V<OT]~Eu)VgdFDJX?#8qv}$79}_>y3>G}l
+p[BK>HwN<(\Kd$A7^}_~^:382 3}n7PGy&=E4LL~	9+ImlB)7P^G|J{,?s@{[K{gcWu
+lC<0ARGj!B@JtDw$ DRnAaJ:J(&RC0vyUN>\vMgU{uOFbTwhIC/Ll[w'nx>|+jcV.|N(L
+c$
+e{<Qv~6
+2$uX!Osy\en=&dwM?^9m+I~&L=PYL%4X$~><_r_6&!4!
+l47lYZ*'0A9Kh[#S]wZa/2LG?3Wr.*VF+8t%x{k_}}{oMwy+Z6i2z<)exAEJ	*=@s?xFSZ)=9m^*.E{`
+;.+i:${G9ioQnkW*v*V6S`V=~g#Xu7p^q&yWk_uTVMHLd=hefY?}t2"2F%2|^.wm2+I_?!r+B3vY^vki_(JgN.u]w^Iu'z#K="	?Fs+44!cP_^zv nV!&}Iu^A^./#<+
+OK`1
+N1pS9?(;@2-$f$B
+)(yHn8X
+m9IP?.DR5;oyW~^9eM.3?,v|[/F|A-1|s#<LT`+@2|P_$\uX@K-MZn!=?W/K@Gv.CEr_%T~(mT9:zh~[>"<s7`Wq>-G$C<!c}y_wn!A!xIKu)*J4PjuAWaNR#zB\gQe>Rh/d~Qgg9.;m%7ab{~+*V[1/M|	h#^%G:J?O%?ysAIw+_]Fv+I)bSTW-.92Sk_iJyPO>d+*|<O6#G$z1 Utb{/G+V\{	[9.#z6Dm;Z|i^{?~_m'2N|;G{oo.3<g^;{#+NYw.gpW_+Xy:yV+[+]yUH#}
+myzzqW/1O_HZ<w81Y!s=G~+v6m[/A8O9f F<uv,^IP#q3H`'niy9;q!z ynX@+
++]3_g`#MEJT^nkT>f9^zz0q=Lj+&1mrPCy1km)zy	vaOv7H^zz@:33Ll	}j'<	?#Uu'n>c:7r!7mt6[nk7Y]'g}-_}msY-x[lr{w}wqM7tu]w_~T'N|P<zOfV9`t g`z,;0<&^&zO|Sz&S>>S4IxMGIP-s&%MLMMY$
+U[tpNt=\{7Y'	~k_/r+xQjn{3_d3=tnET2hnoIOzazTMg5)	s?HgSj-/>>/?/_.rRDZ)3P>z~C/.YL,_?O~}GTMgi20me&~hoTjWK'^_F8	]G+/v+t^v@L2EH@=?5ySUgkvO|m9tB(xv[n^z__(rNuUN->.ne3p	zgg-n,Mz<~/_>|Coy[>5.r2pOR'&)mEg`@{u=>~:n'jU!poo}yQG}+ wV+PCg`we FqWSxUy7=qicD~ c/_o>|G 
+k5Ok_)N}=+6-;@MUKNe=vI<x<OtQp-;\MOO'ExS]_SZlEJ-[ugd5KD7J&1aBhUG.U?mi#7jkZH\v:|}K{8Z`~~~#f"KCs>P^v?*B/Io	+'!ptV*;k6)T>=ZYkhblU5*	@|r<57rAzr#l
++MO>%/yJ9 qOd=@6=@M]I*&}6nx>xt+.8;j6eX y*8FM@6	>2r	jP$?lQ'GNW_-^@ }DMdwib\l?@M]]/zf8iO{Oh";SVPwwg>]oUl6$g(i}Wh,tt)-JLJ6,V1U=+	o 881\g#+9kh&wGy'O9uJz"qz.,/?n.%^s9]$SeJX.G&~^x;~<Y;`b_W5Y<la78c$*<$lx4mlM12/JL`Z8fOkf%dPi	.1}ehX6!`!rdXo_?hx'8v	Z{Yw;;I/: u@^ze7]f|7?U	=wNM	{w3/wh
+Z'!ZOLcbLWYt&]k H}9/'1l%Nd<%m5bV{:]3gFs5hM-JQ}`_/= 9KKup~!=S9\=y^O	V-}}9KYgx} _5_;|=Crg+:p>oU]=Mq&&3JVHIk&BI\,DXK{Y[avS%~s;[)G\&{cr@LXZcS4	~#:]:
+
+Ga8tZ}j<w^G>'[+HtsE"(`4Sw^7?=^v'qNeWVEcwWI3&fqO4BW^zN2j>n2Li@eo>OZ$@I5IAY.=+W=-(SgF`n
+
+;+Z<pGa4$a(eoPNL7}#VAMi{7]~;$
+{k3TRhE^+Xc/R>:AX,1f@""~>p)W9"NszG#ijPESi{Nn.dBm-m<$.m]vR~nGGxpgj)s0cLB0X4Az~1| ?sd<9E?/989h~H9!HC6
+PEA{e$Op O$UF@=s?"=f ml&;a7j}1Iby>*E~;	+!oM5b:L"}>`?$@8k)sX2Ex&DJ%+s~@f*>ub5oSP%BdfJI/[-eTrbw.],zw&CjZz*1){%>[c0}FWCBQ%\=q`SFCOO^; QchA0BRh8Pa7J"k~e:g?h-No
+!
+-/8W?7|1Q#pc'D:M<7i_^r*Sxpf%[_;_ds9/+|p!M;K^DCnW?DwK)d>]=_H5:Q@0b:c][tD0Mc{B*T@{IMoCrF;pv$
+O-u!`.>	IYZ:*9T5*/q:hI\JpKbvJmEHA7d1Yc" mDLG8\Rs}JHhH/J7JPwAk-+@^}8>	O>E6T5~tS:UOc&434c4
+SX ^#U)[YL!,#b":ceT>qo+EoK@'e6xRNc}_DlDS=Q
+ks,m$=B:MC|deWlUjKMYn{^_xp{PnkR>;kt0JCSm~oz=7M0r5zqX[ca2`801i,Y6l*K<|3j\+l6D`iohS&[^:iN.V},^nag9?#?!-g+ej}5Ol7s%-hWYQx4|%>?x#z8pK% }"NP@ceC7D0y;|vdkwNHw8`T#F}ezBr:/@h{FYRmq6}.Bhy
+4_I$"d+zp.|YAJ}PihfiD<.3A;Lu?b?DU}\+MhE4$oBBVpVJi1j
+6y@,TqEl0\]^}E,I>	kFa .6@hZE8;{_h-5S3_8c;4H1@a +.Erxs-?b@d%q]jpO~,LaOX+[,Ab_DcB0`Pr@Alh*?[$"qBs0E)fvK4X(d>i|$GB8K|]42f*fe,r.;~nDoU8	A|d o%A>/<^'i:	xl+uLOC?nW	{yW*Bzle`EPaz6=F}__V%0Dt[]Jk;}K}=y-]  hn1Z(/6Jyf!5LIC0ja@IiCk 7P*9an_&('$z;)\g28!A^*S=CXk1ii5`rvgpoP7(eO\;B!SmV1`oP#jKOft&{t)+~Ok?~ +^r!OxK_{Ew ^Ta@PVs-o>V{nu/7 Vkz?PLf,5mdT1RbZuM5X`gpY&fN<U;C]I>EQE;#J!T[HBCGWsANDDlXGRNJ8
+;8FrO)c}:tX#Jt5_xg)Gt5A2p+-$@[K1qVStVtv3!rx\'p^urx]t{20{Y\=@mfIN+CWkr[0EBN!dFUeF]	]Jv:KVG8R	2o|`LfB}iS7,dTtHXxALl	F,Q;+9Nfe@Wux+
+8@`67"+Z+Ni@({8;	taG	|;[Mzs]|jnWDD\-0[w9>ZoF1JX?IveRNBnTU>+qf1@2ao|sek}	.uUs3f05
+m\;S7M"f]M8i_Hy?AO
+721nfaWg:H#7#?NU;&lOGx+3l$)w.rw+%"^^=jMa^54=K.^}&
+{|)u8q\e+:PZ:8}e?yjMv	]vOp	/V{na@kFzWPZg4\-!{xviMF#?;&kLk@Fq2F(K7((#Vg+8%cX]w }0CwOXw;CF"Fz"&:P-vZ%#1JPW,Uz~O|1cc(vUz
+{(!=et,mf=|s'z+F9t;ps^}d\-[rLlbDQ{%8=Si%G\JvKjWm@$="3ewp>Lw]ET^1Wi]s54Oai:3O+p1IA@Hvo|^@P*VOy8Ffl.+}wyt\M7ydY|c{y?n&HrXheu/{ y.5S3~{>_ou_~AK^3prp{f0`P4l	''A+,W$dA(9#."b1T7[=X7Zb4+Ur_F"X{#V8A;J6lo
+:}Ss9rszW@?	y_wt5u0fI:p_{]T8&xE`h0JfLN^'rMwXxrK&S1mk"1Wqh4`.qp*+rxEX-f+=CSgG:>YHj^ O~DS
+NVq
+C+?AH?T3?#<Y;:Fpo0/~i5ROw%r]+^!my&rV'se?YNKOV|xf_~B#z.x
+}KDMY$R+_wX	BUC"4u/)&K*xOe?)'n+g{~:<@0xgBQ]NP1#gV`Y q#Er:>\~
+TGJ+Nccy,Tq*x(zo70WX#\*=U}3C$@'&ZDfgz=hv@]aeI>XuRS(G[M^ '@kdDCOvclUNc#l3Z7N"+?Ml)Viy6e9W'*^Q-;b'+> -!U,/[)`}*=q
+U?m_8Z)Y<E/'G-~:	-[q@{'=(E!r^vabB5drK.Q/9IY+iM73<.N;$Md8;\T^7wq~#<,:`k~zEeJr[[%5`13jla(yh%F`([A?mwez+K@3[,{|!MM61'':7&1&"&U26	z(baz%qem$*Y42~
+nF*bC	N6D8dG.5o;
+uU2U-@>`#zB!AVy(GG.(_6mV%s=IO?n/4w=+S:v/XVc1]:f'm$\eW3xrxm2ho=|Yq4I{[w8:@\T>#]UW]sZt+udcM|rb.>Z>a`ESJ&|\H]#&LNIFn9g>?L!%r6(K~F%UtTlO/N+{hQd"=aRuim|Fq:%&1A6AWa{g2b1K"p^Dc )^1G@1`K$T<OZP5	ra[s2?F0Zy['&YFk/%KN6Dv|p+G0"e^bt<U8mICW]E?'}+EG&&Q(Utv?pj8!taDHpuo'0,ftaCz`1E;O@	Bl?7n5(g6Jy,2J	+EY9`JemSXjT5P.OYi~^]I!<AOq''X-/BrdZY]u"C->qse{b^@&l16/qOZJ]?&9ZF`*&Tm*9b]Fa;$U'WYI/)Nc%HRv#_=Aj/+%56>XtYT]cO!{0&26Z+9h1RS,T/)92>$n4SV=qO71pPvc*E3xcY3th`O*5@W!ZQE3Y29(XpB@6V)73=Z-B"L	JUWj*lWTsYGoxJclQjea6Ns(1'0/oVQNk "uX\cY>DqxeDw@ur!Cbh/" k8n(cSxg1tPtD+6L [6y.{;X;t!E3FJa	(	v1&
+m%/-_@:aWJw%{=#X]''+qPaBFLDoV'3LRpNbO5Ylf`bXQ26/Tn2?O<,	n]FqOc~v+	H?Xn"kH`I;m1-/yuU`.X?~2{gP.Y+2=1]@v!P~j7OINp(vV5kc8i~O#vk}
+G:j!h9WGT;+@5MA8}UNs]&+QOVt5x[jmP+'M7'v;Gbz<7>iO{]vewHw,*df\QRMl^?iv~1k~l8}+G)R\M]_dB.O]U.=g[b](vxibp18Nh?}`or6$bQd	t}xd{4lH0<tN }A{>~Hrq+\)fH|C2hTp=07G1`D|?C|jLr``7VLLT,F__0CqHMz8'6C|"O(8[5N	6c]U'0n
+[?6PQvI<Uyt;V\[y`9zd\xd_ 
+:9>6at2)#:r+vL'zdr#:?l]w |`X2WaH9_Z:\i_o>1iq'=	 !]te2.B.]88K.)&:[H;jmZS&OhKDp-48#xZ<[d5D",4"Fa"Pzf8B]Ge>2Qz"(3=YQ=K /(YZd{Y.M~`\uDbyBH>B?l&>~Y3,SC0UMPGIlGK3"fPv;>@T)SMO\Lyf:26'SjaL4DN2'L>Y?0@@sDE(wX+a[`2[KktS|X:cU^Vl7,\sBg%?{bLcJ1/~lx[ cm;BgC-V^g`sW;!;N/qTfYMw:[:>t	n8Ep>f`z8cS1`W1eWMt_mPrpE=^ &d	Y|^F'g3'1n`]+^K+.YZQ++5n7sclkL1>D?\i.%rzPdNh"!QP
+52UG
+5fSg"G6 { IE5v60!LaMBV1	VaGhl!Pp~ o'ad=D\M\l_{::X'$SC6_c)X=	sq#y^@#]upo}E?kv:pp^%+>x~OtCcA,I@PEMMS35`YY)3g`P$y1kWv%CFaJ	i`9g@y@eXx=H,]TAnew,en#Zv+(b-"a}HpK1:%uLcSGt1Y\N}`NC]5t83suOXR}*~\?ap+Vj1jp^8DBDo2y;p	=84;|ARg$G'lO`Kg^jQbXb2I;+akC	/iZgv['?2$c(%,iQmL=;xC-"|F.^v{i|EPsvX0-e_p"GR$>ab"Bb=b	~YhlJFq|\Elea$}B 27+Gj9QP>j	#vHp_2vM2N_AMr_l\1	wXtKOo
+{|Rt-rZcH-W=w=mZD%3[@]j$a}^7owi%zFq+RzH%+/LnIMig?k;{<'(8V]|3oTe2Y[%?)L2MLs3 d	
+|c3[lK][.mp2l*^VKCd<kj!X:jcr@K"Q6)re:h#n#+|Q[,JU}Uji
+9F#eb19I4JOY%cCZr;x<c``H3e&VZBcy9IT'zY.bi`#g8~y-	U@W,51Ck{trp
+emJM[w?zWM3}{^Yf;9=`,~O}{/9UO~QGu,X}t1&)SU}\MK,SBf%gl+v@j6J-F,$WwV!<	p/~3C^wn:?UG^b^p#"FF#|CH	wz~N+FR;eZ>74Rk|13`CE6<>>!Z4A@IiZ0NEqm+_c_0WR|>rAd,A-!,!mnm6Vht(N'+Jx-*kV[Gc[\:#*d;aqn E_k	Q3/Na{EzYBL`Wjq1`cX9n6;,}!?);<+z-2+-]i1QRG=%LZ 5 !)5F-*wUEXXY+C,V}oXCfN-QF|F.ogAd#VSZQz7UPi9Y+z^&giDoqk`m\o}i&e*3A+SyY8-,uQT&=mAWvh:{`2|}{<XtVr^ Q.0nAlL6g)C):I}[*
+~{NaFb9a{E$Bk>Sbs/ Ui_El8U6g8\$Fs5	}!ZZ+x+-&JwFDM>ug|A~zNuL+qbe1+X{D+hd1{vD+lG ZJ,E)|pFPyjE;@RHjHp(aHY{m@ccCGZaaqu8V"1/lvi4 xXkKr9k7ZMcAkCp ,7k r:JLz-Y-H:fAi8'!3-jz{D:B/^E&db^&u"bqWeJzMzX	A	NQn<Ed98*n$b+fM,*Y>)ZzN|~cK656Zd@[t;m:ve3iC'<a2i>J~<U{BOvf5Ol!G}4?'tcwZ3;>Vi	UFm6byNt%/RhXf=kk<!&](C/E%kHfcBubn815[%7J;wM{sq+E>/XO>oO]*REyI/+<$Pd?Eu
+4}t_:{$	>Z=]ya{F3yB~Kmg4\Wb_Fao5WE&jSaYk[j>.7m"yb VTDBW*A<Aq# ,nXe[\#vsD96=OZ;ndl/'+JxjDmDKMw-YYAE/E1qH>d{&+~uEskZ>t",O3BWsOLw}X,gs+~?8_6/.SOU=Bc/+.p: F@+C1X(
+rR'p_QzLF3v-_x#@+k<kO6\]VMYC9}>p}@ux-|+{^To1|S.3.N4B"!-OR$tH-qq;eDQN$OHG
+}UkqJke<6	}0/~?%{"1!v.sv+FQC]5dpf@Q6~*yHzAsJ
+k^_</+zHb!<#>'rM8`h2MzZx]EL1LH+>@_?n#!eun=l^)!8;D8F[%dLQr*v"N}_)N3|*X}J<eE4vs=h>cY`y+kY280~!c!H>iA.zj^98_msdGP/Xm"g[m-5FW	9f>wD;SMxNHG<T]l?bS,y+w,q~R+3-,ueD(p,9Wc*QM1-a7wSqnmgH*_rA)eJy?qM[/DLS]e)|{b8r2Rr_lL@p+k4DkSWc:YST6huak>8Q%@S$ _a2h&(|6iN
+.Y`QwM;o1,~^qA
+j.8+iXcx\]"K?#-d)Rk?;q2Dj# 9+&=j7tg	iBd@"u
+k$rDY]h0	s$h.BS9A#6l4-i=gW^5t.4O60-.^[XB?(.hIlHC
+<<hs
+w;TWA\(`6jBua}.w.D_b>8#5K]g_[cEm@Z#U9E,:-?&? x,9ekw>iN>BnUvS',wnHq;>>:|.*daKcn!Ke?9hmbpw[;KDrHh)Y5jf,:QJ50upWp.;T]Sh"$s5'pa%;a87%2W}Kt1~t/JCG2Vws33Qn" r|?iK@a~'NLL2IC4|&'BA<%_i=iUQvrf.D:.iK]B5D3gN8|;=+f4m7:+p"^i_Xe]#CO?~j|x:p$lJOl;&>eed<WX8]++k&\=LXj:mC7!-kcnh^NEH2YFv%~:hnb"KY_!uWuUZZzg,Eiv7oOI+4&>i/<D#y"z{V|saiNGejsyWTb}:f1'._Kf^<$M
+zX?G@ /wt$)yb45X`J@nlhY#&9K4'`\CZ'}(/>H,YY/$|ihy3mR
+|k k8ZQH<Mlucp0&L%C?vE%eUxvZ=JMc>w&	ehtgNW\vtyNtFww|Gkl'I\1W~ls/drlyC|]i,(TS1/.
+uF]TeM/31v0"<MrG}D?n/A>AJCcBqj/?IE*fwRq=v"v$?B}L6U;Wo=6Uo9lQ4={][a7\^{3VB{1z/?MS}>jGuu<3=;yIfL/H2m}w.C5}ds^bA\smi,d!K_B]EQ<f#ixVJ^(5Uy\45=f0#<qB/GPV>X,'R,:os[''K 9cVQM/{Kn|OZi]$w~nomuK6Dn@]gZsj#/"/zR$VX=Uh,@.qlLgpd-9F)[spM:Wdu%!Fw_V6:"&=F1(!B
+]	2'+
++SQ_l866IWD}'ewwy]Sz9X`=Zt{R1G=QJ>~ILG(Y.;4\LY1]XO+.'R5F*obYz~]5>H4BE/@,t|92	?o+zq9gUJR/7~F8VY{r97z/Fp\>x%!z	80x%Eyjt'f'K|>\Ix^4"aJoc52Q|k?GR?I;N1)'0r1S/Ow+_OjN?L+N[/vt. N/2FyXYV;j8cXsR!(<Etk;:YF%
+:cl	N?KQ%Rns1bcnR-x+~J|/'f&$)Axmyia3VE=<JH5ng#jS|}C2x=F:NvL9U|U65+W<vo:Z[wQkzg}YW+Ac0||ydJzbxVFbD~)0&L1`#Jua:g%cDjZ:hR/XHDnK@O\}ARt,E&<
+6+[\/$[MQl2]K"G|DGn?K7kO>Y']<O<w[~J|h_"7xK;mqG4UXYSI:9Eq~CXG]P!*,'kSlb6fM /2zNcbw1*r`7ha[%G[H
+p5K.$s+A`>QKImA&'Y8(?TDK_nVf?pd<wzK/}+/5r>06yDUj-v'V1X^m,Ct^89+(E_S+875uEzkiS]@cQ!6&Kkj+tS/f${ *?7X9cQnFQ)py&|[eK.;/(rX491Ku!NJ}"Avu4M.8dv}p7qRoY,=/z?K?m4;!8t3e[2Xxu*&:}WD L]4#yW>gQsR1f9TwR7?SCe~.1vjkf8 ~"y=Dcd`8IiZzkz99[7#`v\4hgSc>~zwzF&=gh`FcBB\\0kb[*8?.Otb"Bc[AM1/U*%ZFbG6-j	Mp86rIV"o1-}G:.?Ak#>>_SQ"5xp6838/(2r#_b!JaO3$rK
+%3Mfo?{4Y@IuQSq`pPR9	w<n_)]r!\~bjjEM>|8&#v.9Tp@|Wgn[LgL'J2_+K_#Bhm-sAHM1WrfrcmS/<7z:G$Iz+^V<uqZ#10K-l	y|#	RZ+_r +mEeq_i4`sLhBk/Ycem5?cn+PSZ_)mEQY$5+I,,[FcY[uX#eMh2M%sY|*J
+Q4V*w,a`|SSDbIWy<vzY3+1O?3{v;/+;/{CG'n2{ZuanJ4}JjbH,+J$jb8
+:S8>>N&U\c gWCrr80G~chV+v<;		09G"ERjK[jA-.n6Oee%STjID1Y L$u.A(+'RbUso> qWLoKXG\p^=x9+9r\43%.	O[gX	Abj_,( 9U:#l}88@P8(X8g6[nYGp=RhWA4'PKm+="7is^o<Gn?N|	=:RB	`
+iQJBV5++GB=1ckgn	t	wm\d4sO?M]z7+.O&P[ze@@G/g~2<,roR#ao>+L4+/m#V7j]X,9P%U*&K3(`PD6Zv19
+yU$LgdDnv2>5O5=ucDC\M5=0M?cwY9i@ml_770/~p_.Ae3t\ES;kqSIGj87j#[Z-mex31#3;L}m.MQ)m{5-}GMj(h,OWRFE3\Uz"\!S)gW{[f2kC3Gj}Ni~A"zQm}Lz	yA%vLDW_aLI7m`o+wQ`y7#lee#d?2f19/f!!dbh	^xK(A4+6dmEs3!}PF0)A@MjBt'##?;"C7?Z>rPljhl}'t_QSUOo{+8!U0e:LQJ3}@[vm'B;=hRHA&/){-CJmb?n1"Zl	+@F,.Za'8AVFdJWv7vXZ]V|6	i/~OeY!@`&_O8X/X1G/!.Zd?0NP.H$XqZjPIFW1#ThZnx2.tSX9t%mo&AcVz5q oij9g!WH|@yM6r)V:d\=EW.Li@qL'+Oj-0uBLYKUlN6g<XvtFuY0nu4P|A)1]@_184/,U^<iN5yi	m7KCU}xPL:$tU77<rmjE_\_8<'Fm^%~]^**3J})%(bGPm;Q5<^9L4%2a0cm"jy1*s?gP#u%5vS@66Z5wJ4(0'/U0j0g<^b})9t"+e6	ggrv
+}M9UCD2>'~ug~T3EOXd; <ahB)oY4DOGRuV1\s}-K.Aa~MG-[DQP`Q<8
+q.9_{q-8B5HZUQiue}B5x3h	6(r|I3y	o[87g8sAFKGbF+gGJ!Xjf>~PJ`1V-Vxh?P$H$>I1U$=$WEJIk L/L+o?Kb3V:wHgoWg:+P}$_\'!k9/R-A/p[y>6i^'MXoVj]uhrE|\v,K%[r.G__{_?;%aU#J`/4VqzVf(d|wYo EtA++W+uy5ukG_zFd(1wI6Fq]qpU/g\IE5l+4WhV(-Thwo<rygySWb\yCuzr]GHmCk?|9M7YzW__-\5~iGi:chbz>NKzxmU9m?1l?&V2m'1m{(*t%R@NX=wc9.zLi@rFx3
+ZdW<p.p B`#'gvS7dA)X[+MEu/kJ+$R_3B20m:%+nkq}Gb30<~@, A= tqPk!>]J,SM;X[Tsan4r8k/(g{MF%R,T@47LFFUB\$yXB~bf/<L3}<>shS{%Cr0e"oKE|kph:v+AU_7ap6-6W3hgCQzUW^=hs	C4gb<%>Kv!r42.>`+bqHVRxf-,<\CGQCpbO>SOk
+0a9vMCMy3}ZBz<R{SYa8k)]4t\<H'hV*il"(0knEeMJ	~u$+e6BsIQ/PURur&oN$Ar	~Dfs6I|vP(:m,Z`KjM2paJ&Hdz0<_C?q'cRXII\8rLP{xpC~dxmw}E!<* Fh!V\bnSS~Z>Y]#^1/h'>^Fcew2=*bo#E&Qi9E2|K+tGLb{lxDWm^}U,>|>tPdPzpgk} /]!+Dnas0hx>hKxis}VE];[e|]vh?)MAk_N:e*HmciFm)g
+[Go,&mP$j`'sO3ymyw5<qxlxg#a?E~?5k7{p'[uu6mvTv(	~&Ja+6v+xaz-4$Dv[:0H6
+;d.VhmOLlOzPF}A6neLD(s$yvz7u5l5V7o.M\Qw9+EX1qq=dHtGkkDhZ+N<S\:nrhJCGm-<>AQnen|dlGj`Oa)W38j3GSl[+;2m;wB|{Vme,VN?-o-,pD?G{__}X_(?`&,_4l? Gnn~d$TJ(lxU|L{8!sQ0aO g90[*)8z<pg x^hYK
+t?K]zkZ#G)+;{|_qx>iS.32(5h&E$)df'l_Dg.	FD
+<)Ek},/r}Qr#9i?((G)wC__xzMP\MflMTL.YgM9vMIBjR]_0F@f]#YUa#Opdtm_fR/-yDd><Y\rh2;Tc: ^ciAU_x{.5fxcnuW+5z!E+/7_g2?9y<>Fm")R8c"UPbF)W4K(dQ:Z8_)d#U;5cYbkj_Q6+[c8j(WuG.]v]
+:FQIan*X/{t9Yok_S;Wv^zhNz~	,>B+",>E5j#~<2W%O7-x'j
+UGb6*n+/k;~bM}~FW.>r&?`_<}o31yJ(Xp
+8;rXTDJ\X6fO<+2X,KVk,D<}YJ0DtoiLg+>G]ve2d'5*qC3-SbE5G}p`]}'+tQ	c-U{/(YIG;2m	l3m4_qQ;o+Y)"
+hg\d]=v{qqz+qqm6+eu%7x!|ed|g4	K\^\jC1T+;w1^8d.Gm.e )g@R  1gH	U_0R4t^c5eZdv}fJe<b6)=vdHyhpw~m~_vG~a"9@U[%Jl$	:^|qx'-Ii!.|2tazc{<}D'{2$VbZc4@N]"2>F''>1%6>D[^}h<3AM/02+FzB|85[^tM7\ w6RUH20	NXeAiS|J1+oTNCP*_%m'Y62$R|m-:1OmEY$g+"{e+#/@0mUOw}Qu(	ukSNvI2=HKz"[+Rd(EV@C|+JZsOOC\AxR~cbq
+'9{s{XPLe\bk]hk R>d@HM:YGzJRPj	ImM
+-_s3Zx;E+?oAz`FP9[G$C=W++$Vm3xhZgt{+.LoGW|u!cP\l_1+ 8=SfIxJR?<s"Y>ZvjKy+z%bZ6S=o]L&A8"JZ B[Wmz&~qo)_d3m|sY*vhR5s Pea"n\	 8>X	/dh.:R}Af8qV98BM^hkS9H0+,+{dAc~X~;}wc\8^01q.7mC=5vqI8`XXV-a5'?96ooh1VnuS)v#re5~-!NQ3/w-i_l#RvYm6y8Bk1>+n+G"[Ni1G,UxP+lA"X[+aHU3v2&H_$tl^6MiQeH& .2!tc4XNLj8syx%VcO{7V:]^=5BhA=Ft,R5>.8Tx@S5H^/,B,?g,xCj_IBJx#"G-EezO/V[~o}+tM`X_oWlz+7 J{38G7M9nwp++co#FOfM-KuCuUW]3\|m:uk1	bZF" b~k^+=5^W}P%l!F8Y[:ziS9
+I0&Ps0]Z4A@{.+o{mw@f:j^|@{`$X6v#}U51<P1>I-lop+g|x|m@N1\mj8c_o*q:bnoKHj{8|y	p+N3d>(EH>Z5,Q6ib,CmbxyS@bqvx1RrKNE6Vu#:g5/Jh.cTW87Qa+)9b(e8R2`$p/<cp*2N+j&#?6%
+,2(~L6hV8R}ZiS7JS?_R>P/Z[X+Xb"1@q(:?!&a6vJrk]{:,mHm/TAt?g>?S}fF7nK}NC&mgcga|I-+ 7?w7M!???V/LG/YK6%22'XT	/!s,`g[0 8e+|BEjc'j(oCLP9^+s%W >,tW]*`+^W[jk=<[;l8lmsuXIa]U7Pdi8xM+z*)xSN>x&KO\>ma`9g>6G)+
+@m )/r7s+ITP!DrpQD^*'<R	~dm0$(rQErliI"&$4*+tck`E0t[4[+t#6=J#s06rvm_	jj'3u\NF~te[}3pAA9*3v6nC|{sGS_1V)mwz-/IQpe:Ks/G?+9Mr+QaF^(LMEa[}X-/}zpX
+o> Db&n;2,+k{T?R7)X!^^1his5)3S)IH-n6wyT>cT6(D`A'/_<e	lWLmjxi|%F>_x
+}y.>MK:lJ+K\:9HP`1K2=Qjd4},dnU;RO=xQqFj8x%I x9.|<sBkY:vR|f%m~C~.m}}
+(NkC6
+KV@,+0MK[E8k`7~;Z!%uyo'#Mc,M]A!|5BFr#|@z~N LCMXfm`[/	:o(]NN5}@:1;Q/#0:0/=]GzIlT5$ nFt 3Hz} 	k&ia~+k#lQbE[Aco?{zxF*]9_P+lf>pn9>^G@4?X.dOOPl|@[0	4xhqJG-`@"
+JgtNktmcc+hl-GMalO"/62tWY
+K;TNiBK^;d'D#kgjZ59
+Dl)51|~c8WPB=)8Z0>4xo}&qtL/95mrTe>P<7t?&+g]_"|,lQ_rsbZD;L5(=P&|6b`[09C^,=VD@'F7/_2e}?~+!;2bYzK>z'I.z)xIg8&u$tCW1EPHJ:<=g=sq)9mx|X+a#vV1VY+,l>7]G51Xh5=7yG`qy>|W-v]0TT+Vv,N0Y4sSILeDV81\'_`E;@j^1BD(mSC)o{7})pr9-IRIZ1J>IXT&#78@nNCcl\YGG?{acf/RcyS?syQDb8Mo<|G.wq6>~DSSl$^VvBM5\WCG?9n2g^x@04aqNQ>JGB=(\G.O|k	LAba1 k	6?V0'LE(G`+DKf~$6^[\g,uCv9
+F,b'c1f"h1)U&c%D
+PpuG7MPrBb"f>'7"Ad/}@e'l{wq>,W:PoU+UC2w7^&J+ H_B|)C<0rFc	;c|GK_?x/>8vs17|{#cGwUL1x&~L8b4ulPwi{ ,BH Srx@\>ZS|xCbGu9RS~c?c#FA.M|y
+<|Voh??Py+cR?'(-!2Qu(>c<r#G[#*4GxF4z.Jsyl&v#vK7MT~o[Sc'6	?3NFiC;l%k6@wD9t?:HAL6+GB{3<1
+T?x@SiOnR%gKk.J5	z(W9juM{g.3G~*|I2}W+O 1q!'o*sK'@??]yPGOrDeCyYv27XoJr@yr*9(hSeUq"~	v6NPa+E0:f3tW~:^ubiN-=:id^UO	rC1%C>BJWT;mCR(O<;1MWG3}2Lr
+&UNqnQ;^8+2@<\>R;{l1_}W+yX/
+q0J}0_@Xk)9;*@:!Omj1c.C7iDh.-vo|ZUk95=3ZsK*_	zX?1yp {lupa"1I^$"1G6r*Rcb"368saS|e"Lr]*>"!LTE&mHNlC^c*Q65mdu7'f(*iJq,y!["(>!6AD"0
+9@~&
+Vy^\Q_?"0!5nMGz?q\wm]paaoDS7=v77qOXhRh}zeyxe)^mhlDKc!O},vQs5]r&-i@mAYI~(js3J3&6RprUZh?GcfKjzqn\NPMCa*:Xg"vB+OYE;Not90My}JWcG>	IGI5xMX(==dCylz3.N6+1eLujJOWMgZ0#;y{iB}AXNd\Y.q\B?c`[#H	wpW~ygb~g(wn%cxn#jF72Lq.^fd&_RYO!XX$`8=p|Di,.OWBOLB?+vN)C zosn&Fkb?&zo@`	+/pE-J<=MuwX:e4=-9szRxED\sQag9gt^O[cr"|s1GOmC7Exd~>6QJY$Cl_G+[4<Q ,>g|@,.IOoGx
+MAfp~L}yv&:)_my8u]wcy=O\uyGw~;o?pg(~[$d:yf,8n;"F6m#bd`'pL?huVikG+S"B`|#vk."wuO8$vT'?}xun+5=|\;^HI zP;ZFFZ20+\Qx{2X8L;
+A{/
+lNu:b ]:#v'N`s1"E"KB,q9'O3\._=o#Eb>+q`R]bQAE+Z({H+S]>}b?OXdu08e\6_CdDo[^vev}G~,^P+8h[PSvxLo+&v#,?Ne>(">R|6;sM/!L)yc'<O;?!^/w_u~rg.E&R8~|v@:@1eD`5ZL/VO)Oq9|o.!%s&.`:(GsY//wyXCu'{o*}>CrXk}*Nkh4gAA@K]Z>*:T[5y@0JG
+Sb6+7to(mz!34fJ};P];_uapq5/ee[Ajq2sn+q*oz:cji7MA=ruS}pU~'GbP)6s90BZtH]ZZ/Y{]a|@!N:9/:UFmIW+O^(+6T0t&`(F\BCoqF+K+c3DC+5S1kuL0JsRog]O`x\p5f7}wD=Hak GQ0)I&{.o3yrp )1v|2>R+my\<+}*:\eS[@JlS<-0}39o>Fj|p,o{J^r"i&qKs&L+)]E/%?vBm?!-d{+n0+Tg	tr5piDc=8}V|b	W25<}F@8vW%+l!\+%t+~$%KzVLk#fa	*B=0n&Q+tA%t:4"x bSle`,C,PzDtz^3|{V#i||9fn*Gf"^U(:fwx?W:Qoh?b[wpkt5vX*sXqpVW]T_h]ZIUSlyA<vD18CF|+yYA3[g\DJw(1x_,bK,)M7SO(Ehywx,irNV	~M:7Z7:~hg
+L=TeBZ)>bu#r-fb'?|rmSB5Rfl>6}mn9@|D{-m<@(GL2V,0w|A+ud0kok?\zWlGegx3A;Tk6xbWYEulf>7oS>W.8EI}C_\4B'&>K3|`7;MDM#ftSsE G|g~i`UGB6e re_mR\>.N D9H5E#M7'#
+k:'>)OC/sz+R+kpqQ7Hgi@Z]>v>R79'Xxmk(')wCsf9Dz~xGid>>KTwB~lKY87 S2<h\D3KI&2<=SMFC#dM`6xXet [iia..Zqi[e\6&hQF\X,t|3R>	8~s.&pr|>|~a5w}vz`6ctjYtJ#)- S??v_O"GFb-_}o{xn7&&9rO)5L~/!XDaM+VH_9kCR?sy<RFD90`3}MAbZ0H'U}]ixk'Vt8`g^3`]4M:Z[::X&5*	|.)1H9^"p`G~>'}?z_pnV}1q|vO{!Vy6^#`^f)/46JaXH&)}$4HfJ i_(Q<kNW	 
+|_de+W_t"B;x['s=%$2;.^kFSgc`vBx2Ej94Gfl$v8hhkSjB]=b;4e/6,eR8=XQ"u5=65%o~wm{yTv7qtI.SV]xXW#m+c||o;.>3&gB`}B9em1||)*
+p}+i/m#YL94j}{>/Q
+9lbnn6FIdQZf*0CX+yb>R@{`c9h|nz'dx0in#nU!buBh Z{A2y!vP6wk<0AwJQ58h|m|jh`^|jkU/!@K]w65~:g6]vqb`[3{:aER&>PFTOjipi, &(<` .{W]+Go/HW?`+q$%8#vd:FvP$TQj<b<EYe3,-:9UN @C[<rr"z.Ob}iPaA.^sp:	4~_vYeM"@NsOgzy<c;|2kQAK<R8Ec{\weh@riY4ok5+ 9i@-@-hW29WWk#gIUvS7F/(lQ3+ym8U&> ->Eu}Q/F%*Y7skdto}[ogtsAl{[cC<.R6}9Fy<1$P/iq@cl4-m.i&Swe<Y6ZOutAY$}`uWw1&2/y[4p"0~zz&}~G/'&y>_!{o}x]}$F}l^k~W_;S8rN0ETO.H<v';i1B}f#)s,-2TU`S[-p)t!_#j0cW8(F%+%{eL/c0:
+i=~Eb%0VIp+vZ__F!Q|M%g;sDTm5&*6tOI9.0)&K_Zc"Fl\b\8U|,@7CT_;)2m/b4+zplhc)d+c>[Ng=#5g+EE:%|X-h4&z&2<cY+>oug/(AU<r1W	h18npQjcFj/'Bgz>3^dwy'm$f
+k6yb8vB8"`g?L+22@p_9s{7Qvm[D8)}l#g_?{QG
+2z3<BH+`Fd#g,}cf{dpP33+62rz)!GoLZ-;S{a.wN.U-]rp	1>#utn)oyof6I'.b~v7tQX_O4CAve[F{w_:
+?Nf@F!dl[l)d49r+_9'8r^ZIi6i#B|"Ow{B0q+u7-R3vdY+yAHX8sjSW9c };Fve@~0;{Cd\T,f=M7~w~7,VnFO#f&`,5sAu8_RS,8[Dh8,O_-:#*BEO|Nkeyl	"7:Katk1pdtD`sM\hmv|F+:/563{\Xa&L&Lv	RLNp{fL[p\rw4HlX7zIw	d(+kH?-+PPSc+Gqs$GPwZq_4$4O+5v[IF@9Y%)./qbG2N BNonlYS6__
+xJnuF".-	\*1W?@NN%Y3 >`BXCphcpY!(dzscJO{l:z>X-+j0\av+"?uTS`1C/-E63#%qx3 /%c*tQ>=lGITm.#$:_)%=C_5EK3tf ;nC2GX|#y
+h657;WN"Y5xEI7tJ*;ip27()OCYPss9B\dyS'fv9w^.'l 9seWtUmC
+(Cao-k|	q.|ILU	9u5{soH*w^azF)9y#b9698UXxIke}Nf'"`g	N(ezf;o-F|Ih/KWM`j?le(s9OKY!?e'.\?MHg|` 3ib1KbHIp>/^v.s3a")|a]xIISi}eO*Yo"S&9}aG@!^fCAyXae}-(P@xh+W5bOFnJ}[;~Yj(~d<di[pho/P4pGAYWD}6/L7%saW]D~wi|A$O]<xU.hb5^DMW+?=A%a9R*fc!+l I_)Ha[/[Pjm+|dJ6Nmc8\JzCKrVQ|c+tf~@g0X(L@u@b;	2)ICC/BN5qBI=]:Q{3_Rc6rvJZO@yh%Nv'Ej]K>ul_QD?Wuoch*Ugr7st}*MO(77[Ou8+nbYWQ 7}3n{riAL-!vj?yW2OR|"377m=n{o/{hUyeO}5GqcS&?',zB<a\R3jK/-G0,9|k+7@TuMq6m'{qZ\0.2nyE2$4*v
+}.m9bd1.e	&~+n.g7yW7n~`{lwNPRnMo}vi>-}#Kty62o\ -0@;&b];+y_{#<
+%y,{_d/"_W	~-}fN|\L=_5bc2J.	^2DlW-R `h
+qc7a!38Am3'GbwfJxcptrQD1aiHuMm.Z;?68^SnGxzpKctK=lg>QK3v2f'NxXXm59g`FD'C3	Qgy7b:ODRdk.x'(<B){+F74R~13c	V~X|&1o7@)h`(-8(9sO7\G.8`<OZ?,3+y|-v]3(>HNf$JXD!mX4=eUe)K-dToxbKTzB)e{g>]?sjLD<3o~l\.^!G,Nkn '(SfH'isx$6M_litoq7-.>@3k;?zj_OM}G&A~??{u\D7B4qM?*v(T<4+H[o+.8|*7Yagd'|o]Gb?}JKq:aF9-`20Fc\vZ5s#5]_qyF;t}|136sq=K&q@1Gq-&eFi)OD{=V0#=z~
+[Fbm7XL+O/ya+k*HN"ka56zYG:yA3skd-Fr.G*_zbz;3#E?0E4zy.X.kQMsWlw5WoWm]w]^Yo~c98L_q/]K	X}(>cbQR#`}"'@MOd0.ipRw5kTn
+u: <z=`]T:<SE, "?C/CQ
+c%{0+-'7R%d^-MK8D]/a%'_SCs3KaH!B&8AWup7k24xmKCGz}@o|?Og+ee#.'F"~sa4pi%gj	O#Ljb|GDuUkcqN9NiHOWKF}'@@q^2O[I?R>}t
+fF$;$fjC_=xtx@Lz
+4k8mNl{H/
+w"MoCo'=FEF
+bxBUn<<P?HUM0&G6hLpH/ZO-5rR'_?/M=TMa1mG81rCn@A9$]cb0t.E1hI`/>mn4>-	?bo'|D|*x_1FI1&\.5m1_hV1y+(0Z]	#TO4Z{bN=(cJ*\Zp\){mKt0l>U:C4x[++RKX*Wft&=U>m|}`WDTlz9O{-<?|_J?_I'k'Z,drm+n\NpR{0b~N#X~2>5i|_m|`T6N{)p0n`r?ic{0+Sqr=t;{ko`jX	C`3bd]{a+c-kbS[WmdUiXzgRBoI+4Ob"?P`|w~P|o/|KM!#}[E"g$ )c"f$ @e$W15?-&w[&*8W@Tv>1EMqUW9!76W^}Uv
+@q[<98VJb9"iFMO\?|t;-<S&Vomk!6(`+:L%e~(k9V,WHijuA_UDr5/e*B4Zq?{"tq<]+1Y~T'X'mPy1B-_i4X4a2><"+sr~3}[:c;hj8TfK&W:NJtNk/p$@yn<hw;rQiF'
+Tz?I4+#RDxbOCG`'Xa9/865]:6s'td&}a`q~6s`w<{;:o[?`sXGGnOsHn.PK;@s}I>s<(=LzZB_NY/IxlL@m}xU{^!kcx3M#+.2#lV.wq%hW	<^,s}o{=4
+^xu$t/DL5"91{1t \u;cr	Wc0u.KK]o7ZllY{N."%\ G/-{`2sNamG(SOK{Ov$HOx}yIqRhZigsbq'5+_s/j77pM/lx5xRe+b$k5nu+Z?8Q#YB,^ P{a.88g>+	)r~O-$r6Q>&254/B5cY>(	+4KNN1mH&,,K>L<6U|*vc":a+<0uHK+zpR}q0@aV
+u8k*&u}EfvOB_BW][Sx([G:?w{m?ou]0$8g}.vXBeeq+2&ELgYJ?P][e9iZ:+};zFaG~{Uc<;unie+|o~]}Fz"2G)p~~>.cxx/go?n?yj_B[lV"|~jt )aGs'+9YL6k8		?R	D	?}|mp]Z9zekrIrzkzF^}F,<,Hm\O&kb
+{P3@05m.~!9@Vvw-;EjUs"c~?'C b?!"> Dckty?z,`!y1Llchp~7#H:7'8];rM@"5b_~^4~nN"xd::Qc_?ya[+)<;
+t7)+O!Jm31;	kie&^d!F#7^>HG:.:~^M++]pS[>4xb;_D+8|T(kL;5}4*meHJkuFPG9kMpjt (
+uoa8a.x+Oo]~m|Fy%|qM>@n;"K^?xNZH6|e<vi>;Wp1~|5Me-bj!Rn!Y>]!t2yZl*U1BC[0yP@ +f0As}WlH_8K4[,^MyvI.^)o|5pW>xC<4w\@+vR]yq'%k>`nD_>,;wR+Hd,[p8M=9ao~0wNPlW_{mnc+a4(:b>s=I2"?yMg>&2r%G\/Z-(|
+pf_r"x?6!F&_m&Xv3~sw{>#*:XFUxRDerH[r!9g,NmX+p]T7!|I\4\5_q<4nx@(iYBf}kv3Wv,y$7y?i>7oL7u='~/+u#mP\L*Rh'mju2O0Wj;]SejYp>jLv+i][4s	tW>j_i>mw+@|.iTo#{Ee o=)4'x`@4<|n?oO"e"
+Tq7}Lg^TcU'\T8G6]>SqL/>I_::3+<h61FQ'R}8d3e^!4wDG+aj
+H_ct=4V!H3?8bju9I\25'Rf,"`v#>rYc`uc<4x}9`@-v?+>jn^k#<|R4G=Z|rO+$|,Np5/8<K'Zyu:TH{Fv {[`)Kl}X^s1tq@UKqT7[+6A(Y*1nNAohIN`NMW&=jhVG.Dv:<0Qv^})p0,7w+58gXl1gC0XDD +0	25nt]
+ze.A+TO^1AS4f7-+rGpCt']9l#9je[YgU+O+r+9M"30Rh,&
+WCdoaU#D\K_Y(buc|?LjFO}`\Kz-Q4+[
+ U7w'OX}aW=co,8[s-9P{7h-ij3@@M}ALtYiN][Av#^r"d/Z.!a.Q"qiX	*<s(2%|?e[Gim'N}e_B~"CZsGA<x+5CbXz!M&Z+cf=9Hs(+BBU'n.x.HHJBLc;ms<lIdu>9&YygzZR+'6uGEAfob_mw.";r_>`;Qy%YT=OdF.-k$&z:][EU36e,tH|T%;{q.p$+l|/iD9j+Mp=_	3 0=Ylv\#a=|U%j{&1`EGFn%/sLB$LASG7z[b C^;AJb.*^k^	h@
+'o^WC8RH}o5=zW+s:kk!q'3d	Z"?+<O/-nicSIPwo_s'td{w|pe-t|6WK=G '@\u@"eBN?2|k0MBY7`BWW	Y#aZWjAj~S"rvmgbF613vtH?O8"WMv)]O-HwRF6+fL6'SG!ZKAW4Z!LK+0$%bf<	bs!8d^J^l&imF_Tv0@+(c5?B^Tg+Lb:OS9++>+VgOqvgKr;ihf$f|F_%/okclx`>= xYdg1ROo^rmXb4k\Hi0:Fj=f3rv'	"k{:%>@T'F6)99LO
+@5xjDxes_;Bd?=Q-:Jl~`*:1J @Z#dh\\~'+#0Y?\}zxg	T6||d=#M(t<J|wmhQ/YRN0^yYZeA6Ra<N2IY^+^Ij("#R kHpEX3$[4}`uP0`|?l30/yG#Gx~T8Qlh+%}RMm-.I.]?tv]g7={c,8-8!xm " /~ ZyYc70E]) 6ymR8}0A&Z}nQZ+Q0IvD,?e1Vl`ecZ9WdAt=/JN[wlhtGJjgOb`nS/:B7H4sM+"B*E3SMbmT%6/((Um;vN?qm$lcI9+ISIvv+^+o
+;E/1Ol(r^DAjhK)neFPM-luC!Ry)+>x%baSX`"Y<R%rmQ)(+Zbp+J0-Aoq+5af\Zz2/-2I+)G%-2FU->q1mB(Pfv0F!* WJgZ%8kZdX0k,+5mEu>H477W@D1">>\rnI,D+de}_3ghEcG?48fW<<(FGBG0}GfL=`7fu,<_Z2!WmJ:_}"H{U%ne23*Z!\,a<@q6oWGXizcj=n(y\2IIzz?6+I2u	]DU[U(Y{KJyO=uy] )_`\4;n^N_Y_FMMK6?mCi(jD&r&Ad[!VTyY;j`nLaB ~+	G6+>+fAT/E.8heyAh\F+
+I<mv= a+`b/K_v*%esEt@@6U4.lse&>PVh[b]/:bmrg=nV*>BtESJgs
+ It_C?@uG+vS60hYq1c\E_\]c=leG"?UtmC.'d"R3v+Mf}824aZ:VG+:?.
+PycGOu+M~`4Ips<yW<	paJG\Avd B}&CKm|SRcx(c?3z{GxSF?o~gOG\nrqeju0Q3POxEm0)SL:VlR/Q}K1L3d;,9doVN8?)%ed|:L9}$rq/L38
+hUoEN^u!6E:ZaVU8uny?~ze[x(9pvM5hY}@
+
+z{o"vFm{XC2eU?[hD&q$5zqFOcmLDOm&TS-cS69;;v(sE-hcgRni8Wac`]tZ%#2;uP.;Q%9P8"\g+C1$r;bqK_r3t%_u}RC']AR-fRr>HC:q:
+]AFZ.E>Ex
+Gb}p	na('Mz]J]/Jv~hkJip[jn+"} dgBm%V8U0(GA\	9$pdoJE&e)1D7YpJBvnQ=m.a_5(u1	ca?F&%98,ZJ+Boi06md!^1/BqulyuIg5tr])<r8M'r^ga	1%~pAz2F2iY,zmpH;Xhapv+2n7>B3R^Y?#z@90ea{Mw.lP1Ltqgpl`Qr#[M~QqtrcU2eM1=Vr[vh!k}?d*4o6?,:x__}U/mJ`QtvC< yU2l3YOL R}v	+Ik^>4=c6":"6WoIgsONW\z n
+`l@aOSiL{-XUS/$60(E/SciE{6*sM'Z $|7mX9.O7yu}DJ^2X\5EP./m>O?~R\@S>C{;vL[kJv6wc!W+Guf/UoK_6{z&lT4\h?]z?|o+ .9T!k/5V1`+rd|i+9`D9[H_qik
+^A{O:~_h0?mb`4	]-v}YWG%%MB!S+ K+_C}=n{)tiZYqv]6_5L7~V7=2(Gc9:G)RN?zpk^71PZ2YD8C,\D`H'}KVO|`OiG79=%_8m]*.=	:m],U=Hh-%-J)2V}=GTHUp	j7|t`%G-M;NWpx+d.)Vx-{&}rX^amGu98s1&?1?+!+V7+icR`%[kY*0G<Fy/+]%&k\1N`1s5f;G?_k+m!lfS!~fy-K^t2_n\91!jV5P:K}GqZZ`WzHr'vZE/3	tkg$
+b2vq)`$SQglsX"-mVRiK!lyx!n.+Rzw0[X<_`spT-?2tC}q=U:-cyd<?D&\n7iR(L+j2-e7^u,]]:>A=[cU<@J;jATp	F(1<TPvpTv7gmdY2/lJx9Zs2sXo'tsbU+x7zAUiA
+w"@iNghSbCclNkMngW5IQM1Wn|V1){5kSx8O+_>\{9bV>K0&~T<A	z"\gH6b;OK W|/cze!X	~#Iwr7g+O!0U"]&<YT=eW {{NG>HU"}C\oFNHgV;[U_?FYxEo|u;xJ">EbtetmkMe=k9|T{}Kk^#c?Tq`w{-}%6(-oL 6I;/*d(BG6|m`lbb"+Hsg:}1!Gl:G:3&uJ.RD$	dV[Q?"$E3Px9Rq>-![>|,MWA#c\E)=tpN	f/?J%go}Nf6@(X`6dX
+-S &MDomzFOg|SdT"eWmcO0MRn YL(>D'%de8h8~_&!R:3^-c';w	5__YRL]7xCR+pP~V8mlFDoeR?~=K/`u#'w6"nZl~f]L'4OGyD@)0^TDczI
+3P;HApGEnM/sD`
+?m3qyB+ae{f :)Xw\3r"6LjeD^CoQ=<Gq[L&,eu=a78E1-	9HF&}MN
+o=:o}<@s1,+m0	*3%|*:O|^KWg_ZWr-/eNxXX+}.?#5	NI;6qy~vS5Q`{
+j?Sf8,o}`^d:@[N"BBLl#Wx.dx9 1)(b/NE89q+2efE'tVr0+=LdI<LQ7nY?M|<UHXYu}W\'}w~sS)kD8Q/Nwv5alZb:Um8Sidci\muZIlB
+:ue"2W+Rzbn'lHNkLS]8'AA!u?Od+w~.%Rc'_=7r>}b	)@]R{l< /G[g$+g#<K=Z4+%+S?e{L
+q^\r~CCWUDqlMH}\/9z2!}mmia1f+?g5ifr	e"&.IO:LR)qQg O#YvE|1nPwB{DX2>O[z+kr-`1%p-\qW <p .{
+}]ZF$9A:}+}i-q68h*;kUW/2+>+J	cs&S~RKr<RA7:	xAO	Zz?xG.P1D+u|_?)ir;p[ek^bu?,C<+<;t+@'}6!{<+^3u8j"vgYtu0:s 8gg5[NvM}5`E"q>OMy|@3pml'}WH|x.ggr &487gF%-c\fRoe[y>pD-$a->t#w'opquO}zu PCX@$O'ua~oz?2}K_;&:X?h+Xp 4ma9`hw}uJpjT9OY}+rv+CEm,`pm~(T-hc!%=h#^^&#I8}$?sOU7]%.~{UWmyk^4
+	lP))q!8rm
+yK6Efo=bX[|c)Yte9Qw|c>2=}8^@y~`t{&{^c&6xB]72Y+oKsY+\Myp\cx1}psW4hK_{^1w"9g51`HPG]811.}LS)v	8;;vOL<=vT>+0|[DEm^{O[N+Z2}i:syGDV@pn7nEh[\S#1pxW5zaP+E@N2)^e}f;X'q%NEsTYSeEB @A?&c]3x"]7<C6qNngoC7E*a)DNA83]wTdk pmwEqG<JW?)?&_cb3&tt A?oy~oc>{5|q|n^uw\-)/+HRys1yYx{koa	|AL(y8G8
+X2n$d]a%/W;?s%?3wgN{0^&M/5\}2x9+M>Ea,$y+t0SY2c3jv+ij_S!d@T<`bO7m>bQY6Z83x@)]yQ+0&U-%U]\u[O&%o??odO+A9dI D!wJ@&Ma>XEd}|_{I# uMV|40M#~x7=u?s4?'f{i]dLyH}aK
+!4Yeh'?Lq)A$w5{l+htx,W,[0`$m!dH89{zOGCh<%Mb	/2MrA3DnM#S^v,~$@6bI_lkVqUm^R&qmVZ)kI;nDm+'v+g&KP
+.7Z<97@,'~Iw7+;myU"OeSE3BVyOIpsl|lgKh4A4]@`|	2-G?I77^xWu'#2!D-d[LD*!'Xc37U"cNz+MmW4.*~+0hn=+o.?G*Um?LHg=`|@,v,194c(F:	//R*kPFxe?V{|=T$wBN%H	}.ogb_DloV[S$M__Hv1[7UmW>//l
+P6S[(j	/FC;gxb7`;\3NH@9^p&#oXf_zYq%1uyWuH)HI*LSaAM$Gb"+y!z~27Fs3ixtA48h.8Om;v)+,?{D[W]X}w_)6#^]U1i$FC;O)[
+"S[Ow=+kD[>vkwL++"lSq:1t8DcP^"/Ae9JoZtnB)K:l!l
+U9kS/XE3"Nud^7_dS$\jzW\,/,daI0)7~&4L"a9`'+xyomI ~S'XK;z+&bH?hAyvByIncdld\>B{|T}XA	iluaPhy!~cA3\w~^Z7<g;"xs_J@E3`+V,*R*moYaB	GG6Sd]nIWgEG&t)?gc1``4ncA.y/4] `-.!g-[~G(7E(*9U/G\Qt'y1@tYIXNMz.S1P8#x.uvIAPowe.' h)]{(fm[mkV,2y93piR)P3!>_Li ES%<fc&HcLK+PxfUjL![D#|FnNu?Bl91Gxvx'HW#u)V*W%Cw	>@#_z6=wa4|G`B4XolsVd&1Gs_y[}-tMY*
+y,/5
+MELvY))el-aBk%6y(oq>QulOapP$dP$`u"%J%}Y?'}|o<L6?,=k]hWs?wpzl
++10guyViMzisGq]XXds34N@%_7E!1"ybPkiFa:&\!*C|?}+'mrGTON+=RI_V}&/xAXi4#OS11jJkukM\ROu)"[i`t22r|U<]lYqp~`{.n
+Iy>R.ETLrj^.^(>\)m/E'Ys*]+,.w=bqc"<E|E28/DN?W]U,[qZ]\JPytMyi7Wt^JwKX=_q5,o/zMg1pE#9PiB] g'N6|\21`EZbgNG
+N46:?sLkmW/31xn?|~}73xMv72R?'~pq?	?UW^Qn+F<nx|~zD0y'zgrSB 5r
+M^-Z5oi^=OyA{K/8m?~ nhb]3:Fd&H+!VT;X+0*(i-_F1_8!VM&VjdPw~'w}7q}.vYC'C"yOinT+#d['KZEbQ^pq\	!O{WclO!ep_>+o}zm.nvn/s{q>xio{4Y{!iL>%T3ibYv*1_G1S5Y0ekm
+h.~~R!XcFO YFeE|0?vLoL;YZDVkP*-qLhO}tL!5tIw}/Kw	[ ,#zesz	Csb pyn"]c1N+DRU~){E+E8*H
+yfCC0e#>WHI{3};4wC60+YIN)vS|7MRnS(I'mvI)RK_6lje@JGR52G<==o{o	@V9%ttpAmWMXQvKqMm 1jrLLT%|fP~b0~Rf6Pw4!1'FezZ>JK0*3+.Q ?A3y]FcQ.U?38dUrb26+'F~&M
+!AZGg>7xs|i?!$hx=%D[Pg[Y>BD/aM#-eH|BDIpDVR|h-\c p?TqepuP+<,t/?O	,o~FqEjA6r$APWyI#>3^
+u$){IO`E68K,!U3%4LJI7 1?';jg}M=r_/}}jU_b:.OROV_Ze|g%eF{['zNF3u]tM=|~	3+0M:,;*n0!n)IVIIouEiM#+O=XvV0?]OfE7|~0\6>3CO>L	UUl'rjq46K:?:Ql:WHXDSzH(Mp>%H0DHM<**v<Xd>A-^/+%w05\-G}A|;xbNo}&UL>-.m%K.76zpS?ssr~QKkuP+!Mm#&-z>hqK/wA}a'v]zoh;o&p)y_/9]F3ydOb"GG'?gyD-Z&=Q+H[@kzAyP!&$CcQ4lJ>n)8wh-QpI_' q-+A+!*~O,ZxoiQP^+K,6[AV qu(?Iw{10a|}hlP7j h	#-_U*BWnxO}G)Z1?Cx_{-Z	X36p+\wnDY^efl^t@@*
+uj*vX
+QI&p[f)RR^"l
+(g!,q!d.M+&Y~|u7){s+~'SO9>u*8.vnT	xM_RU?X}YTORL>hI6-Aq]I#GuoS0qp7/D>$g=0nGB3OQFFA8a=XI:PK);P!? SH<`	&@!M^2,c2S6IDZ) >eww2mZ~s	l>>M+q@kIgO\[n{u.S`SP{+, &7Bf&FAcAe	-`"MT(&"M~d' hN(hyPYBDK&H'/,]l|uS//ynia|bYbHD- <5gMKzyp=O>S80g*1U	&EA*$-!^)(hyPYBDK&HK|:7\#t99<(g^xQ1qVuo6JC{[2qkR5ul3_Y-7+q$")Y@kjcr/_O/rZKdL$H4}&y1It[ Kqsk]|Wxlm +F7GY3-z3w}uAKHa%Sd|O#~lDXZ?-nq`.;k4= Q	I6%XSs_g&IW2"& Mq*Nyo\4	:1hz;]g#0\7+[ANU]I~vbR Ci7K{	wt Xu{TSnhwx(ia8ysT!Z	Y1?	=8ysSy>B/rIkse>zbbZ?i,ic~=M&\:b)S}5Ci#mOqp}qzGGEYng!%qL06+N8J8W>^ccxGB^vd5g(nF4_s?O~?)E=M9m?>x	n +v	jm[CcB;qwnB!38iy_%l
+[6Q[n'~JMP\#Pe\F%}7{8}kx727!v_:h!<f@1U}|]"\w/^	h]gN-^f?t^@)@{5Vuk,jk?s{T8Uh.0-=/*-\2`7l(~|=xC=qPr$Ywg;{_1}kjL+V^N?t%dSc8`9IA%*auqwv)sTTw_s5
+7+']1n" H/++Rua5Yi3CrQ99`p0] {7F
+zx WL>7NrYB)(G-m8xcFKjRVBj&/Y_~kOp_WHgdx|+c~~34|~+1{g6]Rf+Ms)L-1<hl(e2OOfv@/z"90q^'3]"Z\[E$=|/j\ ej
+E3^;pC ~@_(prUbWk9ooaN32/_WXyD
+*&kw)0C}>kSi{~G>N7Az>?O"#qz)h5/	5/yg^T
+J;vVe}ib['/*C	#$gA Mu	S0DtX?f0L-Ygp)~&0F<]\w3gvWeYx_@t:QsD3|o+\@j$M	:FN)uS']<f;-{p<[ t-M
+%)t02rTE zg
+\_.V>2o3ys]w[uW"odkm1uuW}fUQ;kKZ?&9owIt	+,#_yTwmb|W3=++;uPR<\	 Rw.|>i
+ASA`(IMO:*"VV'_eO{>#_B:s[*}wnc.*8<;+9{5n<=D%=o\cU.]V%o82!~[?O/j.$Nm'y"|~*?.|':b#,auc}DA]	v ^ ooc'd:+GJn_g]oU/8`}c/!tg7+ij4iO{_~_tE'@74ee+}./;NLW)"eiW#xr*#2W=k*^9o??|o|+"PhYd)b9ROl'_Bw"2S74~-H		#Qg3 Mi&?h^v+P8ap(0S%K|i.[0[Yf?K/t0K>t1(Mx;;7Cu_iqGKzF{z4a(7y	tMdKQ'O@$9;geEU\XSZ6hDs.(d!CF<Zn:3\?g6l/_0_PAm+Fxr<>#k&ezX=_*f`{q"!7Odi{AD$s[BKW~{_s-3pXDst	'<m}7x#r}o+PGU;IN)!}AAKQq~;O}u|iM9 pTZ#H^]+p+MwW.KcW"+Ly&0|;m@&qRHU~FP0KRG	u.pa"Iqr0l!@PZ*'kG^Sc{|nMz~PJ^gWL~1SA~aX#O~GbE^g1-EfTh6+1Dk4<N'\ji zDeDuY;W\&j0FI@hA9cf$>hfMW4G\S*)m)-?L$'zevBY-7_I>VKYEkPx-yj_'8~'K_? 8b	v(n+O>y]"rt\d&m+Yu]gT=.M7P	{8< _*r!'+91	xWAGJlc!&~Vx;bA40^ciMN&hbpjFn`)|k|-s6A))</q>Pr+m23aKB^1xHSzzIAb2T	"OO!23!??C=#iu]_tz-JG<[zoGz3<sU2m -^p&C|Fl&iK</\YekQ7}`d9%Lp(!# P{^w?XaP?rS}n_?<E_P+M7}m6kb!o+7-
+6Th7.B=#Iuae!7.D[l'>@YB$J=?vbn`b>$/W0r[Fe?z|J;4}_W&SRlrGGr8"+-UQ4pS$$	.zi ?VaC*8N"?u)FE8`[L?K9Se{rO%$#RuLik1"]=4s +vE	E_=Q"a	Qu8Zg&H5z)aPl 
+vq+2tc8$]V>1g2pAalpJ/^6'N&4F|G8_L39>Sf$V/#eWf{mE)LLAb,Ba"pb"`[[xdZi{Yr+_f!Ctm34Vxr<j}k~\vJag6[u10es`dkJxq.yst{0dHb.m#3%:$(=I95	)7#FDQ+JyuY_;wz42LCG'l3=i0CT,R@W0`++q!`C=hUICbH)bb5	nGVU4Y5x}4<`xkV~B<_|r&T+qh?;woE]":<xf?+H>81a"}7>YxL7kWc{oG"yw.x_^wuG^7x!E'p&~b)'N	4y`QOh
+	wnc18e:CANw!/x|X+t6mt[	gW<O7@FZ'a]om&C?1fDcGD w7>N[] e[9)41cXT'#0:{&v#\	}Z%wOXl&4`b$9i`Wf<1=/U|yh|6o`r<+kPtf^k;{ARSlRml?\=0?+m#}6}[n$eL33[;_^U;ArjshGVZ:eU'Mozv3vV)=+S{Kx5bx	MN*oq;~o>>*oRLRZ]]Sw}S_x~Q
+66Nu6vc25v.:yN(k| 8mI>0y~@N'	]Lk/}gzK'toM	:LJ3&]??C+Kw4pkp/g??$}r1*2{}-oS^[g1\&p5i-"U9rcp$eDX+	&2}/1.+(!~*xY&0X.+Ft.|otFn}RTOl}+
+ddo?uat
+~H9}{rUym$"#	'(=(;	 +xo"1U'+#<x/JyS}C:-oyesY'}eO@Ga	 849b+@cg@zLq	wfzOw]S*o[2m;w|n%?/6RNL:qoi~XFs,nwAY^*+jW\q	yg|
+MW}?EBO
+e
+>*3WM.};aSIrxXpLOv2sI,Z;tY22=87o|7|o9TGBIuIk,bOD3z9Y@y54b;x|Ts9{{{n`'`[,Lo+9$!ICF:v05dA1,8\}g2lB1{,&ac]OO; ^IL#
+;<m}k_,?<<|P^7p==>81V
+h+#dd;m,Ek;ii!C d~1T@cKW]z9R*k _ h%uZN>c:O2?numYl}Ra2=}$|$R@'whZOZc"Z#P+CB<;yqQK-#+.t%2d'q&+6.KXR:_\/[Lo|;zO<w}%o7/lnM[b7+(xdD$Kyb+O%j+|2cyM@ZcKwH09xNt~GZcK/+.+X	B,UY6l'O,@'@#?+T~<-\dWn^Nwv/3GCRH9
+n%K&Wax6y?bHS#p"I#0"E[:Cb|r+e4+?k.0%WfN")x3O2~ 8$I{P
+pB'ePJb/p`3!yaI%wx$v$y$|EI*K_y[GG@O@'qo#'-M^c-eyh{Kb*;,FC$nS9{hr`+mC1u[[Q=mSuIw8)dtRF=%'2	3AiatAnc+Zu5)+i}Oy;I%M?XIvM	h(rbtqhR8OK
+)"_
+<rEX,>OF]cMX2+M[*2h"(?be/'_)u*m;x&\=IL+:X>	{jlk"%hkQOytUaM IG SEfm,g:ikV^n wxr"p&]W;RNdZuezm[D/tn@tkx&l<]A,1Ulh[WIE6y<9Tgx
+"I)Wy<&UnVIJG#P@nG#p#1nUIKrG#vxo<m#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#x<G#B?p;OH
\ No newline at end of file
added in remote
  their  100644 84970c7172887f460750705de8fc06ca7eea4a5b electron/browser/resources/win/atom.manifest
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+
+  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
+    <application>
+      <!-- Windows 10 -->
+      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
+      <!-- Windows 8.1 -->
+      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
+      <!-- Windows 8 -->
+      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
+      <!-- Windows 7 -->
+      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
+      <!-- Windows Vista -->
+      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
+    </application>
+  </compatibility>
+
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type="Win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
+    </dependentAssembly>
+  </dependency>
+
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
+    <security>
+      <requestedPrivileges>
+        <requestedExecutionLevel level="asInvoker" />
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+
+</assembly>
added in remote
  their  100644 ada12bf324ad1dc48e8a040da0f7309841f55f59 electron/browser/resources/win/atom.rc
@@ -0,0 +1,139 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "grit\\ui_unscaled_resources.h"
+#include "resource.h"
+#include <winresrc.h>
+#ifdef IDC_STATIC
+#undef IDC_STATIC
+#endif
+#define IDC_STATIC (-1)
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "windows.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (United States) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE
+BEGIN
+    "#include ""windows.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 0,37,3,0
+ PRODUCTVERSION 0,37,3,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x1L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "CompanyName", "GitHub, Inc."
+            VALUE "FileDescription", "Electron"
+            VALUE "FileVersion", "0.37.3"
+            VALUE "InternalName", "electron.exe"
+            VALUE "LegalCopyright", "Copyright (C) 2015 GitHub, Inc. All rights reserved."
+            VALUE "OriginalFilename", "electron.exe"
+            VALUE "ProductName", "Electron"
+            VALUE "ProductVersion", "0.37.3"
+            VALUE "SquirrelAwareVersion", "1"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (United States) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Icon
+//
+
+IDR_MAINFRAME           ICON                    "electron.ico"
+/////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Cursors
+//
+IDC_ALIAS          CURSOR             "ui\\resources\\cursors\\aliasb.cur"
+IDC_CELL           CURSOR             "ui\\resources\\cursors\\cell.cur"
+IDC_COLRESIZE      CURSOR             "ui\\resources\\cursors\\col_resize.cur"
+IDC_COPYCUR        CURSOR             "ui\\resources\\cursors\\copy.cur"
+IDC_CURSOR_NONE    CURSOR             "ui\\resources\\cursors\\none.cur"
+IDC_HAND_GRAB      CURSOR             "ui\\resources\\cursors\\hand_grab.cur"
+IDC_HAND_GRABBING  CURSOR             "ui\\resources\\cursors\\hand_grabbing.cur"
+IDC_PAN_EAST       CURSOR             "ui\\resources\\cursors\\pan_east.cur"
+IDC_PAN_MIDDLE     CURSOR             "ui\\resources\\cursors\\pan_middle.cur"
+IDC_PAN_NORTH      CURSOR             "ui\\resources\\cursors\\pan_north.cur"
+IDC_PAN_NORTH_EAST CURSOR             "ui\\resources\\cursors\\pan_north_east.cur"
+IDC_PAN_NORTH_WEST CURSOR             "ui\\resources\\cursors\\pan_north_west.cur"
+IDC_PAN_SOUTH      CURSOR             "ui\\resources\\cursors\\pan_south.cur"
+IDC_PAN_SOUTH_EAST CURSOR             "ui\\resources\\cursors\\pan_south_east.cur"
+IDC_PAN_SOUTH_WEST CURSOR             "ui\\resources\\cursors\\pan_south_west.cur"
+IDC_PAN_WEST       CURSOR             "ui\\resources\\cursors\\pan_west.cur"
+IDC_ROWRESIZE      CURSOR             "ui\\resources\\cursors\\row_resize.cur"
+IDC_VERTICALTEXT   CURSOR             "ui\\resources\\cursors\\vertical_text.cur"
+IDC_ZOOMIN         CURSOR             "ui\\resources\\cursors\\zoom_in.cur"
+IDC_ZOOMOUT        CURSOR             "ui\\resources\\cursors\\zoom_out.cur"
+/////////////////////////////////////////////////////////////////////////////
added in remote
  their  100644 aa09177554651fb38078881c4dd73f7d1d17ae7f electron/browser/resources/win/electron.ico
@@ -0,0 +1,250 @@
++||
++[|InbOyDxD|FUk
++
++WWc.Q[5}	K,9a)D:jp79M^ewF7?#ek$	r&MpWOGwy777O;cO>}cY:.-J/)jpo}o?}W	B.Jy.)W#OOs:7O4L-ObRx8}7zc}6lS_&D"wsCe@(^TS:~<?3fE3YGQX8hbVYn??[H5l%y%	b5u_N;s~d6H29{;-~2<v+4\?M_>-C@QQ{)q[n	|\^D]t+-k*Wyg/^QF-i`_?Xy/?t+W'>}+_	5`BP:@M+WhUoVKI[nNC@P,\s5uYf7`7"vqXQ7DapYR0^Sk\eucwy=DLx!"X7wq}.N,L
+hJ&PDCiCi(w7nM`|UWOmwp`*GNL{4vi+0S	7%`CBRD3L<(e=8E#de=&Gk";mE$-PJ=@?{B+GN:P+aFZxQ9&}{MKH:`+s.+%boNDYPP!pfJIf*Ypi'?yCk;$zm8{@(K+]
+
+>FU)W2T`|SAQ/]=%!=P&^xT@9j6"i71L=awDmE|R!~8'<0FN9%?)34[<*th:OjN%o%oh?`]<GZC@G2+jS,aA!mU#6+tJ%~gzpJUtMGldxfce3QAt#9D24sYq#UAQOAC
+f%:`-/aWX	y5^H}EM<+vDT+&V?YfX3U}t|R9=@_lB
+/+p5+Xu+SW #KT<FN])BudO.Hkz1lm		_+!|e}j~xF};Y[:[}?&D`,N}o3Op-Wi_  #"8\@'Xk H`99#y,%J_,[y\CHH9acQE	}'95K^d$?a~hS#x)uF0je}zu-f}uZ	XAx&wk-j]p[o/&NxO.9**83+oe6]h A^*I>h!"z_bB}ud`nQ1r:^U-`>uaQq	36$9a_m5pv#{[%$D%
++0%K~uTkj}}Uqjz]vq@`CP!A2I
+K%r}"W	;<DQ	6cd!r,O@v+z%:7/KP)[`@%]JS*
+=|
+"U=xt]U?FL
+@1ZT<:TW`9OOe<I6Y?C$%GPTUIv$`Rm@4	rab/8L0R0^wxX
++
+<YHV6E&	H1"H6D9[mVYfJ7P)6X>vH>)_`n
+nr?}y7:~:"
+%eBJFZ-; Vt=mi#VU.VqY68tu]KPQ[Z}7>y_Df2q,P_$2ylHDo-^6e[X6<-@4%L]6bP"Q6jVCU.fUm3mG^&9\g(?~6Qf*HvbGL+hZ;\Eoler2I
+4W1KQvXr9_}g~@-  %qG/X'{E@LED-a*CIcYW-AxOD:K+=P*D"	,I8	&>t
+i-eWTSSfM|%.3J{d]4&4y&0K%aI5guTv e0^o+Y9l:c@>F LKYm_
+_
+*!G{t !PC	(2;g3ik'I#PJ"o*kQ)BYjeRS3*hDq{R(X,)R?~1X;U,_j?V2Z!/U9i'6MF6N++lg\5+/mF"DY\Fn'3$!o_m."a	gsi~-JJ2PcPIk.WXBtX2!!!/E\  7e)t9\A2pBVP/Ixx<\'&i5y,YY/4;vj+>I+:Coa;cXP/6VEk;%7uQZWfS)(8oUUMWUe9+WI&]X7Ov]#Me``:qE	F`xn$!Lfd^%jLLY]r '}vbS4\wnIjZrmo:35l'7U_S*
+79D8A7X)k,Q8z1A !QVEX&:eF2vu;]n$+j+\S 2DLs=+)
+U	G@O:QF],dokA!"H5Dn7IXkY%;Gp-nv#s/J\9bDd<_fqC=yXvk T<!*L]TP`FQp'b>*JFdhB=%OI>3g]ve|a	ZdW;c=tuW|cdm+vaNG(8eROz7#0EoAd^7|zmr/;	74joAb#Fhf;eLh@7l1aH:r	G1++!l+Oh("jB}s2`y|?n)'vkxT^A'WP~W4>nfo<V&[ ..;Kg~D^Gm#r"T0@ 
+J%5LP
+
+"JTl%LLr\U+0t95m%}ims=7m+%4,5V4*v*~$S	(n,	aM5r~G5[US'+@#W\>}rN3lS'.{@t%QPtlQ{+NEE-,j>d}g;ms0Xr'"U?l	h/Aq;20<n2,~vw(WFp=CXqDm+Fu7q#++Ja;a~t|3Wj0t[Fx?sRk#SYx+h=zfW}>SO)-W@1\3+G&lSb|a_I+IzD<,)F.[w'X#FXm oC%"<6&--"*Z^T (SC 6$C9.cYy2]Xea|$oov9WHJ9.9ef?Htq7yUN7~1~R^WEn{rEE5ZzXY@]AihLp]cJg8)Pj=l]z.,="|ngb)G1n>zebA0^J+IIew0Voa-mDDc~f!tSVcC^/
+J:0NG>?
+p!9.:N?y=] k,I<`< ",?'@!=U@4h'p(P!i';8a)Z,70WO,]}U.#)Qr^s=[Q/EMO%Mi.(hqz(RQ5O>y[.lV
+H"OEP~S!)Qe+:z")LcdtKd"+K"~	H\w5#GK{UW7#J>^oLNSN)NC+%`yeI="m_
+(DBryf
+t"4BZ'i?	te%3q7VGWKqoxbOp
+[pm+Hw0C`8r"Pujj<g(T+#U&d.-Chb1LuW^U'-3J#V+*#RO+/[d
+d	Bm2`~]+pD03$	
+r*|s\.+JQ>V8x'*,9$ov`i	=-4Ojr+xXZ<Ej,yLF^MJ*|z4J#UCKM65e&zqV9lp\8PIEEkO<v,rS"2$%>>j*+2l{4=9[^oafmbU];Q>ZfO:uFjP02DXDhTFi<;GI Uh'~Ey4|2*Sfv4mOGXv&z`6~!BGb-m9OMGOb8p
+a^;[T=09X	"r`|U!My9AI/>L'?L5+FB @+Y'yzWTnuk
+:0Ze	`CD&TrH+HvhzJGAn7zIH*,i)w*JU`uqgh%8=SGJ.<_oteL^sC+uM2l(Y<}~fl0yt}Co
+G[!S:F}h	~R{+^9o2)v|dl]h)o!B6;e~VE@0 I.Ip$#4'OuvN+tgx?z
+bJ%9nf>5u.pEH]+)xv=JC_74^Xl"|wGO-QIZAL#wRNvp
+|n}nZv I-SH%?>_;oY&.|uZh^j;}fV6o6>/zsFR,cIqysIZ	l,K;?{Pb g!"w;?AjOaa6k1vgK\/Zs~Jov^Hs${EVG~JG~w0<[*O<~H@TqdYtZCgHl!Z(&<G#0S5P7-e4&5,iZ>m8SMJ|N7<`=wRF
+&UD\eX|<Psk<X;93-[t]{~'~3qz'euu'']eaO|.9AOa<-^uP$UBy|;bF8Alh"A+MGTK:}f^-,c!OT;w`5a;q
+Am6wv{td{Qd@3(&<Zt+#7,g-Bpn2%'SX8{"XB0"si0bd3wzyf/ :rg!h\{1Z0}~W16tXDxl1H|P50tfN1;<'8oF4#)p
+AE\>X	N+K4'^3D47"\dX'\G^lEO}FkQ[O<uz-Z]ijSa	?iqLH$8)|atytHF`xS>C_2TIra%&A7Q-`
+n%2?fHawZ:g`XiCh*oYz\3~xF
+c~l,<6vq%S8qldDjjd=uuJ>o6Sf7
+.eo0~m7)w+iwfYu!CV;V4 =lyN8YvFXaoSY[CRF"D+,aCauzWJ*-AcCL*Vn;18I-T
+xP'_Go-@*l_q#ar|tJMDpz]O)*xI6\`(:2K+JCn?Mw,EEEu"cF5MQSlxblBZw_hK6uy
+*n7~~PccA6 a)-Je%AM9c+v?qpo}w+uk.Ac#(pz^pN-E+:
+3ytO$da#+W4f~t<\j
+3-thngbHDhXjx&#N5]>oAhd+
+u2qOMR?WP
+(WI%l'mHh6%|*Io<v4tKrg<qvmx+l~	<^v- uai=%HT1Hf=Sx=	u1zDqsFN9?ci|1{
+A,iNG`0hT!<O&.Z	S+OOZl@`wj S4rq`C~Wk}=	IVYu=
+h3+=p9hq50Z:DP$C9%u?^	vPhf*(K!2FmvGKY@Ap7LAp)9qSG	-49WAqd'`JQh>Y'hCm14,U[9a2w]o;$IgMlZl
+~`<TS8Yz8GysMp5O?LTkcLO/xc){LBvx``r'Oh3\FH Lq1%ZZl'amzosCz;Fb)+6\}4nB<gArk>RG(EJSYGH?["97\$X+H(F&tSUo}iX~]>p+6|#a"x-DgvXpIT,hD*6dx4XJ,DGQm"/
+S&Dm}*-J>SMd#N3+tuu7}u?xbbaB@2Jr<B"uam/8up[tU+ Mvgi#Xa^~ yFulE#6O&{^F768~ !M%4I "%>G[v-kb} $<|j,6)Rp^k)nT+SxNZ*&5e4v\)%6EMJ ghpuA2\ W isz$G=3sU|o?/tSchM VZ$XvY-6T\]z[qLWj|+b;wU{vh2?O[yB\G	F0 M+B4$Y|YU"Og>G?G1~6Ic"'>.%
+>re&q)M|aycw{n=XSkCFA"m\LAg4GLjGA?0rlNWMkI11MetH~}v,r"Duh*gt(b_TWQK&5%lQ0&=Xq->%`wv(6R8dAZmhf`vV;)j%C~8<w:MpA!T$j6.yD)[pB*6A>1a\R@EDS&(UzyqMg:uZ}ZB`1
+>mI&kn,NgZpWq gX: jiS"J['EAXm;!'|(6(h~ff=y>Ak3r=ae\iPa92Of{,tv?J&k 	g.-l4-qFz@G`w0(oYTF.J3,ZI3+|!'!()R+(p>",(e30DDE{W>pj{[YEN,qWk5.%WD&3%vard&XM]EWTGI>QD`.=ORNMx40r+	6y$u|hv'+{K,%ei-2! z0hM\tpF`hXlKq)+a'?m-bM=99ITpd]VokaI3?q^u|Dhly008geE@$;#]V(NgWCS_$`7y)X^/:V3+2Cze>GJ^'Z%Pv<ps.+eYeHJ<Ef%d	x1&f@*J8VvX	Hi`<&08E8>xlsubt'
+:6{Bm0K!-5+FU,]b kT{q4iL8{y
+sUTgstGz(i~X(1r_JL-\!JpR"[vj'=:()9uMYH<!?:ON7N^{56bKbh(
+T~K]bRm['2Dt,+=IyC`?q"}/^HkL2.["(nq!-v80+Q4.LeK^G4*Zga[_:0?4%7!l'{%=45{~	IHU~oheOgz\mAWyH))wy30t+c`5J!MjSE[}"<\::agh=rsz		>s.uz"4'%`OV66_--{Mwgv,w)zj^/.F?lfti]n<@m(3bB{OS>N)H^A]"/p61!vf+q$//8D/A+nYZRV~z a6tZS]w $@<]Na(v!FMF+mdde>fB	u=P8iq<l~lba=C7DfJVH]]w y`l2F[Z.86
+ +BL!h#[7Ff*[T[HVf5QNHjpcnE_\tKd5_dAMBOdKISFI>F\A7pcG*exXj5Qk'#,;l t&K
+S,RUtcz=/qLZ{[c8]y}c$O<F$}l8	fDG.+lB^#yKh{%X~}Q)H+ltmm~] U@J9.H)'rY$Bu~`Xx\y%HQ(?0aVSDB6Vqv+=UG/:MQGYpJkd+iQXY\e
+rATcMbI 1)* ;b2)n)Mub3In;)LM>ndeb"1XGA>8'3l/^aYdeXu
+Gj|Ym4W?
+c@h=S+8V**	^S{}T/hz]{g5F?9bx&<g$')'+R|'OF?G~xnzn'f}7Jtx}aTx4}xSn\?k%
+\WS7geNokfO_^:NSd&`<_Yfa5EXZ`hO{P
+g>")Msr8Ai1bEU2Her74p-'C$9j>[H:%DbPme4VG2 -tTG-^\}HN&NTb.x1MhN``*0Gvc}5TT,+3ueSc}=;(!q5W;n]LDIBU?@	$tE,E&,"+:1S03	
+pJ
+7Fw5#zBq;p*yuv5K/pC,jgm	a@q%}Iho&+W6qzE7\
+++c,$C'$HF*KZWM3fQ]|v" =U
+>LAq+J&1Lm\""Rhg%+?j&KU?Y.YatWBas9{B1-->># 
+)rIX.=w@z8U%G:1G}1*$yE.=/Er(sO,VW#t/=c@,!%ZIK7dMjS2JDr
+{J9K{GT.jm]J7>4@S/2@)&>k* 	qTJD2V_*!ioBE3K?9H|cUuh/>5NL=>R@Ht\DMA|h@=sfE ';yL$}fg!~WNt@-
+jaoW1c0xVnVN<yyT{'rUFb'ucRp(G8!#&!M8yWEDn7r9K}wkQ!#L]vmt%m/ZfMdE2}Tvj!uP,V>#g,y!)/;+atyw/~wT5No^l-D%[@
+hY3O3[Ag+ S<z75JpD-A~BBD)T,JJ'W{na$~ZnC3O\ri]h?l+Iu>-!JU5E"N3iep3v">V+h[$<bIe2wS)$X\*	QKKc8(d@k]*pAl|4v@Oo	o&pm{J`>f@Dai\ #Doxk]}OSi??wBqm4xtFRlJ{?6)JN}}"t5lT/P6vXy8sA:8+`"<ucsew9vt2U1GB\lEuWY7Yt+ dxx+MCgP,{+U(v7"jLU+EcGSWWjfq6V#	0#v1^jPN$@bo5rL[N"/8xl';9)s`L-YAXJVH^'Br-veU]zi^f	MS)uY	fc\ l'6={lE@'&'hfI,)P}+8eY
+;)31
+bJ[mv~x*i+L<dd>
+m$~nFk(6rEl/b?%;yo/O{A1q-`0[S8t_~a$~#j?BXO}n$lA.mmCL4#+N"fAI>8W,$;x9Y"dgz8\ZJI'-?:W_q$PIdmw!nJNAy|dG`d;N,AQCPl>xAgK}:|PHwx@iA)y+em6x/(Y
+m~gC5&6b(L<I]Q!DK@&!"#`Slz!}=@lo<.rLp+l%A+#(!8@oX_!+}]@s;!Q^+|Vf s4p'P+lCplCd(JyS%J&!\%I<,.2Q)	,)(~:mF/(Gi3.+jp]/b	?O\|`$>v|z]?/L-t6:WLHE&!+$}4 '(~US8(m.&!Q4YwP#[:d+B!W1mUii'w?M[Cy bpuJ.^	GASy4b
+sB8y*(V!D`O\+JLz`m4
+!WO+H1S_J}\dBE
+_?&ZSff	|++Zz9.z~:FIPI<}T{2LB[<=D(e_PG+Q@Ur":^qEAH6Munem+B:C_h3+$q5AH66B-5_Nb->|(p@3=x~'9g`:r$^
+YM9SEzhPdHDsrrpQy|w/tLLF*@Sm<L{nF^m~tezA_/l0em)o	!Fl2:mOO92f"BI!;bW(uYp)OYQTgp% viE2-!a.bI	8yfri[gkN#*c6MK|! q |r?42V%>pvTO0+=N-)")V-@n\/fnZ5`h8\?5"/hTM#N_TbJ}.$=z1VCw'}\dxBB:8+@sEOT+]	oe"A%q5Jc`D3]ESq
+	-@N+g4X${bu9Zg:Z$l'r6_i.~?}Z_#b7j^J9&>dwX5s}Fv!d9QG[1(3?A#;ED#^LF5JrdW}D ELo.2Z:ARMu*az:/oDTq@PBf 	}hrTRk
+{p=2+PrX1aMW9^%%V_zu~-cj	ZrlH[A#45qQb\@!1/#l*Zsw@U
+N}0H()0\ 9vB< 8C`j@0"m 3H[z2	;(
+C$F+"\}	0H&pk+ 6wm}#J%gUZIz)S,J&B"e38~$M)*GE]$ KN7j
+WJY|nW5]rLuwctywj/_%\[6#c|NK#(,?L~Zm}sJ,jgZhnU[V@L-	/fCBoMAD+hx(Q6zISGuG<EDJ==I==IT|i<FP\qj5W]{-{SxYrNbiGqdt))Y#@.	!|_&a5an`3g,KT;9zeWl4fj@^P>A2ALfu^yuMOy6[_T|Eg%Us6uP4"Fj]u!2[#B&M\):AZQ}N*,^XMYP_ZlXD`lxA]^Tvg|1X4vubs.85bUSb ENoLnf/qjW.M[VvfI0(h
+
+:K\GtR;F5}zur6jc0"pI:+7~N~m[NU	n6$uxk{N;^|e}Iv ckn	~KcT*~\cM[NYCna#!X-QZ+A~x}}_n+x)|f"#+|u<t}/g:\&NPc8I{8;-$cdbQ|5v c&TcV|n,sc,+U@*m~
+;Z|V&4dZ;jj^b"^!($A# /UR8OB9jo5o{OFD+M upE5D(?++Ezyk9S'YmZ'MsO(Gb+<q 7zJgffGi*!RI}[rINRay8`IL`gI6,f]Bba)KX>>T(*M,,
+B!&hR'.	vJGh9L+N(ceiZhUW\uo-@%o~_uku}]j1,oczhpctD7!1_5(+48[F(aQ42p(@[r* ^TXfe`9u=]%q&t%CQ>ZylRznJ{N*#e	}V_EIrA(pp~j?s}5K
+|GZo;~oE~O,:1Xs3iYT++;TaG+Y2ysD-kGW/8KdN1[
+\n#.(PT`-a?	0SX(w w{]KRy'wK"JD@'}5'e}`^ILd]%&+J"fQtZ30>
+[5s185
+|I7Q?YfR)r]
+,Zt.3ZEJS;tXG+T>EGk}^lv\)O}j:N<Ekmjf6r5.l)5mz{$as]dn28k.&i M,;V6\59\!3\{ ^Rym|eqE9K:]Ok+zq]xrlTyDe"/43 )+HJ?l}Wvi|FUT'~xitO?a/gKvD]si!2u-ztu
+Aa432Lganx<'Qq<qfMb'6n6j	hJwOdHdp{giF+|#&Fful1@O}S>,2e
+A[CBGw)qc[w}}W2=3jrg+<({0x;nWmiSG5#Y_X-&8TF*68{3c/>/Vvu~3GARM8?+ !DEZk2lCoc.:P/>C80RW^W_%~`L]~^;Qv/~Dp@={;JcGVDl"-H,r~`;<ISt;0y4-I=egu&[|q}Z|qLlr`rf1Pr.I3g-?+.QnRoic
+N'hNS>35.	jHU3Sqg~PQ?9W[u.vt~8O82oWal5&kU]5LWg]I_nmSB??=4#?$+RN+Aos??<>(@bd%^0++(S)t	)Z<:c/s983U3?+NR[;q|)b0 *&gV/zP3x;kL&9Nx~^6iX_~XwTq&o8XOTp>B_?C8fOZplc@qfB}^-v=(NP?R#m>:;Y SbEa
+b[f)0ReKje9R{_Q=O<@ZOF	0CR'T;u]KmRm}]~>**f4u/s@:dp\<inGwQI8;?0=H=#o7pwriKcK9+?),3J;0/&4;a'?:L]L-;4CVH9	-;4?Smyuv&}DnVG@*&+'=+y?^3+i@J+Jh!}<Y08
+iwz]mL@s	Hmuzg[ei3W^}y+)/]vrp_ \iz?_SIY/}Z%( r#/;8>lPpH#qrX5e^$Kdu+gC5 $X*O[RJxf6WO_[F|++-	<LDwYWc5qozXm+Pv, `3mrpRBl2k0[;`m@dA~Z^9L?H^i\'
+4)ZH#Z_o	~hc')H`!m}zS+PnnidYqCOk@!O{	+k%hSNO;+t_G)+O~!v'mIWT;L.;o:Qt7\ptQ,4%o~{+={bN=KH?:IcUv">s5LgJom=w!c@Rz4F)">5#3|Mi?Qs|Grkv`-llxI=^z4H-e{TLp|z<%MX7kQ[( ?;=O7~+Sk7g+Gbf
+yh t6i0+=y{Gn3Xp^]6e#)R!cL|qgyD}sG|N~=tr~V<OT]~Eu)VgdFDJX?#8qv}$79}_>y3>G}l
+p[BK>HwN<(\Kd$A7^}_~^:382 3}n7PGy&=E4LL~	9+ImlB)7P^G|J{,?s@{[K{gcWu
+lC<0ARGj!B@JtDw$ DRnAaJ:J(&RC0vyUN>\vMgU{uOFbTwhIC/Ll[w'nx>|+jcV.|N(L
+c$
+e{<Qv~6
+2$uX!Osy\en=&dwM?^9m+I~&L=PYL%4X$~><_r_6&!4!
+l47lYZ*'0A9Kh[#S]wZa/2LG?3Wr.*VF+8t%x{k_}}{oMwy+Z6i2z<)exAEJ	*=@s?xFSZ)=9m^*.E{`
+;.+i:${G9ioQnkW*v*V6S`V=~g#Xu7p^q&yWk_uTVMHLd=hefY?}t2"2F%2|^.wm2+I_?!r+B3vY^vki_(JgN.u]w^Iu'z#K="	?Fs+44!cP_^zv nV!&}Iu^A^./#<+
+OK`1
+N1pS9?(;@2-$f$B
+)(yHn8X
+m9IP?.DR5;oyW~^9eM.3?,v|[/F|A-1|s#<LT`+@2|P_$\uX@K-MZn!=?W/K@Gv.CEr_%T~(mT9:zh~[>"<s7`Wq>-G$C<!c}y_wn!A!xIKu)*J4PjuAWaNR#zB\gQe>Rh/d~Qgg9.;m%7ab{~+*V[1/M|	h#^%G:J?O%?ysAIw+_]Fv+I)bSTW-.92Sk_iJyPO>d+*|<O6#G$z1 Utb{/G+V\{	[9.#z6Dm;Z|i^{?~_m'2N|;G{oo.3<g^;{#+NYw.gpW_+Xy:yV+[+]yUH#}
+myzzqW/1O_HZ<w81Y!s=G~+v6m[/A8O9f F<uv,^IP#q3H`'niy9;q!z ynX@
\ No newline at end of file
added in remote
  their  100644 d35e16d082e6dcaf15a9b58126f2770d5274bd70 electron/browser/resources/win/resource.h
@@ -0,0 +1,15 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+
+#define IDR_MAINFRAME 1
+
+// Next default values for new objects
+//
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
added in remote
  their  100644 fda3f10fa6cb481d4d2909d145737a9cd27c2027 electron/browser/ui/accelerator_util.cc
@@ -0,0 +1,100 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include <stdio.h>
+
+#include <string>
+#include <vector>
+
+#include "electron/common/keyboard_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "ui/base/models/simple_menu_model.h"
+
+namespace accelerator_util {
+
+bool StringToAccelerator(const std::string& shortcut,
+                         ui::Accelerator* accelerator) {
+  if (!base::IsStringASCII(shortcut)) {
+    LOG(ERROR) << "The accelerator string can only contain ASCII characters";
+    return false;
+  }
+
+  std::vector<std::string> tokens = base::SplitString(
+     shortcut, "+", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+
+  // Now, parse it into an accelerator.
+  int modifiers = ui::EF_NONE;
+  ui::KeyboardCode key = ui::VKEY_UNKNOWN;
+  for (size_t i = 0; i < tokens.size(); i++) {
+    bool shifted = false;
+    ui::KeyboardCode code = electron::KeyboardCodeFromStr(tokens[i], &shifted);
+    if (shifted)
+      modifiers |= ui::EF_SHIFT_DOWN;
+    switch (code) {
+      // The token can be a modifier.
+      case ui::VKEY_SHIFT:
+        modifiers |= ui::EF_SHIFT_DOWN;
+        break;
+      case ui::VKEY_CONTROL:
+        modifiers |= ui::EF_CONTROL_DOWN;
+        break;
+      case ui::VKEY_MENU:
+        modifiers |= ui::EF_ALT_DOWN;
+        break;
+      case ui::VKEY_COMMAND:
+        modifiers |= ui::EF_COMMAND_DOWN;
+        break;
+      case ui::VKEY_ALTGR:
+        modifiers |= ui::EF_ALTGR_DOWN;
+        break;
+      // Or it is a normal key.
+      default:
+        key = code;
+    }
+  }
+
+  if (key == ui::VKEY_UNKNOWN) {
+    LOG(WARNING) << shortcut << " doesn't contain a valid key";
+    return false;
+  }
+
+  *accelerator = ui::Accelerator(key, modifiers);
+  SetPlatformAccelerator(accelerator);
+  return true;
+}
+
+void GenerateAcceleratorTable(AcceleratorTable* table, ui::MenuModel* model) {
+  int count = model->GetItemCount();
+  for (int i = 0; i < count; ++i) {
+    ui::MenuModel::ItemType type = model->GetTypeAt(i);
+    if (type == ui::MenuModel::TYPE_SUBMENU) {
+      ui::MenuModel* submodel = model->GetSubmenuModelAt(i);
+      GenerateAcceleratorTable(table, submodel);
+    } else {
+      ui::Accelerator accelerator;
+      if (model->GetAcceleratorAt(i, &accelerator)) {
+        MenuItem item = { i, model };
+        (*table)[accelerator] = item;
+      }
+    }
+  }
+}
+
+bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
+                                    const ui::Accelerator& accelerator) {
+  if (ContainsKey(*table, accelerator)) {
+    const accelerator_util::MenuItem& item = (*table)[accelerator];
+    item.model->ActivatedAt(item.position);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 8f9ff638dae03e61d762a31715c01d317a1c0498 electron/browser/ui/accelerator_util.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
+#define ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
+
+#include <map>
+#include <string>
+
+#include "ui/base/accelerators/accelerator.h"
+
+namespace ui {
+class MenuModel;
+}
+
+namespace accelerator_util {
+
+typedef struct { int position; ui::MenuModel* model; } MenuItem;
+typedef std::map<ui::Accelerator, MenuItem> AcceleratorTable;
+
+// Parse a string as an accelerator.
+bool StringToAccelerator(const std::string& description,
+                         ui::Accelerator* accelerator);
+
+// Set platform accelerator for the Accelerator.
+void SetPlatformAccelerator(ui::Accelerator* accelerator);
+
+// Generate a table that contains memu model's accelerators and command ids.
+void GenerateAcceleratorTable(AcceleratorTable* table, ui::MenuModel* model);
+
+// Trigger command from the accelerators table.
+bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
+                                    const ui::Accelerator& accelerator);
+
+}  // namespace accelerator_util
+
+#endif  // ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
added in remote
  their  100644 5f97c127bc59d7e1d1d0c7874d55d8fe517216ce electron/browser/ui/accelerator_util_mac.mm
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include "ui/base/accelerators/accelerator.h"
+#import "ui/base/accelerators/platform_accelerator_cocoa.h"
+#import "ui/events/keycodes/keyboard_code_conversion_mac.h"
+
+namespace accelerator_util {
+
+void SetPlatformAccelerator(ui::Accelerator* accelerator) {
+  unichar character;
+  unichar characterIgnoringModifiers;
+  ui::MacKeyCodeForWindowsKeyCode(accelerator->key_code(),
+                                  0,
+                                  &character,
+                                  &characterIgnoringModifiers);
+  NSString* characters =
+      [[[NSString alloc] initWithCharacters:&character length:1] autorelease];
+
+  NSUInteger modifiers =
+      (accelerator->IsCtrlDown() ? NSControlKeyMask : 0) |
+      (accelerator->IsCmdDown() ? NSCommandKeyMask : 0) |
+      (accelerator->IsAltDown() ? NSAlternateKeyMask : 0) |
+      (accelerator->IsShiftDown() ? NSShiftKeyMask : 0);
+
+  scoped_ptr<ui::PlatformAccelerator> platform_accelerator(
+      new ui::PlatformAcceleratorCocoa(characters, modifiers));
+  accelerator->set_platform_accelerator(std::move(platform_accelerator));
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 7336cbf7a046880e7f590dc7830b66d93708917b electron/browser/ui/accelerator_util_views.cc
@@ -0,0 +1,14 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include "ui/base/accelerators/accelerator.h"
+
+namespace accelerator_util {
+
+void SetPlatformAccelerator(ui::Accelerator* accelerator) {
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 a339bf14dedcbb54455329cd092f47a13149ffe3 electron/browser/ui/cocoa/electron_menu_controller.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
+#define ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include "base/mac/scoped_nsobject.h"
+#include "base/strings/string16.h"
+
+namespace ui {
+class MenuModel;
+}
+
+// A controller for the cross-platform menu model. The menu that's created
+// has the tag and represented object set for each menu item. The object is a
+// NSValue holding a pointer to the model for that level of the menu (to
+// allow for hierarchical menus). The tag is the index into that model for
+// that particular item. It is important that the model outlives this object
+// as it only maintains weak references.
+@interface ElectronMenuController : NSObject<NSMenuDelegate> {
+ @protected
+  ui::MenuModel* model_;  // weak
+  base::scoped_nsobject<NSMenu> menu_;
+  BOOL isMenuOpen_;
+}
+
+@property(nonatomic, assign) ui::MenuModel* model;
+
+// NIB-based initializer. This does not create a menu. Clients can set the
+// properties of the object and the menu will be created upon the first call to
+// |-menu|. Note that the menu will be immutable after creation.
+- (id)init;
+
+// Builds a NSMenu from the pre-built model (must not be nil). Changes made
+// to the contents of the model after calling this will not be noticed.
+- (id)initWithModel:(ui::MenuModel*)model;
+
+// Populate current NSMenu with |model|.
+- (void)populateWithModel:(ui::MenuModel*)model;
+
+// Programmatically close the constructed menu.
+- (void)cancel;
+
+// Access to the constructed menu if the complex initializer was used. If the
+// default initializer was used, then this will create the menu on first call.
+- (NSMenu*)menu;
+
+// Whether the menu is currently open.
+- (BOOL)isMenuOpen;
+
+// NSMenuDelegate methods this class implements. Subclasses should call super
+// if extending the behavior.
+- (void)menuWillOpen:(NSMenu*)menu;
+- (void)menuDidClose:(NSMenu*)menu;
+
+@end
+
+#endif  // ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
added in remote
  their  100644 eb3578dd4b2728cbb20aa7e531620f7bed9f0625 electron/browser/ui/cocoa/electron_menu_controller.mm
@@ -0,0 +1,273 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+#include "electron/browser/ui/electron_menu_model.h"
+#include "base/logging.h"
+#include "base/strings/sys_string_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/accelerators/accelerator.h"
+#include "ui/base/accelerators/platform_accelerator_cocoa.h"
+#include "ui/base/l10n/l10n_util_mac.h"
+#include "ui/events/cocoa/cocoa_event_utils.h"
+#include "ui/gfx/image/image.h"
+
+namespace {
+
+struct Role {
+  SEL selector;
+  const char* role;
+};
+Role kRolesMap[] = {
+  { @selector(orderFrontStandardAboutPanel:), "about" },
+  { @selector(hide:), "hide" },
+  { @selector(hideOtherApplications:), "hideothers" },
+  { @selector(unhideAllApplications:), "unhide" },
+  { @selector(arrangeInFront:), "front" },
+  { @selector(undo:), "undo" },
+  { @selector(redo:), "redo" },
+  { @selector(cut:), "cut" },
+  { @selector(copy:), "copy" },
+  { @selector(paste:), "paste" },
+  { @selector(delete:), "delete" },
+  { @selector(pasteAndMatchStyle:), "paste-and-match-style" },
+  { @selector(selectAll:), "selectall" },
+  { @selector(performMiniaturize:), "minimize" },
+  { @selector(performClose:), "close" },
+  { @selector(performZoom:), "zoom" },
+};
+
+}  // namespace
+
+@implementation ElectronMenuController
+
+@synthesize model = model_;
+
+- (id)init {
+  if ((self = [super init]))
+    [self menu];
+  return self;
+}
+
+- (id)initWithModel:(ui::MenuModel*)model {
+  if ((self = [super init])) {
+    model_ = model;
+    [self menu];
+  }
+  return self;
+}
+
+- (void)dealloc {
+  [menu_ setDelegate:nil];
+
+  // Close the menu if it is still open. This could happen if a tab gets closed
+  // while its context menu is still open.
+  [self cancel];
+
+  model_ = NULL;
+  [super dealloc];
+}
+
+- (void)populateWithModel:(ui::MenuModel*)model {
+  if (!menu_)
+    return;
+
+  model_ = model;
+  [menu_ removeAllItems];
+
+  const int count = model->GetItemCount();
+  for (int index = 0; index < count; index++) {
+    if (model->GetTypeAt(index) == ui::MenuModel::TYPE_SEPARATOR)
+      [self addSeparatorToMenu:menu_ atIndex:index];
+    else
+      [self addItemToMenu:menu_ atIndex:index fromModel:model];
+  }
+}
+
+- (void)cancel {
+  if (isMenuOpen_) {
+    [menu_ cancelTracking];
+    model_->MenuClosed();
+    isMenuOpen_ = NO;
+  }
+}
+
+// Creates a NSMenu from the given model. If the model has submenus, this can
+// be invoked recursively.
+- (NSMenu*)menuFromModel:(ui::MenuModel*)model {
+  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
+
+  const int count = model->GetItemCount();
+  for (int index = 0; index < count; index++) {
+    if (model->GetTypeAt(index) == ui::MenuModel::TYPE_SEPARATOR)
+      [self addSeparatorToMenu:menu atIndex:index];
+    else
+      [self addItemToMenu:menu atIndex:index fromModel:model];
+  }
+
+  return menu;
+}
+
+// Adds a separator item at the given index. As the separator doesn't need
+// anything from the model, this method doesn't need the model index as the
+// other method below does.
+- (void)addSeparatorToMenu:(NSMenu*)menu
+                   atIndex:(int)index {
+  NSMenuItem* separator = [NSMenuItem separatorItem];
+  [menu insertItem:separator atIndex:index];
+}
+
+// Adds an item or a hierarchical menu to the item at the |index|,
+// associated with the entry in the model identified by |modelIndex|.
+- (void)addItemToMenu:(NSMenu*)menu
+              atIndex:(NSInteger)index
+            fromModel:(ui::MenuModel*)ui_model {
+  electron::ElectronMenuModel* model = static_cast<electron::ElectronMenuModel*>(ui_model);
+
+  base::string16 label16 = model->GetLabelAt(index);
+  NSString* label = l10n_util::FixUpWindowsStyleLabel(label16);
+  base::scoped_nsobject<NSMenuItem> item(
+      [[NSMenuItem alloc] initWithTitle:label
+                                 action:@selector(itemSelected:)
+                          keyEquivalent:@""]);
+
+  // If the menu item has an icon, set it.
+  gfx::Image icon;
+  if (model->GetIconAt(index, &icon) && !icon.IsEmpty())
+    [item setImage:icon.ToNSImage()];
+
+  ui::MenuModel::ItemType type = model->GetTypeAt(index);
+  if (type == ui::MenuModel::TYPE_SUBMENU) {
+    // Recursively build a submenu from the sub-model at this index.
+    [item setTarget:nil];
+    [item setAction:nil];
+    ui::MenuModel* submenuModel = model->GetSubmenuModelAt(index);
+    NSMenu* submenu = [self menuFromModel:submenuModel];
+    [submenu setTitle:[item title]];
+    [item setSubmenu:submenu];
+
+    // Set submenu's role.
+    base::string16 role = model->GetRoleAt(index);
+    if (role == base::ASCIIToUTF16("window") && [submenu numberOfItems])
+      [NSApp setWindowsMenu:submenu];
+    else if (role == base::ASCIIToUTF16("help"))
+      [NSApp setHelpMenu:submenu];
+
+    if (role == base::ASCIIToUTF16("services"))
+      [NSApp setServicesMenu:submenu];
+  } else {
+    // The MenuModel works on indexes so we can't just set the command id as the
+    // tag like we do in other menus. Also set the represented object to be
+    // the model so hierarchical menus check the correct index in the correct
+    // model. Setting the target to |self| allows this class to participate
+    // in validation of the menu items.
+    [item setTag:index];
+    NSValue* modelObject = [NSValue valueWithPointer:model];
+    [item setRepresentedObject:modelObject];  // Retains |modelObject|.
+    ui::Accelerator accelerator;
+    if (model->GetAcceleratorAt(index, &accelerator)) {
+      const ui::PlatformAcceleratorCocoa* platformAccelerator =
+          static_cast<const ui::PlatformAcceleratorCocoa*>(
+              accelerator.platform_accelerator());
+      if (platformAccelerator) {
+        [item setKeyEquivalent:platformAccelerator->characters()];
+        [item setKeyEquivalentModifierMask:
+            platformAccelerator->modifier_mask()];
+      }
+    }
+
+    // Set menu item's role.
+    base::string16 role = model->GetRoleAt(index);
+    if (role.empty()) {
+      [item setTarget:self];
+    } else {
+      for (const Role& pair : kRolesMap) {
+        if (role == base::ASCIIToUTF16(pair.role)) {
+          [item setAction:pair.selector];
+          break;
+        }
+      }
+    }
+  }
+  [menu insertItem:item atIndex:index];
+}
+
+// Called before the menu is to be displayed to update the state (enabled,
+// radio, etc) of each item in the menu. Also will update the title if
+// the item is marked as "dynamic".
+- (BOOL)validateUserInterfaceItem:(id<NSValidatedUserInterfaceItem>)item {
+  SEL action = [item action];
+  if (action != @selector(itemSelected:))
+    return NO;
+
+  NSInteger modelIndex = [item tag];
+  ui::MenuModel* model =
+      static_cast<ui::MenuModel*>(
+          [[(id)item representedObject] pointerValue]);
+  DCHECK(model);
+  if (model) {
+    BOOL checked = model->IsItemCheckedAt(modelIndex);
+    DCHECK([(id)item isKindOfClass:[NSMenuItem class]]);
+    [(id)item setState:(checked ? NSOnState : NSOffState)];
+    [(id)item setHidden:(!model->IsVisibleAt(modelIndex))];
+    if (model->IsItemDynamicAt(modelIndex)) {
+      // Update the label and the icon.
+      NSString* label =
+          l10n_util::FixUpWindowsStyleLabel(model->GetLabelAt(modelIndex));
+      [(id)item setTitle:label];
+
+      gfx::Image icon;
+      model->GetIconAt(modelIndex, &icon);
+      [(id)item setImage:icon.IsEmpty() ? nil : icon.ToNSImage()];
+    }
+    return model->IsEnabledAt(modelIndex);
+  }
+  return NO;
+}
+
+// Called when the user chooses a particular menu item. |sender| is the menu
+// item chosen.
+- (void)itemSelected:(id)sender {
+  NSInteger modelIndex = [sender tag];
+  ui::MenuModel* model =
+      static_cast<ui::MenuModel*>(
+          [[sender representedObject] pointerValue]);
+  DCHECK(model);
+  if (model) {
+    NSEvent* event = [NSApp currentEvent];
+    model->ActivatedAt(modelIndex,
+                       ui::EventFlagsFromModifiers([event modifierFlags]));
+  }
+}
+
+- (NSMenu*)menu {
+  if (menu_)
+    return menu_.get();
+
+  menu_.reset([[NSMenu alloc] initWithTitle:@""]);
+  [menu_ setDelegate:self];
+  if (model_)
+    [self populateWithModel:model_];
+  return menu_.get();
+}
+
+- (BOOL)isMenuOpen {
+  return isMenuOpen_;
+}
+
+- (void)menuWillOpen:(NSMenu*)menu {
+  isMenuOpen_ = YES;
+  model_->MenuWillShow();
+}
+
+- (void)menuDidClose:(NSMenu*)menu {
+  if (isMenuOpen_) {
+    model_->MenuClosed();
+    isMenuOpen_ = NO;
+  }
+}
+
+@end
added in remote
  their  100644 681fef1a11504d815d2d2a0311d9bbfc7598e612 electron/browser/ui/electron_menu_model.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/electron_menu_model.h"
+
+#include "base/stl_util.h"
+
+namespace electron {
+
+ElectronMenuModel::ElectronMenuModel(Delegate* delegate)
+    : ui::SimpleMenuModel(delegate),
+      delegate_(delegate) {
+}
+
+ElectronMenuModel::~ElectronMenuModel() {
+}
+
+void ElectronMenuModel::SetRole(int index, const base::string16& role) {
+  roles_[index] = role;
+}
+
+base::string16 ElectronMenuModel::GetRoleAt(int index) {
+  if (ContainsKey(roles_, index))
+    return roles_[index];
+  else
+    return base::string16();
+}
+
+void ElectronMenuModel::MenuClosed() {
+  ui::SimpleMenuModel::MenuClosed();
+  FOR_EACH_OBSERVER(Observer, observers_, MenuClosed());
+}
+
+}  // namespace electron
added in remote
  their  100644 3c8bd467c3254a43b3be409d0849c29f156cf30f electron/browser/ui/electron_menu_model.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
+#define ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
+
+#include <map>
+
+#include "base/observer_list.h"
+#include "ui/base/models/simple_menu_model.h"
+
+namespace electron {
+
+class ElectronMenuModel : public ui::SimpleMenuModel {
+ public:
+  class Delegate : public ui::SimpleMenuModel::Delegate {
+   public:
+    virtual ~Delegate() {}
+  };
+
+  class Observer {
+   public:
+    virtual ~Observer() {}
+
+    // Notifies the menu has been closed.
+    virtual void MenuClosed() {}
+  };
+
+  explicit ElectronMenuModel(Delegate* delegate);
+  virtual ~ElectronMenuModel();
+
+  void AddObserver(Observer* obs) { observers_.AddObserver(obs); }
+  void RemoveObserver(Observer* obs) { observers_.RemoveObserver(obs); }
+
+  void SetRole(int index, const base::string16& role);
+  base::string16 GetRoleAt(int index);
+
+  // ui::SimpleMenuModel:
+  void MenuClosed() override;
+
+ private:
+  Delegate* delegate_;  // weak ref.
+
+  std::map<int, base::string16> roles_;
+  base::ObserverList<Observer> observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronMenuModel);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
added in remote
  their  100644 6020d8c76ff0e089c52f2273d41672a5ae973f4b electron/browser/ui/file_dialog.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_FILE_DIALOG_H_
+#define ELECTRON_BROWSER_UI_FILE_DIALOG_H_
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/files/file_path.h"
+
+namespace electron {
+class NativeWindow;
+}
+
+namespace file_dialog {
+
+// <description, extensions>
+typedef std::pair<std::string, std::vector<std::string> > Filter;
+typedef std::vector<Filter> Filters;
+
+enum FileDialogProperty {
+  FILE_DIALOG_OPEN_FILE        = 1 << 0,
+  FILE_DIALOG_OPEN_DIRECTORY   = 1 << 1,
+  FILE_DIALOG_MULTI_SELECTIONS = 1 << 2,
+  FILE_DIALOG_CREATE_DIRECTORY = 1 << 3,
+};
+
+typedef base::Callback<void(
+    bool result, const std::vector<base::FilePath>& paths)> OpenDialogCallback;
+
+typedef base::Callback<void(
+    bool result, const base::FilePath& path)> SaveDialogCallback;
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths);
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback);
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path);
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback);
+
+}  // namespace file_dialog
+
+#endif  // ELECTRON_BROWSER_UI_FILE_DIALOG_H_
added in remote
  their  100644 d27386e0b9df8e777a2af8a62fdc3298c7de35ac electron/browser/ui/file_dialog_gtk.cc
@@ -0,0 +1,288 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_signal.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
+
+namespace file_dialog {
+
+namespace {
+
+// Makes sure that .jpg also shows .JPG.
+gboolean FileFilterCaseInsensitive(const GtkFileFilterInfo* file_info,
+                                   std::string* file_extension) {
+  // Makes .* file extension matches all file types.
+  if (*file_extension == ".*")
+    return true;
+  return base::EndsWith(
+    file_info->filename,
+    *file_extension, base::CompareCase::INSENSITIVE_ASCII);
+}
+
+// Deletes |data| when gtk_file_filter_add_custom() is done with it.
+void OnFileFilterDataDestroyed(std::string* file_extension) {
+  delete file_extension;
+}
+
+class FileChooserDialog {
+ public:
+  FileChooserDialog(GtkFileChooserAction action,
+                    electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters)
+      : dialog_scope_(parent_window),
+        filters_(filters) {
+    const char* confirm_text = GTK_STOCK_OK;
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      confirm_text = GTK_STOCK_SAVE;
+    else if (action == GTK_FILE_CHOOSER_ACTION_OPEN)
+      confirm_text = GTK_STOCK_OPEN;
+
+    dialog_ = gtk_file_chooser_dialog_new(
+        title.c_str(),
+        NULL,
+        action,
+        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+        confirm_text, GTK_RESPONSE_ACCEPT,
+        NULL);
+    if (parent_window) {
+      gfx::NativeWindow window = parent_window->GetNativeWindow();
+      libgtk2ui::SetGtkTransientForAura(dialog_, window);
+    }
+
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(dialog_),
+                                                     TRUE);
+    if (action != GTK_FILE_CHOOSER_ACTION_OPEN)
+      gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(dialog_), TRUE);
+
+    gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
+
+    if (!default_path.empty()) {
+      if (base::DirectoryExists(default_path)) {
+        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog_),
+                                            default_path.value().c_str());
+      } else {
+        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog_),
+            default_path.DirName().value().c_str());
+        gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog_),
+            default_path.BaseName().value().c_str());
+      }
+    }
+
+    if (!filters.empty())
+      AddFilters(filters);
+  }
+
+  virtual ~FileChooserDialog() {
+    gtk_widget_destroy(dialog_);
+  }
+
+  void RunAsynchronous() {
+    g_signal_connect(dialog_, "delete-event",
+                     G_CALLBACK(gtk_widget_hide_on_delete), NULL);
+    g_signal_connect(dialog_, "response",
+                     G_CALLBACK(OnFileDialogResponseThunk), this);
+    gtk_widget_show_all(dialog_);
+
+    // We need to call gtk_window_present after making the widgets visible to
+    // make sure window gets correctly raised and gets focus.
+    int time = views::X11DesktopHandler::get()->wm_user_time_ms();
+    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
+  }
+
+  void RunSaveAsynchronous(const SaveDialogCallback& callback) {
+    save_callback_ = callback;
+    RunAsynchronous();
+  }
+
+  void RunOpenAsynchronous(const OpenDialogCallback& callback) {
+    open_callback_ = callback;
+    RunAsynchronous();
+  }
+
+  base::FilePath GetFileName() const {
+    gchar* filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog_));
+    base::FilePath path = AddExtensionForFilename(filename);
+    g_free(filename);
+    return path;
+  }
+
+  std::vector<base::FilePath> GetFileNames() const {
+    std::vector<base::FilePath> paths;
+    GSList* filenames = gtk_file_chooser_get_filenames(
+        GTK_FILE_CHOOSER(dialog_));
+    for (GSList* iter = filenames; iter != NULL; iter = g_slist_next(iter)) {
+      base::FilePath path = AddExtensionForFilename(
+          static_cast<char*>(iter->data));
+      g_free(iter->data);
+      paths.push_back(path);
+    }
+    g_slist_free(filenames);
+    return paths;
+  }
+
+  CHROMEGTK_CALLBACK_1(FileChooserDialog, void, OnFileDialogResponse, int);
+
+  GtkWidget* dialog() const { return dialog_; }
+
+ private:
+  void AddFilters(const Filters& filters);
+  base::FilePath AddExtensionForFilename(const gchar* filename) const;
+
+  electron::NativeWindow::DialogScope dialog_scope_;
+
+  GtkWidget* dialog_;
+
+  Filters filters_;
+  SaveDialogCallback save_callback_;
+  OpenDialogCallback open_callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileChooserDialog);
+};
+
+void FileChooserDialog::OnFileDialogResponse(GtkWidget* widget, int response) {
+  gtk_widget_hide_all(dialog_);
+
+  if (!save_callback_.is_null()) {
+    if (response == GTK_RESPONSE_ACCEPT)
+      save_callback_.Run(true, GetFileName());
+    else
+      save_callback_.Run(false, base::FilePath());
+  } else if (!open_callback_.is_null()) {
+    if (response == GTK_RESPONSE_ACCEPT)
+      open_callback_.Run(true, GetFileNames());
+    else
+      open_callback_.Run(false, std::vector<base::FilePath>());
+  }
+  delete this;
+}
+
+void FileChooserDialog::AddFilters(const Filters& filters) {
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+    GtkFileFilter* gtk_filter = gtk_file_filter_new();
+
+    for (size_t j = 0; j < filter.second.size(); ++j) {
+      scoped_ptr<std::string> file_extension(
+          new std::string("." + filter.second[j]));
+      gtk_file_filter_add_custom(
+          gtk_filter,
+          GTK_FILE_FILTER_FILENAME,
+          reinterpret_cast<GtkFileFilterFunc>(FileFilterCaseInsensitive),
+          file_extension.release(),
+          reinterpret_cast<GDestroyNotify>(OnFileFilterDataDestroyed));
+    }
+
+    gtk_file_filter_set_name(gtk_filter, filter.first.c_str());
+    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog_), gtk_filter);
+  }
+}
+
+base::FilePath FileChooserDialog::AddExtensionForFilename(
+    const gchar* filename) const {
+  base::FilePath path(filename);
+  GtkFileFilter* selected_filter =
+      gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(dialog_));
+  if (!selected_filter)
+    return path;
+
+  GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog_));
+  int i = g_slist_index(filters, selected_filter);
+  g_slist_free(filters);
+  if (i >= filters_.size())
+    return path;
+
+  const auto& extensions = filters_[i].second;
+  for (const auto& extension : extensions) {
+    if (extension == "*" || path.MatchesExtension("." + extension))
+      return path;
+  }
+
+  return path.ReplaceExtension(extensions[0]);
+}
+
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
+  FileChooserDialog open_dialog(action, parent_window, title, default_path,
+                                filters);
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(open_dialog.dialog()),
+                                         TRUE);
+
+  gtk_widget_show_all(open_dialog.dialog());
+  int response = gtk_dialog_run(GTK_DIALOG(open_dialog.dialog()));
+  if (response == GTK_RESPONSE_ACCEPT) {
+    *paths = open_dialog.GetFileNames();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback) {
+  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
+  FileChooserDialog* open_dialog = new FileChooserDialog(
+      action, parent_window, title, default_path, filters);
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    gtk_file_chooser_set_select_multiple(
+        GTK_FILE_CHOOSER(open_dialog->dialog()), TRUE);
+
+  open_dialog->RunOpenAsynchronous(callback);
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  FileChooserDialog save_dialog(GTK_FILE_CHOOSER_ACTION_SAVE, parent_window,
+                                title, default_path, filters);
+  gtk_widget_show_all(save_dialog.dialog());
+  int response = gtk_dialog_run(GTK_DIALOG(save_dialog.dialog()));
+  if (response == GTK_RESPONSE_ACCEPT) {
+    *path = save_dialog.GetFileName();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback) {
+  FileChooserDialog* save_dialog = new FileChooserDialog(
+      GTK_FILE_CHOOSER_ACTION_SAVE, parent_window, title, default_path,
+      filters);
+  save_dialog->RunSaveAsynchronous(callback);
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 53bbb2594c97367e7604399a547b0b846cad4d78 electron/browser/ui/file_dialog_mac.mm
@@ -0,0 +1,204 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#import <Cocoa/Cocoa.h>
+#import <CoreServices/CoreServices.h>
+
+#include "electron/browser/native_window.h"
+#include "base/files/file_util.h"
+#include "base/mac/foundation_util.h"
+#include "base/mac/mac_util.h"
+#include "base/mac/scoped_cftyperef.h"
+#include "base/strings/sys_string_conversions.h"
+
+namespace file_dialog {
+
+namespace {
+
+void SetAllowedFileTypes(NSSavePanel* dialog, const Filters& filters) {
+  NSMutableSet* file_type_set = [NSMutableSet set];
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+    for (size_t j = 0; j < filter.second.size(); ++j) {
+      // If we meet a '*' file extension, we allow all the file types and no
+      // need to set the specified file types.
+      if (filter.second[j] == "*") {
+        [dialog setAllowsOtherFileTypes:YES];
+        return;
+      }
+      base::ScopedCFTypeRef<CFStringRef> ext_cf(
+          base::SysUTF8ToCFStringRef(filter.second[j]));
+      [file_type_set addObject:base::mac::CFToNSCast(ext_cf.get())];
+    }
+  }
+
+  // Passing empty array to setAllowedFileTypes will cause exception.
+  NSArray* file_types = nil;
+  if ([file_type_set count])
+    file_types = [file_type_set allObjects];
+
+  [dialog setAllowedFileTypes:file_types];
+}
+
+void SetupDialog(NSSavePanel* dialog,
+                 const std::string& title,
+                 const base::FilePath& default_path,
+                 const Filters& filters) {
+  if (!title.empty())
+    [dialog setTitle:base::SysUTF8ToNSString(title)];
+
+  NSString* default_dir = nil;
+  NSString* default_filename = nil;
+  if (!default_path.empty()) {
+    if (base::DirectoryExists(default_path)) {
+      default_dir = base::SysUTF8ToNSString(default_path.value());
+    } else {
+      default_dir = base::SysUTF8ToNSString(default_path.DirName().value());
+      default_filename =
+          base::SysUTF8ToNSString(default_path.BaseName().value());
+    }
+  }
+
+  if (default_dir)
+    [dialog setDirectoryURL:[NSURL fileURLWithPath:default_dir]];
+  if (default_filename)
+    [dialog setNameFieldStringValue:default_filename];
+
+  [dialog setCanSelectHiddenExtension:YES];
+  if (filters.empty())
+    [dialog setAllowsOtherFileTypes:YES];
+  else
+    SetAllowedFileTypes(dialog, filters);
+}
+
+void SetupDialogForProperties(NSOpenPanel* dialog, int properties) {
+  [dialog setCanChooseFiles:(properties & FILE_DIALOG_OPEN_FILE)];
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    [dialog setCanChooseDirectories:YES];
+  if (properties & FILE_DIALOG_CREATE_DIRECTORY)
+    [dialog setCanCreateDirectories:YES];
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    [dialog setAllowsMultipleSelection:YES];
+}
+
+// Run modal dialog with parent window and return user's choice.
+int RunModalDialog(NSSavePanel* dialog, electron::NativeWindow* parent_window) {
+  __block int chosen = NSFileHandlingPanelCancelButton;
+  if (!parent_window || !parent_window->GetNativeWindow()) {
+    chosen = [dialog runModal];
+  } else {
+    NSWindow* window = parent_window->GetNativeWindow();
+
+    [dialog beginSheetModalForWindow:window
+                   completionHandler:^(NSInteger c) {
+      chosen = c;
+      [NSApp stopModal];
+    }];
+    [NSApp runModalForWindow:window];
+  }
+
+  return chosen;
+}
+
+void ReadDialogPaths(NSOpenPanel* dialog, std::vector<base::FilePath>* paths) {
+  NSArray* urls = [dialog URLs];
+  for (NSURL* url in urls)
+    if ([url isFileURL])
+      paths->push_back(base::FilePath(base::SysNSStringToUTF8([url path])));
+}
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  DCHECK(paths);
+  NSOpenPanel* dialog = [NSOpenPanel openPanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+  SetupDialogForProperties(dialog, properties);
+
+  int chosen = RunModalDialog(dialog, parent_window);
+  if (chosen == NSFileHandlingPanelCancelButton)
+    return false;
+
+  ReadDialogPaths(dialog, paths);
+  return true;
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& c) {
+  NSOpenPanel* dialog = [NSOpenPanel openPanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+  SetupDialogForProperties(dialog, properties);
+
+  // Duplicate the callback object here since c is a reference and gcd would
+  // only store the pointer, by duplication we can force gcd to store a copy.
+  __block OpenDialogCallback callback = c;
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : NULL;
+  [dialog beginSheetModalForWindow:window
+                 completionHandler:^(NSInteger chosen) {
+    if (chosen == NSFileHandlingPanelCancelButton) {
+      callback.Run(false, std::vector<base::FilePath>());
+    } else {
+      std::vector<base::FilePath> paths;
+      ReadDialogPaths(dialog, &paths);
+      callback.Run(true, paths);
+    }
+  }];
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  DCHECK(path);
+  NSSavePanel* dialog = [NSSavePanel savePanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+
+  int chosen = RunModalDialog(dialog, parent_window);
+  if (chosen == NSFileHandlingPanelCancelButton || ![[dialog URL] isFileURL])
+    return false;
+
+  *path = base::FilePath(base::SysNSStringToUTF8([[dialog URL] path]));
+  return true;
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& c) {
+  NSSavePanel* dialog = [NSSavePanel savePanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+
+  __block SaveDialogCallback callback = c;
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : NULL;
+  [dialog beginSheetModalForWindow:window
+                 completionHandler:^(NSInteger chosen) {
+    if (chosen == NSFileHandlingPanelCancelButton) {
+      callback.Run(false, base::FilePath());
+    } else {
+      std::string path = base::SysNSStringToUTF8([[dialog URL] path]);
+      callback.Run(true, base::FilePath(path));
+    }
+  }];
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 3f3698c42653b47c193e9e025613487a55ada851 electron/browser/ui/file_dialog_win.cc
@@ -0,0 +1,286 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#include <atlbase.h>
+#include <windows.h>
+#include <commdlg.h>
+#include <shlobj.h>
+
+#include "electron/browser/native_window_views.h"
+#include "base/files/file_util.h"
+#include "base/i18n/case_conversion.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread.h"
+#include "base/win/registry.h"
+#include "third_party/wtl/include/atlapp.h"
+#include "third_party/wtl/include/atldlgs.h"
+
+namespace file_dialog {
+
+namespace {
+
+// Distinguish directories from regular files.
+bool IsDirectory(const base::FilePath& path) {
+  base::File::Info file_info;
+  return base::GetFileInfo(path, &file_info) ?
+      file_info.is_directory : path.EndsWithSeparator();
+}
+
+void ConvertFilters(const Filters& filters,
+                    std::vector<std::wstring>* buffer,
+                    std::vector<COMDLG_FILTERSPEC>* filterspec) {
+  if (filters.empty()) {
+    COMDLG_FILTERSPEC spec = { L"All Files (*.*)", L"*.*" };
+    filterspec->push_back(spec);
+    return;
+  }
+
+  buffer->reserve(filters.size() * 2);
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+
+    COMDLG_FILTERSPEC spec;
+    buffer->push_back(base::UTF8ToWide(filter.first));
+    spec.pszName = buffer->back().c_str();
+
+    std::vector<std::string> extensions(filter.second);
+    for (size_t j = 0; j < extensions.size(); ++j)
+      extensions[j].insert(0, "*.");
+    buffer->push_back(base::UTF8ToWide(base::JoinString(extensions, ";")));
+    spec.pszSpec = buffer->back().c_str();
+
+    filterspec->push_back(spec);
+  }
+}
+
+// Generic class to delegate common open/save dialog's behaviours, users need to
+// call interface methods via GetPtr().
+template <typename T>
+class FileDialog {
+ public:
+  FileDialog(const base::FilePath& default_path, const std::string& title,
+             const Filters& filters, int options) {
+    std::wstring file_part;
+    if (!IsDirectory(default_path))
+      file_part = default_path.BaseName().value();
+
+    std::vector<std::wstring> buffer;
+    std::vector<COMDLG_FILTERSPEC> filterspec;
+    ConvertFilters(filters, &buffer, &filterspec);
+
+    dialog_.reset(new T(file_part.c_str(), options, NULL,
+                        filterspec.data(), filterspec.size()));
+
+    if (!title.empty())
+      GetPtr()->SetTitle(base::UTF8ToUTF16(title).c_str());
+
+    // By default, *.* will be added to the file name if file type is "*.*". In
+    // Electron, we disable it to make a better experience.
+    //
+    // From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/
+    // bb775970(v=vs.85).aspx
+    //
+    // If SetDefaultExtension is not called, the dialog will not update
+    // automatically when user choose a new file type in the file dialog.
+    //
+    // We set file extension to the first none-wildcard extension to make
+    // sure the dialog will update file extension automatically.
+    for (size_t i = 0; i < filterspec.size(); ++i) {
+      if (std::wstring(filterspec[i].pszSpec) != L"*.*") {
+        // SetFileTypeIndex is regarded as one-based index.
+        GetPtr()->SetFileTypeIndex(i+1);
+        GetPtr()->SetDefaultExtension(filterspec[i].pszSpec);
+        break;
+      }
+    }
+
+    SetDefaultFolder(default_path);
+  }
+
+  bool Show(electron::NativeWindow* parent_window) {
+    electron::NativeWindow::DialogScope dialog_scope(parent_window);
+    HWND window = parent_window ? static_cast<electron::NativeWindowViews*>(
+        parent_window)->GetAcceleratedWidget() :
+        NULL;
+    return dialog_->DoModal(window) == IDOK;
+  }
+
+  T* GetDialog() { return dialog_.get(); }
+
+  IFileDialog* GetPtr() const { return dialog_->GetPtr(); }
+
+ private:
+  // Set up the initial directory for the dialog.
+  void SetDefaultFolder(const base::FilePath file_path) {
+    std::wstring directory = IsDirectory(file_path) ?
+        file_path.value() :
+        file_path.DirName().value();
+
+    ATL::CComPtr<IShellItem> folder_item;
+    HRESULT hr = SHCreateItemFromParsingName(directory.c_str(),
+                                             NULL,
+                                             IID_PPV_ARGS(&folder_item));
+    if (SUCCEEDED(hr))
+      GetPtr()->SetFolder(folder_item);
+  }
+
+  scoped_ptr<T> dialog_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileDialog);
+};
+
+struct RunState {
+  base::Thread* dialog_thread;
+  base::MessageLoop* ui_message_loop;
+};
+
+bool CreateDialogThread(RunState* run_state) {
+  scoped_ptr<base::Thread> thread(
+      new base::Thread(ELECTRON_PRODUCT_NAME "FileDialogThread"));
+  thread->init_com_with_mta(false);
+  if (!thread->Start())
+    return false;
+
+  run_state->dialog_thread = thread.release();
+  run_state->ui_message_loop = base::MessageLoop::current();
+  return true;
+}
+
+void RunOpenDialogInNewThread(const RunState& run_state,
+                              electron::NativeWindow* parent,
+                              const std::string& title,
+                              const base::FilePath& default_path,
+                              const Filters& filters,
+                              int properties,
+                              const OpenDialogCallback& callback) {
+  std::vector<base::FilePath> paths;
+  bool result = ShowOpenDialog(parent, title, default_path, filters, properties,
+                               &paths);
+  run_state.ui_message_loop->PostTask(FROM_HERE,
+                                      base::Bind(callback, result, paths));
+  run_state.ui_message_loop->DeleteSoon(FROM_HERE, run_state.dialog_thread);
+}
+
+void RunSaveDialogInNewThread(const RunState& run_state,
+                              electron::NativeWindow* parent,
+                              const std::string& title,
+                              const base::FilePath& default_path,
+                              const Filters& filters,
+                              const SaveDialogCallback& callback) {
+  base::FilePath path;
+  bool result = ShowSaveDialog(parent, title, default_path, filters, &path);
+  run_state.ui_message_loop->PostTask(FROM_HERE,
+                                      base::Bind(callback, result, path));
+  run_state.ui_message_loop->DeleteSoon(FROM_HERE, run_state.dialog_thread);
+}
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  int options = FOS_FORCEFILESYSTEM | FOS_FILEMUSTEXIST;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    options |= FOS_PICKFOLDERS;
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    options |= FOS_ALLOWMULTISELECT;
+
+  FileDialog<CShellFileOpenDialog> open_dialog(
+      default_path, title, filters, options);
+  if (!open_dialog.Show(parent_window))
+    return false;
+
+  ATL::CComPtr<IShellItemArray> items;
+  HRESULT hr = static_cast<IFileOpenDialog*>(open_dialog.GetPtr())->GetResults(
+      &items);
+  if (FAILED(hr))
+    return false;
+
+  ATL::CComPtr<IShellItem> item;
+  DWORD count = 0;
+  hr = items->GetCount(&count);
+  if (FAILED(hr))
+    return false;
+
+  paths->reserve(count);
+  for (DWORD i = 0; i < count; ++i) {
+    hr = items->GetItemAt(i, &item);
+    if (FAILED(hr))
+      return false;
+
+    wchar_t file_name[MAX_PATH];
+    hr = CShellFileOpenDialog::GetFileNameFromShellItem(
+        item, SIGDN_FILESYSPATH, file_name, MAX_PATH);
+    if (FAILED(hr))
+      return false;
+
+    paths->push_back(base::FilePath(file_name));
+  }
+
+  return true;
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback) {
+  RunState run_state;
+  if (!CreateDialogThread(&run_state)) {
+    callback.Run(false, std::vector<base::FilePath>());
+    return;
+  }
+
+  run_state.dialog_thread->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunOpenDialogInNewThread, run_state, parent, title,
+                 default_path, filters, properties, callback));
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  FileDialog<CShellFileSaveDialog> save_dialog(
+      default_path, title, filters,
+      FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_OVERWRITEPROMPT);
+  if (!save_dialog.Show(parent_window))
+    return false;
+
+  wchar_t buffer[MAX_PATH];
+  HRESULT hr = save_dialog.GetDialog()->GetFilePath(buffer, MAX_PATH);
+  if (FAILED(hr))
+    return false;
+
+  *path = base::FilePath(buffer);
+  return true;
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback) {
+  RunState run_state;
+  if (!CreateDialogThread(&run_state)) {
+    callback.Run(false, base::FilePath());
+    return;
+  }
+
+  run_state.dialog_thread->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunSaveDialogInNewThread, run_state, parent, title,
+                 default_path, filters, callback));
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 03c1228023f9c025fed69e3724af7080a2508d04 electron/browser/ui/message_box.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
+#define ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/strings/string16.h"
+
+namespace gfx {
+class ImageSkia;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+enum MessageBoxType {
+  MESSAGE_BOX_TYPE_NONE = 0,
+  MESSAGE_BOX_TYPE_INFORMATION,
+  MESSAGE_BOX_TYPE_WARNING,
+  MESSAGE_BOX_TYPE_ERROR,
+  MESSAGE_BOX_TYPE_QUESTION,
+};
+
+enum MessageBoxOptions {
+  MESSAGE_BOX_NONE    = 0,
+  MESSAGE_BOX_NO_LINK = 1 << 0,
+};
+
+typedef base::Callback<void(int code)> MessageBoxCallback;
+
+int ShowMessageBox(NativeWindow* parent_window,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int cancel_id,
+                   int default_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon);
+
+void ShowMessageBox(NativeWindow* parent_window,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback);
+
+// Like ShowMessageBox with simplest settings, but safe to call at very early
+// stage of application.
+void ShowErrorBox(const base::string16& title, const base::string16& content);
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
added in remote
  their  100644 d1f1187dc14a1ab2d71fecc2e5cf206a7d1b07c0 electron/browser/ui/message_box_gtk.cc
@@ -0,0 +1,209 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_signal.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "chrome/browser/ui/libgtk2ui/skia_utils_gtk2.h"
+#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
+
+#define ANSI_FOREGROUND_RED   "\x1b[31m"
+#define ANSI_FOREGROUND_BLACK "\x1b[30m"
+#define ANSI_TEXT_BOLD        "\x1b[1m"
+#define ANSI_BACKGROUND_GRAY  "\x1b[47m"
+#define ANSI_RESET            "\x1b[0m"
+
+namespace electron {
+
+namespace {
+
+class GtkMessageBox {
+ public:
+  GtkMessageBox(NativeWindow* parent_window,
+                MessageBoxType type,
+                const std::vector<std::string>& buttons,
+                int default_id,
+                int cancel_id,
+                const std::string& title,
+                const std::string& message,
+                const std::string& detail,
+                const gfx::ImageSkia& icon)
+      : dialog_scope_(parent_window),
+        cancel_id_(cancel_id) {
+    // Create dialog.
+    dialog_ = gtk_message_dialog_new(
+        nullptr,  // parent
+        static_cast<GtkDialogFlags>(0),  // no flags
+        GetMessageType(type),  // type
+        GTK_BUTTONS_NONE,  // no buttons
+        "%s", message.c_str());
+    if (!detail.empty())
+      gtk_message_dialog_format_secondary_text(
+          GTK_MESSAGE_DIALOG(dialog_), "%s", detail.c_str());
+    if (!title.empty())
+      gtk_window_set_title(GTK_WINDOW(dialog_), title.c_str());
+
+    // Set dialog's icon.
+    if (!icon.isNull()) {
+      GdkPixbuf* pixbuf = libgtk2ui::GdkPixbufFromSkBitmap(*icon.bitmap());
+      GtkWidget* image = gtk_image_new_from_pixbuf(pixbuf);
+      gtk_message_dialog_set_image(GTK_MESSAGE_DIALOG(dialog_), image);
+      gtk_widget_show(image);
+      g_object_unref(pixbuf);
+    }
+
+    // Add buttons.
+    for (size_t i = 0; i < buttons.size(); ++i) {
+      GtkWidget* button = gtk_dialog_add_button(
+          GTK_DIALOG(dialog_), TranslateToStock(i, buttons[i]), i);
+      if (static_cast<int>(i) == default_id)
+        gtk_widget_grab_focus(button);
+    }
+
+    // Parent window.
+    if (parent_window) {
+      gfx::NativeWindow window = parent_window->GetNativeWindow();
+      libgtk2ui::SetGtkTransientForAura(dialog_, window);
+    }
+  }
+
+  ~GtkMessageBox() {
+    gtk_widget_destroy(dialog_);
+  }
+
+  GtkMessageType GetMessageType(MessageBoxType type) {
+    switch (type) {
+      case MESSAGE_BOX_TYPE_INFORMATION:
+        return GTK_MESSAGE_INFO;
+      case MESSAGE_BOX_TYPE_WARNING:
+        return GTK_MESSAGE_WARNING;
+      case MESSAGE_BOX_TYPE_QUESTION:
+        return GTK_MESSAGE_QUESTION;
+      case MESSAGE_BOX_TYPE_ERROR:
+        return GTK_MESSAGE_ERROR;
+      default:
+        return GTK_MESSAGE_OTHER;
+    }
+  }
+
+  const char* TranslateToStock(int id, const std::string& text) {
+    std::string lower = base::ToLowerASCII(text);
+    if (lower == "cancel")
+      return GTK_STOCK_CANCEL;
+    else if (lower == "no")
+      return GTK_STOCK_NO;
+    else if (lower == "ok")
+      return GTK_STOCK_OK;
+    else if (lower == "yes")
+      return GTK_STOCK_YES;
+    else
+      return text.c_str();
+  }
+
+  void Show() {
+    gtk_widget_show_all(dialog_);
+    // We need to call gtk_window_present after making the widgets visible to
+    // make sure window gets correctly raised and gets focus.
+    int time = views::X11DesktopHandler::get()->wm_user_time_ms();
+    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
+  }
+
+  int RunSynchronous() {
+    gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
+    Show();
+    int response = gtk_dialog_run(GTK_DIALOG(dialog_));
+    if (response < 0)
+      return cancel_id_;
+    else
+      return response;
+  }
+
+  void RunAsynchronous(const MessageBoxCallback& callback) {
+    callback_ = callback;
+    g_signal_connect(dialog_, "delete-event",
+                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
+    g_signal_connect(dialog_, "response",
+                     G_CALLBACK(OnResponseDialogThunk), this);
+    Show();
+  }
+
+  CHROMEGTK_CALLBACK_1(GtkMessageBox, void, OnResponseDialog, int);
+
+ private:
+  electron::NativeWindow::DialogScope dialog_scope_;
+
+  // The id to return when the dialog is closed without pressing buttons.
+  int cancel_id_;
+
+  GtkWidget* dialog_;
+  MessageBoxCallback callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(GtkMessageBox);
+};
+
+void GtkMessageBox::OnResponseDialog(GtkWidget* widget, int response) {
+  gtk_widget_hide_all(dialog_);
+
+  if (response < 0)
+    callback_.Run(cancel_id_);
+  else
+    callback_.Run(response);
+  delete this;
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  return GtkMessageBox(parent, type, buttons, default_id, cancel_id,
+                       title, message, detail, icon).RunSynchronous();
+}
+
+void ShowMessageBox(NativeWindow* parent,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  (new GtkMessageBox(parent, type, buttons, default_id, cancel_id,
+                     title, message, detail, icon))->RunAsynchronous(callback);
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  if (Browser::Get()->is_ready()) {
+    GtkMessageBox(nullptr, MESSAGE_BOX_TYPE_ERROR, { "OK" }, -1, 0, "Error",
+                  base::UTF16ToUTF8(title).c_str(),
+                  base::UTF16ToUTF8(content).c_str(),
+                  gfx::ImageSkia()).RunSynchronous();
+  } else {
+    fprintf(stderr,
+            ANSI_TEXT_BOLD ANSI_BACKGROUND_GRAY
+            ANSI_FOREGROUND_RED  "%s\n"
+            ANSI_FOREGROUND_BLACK "%s"
+            ANSI_RESET "\n",
+            base::UTF16ToUTF8(title).c_str(),
+            base::UTF16ToUTF8(content).c_str());
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 34455d42dabd42312ad8fec114d08d832a996a8f electron/browser/ui/message_box_mac.mm
@@ -0,0 +1,182 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#import <Cocoa/Cocoa.h>
+
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/mac/mac_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "skia/ext/skia_utils_mac.h"
+
+@interface ModalDelegate : NSObject {
+ @private
+  electron::MessageBoxCallback callback_;
+  NSAlert* alert_;
+  bool callEndModal_;
+}
+- (id)initWithCallback:(const electron::MessageBoxCallback&)callback
+              andAlert:(NSAlert*)alert
+          callEndModal:(bool)flag;
+@end
+
+@implementation ModalDelegate
+
+- (id)initWithCallback:(const electron::MessageBoxCallback&)callback
+              andAlert:(NSAlert*)alert
+          callEndModal:(bool)flag {
+  if ((self = [super init])) {
+    callback_ = callback;
+    alert_ = alert;
+    callEndModal_ = flag;
+  }
+  return self;
+}
+
+- (void)alertDidEnd:(NSAlert*)alert
+         returnCode:(NSInteger)returnCode
+        contextInfo:(void*)contextInfo {
+  callback_.Run(returnCode);
+  [alert_ release];
+  [self release];
+
+  if (callEndModal_)
+    [NSApp stopModal];
+}
+
+@end
+
+namespace electron {
+
+namespace {
+
+NSAlert* CreateNSAlert(NativeWindow* parent_window,
+                       MessageBoxType type,
+                       const std::vector<std::string>& buttons,
+                       int default_id,
+                       const std::string& title,
+                       const std::string& message,
+                       const std::string& detail,
+                       const gfx::ImageSkia& icon) {
+  // Ignore the title; it's the window title on other platforms and ignorable.
+  NSAlert* alert = [[NSAlert alloc] init];
+  [alert setMessageText:base::SysUTF8ToNSString(message)];
+  [alert setInformativeText:base::SysUTF8ToNSString(detail)];
+
+  switch (type) {
+    case MESSAGE_BOX_TYPE_INFORMATION:
+      [alert setAlertStyle:NSInformationalAlertStyle];
+      break;
+    case MESSAGE_BOX_TYPE_WARNING:
+      [alert setAlertStyle:NSWarningAlertStyle];
+      break;
+    default:
+      break;
+  }
+
+  for (size_t i = 0; i < buttons.size(); ++i) {
+    NSString* title = base::SysUTF8ToNSString(buttons[i]);
+    // An empty title causes crash on OS X.
+    if (buttons[i].empty())
+      title = @"(empty)";
+    NSButton* button = [alert addButtonWithTitle:title];
+    [button setTag:i];
+  }
+
+  NSArray* ns_buttons = [alert buttons];
+  if (default_id >= 0 && default_id < static_cast<int>([ns_buttons count])) {
+    // Focus the button at default_id if the user opted to do so.
+    // The first button added gets set as the default selected.
+    // So remove that default, and make the requested button the default.
+    [[ns_buttons objectAtIndex:0] setKeyEquivalent:@""];
+    [[ns_buttons objectAtIndex:default_id] setKeyEquivalent:@"\r"];
+  }
+
+  if (!icon.isNull()) {
+    NSImage* image = skia::SkBitmapToNSImageWithColorSpace(
+        *icon.bitmap(), base::mac::GetGenericRGBColorSpace());
+    [alert setIcon:image];
+  }
+
+  return alert;
+}
+
+void SetReturnCode(int* ret_code, int result) {
+  *ret_code = result;
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent_window,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  NSAlert* alert = CreateNSAlert(
+      parent_window, type, buttons, default_id, title, message,
+      detail, icon);
+
+  // Use runModal for synchronous alert without parent, since we don't have a
+  // window to wait for.
+  if (!parent_window || !parent_window->GetNativeWindow())
+    return [[alert autorelease] runModal];
+
+  int ret_code = -1;
+  ModalDelegate* delegate = [[ModalDelegate alloc]
+      initWithCallback:base::Bind(&SetReturnCode, &ret_code)
+              andAlert:alert
+          callEndModal:true];
+
+  NSWindow* window = parent_window->GetNativeWindow();
+  [alert beginSheetModalForWindow:window
+                    modalDelegate:delegate
+                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
+                      contextInfo:nil];
+
+  [NSApp runModalForWindow:window];
+  return ret_code;
+}
+
+void ShowMessageBox(NativeWindow* parent_window,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  NSAlert* alert = CreateNSAlert(
+      parent_window, type, buttons, default_id, title, message,
+      detail, icon);
+  ModalDelegate* delegate = [[ModalDelegate alloc] initWithCallback:callback
+                                                           andAlert:alert
+                                                       callEndModal:false];
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : nil;
+  [alert beginSheetModalForWindow:window
+                    modalDelegate:delegate
+                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
+                      contextInfo:nil];
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  NSAlert* alert = [[NSAlert alloc] init];
+  [alert setMessageText:base::SysUTF16ToNSString(title)];
+  [alert setInformativeText:base::SysUTF16ToNSString(content)];
+  [alert setAlertStyle:NSWarningAlertStyle];
+  [alert runModal];
+  [alert release];
+}
+
+}  // namespace electron
added in remote
  their  100644 23588526adb24381e4b76704ebaa7a6b550d5be0 electron/browser/ui/message_box_win.cc
@@ -0,0 +1,244 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#include <windows.h>
+#include <commctrl.h>
+
+#include <map>
+#include <vector>
+
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window_views.h"
+#include "base/callback.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread.h"
+#include "base/win/scoped_gdi_object.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/gfx/icon_util.h"
+
+namespace electron {
+
+namespace {
+
+// Small command ID values are already taken by Windows, we have to start from
+// a large number to avoid conflicts with Windows.
+const int kIDStart = 100;
+
+// Get the common ID from button's name.
+struct CommonButtonID {
+  int button;
+  int id;
+};
+CommonButtonID GetCommonID(const base::string16& button) {
+  base::string16 lower = base::ToLowerASCII(button);
+  if (lower == L"ok")
+    return { TDCBF_OK_BUTTON, IDOK };
+  else if (lower == L"yes")
+    return { TDCBF_YES_BUTTON, IDYES };
+  else if (lower == L"no")
+    return { TDCBF_NO_BUTTON, IDNO };
+  else if (lower == L"cancel")
+    return { TDCBF_CANCEL_BUTTON, IDCANCEL };
+  else if (lower == L"retry")
+    return { TDCBF_RETRY_BUTTON, IDRETRY };
+  else if (lower == L"close")
+    return { TDCBF_CLOSE_BUTTON, IDCLOSE };
+  return { -1, -1 };
+}
+
+// Determine whether the buttons are common buttons, if so map common ID
+// to button ID.
+void MapToCommonID(const std::vector<base::string16>& buttons,
+                   std::map<int, int>* id_map,
+                   TASKDIALOG_COMMON_BUTTON_FLAGS* button_flags,
+                   std::vector<TASKDIALOG_BUTTON>* dialog_buttons) {
+  for (size_t i = 0; i < buttons.size(); ++i) {
+    auto common = GetCommonID(buttons[i]);
+    if (common.button != -1) {
+      // It is a common button.
+      (*id_map)[common.id] = i;
+      (*button_flags) |= common.button;
+    } else {
+      // It is a custom button.
+      dialog_buttons->push_back({i + kIDStart, buttons[i].c_str()});
+    }
+  }
+}
+
+int ShowMessageBoxUTF16(HWND parent,
+                        MessageBoxType type,
+                        const std::vector<base::string16>& buttons,
+                        int default_id,
+                        int cancel_id,
+                        int options,
+                        const base::string16& title,
+                        const base::string16& message,
+                        const base::string16& detail,
+                        const gfx::ImageSkia& icon) {
+  TASKDIALOG_FLAGS flags =
+      TDF_SIZE_TO_CONTENT |  // Show all content.
+      TDF_ALLOW_DIALOG_CANCELLATION;  // Allow canceling the dialog.
+
+  TASKDIALOGCONFIG config = { 0 };
+  config.cbSize     = sizeof(config);
+  config.hwndParent = parent;
+  config.hInstance  = GetModuleHandle(NULL);
+  config.dwFlags    = flags;
+
+  if (default_id > 0)
+    config.nDefaultButton = kIDStart + default_id;
+
+  // TaskDialogIndirect doesn't allow empty name, if we set empty title it
+  // will show "electron.exe" in title.
+  base::string16 app_name = base::UTF8ToUTF16(Browser::Get()->GetName());
+  if (title.empty())
+    config.pszWindowTitle = app_name.c_str();
+  else
+    config.pszWindowTitle = title.c_str();
+
+  base::win::ScopedHICON hicon;
+  if (!icon.isNull()) {
+    hicon = IconUtil::CreateHICONFromSkBitmap(*icon.bitmap());
+    config.dwFlags |= TDF_USE_HICON_MAIN;
+    config.hMainIcon = hicon.get();
+  } else {
+    // Show icon according to dialog's type.
+    switch (type) {
+      case MESSAGE_BOX_TYPE_INFORMATION:
+      case MESSAGE_BOX_TYPE_QUESTION:
+        config.pszMainIcon = TD_INFORMATION_ICON;
+        break;
+      case MESSAGE_BOX_TYPE_WARNING:
+        config.pszMainIcon = TD_WARNING_ICON;
+        break;
+      case MESSAGE_BOX_TYPE_ERROR:
+        config.pszMainIcon = TD_ERROR_ICON;
+        break;
+    }
+  }
+
+  // If "detail" is empty then don't make message hilighted.
+  if (detail.empty()) {
+    config.pszContent = message.c_str();
+  } else {
+    config.pszMainInstruction = message.c_str();
+    config.pszContent = detail.c_str();
+  }
+
+  // Iterate through the buttons, put common buttons in dwCommonButtons
+  // and custom buttons in pButtons.
+  std::map<int, int> id_map;
+  std::vector<TASKDIALOG_BUTTON> dialog_buttons;
+  if (options & MESSAGE_BOX_NO_LINK) {
+    for (size_t i = 0; i < buttons.size(); ++i)
+      dialog_buttons.push_back({i + kIDStart, buttons[i].c_str()});
+  } else {
+    MapToCommonID(buttons, &id_map, &config.dwCommonButtons, &dialog_buttons);
+  }
+  if (dialog_buttons.size() > 0) {
+    config.pButtons = &dialog_buttons.front();
+    config.cButtons = dialog_buttons.size();
+    if (!(options & MESSAGE_BOX_NO_LINK))
+      config.dwFlags |= TDF_USE_COMMAND_LINKS;  // custom buttons as links.
+  }
+
+  int id = 0;
+  TaskDialogIndirect(&config, &id, NULL, NULL);
+  if (id_map.find(id) != id_map.end())  // common button.
+    return id_map[id];
+  else if (id >= kIDStart)  // custom button.
+    return id - kIDStart;
+  else
+    return cancel_id;
+}
+
+void RunMessageBoxInNewThread(base::Thread* thread,
+                              NativeWindow* parent,
+                              MessageBoxType type,
+                              const std::vector<std::string>& buttons,
+                              int default_id,
+                              int cancel_id,
+                              int options,
+                              const std::string& title,
+                              const std::string& message,
+                              const std::string& detail,
+                              const gfx::ImageSkia& icon,
+                              const MessageBoxCallback& callback) {
+  int result = ShowMessageBox(parent, type, buttons, default_id,
+                              cancel_id, options, title, message, detail, icon);
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI, FROM_HERE, base::Bind(callback, result));
+  content::BrowserThread::DeleteSoon(
+      content::BrowserThread::UI, FROM_HERE, thread);
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  std::vector<base::string16> utf16_buttons;
+  for (const auto& button : buttons)
+    utf16_buttons.push_back(base::UTF8ToUTF16(button));
+
+  HWND hwnd_parent = parent ?
+      static_cast<electron::NativeWindowViews*>(parent)->GetAcceleratedWidget() :
+      NULL;
+
+  NativeWindow::DialogScope dialog_scope(parent);
+  return ShowMessageBoxUTF16(hwnd_parent,
+                             type,
+                             utf16_buttons,
+                             default_id,
+                             cancel_id,
+                             options,
+                             base::UTF8ToUTF16(title),
+                             base::UTF8ToUTF16(message),
+                             base::UTF8ToUTF16(detail),
+                             icon);
+}
+
+void ShowMessageBox(NativeWindow* parent,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  scoped_ptr<base::Thread> thread(
+      new base::Thread(ELECTRON_PRODUCT_NAME "MessageBoxThread"));
+  thread->init_com_with_mta(false);
+  if (!thread->Start()) {
+    callback.Run(cancel_id);
+    return;
+  }
+
+  base::Thread* unretained = thread.release();
+  unretained->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunMessageBoxInNewThread, base::Unretained(unretained),
+                 parent, type, buttons, default_id, cancel_id, options, title,
+                 message, detail, icon, callback));
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  ShowMessageBoxUTF16(NULL, MESSAGE_BOX_TYPE_ERROR, {}, -1, 0, 0, L"Error",
+                      title, content, gfx::ImageSkia());
+}
+
+}  // namespace electron
added in remote
  their  100644 8000863912f27027b709548508e752cab218f859 electron/browser/ui/tray_icon.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon.h"
+
+namespace electron {
+
+TrayIcon::TrayIcon() {
+}
+
+TrayIcon::~TrayIcon() {
+}
+
+void TrayIcon::SetPressedImage(const gfx::Image& image) {
+}
+
+void TrayIcon::SetTitle(const std::string& title) {
+}
+
+void TrayIcon::SetHighlightMode(bool highlight) {
+}
+
+void TrayIcon::DisplayBalloon(const gfx::Image& icon,
+                              const base::string16& title,
+                              const base::string16& contents) {
+}
+
+void TrayIcon::PopUpContextMenu(const gfx::Point& pos,
+                                ui::SimpleMenuModel* menu_model) {
+}
+
+void TrayIcon::NotifyClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyDoubleClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_,
+                    OnDoubleClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyBalloonShow() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonShow());
+}
+
+void TrayIcon::NotifyBalloonClicked() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonClicked());
+}
+
+void TrayIcon::NotifyBalloonClosed() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonClosed());
+}
+
+void TrayIcon::NotifyRightClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_,
+                    OnRightClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyDrop() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDrop());
+}
+
+void TrayIcon::NotifyDropFiles(const std::vector<std::string>& files) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDropFiles(files));
+}
+
+void TrayIcon::NotifyDragEntered() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragEntered());
+}
+
+void TrayIcon::NotifyDragExited() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragExited());
+}
+
+void TrayIcon::NotifyDragEnded() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragEnded());
+}
+
+}  // namespace electron
added in remote
  their  100644 c5f3595ffe3f3983fa54935d2a42340bfb699128 electron/browser/ui/tray_icon.h
@@ -0,0 +1,83 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/tray_icon_observer.h"
+#include "base/observer_list.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace electron {
+
+class TrayIcon {
+ public:
+  static TrayIcon* Create();
+
+  virtual ~TrayIcon();
+
+  // Sets the image associated with this status icon.
+  virtual void SetImage(const gfx::Image& image) = 0;
+
+  // Sets the image associated with this status icon when pressed.
+  virtual void SetPressedImage(const gfx::Image& image);
+
+  // Sets the hover text for this status icon. This is also used as the label
+  // for the menu item which is created as a replacement for the status icon
+  // click action on platforms that do not support custom click actions for the
+  // status icon (e.g. Ubuntu Unity).
+  virtual void SetToolTip(const std::string& tool_tip) = 0;
+
+  // Sets the title displayed aside of the status icon in the status bar. This
+  // only works on OS X.
+  virtual void SetTitle(const std::string& title);
+
+  // Sets whether the status icon is highlighted when it is clicked. This only
+  // works on OS X.
+  virtual void SetHighlightMode(bool highlight);
+
+  // Displays a notification balloon with the specified contents.
+  // Depending on the platform it might not appear by the icon tray.
+  virtual void DisplayBalloon(const gfx::Image& icon,
+                              const base::string16& title,
+                              const base::string16& contents);
+
+  // Popups the menu.
+  virtual void PopUpContextMenu(const gfx::Point& pos,
+                                ui::SimpleMenuModel* menu_model);
+
+  // Set the context menu for this icon.
+  virtual void SetContextMenu(ui::SimpleMenuModel* menu_model) = 0;
+
+  void AddObserver(TrayIconObserver* obs) { observers_.AddObserver(obs); }
+  void RemoveObserver(TrayIconObserver* obs) { observers_.RemoveObserver(obs); }
+  void NotifyClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
+  void NotifyDoubleClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
+  void NotifyBalloonShow();
+  void NotifyBalloonClicked();
+  void NotifyBalloonClosed();
+  void NotifyRightClicked(const gfx::Rect& bounds = gfx::Rect(),
+                          int modifiers = 0);
+  void NotifyDrop();
+  void NotifyDropFiles(const std::vector<std::string>& files);
+  void NotifyDragEntered();
+  void NotifyDragExited();
+  void NotifyDragEnded();
+
+ protected:
+  TrayIcon();
+
+ private:
+  base::ObserverList<TrayIconObserver> observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIcon);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_H_
added in remote
  their  100644 b7e893c18054c5dc094412942497861d8539efd7 electron/browser/ui/tray_icon_cocoa.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include <string>
+
+#include "electron/browser/ui/electron_menu_model.h"
+#include "electron/browser/ui/tray_icon.h"
+#include "base/mac/scoped_nsobject.h"
+
+@class ElectronMenuController;
+@class StatusItemView;
+
+namespace electron {
+
+class TrayIconCocoa : public TrayIcon,
+                      public ElectronMenuModel::Observer {
+ public:
+  TrayIconCocoa();
+  virtual ~TrayIconCocoa();
+
+  void SetImage(const gfx::Image& image) override;
+  void SetPressedImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void SetTitle(const std::string& title) override;
+  void SetHighlightMode(bool highlight) override;
+  void PopUpContextMenu(const gfx::Point& pos,
+                        ui::SimpleMenuModel* menu_model) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ protected:
+  // ElectronMenuModel::Observer:
+  void MenuClosed() override;
+
+ private:
+  // Atom custom view for NSStatusItem.
+  base::scoped_nsobject<StatusItemView> status_item_view_;
+
+  // Status menu shown when right-clicking the system icon.
+  base::scoped_nsobject<ElectronMenuController> menu_;
+
+  // Used for unregistering observer.
+  ElectronMenuModel* menu_model_;  // weak ref.
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIconCocoa);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
added in remote
  their  100644 b191951c1214f2057fd00afe38148cb561913b2a electron/browser/ui/tray_icon_cocoa.mm
@@ -0,0 +1,391 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon_cocoa.h"
+
+#include "electron/browser/ui/cocoa/electron_menu_controller.h"
+#include "base/strings/sys_string_conversions.h"
+#include "ui/events/cocoa/cocoa_event_utils.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/screen.h"
+
+namespace {
+
+// By default, OS X sets 4px to tray image as left and right padding margin.
+const CGFloat kHorizontalMargin = 4;
+// OS X tends to make the title 2px lower.
+const CGFloat kVerticalTitleMargin = 2;
+
+}  //  namespace
+
+@interface StatusItemView : NSView {
+  electron::TrayIconCocoa* trayIcon_; // weak
+  ElectronMenuController* menuController_; // weak
+  BOOL isHighlightEnable_;
+  BOOL forceHighlight_;
+  BOOL inMouseEventSequence_;
+  base::scoped_nsobject<NSImage> image_;
+  base::scoped_nsobject<NSImage> alternateImage_;
+  base::scoped_nsobject<NSImageView> image_view_;
+  base::scoped_nsobject<NSString> title_;
+  base::scoped_nsobject<NSStatusItem> statusItem_;
+}
+
+@end  // @interface StatusItemView
+
+@implementation StatusItemView
+
+- (id)initWithImage:(NSImage*)image icon:(electron::TrayIconCocoa*)icon {
+  image_.reset([image copy]);
+  trayIcon_ = icon;
+  isHighlightEnable_ = YES;
+  forceHighlight_ = NO;
+  inMouseEventSequence_ = NO;
+
+  if ((self = [super initWithFrame: CGRectZero])) {
+    // Setup the image view.
+    image_view_.reset([[NSImageView alloc] initWithFrame: CGRectZero]);
+    [image_view_ setImageScaling:NSImageScaleNone];
+    [image_view_ setImageAlignment:NSImageAlignCenter];
+    [self addSubview:image_view_];
+
+    // Unregister image_view_ as a dragged destination, allows its parent view
+    // (StatusItemView) handle dragging events.
+    [image_view_ unregisterDraggedTypes];
+    [self registerForDraggedTypes: @[NSFilenamesPboardType]];
+
+    // Create the status item.
+    NSStatusItem * item = [[NSStatusBar systemStatusBar]
+                            statusItemWithLength:NSVariableStatusItemLength];
+    statusItem_.reset([item retain]);
+    [statusItem_ setView:self];
+
+    // Finalize setup by sizing our views
+    [self updateDimensions];
+  }
+  return self;
+}
+
+- (void)updateDimensions {
+  NSStatusBar * bar = [NSStatusBar systemStatusBar];
+  [image_view_ setFrame: NSMakeRect(0, 0, [self iconWidth], [bar thickness])];
+  [self setFrame: NSMakeRect(0, 0, [self fullWidth], [bar thickness])];
+  [self setNeedsDisplay:YES];
+}
+
+- (void)removeItem {
+  [[NSStatusBar systemStatusBar] removeStatusItem:statusItem_];
+  statusItem_.reset();
+}
+
+- (void)drawRect:(NSRect)dirtyRect {
+  // Draw the tray icon and title that align with NSStatusItem, layout:
+  //   ----------------
+  //   | icon | title |
+  ///  ----------------
+
+  // Draw background.
+  BOOL highlight = [self shouldHighlight];
+  CGFloat thickness = [[statusItem_ statusBar] thickness];
+  [statusItem_ drawStatusBarBackgroundInRect:self.bounds withHighlight:highlight];
+
+  // Make use of NSImageView to draw the image, which can correctly draw
+  // template image under dark menu bar.
+  if (inMouseEventSequence_ && alternateImage_ &&
+      [image_view_ image] != alternateImage_.get()) {
+    [image_view_ setImage:alternateImage_];
+  } else if ([image_view_ image] != image_.get()) {
+    [image_view_ setImage:image_];
+  }
+
+  if (title_) {
+    // Highlight the text when icon is highlighted or in dark mode.
+    highlight |= [self isDarkMode];
+    // Draw title.
+    NSRect titleDrawRect = NSMakeRect(
+        [self iconWidth], -kVerticalTitleMargin, [self titleWidth], thickness);
+    [title_ drawInRect:titleDrawRect
+        withAttributes:[self titleAttributesWithHighlight:highlight]];
+  }
+}
+
+- (BOOL)isDarkMode {
+  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
+  NSString* mode = [defaults stringForKey:@"AppleInterfaceStyle"];
+  return mode && [mode isEqualToString:@"Dark"];
+}
+
+// The width of the full status item.
+- (CGFloat)fullWidth {
+  if (title_)
+    return [self iconWidth] + [self titleWidth] + kHorizontalMargin;
+  else
+    return [self iconWidth];
+}
+
+// The width of the icon.
+- (CGFloat)iconWidth {
+  CGFloat thickness = [[NSStatusBar systemStatusBar] thickness];
+  CGFloat imageHeight = [image_ size].height;
+  CGFloat imageWidth = [image_ size].width;
+  CGFloat iconWidth = imageWidth;
+  if (imageWidth < thickness) {
+    // Image's width must be larger than menu bar's height.
+    iconWidth = thickness;
+  } else {
+    CGFloat verticalMargin = thickness - imageHeight;
+    // Image must have same horizontal vertical margin.
+    if (verticalMargin > 0 && imageWidth != imageHeight)
+      iconWidth = imageWidth + verticalMargin;
+    CGFloat horizontalMargin = thickness - imageWidth;
+    // Image must have at least kHorizontalMargin horizontal margin on each
+    // side.
+    if (horizontalMargin < 2 * kHorizontalMargin)
+      iconWidth = imageWidth + 2 * kHorizontalMargin;
+  }
+  return iconWidth;
+}
+
+// The width of the title.
+- (CGFloat)titleWidth {
+  if (!title_)
+     return 0;
+  base::scoped_nsobject<NSAttributedString> attributes(
+      [[NSAttributedString alloc] initWithString:title_
+                                      attributes:[self titleAttributes]]);
+  return [attributes size].width;
+}
+
+- (NSDictionary*)titleAttributesWithHighlight:(BOOL)highlight {
+  NSFont* font = [NSFont menuBarFontOfSize:0];
+  NSColor* foregroundColor = highlight ?
+      [NSColor whiteColor] :
+      [NSColor colorWithRed:0.265625 green:0.25390625 blue:0.234375 alpha:1.0];
+  return @{
+    NSFontAttributeName: font,
+    NSForegroundColorAttributeName: foregroundColor
+  };
+}
+
+- (NSDictionary*)titleAttributes {
+  return [self titleAttributesWithHighlight:[self isDarkMode]];
+}
+
+- (void)setImage:(NSImage*)image {
+  image_.reset([image copy]);
+  [self updateDimensions];
+}
+
+- (void)setAlternateImage:(NSImage*)image {
+  alternateImage_.reset([image copy]);
+}
+
+- (void)setHighlight:(BOOL)highlight {
+  isHighlightEnable_ = highlight;
+}
+
+- (void)setTitle:(NSString*)title {
+  if (title.length > 0) {
+    title_.reset([title copy]);
+  } else {
+    title_.reset();
+  }
+  [self updateDimensions];
+}
+
+- (void)setMenuController:(ElectronMenuController*)menu {
+  menuController_ = menu;
+}
+
+- (void)mouseDown:(NSEvent*)event {
+  inMouseEventSequence_ = YES;
+  [self setNeedsDisplay:YES];
+}
+
+- (void)mouseUp:(NSEvent*)event {
+  if (!inMouseEventSequence_) {
+     // If the menu is showing, when user clicked the tray icon, the `mouseDown`
+     // event will be dissmissed, we need to close the menu at this time.
+     [self setNeedsDisplay:YES];
+     return;
+  }
+  inMouseEventSequence_ = NO;
+
+  // Show menu when there is a context menu.
+  // NB(hokein): Make tray's behavior more like official one's.
+  // When the tray icon gets clicked quickly multiple times, the
+  // event.clickCount doesn't always return 1. Instead, it returns a value that
+  // counts the clicked times.
+  // So we don't check the clickCount here, just pop up the menu for each click
+  // event.
+  if (menuController_)
+    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
+
+  // Don't emit click events when menu is showing.
+  if (menuController_)
+    return;
+
+  // Single click event.
+  if (event.clickCount == 1)
+    trayIcon_->NotifyClicked(
+        [self getBoundsFromEvent:event],
+        ui::EventFlagsFromModifiers([event modifierFlags]));
+
+  // Double click event.
+  if (event.clickCount == 2)
+    trayIcon_->NotifyDoubleClicked(
+        [self getBoundsFromEvent:event],
+        ui::EventFlagsFromModifiers([event modifierFlags]));
+
+  [self setNeedsDisplay:YES];
+}
+
+- (void)popUpContextMenu:(ui::SimpleMenuModel*)menu_model {
+  // Show a custom menu.
+  if (menu_model) {
+    base::scoped_nsobject<ElectronMenuController> menuController(
+        [[ElectronMenuController alloc] initWithModel:menu_model]);
+    forceHighlight_ = YES;  // Should highlight when showing menu.
+    [self setNeedsDisplay:YES];
+    [statusItem_ popUpStatusItemMenu:[menuController menu]];
+    forceHighlight_ = NO;
+    [self setNeedsDisplay:YES];
+    return;
+  }
+
+  if (menuController_ && ![menuController_ isMenuOpen]) {
+    // Redraw the dray icon to show highlight if it is enabled.
+    [self setNeedsDisplay:YES];
+    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
+    // The popUpStatusItemMenu returns only after the showing menu is closed.
+    // When it returns, we need to redraw the tray icon to not show highlight.
+    [self setNeedsDisplay:YES];
+  }
+}
+
+- (void)rightMouseUp:(NSEvent*)event {
+  trayIcon_->NotifyRightClicked(
+      [self getBoundsFromEvent:event],
+      ui::EventFlagsFromModifiers([event modifierFlags]));
+}
+
+- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragEntered();
+  return NSDragOperationCopy;
+}
+
+- (void)draggingExited:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragExited();
+}
+
+- (void)draggingEnded:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragEnded();
+
+  if (NSPointInRect([sender draggingLocation], self.frame)) {
+    trayIcon_->NotifyDrop();
+    [self handleDrop:sender];
+  }
+}
+
+- (BOOL)handleDrop:(id <NSDraggingInfo>)sender {
+  NSPasteboard* pboard = [sender draggingPasteboard];
+
+  if ([[pboard types] containsObject:NSFilenamesPboardType]) {
+    std::vector<std::string> dropFiles;
+    NSArray* files = [pboard propertyListForType:NSFilenamesPboardType];
+    for (NSString* file in files)
+      dropFiles.push_back(base::SysNSStringToUTF8(file));
+    trayIcon_->NotifyDropFiles(dropFiles);
+    return YES;
+  }
+  return NO;
+}
+
+- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender {
+  return YES;
+}
+
+- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender {
+  return YES;
+}
+
+- (BOOL)shouldHighlight {
+  if (isHighlightEnable_ && forceHighlight_)
+    return true;
+  BOOL isMenuOpen = menuController_ && [menuController_ isMenuOpen];
+  return isHighlightEnable_ && (inMouseEventSequence_ || isMenuOpen);
+}
+
+- (gfx::Rect)getBoundsFromEvent:(NSEvent*)event {
+  NSRect frame = event.window.frame;
+  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
+  return bounds;
+}
+@end
+
+namespace electron {
+
+TrayIconCocoa::TrayIconCocoa() : menu_model_(nullptr) {
+}
+
+TrayIconCocoa::~TrayIconCocoa() {
+  [status_item_view_ removeItem];
+  if (menu_model_)
+    menu_model_->RemoveObserver(this);
+}
+
+void TrayIconCocoa::SetImage(const gfx::Image& image) {
+  if (status_item_view_) {
+    [status_item_view_ setImage:image.AsNSImage()];
+  } else {
+    status_item_view_.reset(
+        [[StatusItemView alloc] initWithImage:image.AsNSImage()
+                                         icon:this]);
+  }
+}
+
+void TrayIconCocoa::SetPressedImage(const gfx::Image& image) {
+  [status_item_view_ setAlternateImage:image.AsNSImage()];
+}
+
+void TrayIconCocoa::SetToolTip(const std::string& tool_tip) {
+  [status_item_view_ setToolTip:base::SysUTF8ToNSString(tool_tip)];
+}
+
+void TrayIconCocoa::SetTitle(const std::string& title) {
+  [status_item_view_ setTitle:base::SysUTF8ToNSString(title)];
+}
+
+void TrayIconCocoa::SetHighlightMode(bool highlight) {
+  [status_item_view_ setHighlight:highlight];
+}
+
+void TrayIconCocoa::PopUpContextMenu(const gfx::Point& pos,
+                                     ui::SimpleMenuModel* menu_model) {
+  [status_item_view_ popUpContextMenu:menu_model];
+}
+
+void TrayIconCocoa::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  // Substribe to MenuClosed event.
+  if (menu_model_)
+    menu_model_->RemoveObserver(this);
+  static_cast<ElectronMenuModel*>(menu_model)->AddObserver(this);
+
+  // Create native menu.
+  menu_.reset([[ElectronMenuController alloc] initWithModel:menu_model]);
+  [status_item_view_ setMenuController:menu_.get()];
+}
+
+void TrayIconCocoa::MenuClosed() {
+  [status_item_view_ setNeedsDisplay:YES];
+}
+
+// static
+TrayIcon* TrayIcon::Create() {
+  return new TrayIconCocoa;
+}
+
+}  // namespace electron
added in remote
  their  100644 65ca76a62ffa000cc8d1cbe24b24e4cac4768de6 electron/browser/ui/tray_icon_gtk.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon_gtk.h"
+
+#include "base/guid.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/libgtk2ui/app_indicator_icon.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_status_icon.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+TrayIconGtk::TrayIconGtk() {
+}
+
+TrayIconGtk::~TrayIconGtk() {
+}
+
+void TrayIconGtk::SetImage(const gfx::Image& image) {
+  if (icon_) {
+    icon_->SetImage(image.AsImageSkia());
+    return;
+  }
+
+  base::string16 empty;
+  if (libgtk2ui::AppIndicatorIcon::CouldOpen())
+    icon_.reset(new libgtk2ui::AppIndicatorIcon(
+        base::GenerateGUID(), image.AsImageSkia(), empty));
+  else
+    icon_.reset(new libgtk2ui::Gtk2StatusIcon(image.AsImageSkia(), empty));
+  icon_->set_delegate(this);
+}
+
+void TrayIconGtk::SetToolTip(const std::string& tool_tip) {
+  icon_->SetToolTip(base::UTF8ToUTF16(tool_tip));
+}
+
+void TrayIconGtk::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  icon_->UpdatePlatformContextMenu(menu_model);
+}
+
+void TrayIconGtk::OnClick() {
+  NotifyClicked();
+}
+
+bool TrayIconGtk::HasClickAction() {
+  return false;
+}
+
+// static
+TrayIcon* TrayIcon::Create() {
+  return new TrayIconGtk;
+}
+
+}  // namespace electron
added in remote
  their  100644 1f1b807c229e6d7d122f26f745da5313e2892bd3 electron/browser/ui/tray_icon_gtk.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
+
+#include <string>
+
+#include "electron/browser/ui/tray_icon.h"
+#include "ui/views/linux_ui/status_icon_linux.h"
+
+namespace views {
+class StatusIconLinux;
+}
+
+namespace electron {
+
+class TrayIconGtk : public TrayIcon,
+                    public views::StatusIconLinux::Delegate {
+ public:
+  TrayIconGtk();
+  virtual ~TrayIconGtk();
+
+  // TrayIcon:
+  void SetImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ private:
+  // views::StatusIconLinux::Delegate:
+  void OnClick() override;
+  bool HasClickAction() override;
+
+  scoped_ptr<views::StatusIconLinux> icon_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIconGtk);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
added in remote
  their  100644 cb9c8ff63d0f0eaf77713dc2e034027d19d36772 electron/browser/ui/tray_icon_observer.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
+
+#include <string>
+#include <vector>
+
+namespace gfx {
+class Rect;
+}
+
+namespace electron {
+
+class TrayIconObserver {
+ public:
+  virtual void OnClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnBalloonShow() {}
+  virtual void OnBalloonClicked() {}
+  virtual void OnBalloonClosed() {}
+  virtual void OnRightClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnDrop() {}
+  virtual void OnDropFiles(const std::vector<std::string>& files) {}
+  virtual void OnDragEntered() {}
+  virtual void OnDragExited() {}
+  virtual void OnDragEnded() {}
+
+ protected:
+  virtual ~TrayIconObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
added in remote
  their  100644 18aac4ca4afbf5bfe3e140b5565ddaea03882706 electron/browser/ui/tray_icon_win.cc
@@ -0,0 +1,16 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon.h"
+#include "electron/browser/ui/win/notify_icon_host.h"
+
+namespace electron {
+
+// static
+TrayIcon* TrayIcon::Create() {
+  static NotifyIconHost host;
+  return host.CreateNotifyIcon();
+}
+
+}  // namespace electron
added in remote
  their  100644 71b045fc76937348c7059b27670bd2709d57438a electron/browser/ui/views/frameless_view.cc
@@ -0,0 +1,118 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/frameless_view.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/aura/window.h"
+#include "ui/base/hit_test.h"
+#include "ui/views/widget/widget.h"
+#include "ui/views/widget/widget_delegate.h"
+
+namespace electron {
+
+namespace {
+
+const int kResizeInsideBoundsSize = 5;
+const int kResizeAreaCornerSize = 16;
+
+const char kViewClassName[] = "FramelessView";
+
+}  // namespace
+
+FramelessView::FramelessView() : window_(NULL), frame_(NULL) {
+}
+
+FramelessView::~FramelessView() {
+}
+
+void FramelessView::Init(NativeWindowViews* window, views::Widget* frame) {
+  window_ = window;
+  frame_ = frame;
+}
+
+int FramelessView::ResizingBorderHitTest(const gfx::Point& point) {
+  // Check the frame first, as we allow a small area overlapping the contents
+  // to be used for resize handles.
+  bool can_ever_resize = frame_->widget_delegate() ?
+      frame_->widget_delegate()->CanResize() :
+      false;
+  // Don't allow overlapping resize handles when the window is maximized or
+  // fullscreen, as it can't be resized in those states.
+  int resize_border =
+      frame_->IsMaximized() || frame_->IsFullscreen() ? 0 :
+      kResizeInsideBoundsSize;
+  return GetHTComponentForFrame(point, resize_border, resize_border,
+      kResizeAreaCornerSize, kResizeAreaCornerSize, can_ever_resize);
+}
+
+gfx::Rect FramelessView::GetBoundsForClientView() const {
+  return bounds();
+}
+
+gfx::Rect FramelessView::GetWindowBoundsForClientBounds(
+    const gfx::Rect& client_bounds) const {
+  gfx::Rect window_bounds = client_bounds;
+  // Enforce minimum size (1, 1) in case that client_bounds is passed with
+  // empty size. This could occur when the frameless window is being
+  // initialized.
+  if (window_bounds.IsEmpty()) {
+    window_bounds.set_width(1);
+    window_bounds.set_height(1);
+  }
+  return window_bounds;
+}
+
+int FramelessView::NonClientHitTest(const gfx::Point& cursor) {
+  if (frame_->IsFullscreen())
+    return HTCLIENT;
+
+  // Check for possible draggable region in the client area for the frameless
+  // window.
+  SkRegion* draggable_region = window_->draggable_region();
+  if (draggable_region && draggable_region->contains(cursor.x(), cursor.y()))
+    return HTCAPTION;
+
+  // Support resizing frameless window by dragging the border.
+  int frame_component = ResizingBorderHitTest(cursor);
+  if (frame_component != HTNOWHERE)
+    return frame_component;
+
+  return HTCLIENT;
+}
+
+void FramelessView::GetWindowMask(const gfx::Size& size,
+                                  gfx::Path* window_mask) {
+}
+
+void FramelessView::ResetWindowControls() {
+}
+
+void FramelessView::UpdateWindowIcon() {
+}
+
+void FramelessView::UpdateWindowTitle() {
+}
+
+void FramelessView::SizeConstraintsChanged() {
+}
+
+gfx::Size FramelessView::GetPreferredSize() const {
+  return frame_->non_client_view()->GetWindowBoundsForClientBounds(
+      gfx::Rect(frame_->client_view()->GetPreferredSize())).size();
+}
+
+gfx::Size FramelessView::GetMinimumSize() const {
+  return window_->GetContentSizeConstraints().GetMinimumSize();
+}
+
+gfx::Size FramelessView::GetMaximumSize() const {
+  return window_->GetContentSizeConstraints().GetMaximumSize();
+}
+
+const char* FramelessView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 050b2e2bb49e28cfd24e51c139847a3b60ffb71f electron/browser/ui/views/frameless_view.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
+
+#include "ui/views/window/non_client_view.h"
+
+namespace views {
+class Widget;
+}
+
+namespace electron {
+
+class NativeWindowViews;
+
+class FramelessView : public views::NonClientFrameView {
+ public:
+  FramelessView();
+  virtual ~FramelessView();
+
+  virtual void Init(NativeWindowViews* window, views::Widget* frame);
+
+  // Returns whether the |point| is on frameless window's resizing border.
+  int ResizingBorderHitTest(const gfx::Point& point);
+
+ protected:
+  // views::NonClientFrameView:
+  gfx::Rect GetBoundsForClientView() const override;
+  gfx::Rect GetWindowBoundsForClientBounds(
+      const gfx::Rect& client_bounds) const override;
+  int NonClientHitTest(const gfx::Point& point) override;
+  void GetWindowMask(const gfx::Size& size,
+                     gfx::Path* window_mask) override;
+  void ResetWindowControls() override;
+  void UpdateWindowIcon() override;
+  void UpdateWindowTitle() override;
+  void SizeConstraintsChanged() override;
+
+  // Overridden from View:
+  gfx::Size GetPreferredSize() const override;
+  gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
+  const char* GetClassName() const override;
+
+  // Not owned.
+  NativeWindowViews* window_;
+  views::Widget* frame_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FramelessView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
added in remote
  their  100644 71307107d11d262d7900e340bc72c69219991d69 electron/browser/ui/views/global_menu_bar_x11.cc
@@ -0,0 +1,319 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
+
+#include <X11/Xlib.h>
+
+// This conflicts with mate::Converter,
+#undef True
+#undef False
+// and V8.
+#undef None
+
+#include <dlfcn.h>
+#include <glib-object.h>
+
+#include "electron/browser/native_window_views.h"
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/accelerators/menu_label_accelerator_util_linux.h"
+#include "ui/base/models/menu_model.h"
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+
+// libdbusmenu-glib types
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_func)();
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_with_id_func)(int id);
+
+typedef int (*dbusmenu_menuitem_get_id_func)(DbusmenuMenuitem* item);
+typedef GList* (*dbusmenu_menuitem_get_children_func)(DbusmenuMenuitem* item);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_child_append_func)(
+    DbusmenuMenuitem* parent,
+    DbusmenuMenuitem* child);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    const char* value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_variant_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    GVariant* value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_bool_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    bool value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_int_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    int value);
+
+typedef struct _DbusmenuServer      DbusmenuServer;
+typedef DbusmenuServer* (*dbusmenu_server_new_func)(const char* object);
+typedef void (*dbusmenu_server_set_root_func)(DbusmenuServer* self,
+                                              DbusmenuMenuitem* root);
+
+namespace electron {
+
+namespace {
+
+// Retrieved functions from libdbusmenu-glib.
+
+// DbusmenuMenuItem methods:
+dbusmenu_menuitem_new_func menuitem_new = NULL;
+dbusmenu_menuitem_new_with_id_func menuitem_new_with_id = NULL;
+dbusmenu_menuitem_get_id_func menuitem_get_id = NULL;
+dbusmenu_menuitem_get_children_func menuitem_get_children = NULL;
+dbusmenu_menuitem_get_children_func menuitem_take_children = NULL;
+dbusmenu_menuitem_child_append_func menuitem_child_append = NULL;
+dbusmenu_menuitem_property_set_func menuitem_property_set = NULL;
+dbusmenu_menuitem_property_set_variant_func menuitem_property_set_variant =
+    NULL;
+dbusmenu_menuitem_property_set_bool_func menuitem_property_set_bool = NULL;
+dbusmenu_menuitem_property_set_int_func menuitem_property_set_int = NULL;
+
+// DbusmenuServer methods:
+dbusmenu_server_new_func server_new = NULL;
+dbusmenu_server_set_root_func server_set_root = NULL;
+
+// Properties that we set on menu items:
+const char kPropertyEnabled[] = "enabled";
+const char kPropertyLabel[] = "label";
+const char kPropertyShortcut[] = "shortcut";
+const char kPropertyType[] = "type";
+const char kPropertyToggleType[] = "toggle-type";
+const char kPropertyToggleState[] = "toggle-state";
+const char kPropertyVisible[] = "visible";
+const char kPropertyChildrenDisplay[] = "children-display";
+
+const char kToggleCheck[] = "checkmark";
+const char kToggleRadio[] = "radio";
+const char kTypeSeparator[] = "separator";
+const char kDisplaySubmenu[] = "submenu";
+
+void EnsureMethodsLoaded() {
+  static bool attempted_load = false;
+  if (attempted_load)
+    return;
+  attempted_load = true;
+
+  void* dbusmenu_lib = dlopen("libdbusmenu-glib.so", RTLD_LAZY);
+  if (!dbusmenu_lib)
+    dbusmenu_lib = dlopen("libdbusmenu-glib.so.4", RTLD_LAZY);
+  if (!dbusmenu_lib)
+    return;
+
+  // DbusmenuMenuItem methods.
+  menuitem_new = reinterpret_cast<dbusmenu_menuitem_new_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new"));
+  menuitem_new_with_id = reinterpret_cast<dbusmenu_menuitem_new_with_id_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new_with_id"));
+  menuitem_get_id = reinterpret_cast<dbusmenu_menuitem_get_id_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_id"));
+  menuitem_get_children = reinterpret_cast<dbusmenu_menuitem_get_children_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_children"));
+  menuitem_take_children =
+      reinterpret_cast<dbusmenu_menuitem_get_children_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_take_children"));
+  menuitem_child_append = reinterpret_cast<dbusmenu_menuitem_child_append_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_child_append"));
+  menuitem_property_set = reinterpret_cast<dbusmenu_menuitem_property_set_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set"));
+  menuitem_property_set_variant =
+      reinterpret_cast<dbusmenu_menuitem_property_set_variant_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_variant"));
+  menuitem_property_set_bool =
+      reinterpret_cast<dbusmenu_menuitem_property_set_bool_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_bool"));
+  menuitem_property_set_int =
+      reinterpret_cast<dbusmenu_menuitem_property_set_int_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_int"));
+
+  // DbusmenuServer methods.
+  server_new = reinterpret_cast<dbusmenu_server_new_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_server_new"));
+  server_set_root = reinterpret_cast<dbusmenu_server_set_root_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_server_set_root"));
+}
+
+ui::MenuModel* ModelForMenuItem(DbusmenuMenuitem* item) {
+  return reinterpret_cast<ui::MenuModel*>(
+      g_object_get_data(G_OBJECT(item), "model"));
+}
+
+bool GetMenuItemID(DbusmenuMenuitem* item, int *id) {
+  gpointer id_ptr = g_object_get_data(G_OBJECT(item), "menu-id");
+  if (id_ptr != NULL) {
+    *id = GPOINTER_TO_INT(id_ptr) - 1;
+    return true;
+  }
+
+  return false;
+}
+
+void SetMenuItemID(DbusmenuMenuitem* item, int id) {
+  DCHECK_GE(id, 0);
+
+  // Add 1 to the menu_id to avoid setting zero (null) to "menu-id".
+  g_object_set_data(G_OBJECT(item), "menu-id", GINT_TO_POINTER(id + 1));
+}
+
+}  // namespace
+
+GlobalMenuBarX11::GlobalMenuBarX11(NativeWindowViews* window)
+    : window_(window),
+      xid_(window_->GetNativeWindow()->GetHost()->GetAcceleratedWidget()),
+      server_(NULL) {
+  EnsureMethodsLoaded();
+  if (server_new)
+    InitServer(xid_);
+
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
+}
+
+GlobalMenuBarX11::~GlobalMenuBarX11() {
+  if (IsServerStarted())
+    g_object_unref(server_);
+
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
+}
+
+// static
+std::string GlobalMenuBarX11::GetPathForWindow(gfx::AcceleratedWidget xid) {
+  return base::StringPrintf("/com/canonical/menu/%lX", xid);
+}
+
+void GlobalMenuBarX11::SetMenu(ui::MenuModel* menu_model) {
+  if (!IsServerStarted())
+    return;
+
+  DbusmenuMenuitem* root_item = menuitem_new();
+  menuitem_property_set(root_item, kPropertyLabel, "Root");
+  menuitem_property_set_bool(root_item, kPropertyVisible, true);
+  BuildMenuFromModel(menu_model, root_item);
+
+  server_set_root(server_, root_item);
+  g_object_unref(root_item);
+}
+
+bool GlobalMenuBarX11::IsServerStarted() const {
+  return server_;
+}
+
+void GlobalMenuBarX11::InitServer(gfx::AcceleratedWidget xid) {
+  std::string path = GetPathForWindow(xid);
+  server_ = server_new(path.c_str());
+}
+
+void GlobalMenuBarX11::OnWindowMapped() {
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
+}
+
+void GlobalMenuBarX11::OnWindowUnmapped() {
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
+}
+
+void GlobalMenuBarX11::BuildMenuFromModel(ui::MenuModel* model,
+                                          DbusmenuMenuitem* parent) {
+  for (int i = 0; i < model->GetItemCount(); ++i) {
+    DbusmenuMenuitem* item = menuitem_new();
+    menuitem_property_set_bool(item, kPropertyVisible, model->IsVisibleAt(i));
+
+    ui::MenuModel::ItemType type = model->GetTypeAt(i);
+    if (type == ui::MenuModel::TYPE_SEPARATOR) {
+      menuitem_property_set(item, kPropertyType, kTypeSeparator);
+    } else {
+      std::string label = ui::ConvertAcceleratorsFromWindowsStyle(
+          base::UTF16ToUTF8(model->GetLabelAt(i)));
+      menuitem_property_set(item, kPropertyLabel, label.c_str());
+      menuitem_property_set_bool(item, kPropertyEnabled, model->IsEnabledAt(i));
+
+      g_object_set_data(G_OBJECT(item), "model", model);
+      SetMenuItemID(item, i);
+
+      if (type == ui::MenuModel::TYPE_SUBMENU) {
+        menuitem_property_set(item, kPropertyChildrenDisplay, kDisplaySubmenu);
+        g_signal_connect(item, "about-to-show",
+                         G_CALLBACK(OnSubMenuShowThunk), this);
+      } else {
+        ui::Accelerator accelerator;
+        if (model->GetAcceleratorAt(i, &accelerator))
+          RegisterAccelerator(item, accelerator);
+
+        g_signal_connect(item, "item-activated",
+                         G_CALLBACK(OnItemActivatedThunk), this);
+
+        if (type == ui::MenuModel::TYPE_CHECK ||
+            type == ui::MenuModel::TYPE_RADIO) {
+          menuitem_property_set(item, kPropertyToggleType,
+              type == ui::MenuModel::TYPE_CHECK ? kToggleCheck : kToggleRadio);
+          menuitem_property_set_int(item, kPropertyToggleState,
+              model->IsItemCheckedAt(i));
+        }
+      }
+    }
+
+    menuitem_child_append(parent, item);
+    g_object_unref(item);
+  }
+}
+
+void GlobalMenuBarX11::RegisterAccelerator(DbusmenuMenuitem* item,
+                                           const ui::Accelerator& accelerator) {
+  // A translation of libdbusmenu-gtk's menuitem_property_set_shortcut()
+  // translated from GDK types to ui::Accelerator types.
+  GVariantBuilder builder;
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
+
+  if (accelerator.IsCtrlDown())
+    g_variant_builder_add(&builder, "s", "Control");
+  if (accelerator.IsAltDown())
+    g_variant_builder_add(&builder, "s", "Alt");
+  if (accelerator.IsShiftDown())
+    g_variant_builder_add(&builder, "s", "Shift");
+
+  char* name = XKeysymToString(XKeysymForWindowsKeyCode(
+      accelerator.key_code(), false));
+  if (!name) {
+    NOTIMPLEMENTED();
+    return;
+  }
+  g_variant_builder_add(&builder, "s", name);
+
+  GVariant* inside_array = g_variant_builder_end(&builder);
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_add_value(&builder, inside_array);
+  GVariant* outside_array = g_variant_builder_end(&builder);
+
+  menuitem_property_set_variant(item, kPropertyShortcut, outside_array);
+}
+
+void GlobalMenuBarX11::OnItemActivated(DbusmenuMenuitem* item,
+                                       unsigned int timestamp) {
+  int id;
+  ui::MenuModel* model = ModelForMenuItem(item);
+  if (model && GetMenuItemID(item, &id))
+    model->ActivatedAt(id, 0);
+}
+
+void GlobalMenuBarX11::OnSubMenuShow(DbusmenuMenuitem* item) {
+  int id;
+  ui::MenuModel* model = ModelForMenuItem(item);
+  if (!model || !GetMenuItemID(item, &id))
+    return;
+
+  // Clear children.
+  GList *children = menuitem_take_children(item);
+  g_list_foreach(children, reinterpret_cast<GFunc>(g_object_unref), NULL);
+  g_list_free(children);
+
+  // Build children.
+  BuildMenuFromModel(model->GetSubmenuModelAt(id), item);
+}
+
+}  // namespace electron
added in remote
  their  100644 a6942f62d0065f000227744ac3212e1cdb05dd91 electron/browser/ui/views/global_menu_bar_x11.h
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
+#define ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "ui/base/glib/glib_signal.h"
+#include "ui/gfx/native_widget_types.h"
+
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef struct _DbusmenuServer   DbusmenuServer;
+
+namespace ui {
+class Accelerator;
+class MenuModel;
+}
+
+namespace electron {
+
+class NativeWindowViews;
+
+// Controls the Mac style menu bar on Unity.
+//
+// Unity has an Apple-like menu bar at the top of the screen that changes
+// depending on the active window. In the GTK port, we had a hidden GtkMenuBar
+// object in each GtkWindow which existed only to be scrapped by the
+// libdbusmenu-gtk code. Since we don't have GtkWindows anymore, we need to
+// interface directly with the lower level libdbusmenu-glib, which we
+// opportunistically dlopen() since not everyone is running Ubuntu.
+//
+// This class is like the chrome's corresponding one, but it generates the menu
+// from menu models instead, and it is also per-window specific.
+class GlobalMenuBarX11 {
+ public:
+  explicit GlobalMenuBarX11(NativeWindowViews* window);
+  virtual ~GlobalMenuBarX11();
+
+  // Creates the object path for DbusmenuServer which is attached to |xid|.
+  static std::string GetPathForWindow(gfx::AcceleratedWidget xid);
+
+  void SetMenu(ui::MenuModel* menu_model);
+  bool IsServerStarted() const;
+
+  // Called by NativeWindow when it show/hides.
+  void OnWindowMapped();
+  void OnWindowUnmapped();
+
+ private:
+  // Creates a DbusmenuServer.
+  void InitServer(gfx::AcceleratedWidget xid);
+
+  // Create a menu from menu model.
+  void BuildMenuFromModel(ui::MenuModel* model, DbusmenuMenuitem* parent);
+
+  // Sets the accelerator for |item|.
+  void RegisterAccelerator(DbusmenuMenuitem* item,
+                           const ui::Accelerator& accelerator);
+
+  CHROMEG_CALLBACK_1(GlobalMenuBarX11, void, OnItemActivated, DbusmenuMenuitem*,
+                     unsigned int);
+  CHROMEG_CALLBACK_0(GlobalMenuBarX11, void, OnSubMenuShow, DbusmenuMenuitem*);
+
+  NativeWindowViews* window_;
+  gfx::AcceleratedWidget xid_;
+
+  DbusmenuServer* server_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalMenuBarX11);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
added in remote
  their  100644 33e1755c50596aea4f605c3c5f0cc05ae4779d88 electron/browser/ui/views/menu_bar.cc
@@ -0,0 +1,162 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_bar.h"
+
+#if defined(USE_X11)
+#include "gtk/gtk.h"
+#endif
+
+#include "electron/browser/ui/views/menu_delegate.h"
+#include "electron/browser/ui/views/submenu_button.h"
+#include "ui/base/models/menu_model.h"
+#include "ui/views/background.h"
+#include "ui/views/layout/box_layout.h"
+
+#if defined(OS_WIN)
+#include "ui/gfx/color_utils.h"
+#elif defined(USE_X11)
+#include "chrome/browser/ui/libgtk2ui/skia_utils_gtk2.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "ElectronMenuBar";
+
+// Default color of the menu bar.
+const SkColor kDefaultColor = SkColorSetARGB(255, 233, 233, 233);
+
+#if defined(USE_X11)
+void GetMenuBarColor(SkColor* enabled, SkColor* disabled, SkColor* highlight,
+                     SkColor* hover, SkColor* background) {
+  GtkWidget* menu_bar = gtk_menu_bar_new();
+
+  GtkStyle* style = gtk_rc_get_style(menu_bar);
+  *enabled = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_NORMAL]);
+  *disabled = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_INSENSITIVE]);
+  *highlight = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_SELECTED]);
+  *hover = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_PRELIGHT]);
+  *background = libgtk2ui::GdkColorToSkColor(style->bg[GTK_STATE_NORMAL]);
+
+  gtk_widget_destroy(menu_bar);
+}
+#endif
+
+}  // namespace
+
+MenuBar::MenuBar()
+    : background_color_(kDefaultColor),
+      menu_model_(NULL) {
+#if defined(OS_WIN)
+  background_color_ = color_utils::GetSysSkColor(COLOR_MENUBAR);
+#elif defined(USE_X11)
+  GetMenuBarColor(&enabled_color_, &disabled_color_, &highlight_color_,
+                  &hover_color_, &background_color_);
+#endif
+
+  set_background(views::Background::CreateSolidBackground(background_color_));
+  SetLayoutManager(new views::BoxLayout(
+      views::BoxLayout::kHorizontal, 0, 0, 0));
+}
+
+MenuBar::~MenuBar() {
+}
+
+void MenuBar::SetMenu(ui::MenuModel* model) {
+  menu_model_ = model;
+  RemoveAllChildViews(true);
+
+  for (int i = 0; i < model->GetItemCount(); ++i) {
+    SubmenuButton* button = new SubmenuButton(this, model->GetLabelAt(i), this);
+    button->set_tag(i);
+
+#if defined(USE_X11)
+    button->SetTextColor(views::Button::STATE_NORMAL, enabled_color_);
+    button->SetTextColor(views::Button::STATE_DISABLED, disabled_color_);
+    button->SetTextColor(views::Button::STATE_PRESSED, highlight_color_);
+    button->SetTextColor(views::Button::STATE_HOVERED, hover_color_);
+    button->SetUnderlineColor(enabled_color_);
+#elif defined(OS_WIN)
+    button->SetUnderlineColor(color_utils::GetSysSkColor(COLOR_GRAYTEXT));
+#endif
+
+    AddChildView(button);
+  }
+}
+
+void MenuBar::SetAcceleratorVisibility(bool visible) {
+  for (int i = 0; i < child_count(); ++i)
+    static_cast<SubmenuButton*>(child_at(i))->SetAcceleratorVisibility(visible);
+}
+
+int MenuBar::GetAcceleratorIndex(base::char16 key) {
+  for (int i = 0; i < child_count(); ++i) {
+    SubmenuButton* button = static_cast<SubmenuButton*>(child_at(i));
+    if (button->accelerator() == key)
+      return i;
+  }
+  return -1;
+}
+
+void MenuBar::ActivateAccelerator(base::char16 key) {
+  int i = GetAcceleratorIndex(key);
+  if (i != -1)
+    static_cast<SubmenuButton*>(child_at(i))->Activate();
+}
+
+int MenuBar::GetItemCount() const {
+  return menu_model_->GetItemCount();
+}
+
+bool MenuBar::GetMenuButtonFromScreenPoint(const gfx::Point& point,
+                                           ui::MenuModel** menu_model,
+                                           views::MenuButton** button) {
+  gfx::Point location(point);
+  views::View::ConvertPointFromScreen(this, &location);
+
+  if (location.x() < 0 || location.x() >= width() || location.y() < 0 ||
+      location.y() >= height())
+    return false;
+
+  for (int i = 0; i < child_count(); ++i) {
+    views::View* view = child_at(i);
+    if (view->bounds().Contains(location) &&
+        (menu_model_->GetTypeAt(i) == ui::MenuModel::TYPE_SUBMENU)) {
+      *menu_model = menu_model_->GetSubmenuModelAt(i);
+      *button = static_cast<views::MenuButton*>(view);
+      return true;
+    }
+  }
+
+  return false;
+}
+
+const char* MenuBar::GetClassName() const {
+  return kViewClassName;
+}
+
+void MenuBar::ButtonPressed(views::Button* sender, const ui::Event& event) {
+}
+
+void MenuBar::OnMenuButtonClicked(views::View* source,
+                                  const gfx::Point& point) {
+  // Hide the accelerator when a submenu is activated.
+  SetAcceleratorVisibility(false);
+
+  if (!menu_model_)
+    return;
+
+  views::MenuButton* button = static_cast<views::MenuButton*>(source);
+  int id = button->tag();
+  ui::MenuModel::ItemType type = menu_model_->GetTypeAt(id);
+  if (type != ui::MenuModel::TYPE_SUBMENU)
+    return;
+
+  MenuDelegate menu_delegate(this);
+  menu_delegate.RunMenu(menu_model_->GetSubmenuModelAt(id), button);
+}
+
+}  // namespace electron
added in remote
  their  100644 74fdcd01c915280994c2232bcbcc1f38946edd27 electron/browser/ui/views/menu_bar.h
@@ -0,0 +1,80 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
+
+#include "ui/views/controls/button/button.h"
+#include "ui/views/controls/button/menu_button_listener.h"
+#include "ui/views/view.h"
+
+namespace ui {
+class MenuModel;
+}
+
+namespace views {
+class MenuButton;
+}
+
+namespace electron {
+
+class MenuDelegate;
+
+class MenuBar : public views::View,
+                public views::ButtonListener,
+                public views::MenuButtonListener {
+ public:
+  MenuBar();
+  virtual ~MenuBar();
+
+  // Replaces current menu with a new one.
+  void SetMenu(ui::MenuModel* menu_model);
+
+  // Shows underline under accelerators.
+  void SetAcceleratorVisibility(bool visible);
+
+  // Returns which submenu has accelerator |key|, -1 would be returned when
+  // there is no matching submenu.
+  int GetAcceleratorIndex(base::char16 key);
+
+  // Shows the submenu whose accelerator is |key|.
+  void ActivateAccelerator(base::char16 key);
+
+  // Returns there are how many items in the root menu.
+  int GetItemCount() const;
+
+  // Get the menu under specified screen point.
+  bool GetMenuButtonFromScreenPoint(const gfx::Point& point,
+                                    ui::MenuModel** menu_model,
+                                    views::MenuButton** button);
+
+ protected:
+  // views::View:
+  const char* GetClassName() const override;
+
+  // views::ButtonListener:
+  void ButtonPressed(views::Button* sender, const ui::Event& event) override;
+
+  // views::MenuButtonListener:
+  void OnMenuButtonClicked(views::View* source,
+                                   const gfx::Point& point) override;
+
+ private:
+  SkColor background_color_;
+
+#if defined(USE_X11)
+  SkColor enabled_color_;
+  SkColor disabled_color_;
+  SkColor highlight_color_;
+  SkColor hover_color_;
+#endif
+
+  ui::MenuModel* menu_model_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuBar);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
added in remote
  their  100644 e315b0a4c78cb260d7c43086b18d6ac4ffd9313b electron/browser/ui/views/menu_delegate.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_delegate.h"
+
+#include "electron/browser/ui/views/menu_bar.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/views/controls/button/menu_button.h"
+#include "ui/views/controls/menu/menu_item_view.h"
+#include "ui/views/controls/menu/menu_model_adapter.h"
+#include "ui/views/controls/menu/menu_runner.h"
+#include "ui/views/widget/widget.h"
+
+namespace electron {
+
+MenuDelegate::MenuDelegate(MenuBar* menu_bar)
+    : menu_bar_(menu_bar),
+      id_(-1) {
+}
+
+MenuDelegate::~MenuDelegate() {
+}
+
+void MenuDelegate::RunMenu(ui::MenuModel* model, views::MenuButton* button) {
+  gfx::Point screen_loc;
+  views::View::ConvertPointToScreen(button, &screen_loc);
+  // Subtract 1 from the height to make the popup flush with the button border.
+  gfx::Rect bounds(screen_loc.x(), screen_loc.y(), button->width(),
+                   button->height() - 1);
+
+  id_ = button->tag();
+  adapter_.reset(new views::MenuModelAdapter(model));
+
+  views::MenuItemView* item = new views::MenuItemView(this);
+  static_cast<views::MenuModelAdapter*>(adapter_.get())->BuildMenu(item);
+
+  menu_runner_.reset(new views::MenuRunner(
+      item,
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
+  ignore_result(menu_runner_->RunMenuAt(
+      button->GetWidget()->GetTopLevelWidget(),
+      button,
+      bounds,
+      views::MENU_ANCHOR_TOPRIGHT,
+      ui::MENU_SOURCE_MOUSE));
+}
+
+void MenuDelegate::ExecuteCommand(int id) {
+  adapter_->ExecuteCommand(id);
+}
+
+void MenuDelegate::ExecuteCommand(int id, int mouse_event_flags) {
+  adapter_->ExecuteCommand(id, mouse_event_flags);
+}
+
+bool MenuDelegate::IsTriggerableEvent(views::MenuItemView* source,
+                                      const ui::Event& e) {
+  return adapter_->IsTriggerableEvent(source, e);
+}
+
+bool MenuDelegate::GetAccelerator(int id, ui::Accelerator* accelerator) const {
+  return adapter_->GetAccelerator(id, accelerator);
+}
+
+base::string16 MenuDelegate::GetLabel(int id) const {
+  return adapter_->GetLabel(id);
+}
+
+const gfx::FontList* MenuDelegate::GetLabelFontList(int id) const {
+  return adapter_->GetLabelFontList(id);
+}
+
+bool MenuDelegate::IsCommandEnabled(int id) const {
+  return adapter_->IsCommandEnabled(id);
+}
+
+bool MenuDelegate::IsCommandVisible(int id) const {
+  return adapter_->IsCommandVisible(id);
+}
+
+bool MenuDelegate::IsItemChecked(int id) const {
+  return adapter_->IsItemChecked(id);
+}
+
+void MenuDelegate::SelectionChanged(views::MenuItemView* menu) {
+  adapter_->SelectionChanged(menu);
+}
+
+void MenuDelegate::WillShowMenu(views::MenuItemView* menu) {
+  adapter_->WillShowMenu(menu);
+}
+
+void MenuDelegate::WillHideMenu(views::MenuItemView* menu) {
+  adapter_->WillHideMenu(menu);
+}
+
+views::MenuItemView* MenuDelegate::GetSiblingMenu(
+    views::MenuItemView* menu,
+    const gfx::Point& screen_point,
+    views::MenuAnchorPosition* anchor,
+    bool* has_mnemonics,
+    views::MenuButton**) {
+  views::MenuButton* button;
+  ui::MenuModel* model;
+  if (menu_bar_->GetMenuButtonFromScreenPoint(screen_point, &model, &button) &&
+      button->tag() != id_) {
+    DCHECK(menu_runner_->IsRunning());
+    menu_runner_->Cancel();
+    // After canceling the menu, we need to wait until next tick
+    // so we are out of nested message loop.
+    content::BrowserThread::PostTask(
+        content::BrowserThread::UI, FROM_HERE,
+        base::Bind(base::IgnoreResult(&views::MenuButton::Activate),
+                   base::Unretained(button)));
+  }
+
+  return nullptr;
+}
+
+}  // namespace electron
added in remote
  their  100644 e04cdc4de2fae7e19830cd1a2dbbd7ac6b63e516 electron/browser/ui/views/menu_delegate.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "ui/views/controls/menu/menu_delegate.h"
+
+namespace views {
+class MenuRunner;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace electron {
+
+class MenuBar;
+
+class MenuDelegate : public views::MenuDelegate {
+ public:
+  explicit MenuDelegate(MenuBar* menu_bar);
+  virtual ~MenuDelegate();
+
+  void RunMenu(ui::MenuModel* model, views::MenuButton* button);
+
+ protected:
+  // views::MenuDelegate:
+  void ExecuteCommand(int id) override;
+  void ExecuteCommand(int id, int mouse_event_flags) override;
+  bool IsTriggerableEvent(views::MenuItemView* source,
+                          const ui::Event& e) override;
+  bool GetAccelerator(int id, ui::Accelerator* accelerator) const override;
+  base::string16 GetLabel(int id) const override;
+  const gfx::FontList* GetLabelFontList(int id) const override;
+  bool IsCommandEnabled(int id) const override;
+  bool IsCommandVisible(int id) const override;
+  bool IsItemChecked(int id) const override;
+  void SelectionChanged(views::MenuItemView* menu) override;
+  void WillShowMenu(views::MenuItemView* menu) override;
+  void WillHideMenu(views::MenuItemView* menu) override;
+  views::MenuItemView* GetSiblingMenu(
+      views::MenuItemView* menu,
+      const gfx::Point& screen_point,
+      views::MenuAnchorPosition* anchor,
+      bool* has_mnemonics,
+      views::MenuButton** button) override;
+
+ private:
+  MenuBar* menu_bar_;
+  int id_;
+  scoped_ptr<views::MenuDelegate> adapter_;
+  scoped_ptr<views::MenuRunner> menu_runner_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
added in remote
  their  100644 7b519840d67a7985862e847db12e794ab4368b32 electron/browser/ui/views/menu_layout.cc
@@ -0,0 +1,86 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_layout.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/native_window_views.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+#if defined(OS_WIN)
+gfx::Rect SubstractBorderSize(gfx::Rect bounds) {
+  int border_width = GetSystemMetrics(SM_CXSIZEFRAME) - 1;
+  int border_height = GetSystemMetrics(SM_CYSIZEFRAME) - 1;
+  bounds.set_x(bounds.x() + border_width);
+  bounds.set_y(bounds.y() + border_height);
+  bounds.set_width(bounds.width() - 2 * border_width);
+  bounds.set_height(bounds.height() - 2 * border_height);
+  return bounds;
+}
+#endif
+
+}  // namespace
+
+MenuLayout::MenuLayout(NativeWindowViews* window, int menu_height)
+    : window_(window),
+      menu_height_(menu_height) {
+}
+
+MenuLayout::~MenuLayout() {
+}
+
+void MenuLayout::Layout(views::View* host) {
+#if defined(OS_WIN)
+  // Reserve border space for maximized frameless window so we won't have the
+  // content go outside of screen.
+  if (!window_->has_frame() && window_->IsMaximized()) {
+    gfx::Rect bounds = SubstractBorderSize(host->GetContentsBounds());
+    host->child_at(0)->SetBoundsRect(bounds);
+    return;
+  }
+#endif
+
+  if (!HasMenu(host)) {
+    views::FillLayout::Layout(host);
+    return;
+  }
+
+  gfx::Size size = host->GetContentsBounds().size();
+  gfx::Rect menu_Bar_bounds = gfx::Rect(0, 0, size.width(), menu_height_);
+  gfx::Rect web_view_bounds = gfx::Rect(
+      0, menu_height_, size.width(), size.height() - menu_height_);
+
+  views::View* web_view = host->child_at(0);
+  views::View* menu_bar = host->child_at(1);
+  web_view->SetBoundsRect(web_view_bounds);
+  menu_bar->SetBoundsRect(menu_Bar_bounds);
+}
+
+gfx::Size MenuLayout::GetPreferredSize(const views::View* host) const {
+  gfx::Size size = views::FillLayout::GetPreferredSize(host);
+  if (!HasMenu(host))
+    return size;
+
+  size.set_height(size.height() + menu_height_);
+  return size;
+}
+
+int MenuLayout::GetPreferredHeightForWidth(
+    const views::View* host, int width) const {
+  int height = views::FillLayout::GetPreferredHeightForWidth(host, width);
+  if (!HasMenu(host))
+    return height;
+
+  return height + menu_height_;
+}
+
+bool MenuLayout::HasMenu(const views::View* host) const {
+  return host->child_count() == 2;
+}
+
+}  // namespace electron
added in remote
  their  100644 bd3cd0ce02fdc781f62087e2682bfa566ed080d9 electron/browser/ui/views/menu_layout.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
+
+#include "ui/views/layout/fill_layout.h"
+
+namespace electron {
+
+class NativeWindowViews;
+
+class MenuLayout : public views::FillLayout {
+ public:
+  MenuLayout(NativeWindowViews* window, int menu_height);
+  virtual ~MenuLayout();
+
+  // views::LayoutManager:
+  void Layout(views::View* host) override;
+  gfx::Size GetPreferredSize(const views::View* host) const override;
+  int GetPreferredHeightForWidth(
+      const views::View* host, int width) const override;
+
+ private:
+  bool HasMenu(const views::View* host) const;
+
+  NativeWindowViews* window_;
+  int menu_height_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuLayout);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
added in remote
  their  100644 e03594e14c81fcb3de7bfbadc21998482f1398be electron/browser/ui/views/native_frame_view.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/native_frame_view.h"
+
+#include "electron/browser/native_window.h"
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "ElectronNativeFrameView";
+
+}  // namespace
+
+NativeFrameView::NativeFrameView(NativeWindow* window, views::Widget* widget)
+    : views::NativeFrameView(widget),
+      window_(window) {
+}
+
+gfx::Size NativeFrameView::GetMinimumSize() const {
+  return window_->GetMinimumSize();
+}
+
+gfx::Size NativeFrameView::GetMaximumSize() const {
+  return window_->GetMaximumSize();
+}
+
+const char* NativeFrameView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 62120374283b0d91cc972ee0af0642d71b5df456 electron/browser/ui/views/native_frame_view.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
+
+#include "ui/views/window/native_frame_view.h"
+
+namespace electron {
+
+class NativeWindow;
+
+// Like the views::NativeFrameView, but returns the min/max size from the
+// NativeWindowViews.
+class NativeFrameView : public views::NativeFrameView {
+ public:
+  NativeFrameView(NativeWindow* window, views::Widget* widget);
+
+ protected:
+  // views::View:
+  gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
+  const char* GetClassName() const override;
+
+ private:
+  NativeWindow* window_;  // weak ref.
+
+  DISALLOW_COPY_AND_ASSIGN(NativeFrameView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
added in remote
  their  100644 d4eabbbe790294cded2902f879ec939931e9dcd4 electron/browser/ui/views/submenu_button.cc
@@ -0,0 +1,98 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/submenu_button.h"
+
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/text_utils.h"
+#include "ui/views/controls/button/label_button_border.h"
+
+namespace electron {
+
+namespace {
+
+// Filter out the "&" in menu label.
+base::string16 FilterAccelerator(const base::string16& label) {
+  base::string16 out;
+  base::RemoveChars(label, base::ASCIIToUTF16("&").c_str(), &out);
+  return out;
+}
+
+}  // namespace
+
+SubmenuButton::SubmenuButton(views::ButtonListener* listener,
+                             const base::string16& title,
+                             views::MenuButtonListener* menu_button_listener)
+    : views::MenuButton(listener, FilterAccelerator(title),
+                        menu_button_listener, false),
+      accelerator_(0),
+      show_underline_(false),
+      underline_start_(-1),
+      underline_end_(-1),
+      text_width_(0),
+      text_height_(0),
+      underline_color_(SK_ColorBLACK) {
+#if defined(OS_LINUX)
+  // Dont' use native style border.
+  SetBorder(std::move(CreateDefaultBorder()));
+#endif
+
+  if (GetUnderlinePosition(title, &accelerator_, &underline_start_,
+                           &underline_end_))
+    gfx::Canvas::SizeStringInt(GetText(), GetFontList(), &text_width_,
+                               &text_height_, 0, 0);
+}
+
+SubmenuButton::~SubmenuButton() {
+}
+
+void SubmenuButton::SetAcceleratorVisibility(bool visible) {
+  if (visible == show_underline_)
+    return;
+
+  show_underline_ = visible;
+  SchedulePaint();
+}
+
+void SubmenuButton::SetUnderlineColor(SkColor color) {
+  underline_color_ = color;
+}
+
+void SubmenuButton::OnPaint(gfx::Canvas* canvas) {
+  views::MenuButton::OnPaint(canvas);
+
+  if (show_underline_ && (underline_start_ != underline_end_)) {
+    int padding = (width() - text_width_) / 2;
+    int underline_height = (height() + text_height_) / 2 - 2;
+    canvas->DrawLine(gfx::Point(underline_start_ + padding, underline_height),
+                     gfx::Point(underline_end_ + padding, underline_height),
+                     underline_color_);
+  }
+}
+
+bool SubmenuButton::GetUnderlinePosition(const base::string16& text,
+                                         base::char16* accelerator,
+                                         int* start, int* end) {
+  int pos, span;
+  base::string16 trimmed = gfx::RemoveAcceleratorChar(text, '&', &pos, &span);
+  if (pos > -1 && span != 0) {
+    *accelerator = base::ToUpperASCII(trimmed[pos]);
+    GetCharacterPosition(trimmed, pos, start);
+    GetCharacterPosition(trimmed, pos + span, end);
+    return true;
+  }
+
+  return false;
+}
+
+void SubmenuButton::GetCharacterPosition(
+    const base::string16& text, int index, int* pos) {
+  int height;
+  gfx::Canvas::SizeStringInt(text.substr(0, index), GetFontList(), pos, &height,
+                             0, 0);
+}
+
+}  // namespace electron
added in remote
  their  100644 275c2b1873109c41364d76bb2964baa28b19ff50 electron/browser/ui/views/submenu_button.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
+#define ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
+
+#include "ui/views/controls/button/menu_button.h"
+
+namespace electron {
+
+// Special button that used by menu bar to show submenus.
+class SubmenuButton : public views::MenuButton {
+ public:
+  SubmenuButton(views::ButtonListener* listener,
+                const base::string16& title,
+                views::MenuButtonListener* menu_button_listener);
+  virtual ~SubmenuButton();
+
+  void SetAcceleratorVisibility(bool visible);
+  void SetUnderlineColor(SkColor color);
+
+  void SetEnabledColor(SkColor color);
+  void SetBackgroundColor(SkColor color);
+
+  base::char16 accelerator() const { return accelerator_; }
+
+  // views::MenuButton:
+  void OnPaint(gfx::Canvas* canvas) override;
+
+ private:
+  bool GetUnderlinePosition(const base::string16& text,
+                            base::char16* accelerator,
+                            int* start, int* end);
+  void GetCharacterPosition(
+      const base::string16& text, int index, int* pos);
+
+  base::char16 accelerator_;
+
+  bool show_underline_;
+
+  int underline_start_;
+  int underline_end_;
+  int text_width_;
+  int text_height_;
+  SkColor underline_color_;
+
+  DISALLOW_COPY_AND_ASSIGN(SubmenuButton);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
added in remote
  their  100644 b2c6bffe4facf4dd1206961cda1aef8347bcbb19 electron/browser/ui/views/win_frame_view.cc
@@ -0,0 +1,45 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/win_frame_view.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/views/widget/widget.h"
+#include "ui/views/win/hwnd_util.h"
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "WinFrameView";
+
+}  // namespace
+
+
+WinFrameView::WinFrameView() {
+}
+
+WinFrameView::~WinFrameView() {
+}
+
+
+gfx::Rect WinFrameView::GetWindowBoundsForClientBounds(
+    const gfx::Rect& client_bounds) const {
+  return views::GetWindowBoundsForClientBounds(
+      static_cast<views::View*>(const_cast<WinFrameView*>(this)),
+      client_bounds);
+}
+
+int WinFrameView::NonClientHitTest(const gfx::Point& point) {
+  if (window_->has_frame())
+    return frame_->client_view()->NonClientHitTest(point);
+  else
+    return FramelessView::NonClientHitTest(point);
+}
+
+const char* WinFrameView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 b1646da0ea4bc8e1f9fd32fa2b3a6b63574d7ad2 electron/browser/ui/views/win_frame_view.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
+
+#include "electron/browser/ui/views/frameless_view.h"
+
+namespace electron {
+
+class WinFrameView : public FramelessView {
+ public:
+  WinFrameView();
+  virtual ~WinFrameView();
+
+  // views::NonClientFrameView:
+  gfx::Rect GetWindowBoundsForClientBounds(
+      const gfx::Rect& client_bounds) const override;
+  int NonClientHitTest(const gfx::Point& point) override;
+
+  // views::View:
+  const char* GetClassName() const override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WinFrameView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
added in remote
  their  100644 20343b603c31e6dc24838892e611ec743bd11fa6 electron/browser/ui/win/electron_desktop_window_tree_host_win.cc
@@ -0,0 +1,28 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/electron_desktop_window_tree_host_win.h"
+
+#include "electron/browser/ui/win/message_handler_delegate.h"
+
+namespace electron {
+
+ElectronDesktopWindowTreeHostWin::ElectronDesktopWindowTreeHostWin(
+    MessageHandlerDelegate* delegate,
+    views::internal::NativeWidgetDelegate* native_widget_delegate,
+    views::DesktopNativeWidgetAura* desktop_native_widget_aura)
+        : views::DesktopWindowTreeHostWin(native_widget_delegate,
+                                          desktop_native_widget_aura),
+          delegate_(delegate) {
+}
+
+ElectronDesktopWindowTreeHostWin::~ElectronDesktopWindowTreeHostWin() {
+}
+
+bool ElectronDesktopWindowTreeHostWin::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  return delegate_->PreHandleMSG(message, w_param, l_param, result);
+}
+
+}  // namespace electron
added in remote
  their  100644 496046cb2e888d916ba8c6dd7d9b037c96840e06 electron/browser/ui/win/electron_desktop_window_tree_host_win.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
+#define ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
+
+#include <windows.h>
+
+#include <vector>
+
+#include "electron/browser/native_window.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+
+namespace electron {
+
+class MessageHandlerDelegate;
+
+class ElectronDesktopWindowTreeHostWin : public views::DesktopWindowTreeHostWin {
+ public:
+  ElectronDesktopWindowTreeHostWin(
+      MessageHandlerDelegate* delegate,
+      views::internal::NativeWidgetDelegate* native_widget_delegate,
+      views::DesktopNativeWidgetAura* desktop_native_widget_aura);
+  ~ElectronDesktopWindowTreeHostWin() override;
+
+ protected:
+  bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) override;
+
+ private:
+  MessageHandlerDelegate* delegate_;  // weak ref
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronDesktopWindowTreeHostWin);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
added in remote
  their  100644 42ac2ec021834f6d0f4d79e93eff111ae553eca9 electron/browser/ui/win/message_handler_delegate.cc
@@ -0,0 +1,14 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/message_handler_delegate.h"
+
+namespace electron {
+
+bool MessageHandlerDelegate::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 6afa05169f48bf5c74502237371f7c03fece7c32 electron/browser/ui/win/message_handler_delegate.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
+#define ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
+
+#include <windows.h>
+
+namespace electron {
+
+class MessageHandlerDelegate {
+ public:
+  // Catch-all message handling and filtering. Called before
+  // HWNDMessageHandler's built-in handling, which may pre-empt some
+  // expectations in Views/Aura if messages are consumed. Returns true if the
+  // message was consumed by the delegate and should not be processed further
+  // by the HWNDMessageHandler. In this case, |result| is returned. |result| is
+  // not modified otherwise.
+  virtual bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
added in remote
  their  100644 7f49d84ec611d1bf202164aa718b95fdd6d4f0d3 electron/browser/ui/win/notify_icon.cc
@@ -0,0 +1,178 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon.h"
+
+#include "electron/browser/ui/win/notify_icon_host.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/screen.h"
+#include "ui/views/controls/menu/menu_runner.h"
+
+namespace electron {
+
+NotifyIcon::NotifyIcon(NotifyIconHost* host,
+                       UINT id,
+                       HWND window,
+                       UINT message)
+    : host_(host),
+      icon_id_(id),
+      window_(window),
+      message_id_(message),
+      menu_model_(NULL) {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_MESSAGE;
+  icon_data.uCallbackMessage = message_id_;
+  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
+  // This can happen if the explorer process isn't running when we try to
+  // create the icon for some reason (for example, at startup).
+  if (!result)
+    LOG(WARNING) << "Unable to create status tray icon.";
+}
+
+NotifyIcon::~NotifyIcon() {
+  // Remove our icon.
+  host_->Remove(this);
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  Shell_NotifyIcon(NIM_DELETE, &icon_data);
+}
+
+void NotifyIcon::HandleClickEvent(int modifiers,
+                                  bool left_mouse_click,
+                                  bool double_button_click) {
+  NOTIFYICONIDENTIFIER icon_id;
+  memset(&icon_id, 0, sizeof(NOTIFYICONIDENTIFIER));
+  icon_id.uID = icon_id_;
+  icon_id.hWnd = window_;
+  icon_id.cbSize = sizeof(NOTIFYICONIDENTIFIER);
+
+  RECT rect = { 0 };
+  Shell_NotifyIconGetRect(&icon_id, &rect);
+
+  if (left_mouse_click) {
+    if (double_button_click)  // double left click
+      NotifyDoubleClicked(gfx::Rect(rect), modifiers);
+    else  // single left click
+      NotifyClicked(gfx::Rect(rect), modifiers);
+    return;
+  } else if (!double_button_click) {  // single right click
+    if (menu_model_)
+      PopUpContextMenu(gfx::Point(), menu_model_);
+    else
+      NotifyRightClicked(gfx::Rect(rect), modifiers);
+  }
+}
+
+void NotifyIcon::ResetIcon() {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  // Delete any previously existing icon.
+  Shell_NotifyIcon(NIM_DELETE, &icon_data);
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_MESSAGE;
+  icon_data.uCallbackMessage = message_id_;
+  icon_data.hIcon = icon_.get();
+  // If we have an image, then set the NIF_ICON flag, which tells
+  // Shell_NotifyIcon() to set the image for the status icon it creates.
+  if (icon_data.hIcon)
+    icon_data.uFlags |= NIF_ICON;
+  // Re-add our icon.
+  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to re-create status tray icon.";
+}
+
+void NotifyIcon::SetImage(const gfx::Image& image) {
+  // Create the icon.
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_ICON;
+  icon_ = IconUtil::CreateHICONFromSkBitmap(image.AsBitmap());
+  icon_data.hIcon = icon_.get();
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Error setting status tray icon image";
+}
+
+void NotifyIcon::SetPressedImage(const gfx::Image& image) {
+  // Ignore pressed images, since the standard on Windows is to not highlight
+  // pressed status icons.
+}
+
+void NotifyIcon::SetToolTip(const std::string& tool_tip) {
+  // Create the icon.
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_TIP;
+  wcsncpy_s(icon_data.szTip, base::UTF8ToUTF16(tool_tip).c_str(), _TRUNCATE);
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to set tooltip for status tray icon";
+}
+
+void NotifyIcon::DisplayBalloon(const gfx::Image& icon,
+                                const base::string16& title,
+                                const base::string16& contents) {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_INFO;
+  icon_data.dwInfoFlags = NIIF_INFO;
+  wcsncpy_s(icon_data.szInfoTitle, title.c_str(), _TRUNCATE);
+  wcsncpy_s(icon_data.szInfo, contents.c_str(), _TRUNCATE);
+  icon_data.uTimeout = 0;
+
+  base::win::Version win_version = base::win::GetVersion();
+  if (!icon.IsEmpty() && win_version != base::win::VERSION_PRE_XP) {
+    balloon_icon_ = IconUtil::CreateHICONFromSkBitmap(icon.AsBitmap());
+    icon_data.hBalloonIcon = balloon_icon_.get();
+    icon_data.dwInfoFlags = NIIF_USER | NIIF_LARGE_ICON;
+  }
+
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to create status tray balloon.";
+}
+
+void NotifyIcon::PopUpContextMenu(const gfx::Point& pos,
+                                  ui::SimpleMenuModel* menu_model) {
+  // Returns if context menu isn't set.
+  if (!menu_model)
+    return;
+  // Set our window as the foreground window, so the context menu closes when
+  // we click away from it.
+  if (!SetForegroundWindow(window_))
+    return;
+
+  // Show menu at mouse's position by default.
+  gfx::Rect rect(pos, gfx::Size());
+  if (pos.IsOrigin())
+    rect.set_origin(gfx::Screen::GetNativeScreen()->GetCursorScreenPoint());
+
+  views::MenuRunner menu_runner(
+      menu_model,
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS);
+  ignore_result(menu_runner.RunMenuAt(
+      NULL, NULL, rect, views::MENU_ANCHOR_TOPLEFT, ui::MENU_SOURCE_MOUSE));
+}
+
+void NotifyIcon::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  menu_model_ = menu_model;
+}
+
+void NotifyIcon::InitIconData(NOTIFYICONDATA* icon_data) {
+  memset(icon_data, 0, sizeof(NOTIFYICONDATA));
+  icon_data->cbSize = sizeof(NOTIFYICONDATA);
+  icon_data->hWnd = window_;
+  icon_data->uID = icon_id_;
+}
+
+}  // namespace electron
added in remote
  their  100644 881bc42fac90122b20bb8ed53234f07f1fad0045 electron/browser/ui/win/notify_icon.h
@@ -0,0 +1,87 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
+#define ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
+
+#include <windows.h>
+#include <shellapi.h>
+
+#include <string>
+
+#include "electron/browser/ui/tray_icon.h"
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/win/scoped_gdi_object.h"
+
+namespace gfx {
+class Point;
+}
+
+namespace electron {
+
+class NotifyIconHost;
+
+class NotifyIcon : public TrayIcon {
+ public:
+  // Constructor which provides this icon's unique ID and messaging window.
+  NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message);
+  virtual ~NotifyIcon();
+
+  // Handles a click event from the user - if |left_button_click| is true and
+  // there is a registered observer, passes the click event to the observer,
+  // otherwise displays the context menu if there is one.
+  void HandleClickEvent(int modifiers,
+                        bool left_button_click,
+                        bool double_button_click);
+
+  // Re-creates the status tray icon now after the taskbar has been created.
+  void ResetIcon();
+
+  UINT icon_id() const { return icon_id_; }
+  HWND window() const { return window_; }
+  UINT message_id() const { return message_id_; }
+
+  // Overridden from TrayIcon:
+  void SetImage(const gfx::Image& image) override;
+  void SetPressedImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void DisplayBalloon(const gfx::Image& icon,
+                      const base::string16& title,
+                      const base::string16& contents) override;
+  void PopUpContextMenu(const gfx::Point& pos,
+                        ui::SimpleMenuModel* menu_model) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ private:
+  void InitIconData(NOTIFYICONDATA* icon_data);
+
+  // The tray that owns us.  Weak.
+  NotifyIconHost* host_;
+
+  // The unique ID corresponding to this icon.
+  UINT icon_id_;
+
+  // Window used for processing messages from this icon.
+  HWND window_;
+
+  // The message identifier used for status icon messages.
+  UINT message_id_;
+
+  // The currently-displayed icon for the window.
+  base::win::ScopedHICON icon_;
+
+  // The currently-displayed icon for the notification balloon.
+  base::win::ScopedHICON balloon_icon_;
+
+  // The context menu.
+  ui::SimpleMenuModel* menu_model_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotifyIcon);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
added in remote
  their  100644 13766649534a30eae66a1eb89288a24efd5c46c2 electron/browser/ui/win/notify_icon_host.cc
@@ -0,0 +1,190 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon_host.h"
+
+#include <commctrl.h>
+#include <winuser.h>
+
+#include "electron/browser/ui/win/notify_icon.h"
+#include "base/bind.h"
+#include "base/stl_util.h"
+#include "base/threading/non_thread_safe.h"
+#include "base/threading/thread.h"
+#include "base/win/win_util.h"
+#include "base/win/wrapped_window_proc.h"
+#include "ui/events/event_constants.h"
+#include "ui/events/win/system_event_state_lookup.h"
+#include "ui/gfx/win/hwnd_util.h"
+
+namespace electron {
+
+namespace {
+
+const UINT kNotifyIconMessage = WM_APP + 1;
+
+// |kBaseIconId| is 2 to avoid conflicts with plugins that hard-code id 1.
+const UINT kBaseIconId = 2;
+
+const wchar_t kNotifyIconHostWindowClass[] = L"Electron_NotifyIconHostWindow";
+
+bool IsWinPressed() {
+  return ((::GetKeyState(VK_LWIN) & 0x8000) == 0x8000) ||
+         ((::GetKeyState(VK_RWIN) & 0x8000) == 0x8000);
+}
+
+int GetKeyboardModifers() {
+  int modifiers = ui::EF_NONE;
+  if (ui::win::IsShiftPressed())
+    modifiers |= ui::EF_SHIFT_DOWN;
+  if (ui::win::IsCtrlPressed())
+    modifiers |= ui::EF_CONTROL_DOWN;
+  if (ui::win::IsAltPressed())
+    modifiers |= ui::EF_ALT_DOWN;
+  if (IsWinPressed())
+    modifiers |= ui::EF_COMMAND_DOWN;
+  return modifiers;
+}
+
+}  // namespace
+
+NotifyIconHost::NotifyIconHost()
+    : next_icon_id_(1),
+      electron_(0),
+      instance_(NULL),
+      window_(NULL) {
+  // Register our window class
+  WNDCLASSEX window_class;
+  base::win::InitializeWindowClass(
+      kNotifyIconHostWindowClass,
+      &base::win::WrappedWindowProc<NotifyIconHost::WndProcStatic>,
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
+  instance_ = window_class.hInstance;
+  electron_ = RegisterClassEx(&window_class);
+  CHECK(electron_);
+
+  // If the taskbar is re-created after we start up, we have to rebuild all of
+  // our icons.
+  taskbar_created_message_ = RegisterWindowMessage(TEXT("TaskbarCreated"));
+
+  // Create an offscreen window for handling messages for the status icons. We
+  // create a hidden WS_POPUP window instead of an HWND_MESSAGE window, because
+  // only top-level windows such as popups can receive broadcast messages like
+  // "TaskbarCreated".
+  window_ = CreateWindow(MAKEINTATOM(electron_),
+                         0, WS_POPUP, 0, 0, 0, 0, 0, 0, instance_, 0);
+  gfx::CheckWindowCreated(window_);
+  gfx::SetWindowUserData(window_, this);
+}
+
+NotifyIconHost::~NotifyIconHost() {
+  if (window_)
+    DestroyWindow(window_);
+
+  if (electron_)
+    UnregisterClass(MAKEINTATOM(electron_), instance_);
+
+  NotifyIcons copied_container(notify_icons_);
+  STLDeleteContainerPointers(copied_container.begin(), copied_container.end());
+}
+
+NotifyIcon* NotifyIconHost::CreateNotifyIcon() {
+  NotifyIcon* notify_icon =
+      new NotifyIcon(this, NextIconId(), window_, kNotifyIconMessage);
+  notify_icons_.push_back(notify_icon);
+  return notify_icon;
+}
+
+void NotifyIconHost::Remove(NotifyIcon* icon) {
+  NotifyIcons::iterator i(
+      std::find(notify_icons_.begin(), notify_icons_.end(), icon));
+
+  if (i == notify_icons_.end()) {
+    NOTREACHED();
+    return;
+  }
+
+  notify_icons_.erase(i);
+}
+
+LRESULT CALLBACK NotifyIconHost::WndProcStatic(HWND hwnd,
+                                              UINT message,
+                                              WPARAM wparam,
+                                              LPARAM lparam) {
+  NotifyIconHost* msg_wnd = reinterpret_cast<NotifyIconHost*>(
+      GetWindowLongPtr(hwnd, GWLP_USERDATA));
+  if (msg_wnd)
+    return msg_wnd->WndProc(hwnd, message, wparam, lparam);
+  else
+    return ::DefWindowProc(hwnd, message, wparam, lparam);
+}
+
+LRESULT CALLBACK NotifyIconHost::WndProc(HWND hwnd,
+                                        UINT message,
+                                        WPARAM wparam,
+                                        LPARAM lparam) {
+  if (message == taskbar_created_message_) {
+    // We need to reset all of our icons because the taskbar went away.
+    for (NotifyIcons::const_iterator i(notify_icons_.begin());
+         i != notify_icons_.end(); ++i) {
+      NotifyIcon* win_icon = static_cast<NotifyIcon*>(*i);
+      win_icon->ResetIcon();
+    }
+    return TRUE;
+  } else if (message == kNotifyIconMessage) {
+    NotifyIcon* win_icon = NULL;
+
+    // Find the selected status icon.
+    for (NotifyIcons::const_iterator i(notify_icons_.begin());
+         i != notify_icons_.end(); ++i) {
+      NotifyIcon* current_win_icon = static_cast<NotifyIcon*>(*i);
+      if (current_win_icon->icon_id() == wparam) {
+        win_icon = current_win_icon;
+        break;
+      }
+    }
+
+    // It is possible for this procedure to be called with an obsolete icon
+    // id.  In that case we should just return early before handling any
+    // actions.
+    if (!win_icon)
+      return TRUE;
+
+    switch (lparam) {
+      case TB_CHECKBUTTON:
+        win_icon->NotifyBalloonShow();
+        return TRUE;
+
+      case TB_INDETERMINATE:
+        win_icon->NotifyBalloonClicked();
+        return TRUE;
+
+      case TB_HIDEBUTTON:
+        win_icon->NotifyBalloonClosed();
+        return TRUE;
+
+      case WM_LBUTTONDOWN:
+      case WM_RBUTTONDOWN:
+      case WM_LBUTTONDBLCLK:
+      case WM_RBUTTONDBLCLK:
+      case WM_CONTEXTMENU:
+        // Walk our icons, find which one was clicked on, and invoke its
+        // HandleClickEvent() method.
+        win_icon->HandleClickEvent(
+            GetKeyboardModifers(),
+            (lparam == WM_LBUTTONDOWN || lparam == WM_LBUTTONDBLCLK),
+            (lparam == WM_LBUTTONDBLCLK || lparam == WM_RBUTTONDBLCLK));
+        return TRUE;
+    }
+  }
+  return ::DefWindowProc(hwnd, message, wparam, lparam);
+}
+
+UINT NotifyIconHost::NextIconId() {
+  UINT icon_id = next_icon_id_++;
+  return kBaseIconId + icon_id;
+}
+
+}  // namespace electron
added in remote
  their  100644 7a3383ee576ee87b11ea7c62b073f5179c2c2f76 electron/browser/ui/win/notify_icon_host.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
+#define ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
+
+#include <windows.h>
+
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace electron {
+
+class NotifyIcon;
+
+class NotifyIconHost {
+ public:
+  NotifyIconHost();
+  ~NotifyIconHost();
+
+  NotifyIcon* CreateNotifyIcon();
+  void Remove(NotifyIcon* notify_icon);
+
+ private:
+  typedef std::vector<NotifyIcon*> NotifyIcons;
+
+  // Static callback invoked when a message comes in to our messaging window.
+  static LRESULT CALLBACK
+      WndProcStatic(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
+
+  LRESULT CALLBACK
+      WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
+
+  UINT NextIconId();
+
+  // The unique icon ID we will assign to the next icon.
+  UINT next_icon_id_;
+
+  // List containing all active NotifyIcons.
+  NotifyIcons notify_icons_;
+
+  // The window class of |window_|.
+  ATOM electron_;
+
+  // The handle of the module that contains the window procedure of |window_|.
+  HMODULE instance_;
+
+  // The window used for processing events.
+  HWND window_;
+
+  // The message ID of the "TaskbarCreated" message, sent to us when we need to
+  // reset our status icons.
+  UINT taskbar_created_message_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotifyIconHost);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
added in remote
  their  100644 282717800b0cc78e81f24df32988a5b57bb604d2 electron/browser/ui/win/taskbar_host.cc
@@ -0,0 +1,166 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/taskbar_host.h"
+
+#include <string>
+
+#include "base/stl_util.h"
+#include "base/win/scoped_gdi_object.h"
+#include "base/strings/utf_string_conversions.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/icon_util.h"
+
+namespace electron {
+
+namespace {
+
+// From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/dd378460(v=vs.85).aspx#thumbbars
+// The thumbnail toolbar has a maximum of seven buttons due to the limited room.
+const size_t kMaxButtonsCount = 7;
+
+// The base id of Thumbar button.
+const int kButtonIdBase = 40001;
+
+bool GetThumbarButtonFlags(const std::vector<std::string>& flags,
+                           THUMBBUTTONFLAGS* out) {
+  THUMBBUTTONFLAGS result = THBF_ENABLED;  // THBF_ENABLED == 0
+  for (const auto& flag : flags) {
+    if (flag == "disabled")
+      result |= THBF_DISABLED;
+    else if (flag == "dismissonclick")
+      result |= THBF_DISMISSONCLICK;
+    else if (flag == "nobackground")
+      result |= THBF_NOBACKGROUND;
+    else if (flag == "hidden")
+      result |= THBF_HIDDEN;
+    else if (flag == "noninteractive")
+      result |= THBF_NONINTERACTIVE;
+    else
+      return false;
+  }
+  *out = result;
+  return true;
+}
+
+}  // namespace
+
+TaskbarHost::TaskbarHost() : thumbar_buttons_added_(false) {
+}
+
+TaskbarHost::~TaskbarHost() {
+}
+
+bool TaskbarHost::SetThumbarButtons(
+    HWND window, const std::vector<ThumbarButton>& buttons) {
+  if (buttons.size() > kMaxButtonsCount || !InitailizeTaskbar())
+    return false;
+
+  callback_map_.clear();
+
+  // The number of buttons in thumbar can not be changed once it is created,
+  // so we have to claim kMaxButtonsCount buttons initialy in case users add
+  // more buttons later.
+  base::win::ScopedHICON icons[kMaxButtonsCount] = {};
+  THUMBBUTTON thumb_buttons[kMaxButtonsCount] = {};
+
+  for (size_t i = 0; i < kMaxButtonsCount; ++i) {
+    THUMBBUTTON& thumb_button = thumb_buttons[i];
+
+    // Set ID.
+    thumb_button.iId = kButtonIdBase + i;
+    thumb_button.dwMask = THB_FLAGS;
+
+    if (i >= buttons.size()) {
+      // This button is used to occupy the place in toolbar, and it does not
+      // show.
+      thumb_button.dwFlags = THBF_HIDDEN;
+      continue;
+    }
+
+    // This button is user's button.
+    const ThumbarButton& button = buttons[i];
+
+    // Generate flags.
+    thumb_button.dwFlags = THBF_ENABLED;
+    if (!GetThumbarButtonFlags(button.flags, &thumb_button.dwFlags))
+      return false;
+
+    // Set icon.
+    if (!button.icon.IsEmpty()) {
+      thumb_button.dwMask |= THB_ICON;
+      icons[i] = IconUtil::CreateHICONFromSkBitmap(button.icon.AsBitmap());
+      thumb_button.hIcon = icons[i].get();
+    }
+
+    // Set tooltip.
+    if (!button.tooltip.empty()) {
+      thumb_button.dwMask |= THB_TOOLTIP;
+      wcsncpy_s(thumb_button.szTip, base::UTF8ToUTF16(button.tooltip).c_str(),
+                _TRUNCATE);
+    }
+
+    // Save callback.
+    callback_map_[thumb_button.iId] = button.clicked_callback;
+  }
+
+  // Finally add them to taskbar.
+  HRESULT r;
+  if (thumbar_buttons_added_)
+    r = taskbar_->ThumbBarUpdateButtons(window, kMaxButtonsCount,
+                                        thumb_buttons);
+  else
+    r = taskbar_->ThumbBarAddButtons(window, kMaxButtonsCount, thumb_buttons);
+
+  thumbar_buttons_added_ = true;
+  return SUCCEEDED(r);
+}
+
+bool TaskbarHost::SetProgressBar(HWND window, double value) {
+  if (!InitailizeTaskbar())
+    return false;
+
+  HRESULT r;
+  if (value > 1.0)
+    r = taskbar_->SetProgressState(window, TBPF_INDETERMINATE);
+  else if (value < 0)
+    r = taskbar_->SetProgressState(window, TBPF_NOPROGRESS);
+  else
+    r = taskbar_->SetProgressValue(window, static_cast<int>(value * 100), 100);
+  return SUCCEEDED(r);
+}
+
+bool TaskbarHost::SetOverlayIcon(
+    HWND window, const gfx::Image& overlay, const std::string& text) {
+  if (!InitailizeTaskbar())
+    return false;
+
+  base::win::ScopedHICON icon(
+      IconUtil::CreateHICONFromSkBitmap(overlay.AsBitmap()));
+  return SUCCEEDED(taskbar_->SetOverlayIcon(
+      window, icon.get(), base::UTF8ToUTF16(text).c_str()));
+}
+
+bool TaskbarHost::HandleThumbarButtonEvent(int button_id) {
+  if (ContainsKey(callback_map_, button_id)) {
+    auto callback = callback_map_[button_id];
+    if (!callback.is_null())
+      callback.Run();
+    return true;
+  }
+  return false;
+}
+
+bool TaskbarHost::InitailizeTaskbar() {
+  if (FAILED(taskbar_.CreateInstance(CLSID_TaskbarList,
+                                     nullptr,
+                                     CLSCTX_INPROC_SERVER)) ||
+      FAILED(taskbar_->HrInit())) {
+    return false;
+  } else {
+    return true;
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 bef917602487ee3d60637e9636be87655f5986ed electron/browser/ui/win/taskbar_host.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
+#define ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
+
+#include <shobjidl.h>
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/win/scoped_comptr.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+class TaskbarHost {
+ public:
+  struct ThumbarButton {
+    std::string tooltip;
+    gfx::Image icon;
+    std::vector<std::string> flags;
+    base::Closure clicked_callback;
+  };
+
+  TaskbarHost();
+  virtual ~TaskbarHost();
+
+  // Add or update the buttons in thumbar.
+  bool SetThumbarButtons(
+      HWND window, const std::vector<ThumbarButton>& buttons);
+
+  // Set the progress state in taskbar.
+  bool SetProgressBar(HWND window, double value);
+
+  // Set the overlay icon in taskbar.
+  bool SetOverlayIcon(
+      HWND window, const gfx::Image& overlay, const std::string& text);
+
+  // Called by the window that there is a button in thumbar clicked.
+  bool HandleThumbarButtonEvent(int button_id);
+
+ private:
+  // Initailize the taskbar object.
+  bool InitailizeTaskbar();
+
+  using CallbackMap = std::map<int, base::Closure>;
+  CallbackMap callback_map_;
+
+  // The COM object of taskbar.
+  base::win::ScopedComPtr<ITaskbarList3> taskbar_;
+
+  // Whether we have already added the buttons to thumbar.
+  bool thumbar_buttons_added_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskbarHost);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
added in remote
  their  100644 03973bb4a904f59c85780f2351872f2231b89854 electron/browser/ui/x/window_state_watcher.cc
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/x/window_state_watcher.h"
+
+#include <X11/Xlib.h>
+
+#include "ui/events/platform/platform_event_source.h"
+
+namespace electron {
+
+namespace {
+
+const char* kAtomsToCache[] = {
+  "_NET_WM_STATE",
+  NULL,
+};
+
+}  // namespace
+
+WindowStateWatcher::WindowStateWatcher(NativeWindowViews* window)
+    : window_(window),
+      widget_(window->GetAcceleratedWidget()),
+      electron_cache_(gfx::GetXDisplay(), kAtomsToCache),
+      was_minimized_(false),
+      was_maximized_(false) {
+  ui::PlatformEventSource::GetInstance()->AddPlatformEventObserver(this);
+}
+
+WindowStateWatcher::~WindowStateWatcher() {
+  ui::PlatformEventSource::GetInstance()->RemovePlatformEventObserver(this);
+}
+
+void WindowStateWatcher::WillProcessEvent(const ui::PlatformEvent& event) {
+  if (IsWindowStateEvent(event)) {
+    was_minimized_ = window_->IsMinimized();
+    was_maximized_ = window_->IsMaximized();
+  }
+}
+
+void WindowStateWatcher::DidProcessEvent(const ui::PlatformEvent& event) {
+  if (IsWindowStateEvent(event)) {
+    bool is_minimized = window_->IsMinimized();
+    bool is_maximized = window_->IsMaximized();
+    bool is_fullscreen = window_->IsFullscreen();
+    if (is_minimized != was_minimized_) {
+      if (is_minimized)
+        window_->NotifyWindowMinimize();
+      else
+        window_->NotifyWindowRestore();
+    } else if (is_maximized != was_maximized_) {
+      if (is_maximized)
+        window_->NotifyWindowMaximize();
+      else
+        window_->NotifyWindowUnmaximize();
+    } else {
+      // If this is neither a "maximize" or "minimize" event, then we think it
+      // is a "fullscreen" event.
+      // The "IsFullscreen()" becomes true immediately before "WillProcessEvent"
+      // is called, so we can not handle this like "maximize" and "minimize" by
+      // watching whether they have changed.
+      if (is_fullscreen)
+        window_->NotifyWindowEnterFullScreen();
+      else
+        window_->NotifyWindowLeaveFullScreen();
+    }
+  }
+}
+
+bool WindowStateWatcher::IsWindowStateEvent(const ui::PlatformEvent& event) {
+  ::Atom changed_atom = event->xproperty.atom;
+  return (changed_atom == electron_cache_.GetAtom("_NET_WM_STATE") &&
+          event->type == PropertyNotify &&
+          event->xproperty.window == widget_);
+}
+
+}  // namespace electron
added in remote
  their  100644 74bc431ddeb1fa5de43c51765d168ae21913e9ce electron/browser/ui/x/window_state_watcher.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
+#define ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
+
+#include "ui/events/platform/platform_event_observer.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/gfx/x/x11_electron_cache.h"
+
+namespace electron {
+
+class WindowStateWatcher : public ui::PlatformEventObserver {
+ public:
+  explicit WindowStateWatcher(NativeWindowViews* window);
+  virtual ~WindowStateWatcher();
+
+ protected:
+  // ui::PlatformEventObserver:
+  void WillProcessEvent(const ui::PlatformEvent& event) override;
+  void DidProcessEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  bool IsWindowStateEvent(const ui::PlatformEvent& event);
+
+  NativeWindowViews* window_;
+  gfx::AcceleratedWidget widget_;
+
+  ui::X11ElectronCache electron_cache_;
+
+  bool was_minimized_;
+  bool was_maximized_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowStateWatcher);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
added in remote
  their  100644 3ac72fd71d88ccd7227d0d1b1da37108f91bc506 electron/browser/ui/x/x_window_utils.cc
@@ -0,0 +1,90 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/x/x_window_utils.h"
+
+#include <X11/Xatom.h>
+
+#include "base/environment.h"
+#include "base/strings/string_util.h"
+#include "dbus/bus.h"
+#include "dbus/object_proxy.h"
+#include "dbus/message.h"
+#include "ui/base/x/x11_util.h"
+
+namespace electron {
+
+::Atom GetAtom(const char* name) {
+  return XInternAtom(gfx::GetXDisplay(), name, false);
+}
+
+void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state) {
+  XEvent xclient;
+  memset(&xclient, 0, sizeof(xclient));
+  xclient.type = ClientMessage;
+  xclient.xclient.window = xwindow;
+  xclient.xclient.message_type = GetAtom("_NET_WM_STATE");
+  xclient.xclient.format = 32;
+  xclient.xclient.data.l[0] = enabled ? 1 : 0;
+  xclient.xclient.data.l[1] = state;
+  xclient.xclient.data.l[2] = None;
+  xclient.xclient.data.l[3] = 1;
+  xclient.xclient.data.l[4] = 0;
+
+  XDisplay* xdisplay = gfx::GetXDisplay();
+  XSendEvent(xdisplay, DefaultRootWindow(xdisplay), False,
+             SubstructureRedirectMask | SubstructureNotifyMask,
+             &xclient);
+}
+
+void SetWindowType(::Window xwindow, const std::string& type) {
+  XDisplay* xdisplay = gfx::GetXDisplay();
+  std::string type_prefix = "_NET_WM_WINDOW_TYPE_";
+  ::Atom window_type = XInternAtom(
+      xdisplay, (type_prefix + base::ToUpperASCII(type)).c_str(), False);
+  XChangeProperty(xdisplay, xwindow,
+                  XInternAtom(xdisplay, "_NET_WM_WINDOW_TYPE", False),
+                  XA_ATOM,
+                  32, PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&window_type), 1);
+}
+
+bool ShouldUseGlobalMenuBar() {
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (env->HasVar("ELECTRON_FORCE_WINDOW_MENU_BAR"))
+    return false;
+
+  dbus::Bus::Options options;
+  scoped_refptr<dbus::Bus> bus(new dbus::Bus(options));
+
+  dbus::ObjectProxy* object_proxy =
+      bus->GetObjectProxy(DBUS_SERVICE_DBUS, dbus::ObjectPath(DBUS_PATH_DBUS));
+  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS, "ListNames");
+  scoped_ptr<dbus::Response> response(object_proxy->CallMethodAndBlock(
+      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT));
+  if (!response) {
+    bus->ShutdownAndBlock();
+    return false;
+  }
+
+  dbus::MessageReader reader(response.get());
+  dbus::MessageReader array_reader(NULL);
+  if (!reader.PopArray(&array_reader)) {
+    bus->ShutdownAndBlock();
+    return false;
+  }
+  while (array_reader.HasMoreData()) {
+    std::string name;
+    if (array_reader.PopString(&name) &&
+        name == "com.canonical.AppMenu.Registrar") {
+      bus->ShutdownAndBlock();
+      return true;
+    }
+  }
+
+  bus->ShutdownAndBlock();
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 d089d1b3a38c87baabc4c0a1d7f4af36f58a510d electron/browser/ui/x/x_window_utils.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
+#define ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
+
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/Xlib.h>
+
+#include <string>
+
+namespace electron {
+
+::Atom GetAtom(const char* name);
+
+// Sends a message to the x11 window manager, enabling or disabling the |state|
+// for _NET_WM_STATE.
+void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state);
+
+// Sets the _NET_WM_WINDOW_TYPE of window.
+void SetWindowType(::Window xwindow, const std::string& type);
+
+// Returns true if the bus name "com.canonical.AppMenu.Registrar" is available.
+bool ShouldUseGlobalMenuBar();
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
added in remote
  their  100644 135c54efc88b175de6c922777c263b4a9f85491d electron/browser/web_contents_permission_helper.cc
@@ -0,0 +1,94 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_contents_permission_helper.h"
+
+#include <string>
+
+#include "electron/browser/electron_permission_manager.h"
+#include "brightray/browser/media/media_stream_devices_controller.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_process_host.h"
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::WebContentsPermissionHelper);
+
+namespace electron {
+
+namespace {
+
+void MediaAccessAllowed(
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& callback,
+    bool allowed) {
+  brightray::MediaStreamDevicesController controller(request, callback);
+  if (allowed)
+    controller.TakeAction();
+  else
+    controller.Deny(content::MEDIA_DEVICE_PERMISSION_DENIED);
+}
+
+void OnPointerLockResponse(content::WebContents* web_contents, bool allowed) {
+  if (web_contents)
+    web_contents->GotResponseToLockMouseRequest(allowed);
+}
+
+void OnPermissionResponse(const base::Callback<void(bool)>& callback,
+                          content::PermissionStatus status) {
+  if (status == content::PERMISSION_STATUS_GRANTED)
+    callback.Run(true);
+  else
+    callback.Run(false);
+}
+
+}  // namespace
+
+WebContentsPermissionHelper::WebContentsPermissionHelper(
+    content::WebContents* web_contents)
+    : web_contents_(web_contents) {
+}
+
+WebContentsPermissionHelper::~WebContentsPermissionHelper() {
+}
+
+void WebContentsPermissionHelper::RequestPermission(
+    content::PermissionType permission,
+    const base::Callback<void(bool)>& callback,
+    bool user_gesture) {
+  auto rfh = web_contents_->GetMainFrame();
+  auto permission_manager = static_cast<ElectronPermissionManager*>(
+      web_contents_->GetBrowserContext()->GetPermissionManager());
+  auto origin = web_contents_->GetLastCommittedURL();
+  permission_manager->RequestPermission(
+      permission, rfh, origin, user_gesture,
+      base::Bind(&OnPermissionResponse, callback));
+}
+
+void WebContentsPermissionHelper::RequestFullscreenPermission(
+    const base::Callback<void(bool)>& callback) {
+  RequestPermission((content::PermissionType)(PermissionType::FULLSCREEN),
+                    callback);
+}
+
+void WebContentsPermissionHelper::RequestMediaAccessPermission(
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& response_callback) {
+  auto callback = base::Bind(&MediaAccessAllowed, request, response_callback);
+  // The permission type doesn't matter here, AUDIO_CAPTURE/VIDEO_CAPTURE
+  // are presented as same type in content_converter.h.
+  RequestPermission(content::PermissionType::AUDIO_CAPTURE, callback);
+}
+
+void WebContentsPermissionHelper::RequestWebNotificationPermission(
+    const base::Callback<void(bool)>& callback) {
+  RequestPermission(content::PermissionType::NOTIFICATIONS, callback);
+}
+
+void WebContentsPermissionHelper::RequestPointerLockPermission(
+    bool user_gesture) {
+  RequestPermission((content::PermissionType)(PermissionType::POINTER_LOCK),
+                    base::Bind(&OnPointerLockResponse, web_contents_),
+                    user_gesture);
+}
+
+}  // namespace electron
added in remote
  their  100644 7eb71959cabd6f3ab628c3b721ff9dcc46e0c609 electron/browser/web_contents_permission_helper.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
+#define ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
+
+#include "content/public/browser/permission_type.h"
+#include "content/public/browser/web_contents_user_data.h"
+#include "content/public/common/media_stream_request.h"
+
+namespace electron {
+
+// Applies the permission requested for WebContents.
+class WebContentsPermissionHelper
+    : public content::WebContentsUserData<WebContentsPermissionHelper> {
+ public:
+  ~WebContentsPermissionHelper() override;
+
+  enum class PermissionType {
+    POINTER_LOCK = static_cast<int>(content::PermissionType::NUM) + 1,
+    FULLSCREEN
+  };
+
+  void RequestFullscreenPermission(
+      const base::Callback<void(bool)>& callback);
+  void RequestMediaAccessPermission(
+      const content::MediaStreamRequest& request,
+      const content::MediaResponseCallback& callback);
+  void RequestWebNotificationPermission(
+      const base::Callback<void(bool)>& callback);
+  void RequestPointerLockPermission(bool user_gesture);
+
+ private:
+  explicit WebContentsPermissionHelper(content::WebContents* web_contents);
+  friend class content::WebContentsUserData<WebContentsPermissionHelper>;
+
+  void RequestPermission(
+      content::PermissionType permission,
+      const base::Callback<void(bool)>& callback,
+      bool user_gesture = false);
+
+  content::WebContents* web_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsPermissionHelper);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
added in remote
  their  100644 6ebe09ad537121f811cea6293095108a06d5ecee electron/browser/web_contents_preferences.cc
@@ -0,0 +1,201 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_contents_preferences.h"
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/common/web_preferences.h"
+#include "native_mate/dictionary.h"
+#include "net/base/filename_util.h"
+
+#if defined(OS_WIN)
+#include "ui/gfx/switches.h"
+#endif
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::WebContentsPreferences);
+
+namespace electron {
+
+// static
+std::vector<WebContentsPreferences*> WebContentsPreferences::instances_;
+
+WebContentsPreferences::WebContentsPreferences(
+    content::WebContents* web_contents,
+    const mate::Dictionary& web_preferences)
+    : web_contents_(web_contents) {
+  v8::Isolate* isolate = web_preferences.isolate();
+  mate::Dictionary copied(isolate, web_preferences.GetHandle()->Clone());
+  // Following fields should not be stored.
+  copied.Delete("embedder");
+  copied.Delete("isGuest");
+  copied.Delete("session");
+
+  mate::ConvertFromV8(isolate, copied.GetHandle(), &web_preferences_);
+  web_contents->SetUserData(UserDataKey(), this);
+
+  instances_.push_back(this);
+}
+
+WebContentsPreferences::~WebContentsPreferences() {
+  instances_.erase(
+      std::remove(instances_.begin(), instances_.end(), this),
+      instances_.end());
+}
+
+void WebContentsPreferences::Merge(const base::DictionaryValue& extend) {
+  web_preferences_.MergeDictionary(&extend);
+}
+
+// static
+content::WebContents* WebContentsPreferences::GetWebContentsFromProcessID(
+    int process_id) {
+  for (WebContentsPreferences* preferences : instances_) {
+    content::WebContents* web_contents = preferences->web_contents_;
+    if (web_contents->GetRenderProcessHost()->GetID() == process_id)
+      return web_contents;
+  }
+  return nullptr;
+}
+
+// static
+void WebContentsPreferences::AppendExtraCommandLineSwitches(
+    content::WebContents* web_contents, base::CommandLine* command_line) {
+  WebContentsPreferences* self = FromWebContents(web_contents);
+  if (!self)
+    return;
+
+  base::DictionaryValue& web_preferences = self->web_preferences_;
+
+  bool b;
+#if defined(OS_WIN)
+  // Check if DirectWrite is disabled.
+  if (web_preferences.GetBoolean(options::kDirectWrite, &b) && !b)
+    command_line->AppendSwitch(::switches::kDisableDirectWrite);
+#endif
+
+  // Check if plugins are enabled.
+  if (web_preferences.GetBoolean("plugins", &b) && b)
+    command_line->AppendSwitch(switches::kEnablePlugins);
+
+  // Experimental flags.
+  if (web_preferences.GetBoolean(options::kExperimentalFeatures, &b) && b)
+    command_line->AppendSwitch(
+        ::switches::kEnableExperimentalWebPlatformFeatures);
+  if (web_preferences.GetBoolean(options::kExperimentalCanvasFeatures, &b) && b)
+    command_line->AppendSwitch(::switches::kEnableExperimentalCanvasFeatures);
+
+  // Check if we have node integration specified.
+  bool node_integration = true;
+  web_preferences.GetBoolean(options::kNodeIntegration, &node_integration);
+  // Be compatible with old API of "node-integration" option.
+  std::string old_token;
+  if (web_preferences.GetString(options::kNodeIntegration, &old_token) &&
+      old_token != "disable")
+    node_integration = true;
+  command_line->AppendSwitchASCII(switches::kNodeIntegration,
+                                  node_integration ? "true" : "false");
+
+  // The preload script.
+  base::FilePath::StringType preload;
+  if (web_preferences.GetString(options::kPreloadScript, &preload)) {
+    if (base::FilePath(preload).IsAbsolute())
+      command_line->AppendSwitchNative(switches::kPreloadScript, preload);
+    else
+      LOG(ERROR) << "preload script must have absolute path.";
+  } else if (web_preferences.GetString(options::kPreloadURL, &preload)) {
+    // Translate to file path if there is "preload-url" option.
+    base::FilePath preload_path;
+    if (net::FileURLToFilePath(GURL(preload), &preload_path))
+      command_line->AppendSwitchPath(switches::kPreloadScript, preload_path);
+    else
+      LOG(ERROR) << "preload url must be file:// protocol.";
+  }
+
+  // The zoom factor.
+  double zoom_factor = 1.0;
+  if (web_preferences.GetDouble(options::kZoomFactor, &zoom_factor) &&
+      zoom_factor != 1.0)
+    command_line->AppendSwitchASCII(switches::kZoomFactor,
+                                    base::DoubleToString(zoom_factor));
+
+  // --guest-instance-id, which is used to identify guest WebContents.
+  int guest_instance_id;
+  if (web_preferences.GetInteger(options::kGuestInstanceID, &guest_instance_id))
+      command_line->AppendSwitchASCII(switches::kGuestInstanceID,
+                                      base::IntToString(guest_instance_id));
+
+  // Pass the opener's window id.
+  int opener_id;
+  if (web_preferences.GetInteger(options::kOpenerID, &opener_id))
+      command_line->AppendSwitchASCII(switches::kOpenerID,
+                                      base::IntToString(opener_id));
+
+  // Enable blink features.
+  std::string blink_features;
+  if (web_preferences.GetString(options::kBlinkFeatures, &blink_features))
+      command_line->AppendSwitchASCII(::switches::kEnableBlinkFeatures,
+                                      blink_features);
+}
+
+// static
+void WebContentsPreferences::OverrideWebkitPrefs(
+    content::WebContents* web_contents, content::WebPreferences* prefs) {
+  WebContentsPreferences* self = FromWebContents(web_contents);
+  if (!self)
+    return;
+
+  bool b;
+  if (self->web_preferences_.GetBoolean("javascript", &b))
+    prefs->javascript_enabled = b;
+  if (self->web_preferences_.GetBoolean("images", &b))
+    prefs->images_enabled = b;
+  if (self->web_preferences_.GetBoolean("textAreasAreResizable", &b))
+    prefs->text_areas_are_resizable = b;
+  if (self->web_preferences_.GetBoolean("webgl", &b))
+    prefs->experimental_webgl_enabled = b;
+  if (self->web_preferences_.GetBoolean("webaudio", &b))
+    prefs->webaudio_enabled = b;
+  if (self->web_preferences_.GetBoolean("webSecurity", &b)) {
+    prefs->web_security_enabled = b;
+    prefs->allow_displaying_insecure_content = !b;
+    prefs->allow_running_insecure_content = !b;
+  }
+  if (self->web_preferences_.GetBoolean("allowDisplayingInsecureContent", &b))
+    prefs->allow_displaying_insecure_content = b;
+  if (self->web_preferences_.GetBoolean("allowRunningInsecureContent", &b))
+    prefs->allow_running_insecure_content = b;
+  const base::DictionaryValue* fonts = nullptr;
+  if (self->web_preferences_.GetDictionary("defaultFontFamily", &fonts)) {
+    base::string16 font;
+    if (fonts->GetString("standard", &font))
+      prefs->standard_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("serif", &font))
+      prefs->serif_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("sansSerif", &font))
+      prefs->sans_serif_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("monospace", &font))
+      prefs->fixed_font_family_map[content::kCommonScript] = font;
+  }
+  int size;
+  if (self->web_preferences_.GetInteger("defaultFontSize", &size))
+    prefs->default_font_size = size;
+  if (self->web_preferences_.GetInteger("defaultMonospaceFontSize", &size))
+    prefs->default_fixed_font_size = size;
+  if (self->web_preferences_.GetInteger("minimumFontSize", &size))
+    prefs->minimum_font_size = size;
+  std::string encoding;
+  if (self->web_preferences_.GetString("defaultEncoding", &encoding))
+    prefs->default_encoding = encoding;
+}
+
+}  // namespace electron
added in remote
  their  100644 50a0a01168755a9a21b81bf7bea13293be66a0a3 electron/browser/web_contents_preferences.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
+#define ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
+
+#include <vector>
+
+#include "base/values.h"
+#include "content/public/browser/web_contents_user_data.h"
+
+namespace base {
+class CommandLine;
+}
+
+namespace content {
+struct WebPreferences;
+}
+
+namespace mate {
+class Dictionary;
+}
+
+namespace electron {
+
+// Stores and applies the preferences of WebContents.
+class WebContentsPreferences
+    : public content::WebContentsUserData<WebContentsPreferences> {
+ public:
+  // Get WebContents according to process ID.
+  static content::WebContents* GetWebContentsFromProcessID(int process_id);
+
+  // Append command paramters according to |web_contents|'s preferences.
+  static void AppendExtraCommandLineSwitches(
+      content::WebContents* web_contents, base::CommandLine* command_line);
+
+  // Modify the WebPreferences according to |web_contents|'s preferences.
+  static void OverrideWebkitPrefs(
+      content::WebContents* web_contents, content::WebPreferences* prefs);
+
+  WebContentsPreferences(content::WebContents* web_contents,
+                         const mate::Dictionary& web_preferences);
+  ~WebContentsPreferences() override;
+
+  // $.extend(|web_preferences_|, |new_web_preferences|).
+  void Merge(const base::DictionaryValue& new_web_preferences);
+
+  // Returns the web preferences.
+  base::DictionaryValue* web_preferences() { return &web_preferences_; }
+
+ private:
+  friend class content::WebContentsUserData<WebContentsPreferences>;
+
+  static std::vector<WebContentsPreferences*> instances_;
+
+  content::WebContents* web_contents_;
+  base::DictionaryValue web_preferences_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsPreferences);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
added in remote
  their  100644 50ebe0e1e2e3e18763399bef278e177ecb9e12b1 electron/browser/web_dialog_helper.cc
@@ -0,0 +1,155 @@
+// Copyright (c) 2014 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_dialog_helper.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/prefs/pref_service.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/file_chooser_file_info.h"
+#include "net/base/mime_util.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+namespace {
+
+file_dialog::Filters GetFileTypesFromAcceptType(
+    const std::vector<base::string16>& accept_types) {
+  file_dialog::Filters filters;
+  if (accept_types.empty())
+    return filters;
+
+  std::vector<base::FilePath::StringType> extensions;
+
+  for (const auto& accept_type : accept_types) {
+    std::string ascii_type = base::UTF16ToASCII(accept_type);
+    if (ascii_type[0] == '.') {
+      // If the type starts with a period it is assumed to be a file extension,
+      // like `.txt`, // so we just have to add it to the list.
+      base::FilePath::StringType extension(
+          ascii_type.begin(), ascii_type.end());
+      // Skip the first character.
+      extensions.push_back(extension.substr(1));
+    } else {
+      // For MIME Type, `audio/*, vidio/*, image/*
+      net::GetExtensionsForMimeType(ascii_type, &extensions);
+    }
+  }
+
+  // If no valid exntesion is added, return empty filters.
+  if (extensions.empty())
+    return filters;
+
+  filters.push_back(file_dialog::Filter());
+  for (const auto& extension : extensions) {
+#if defined(OS_WIN)
+    filters[0].second.push_back(base::UTF16ToASCII(extension));
+#else
+    filters[0].second.push_back(extension);
+#endif
+  }
+  return filters;
+}
+
+}  // namespace
+
+namespace electron {
+
+WebDialogHelper::WebDialogHelper(NativeWindow* window)
+    : window_(window),
+      weak_factory_(this) {
+}
+
+WebDialogHelper::~WebDialogHelper() {
+}
+
+
+void WebDialogHelper::RunFileChooser(content::WebContents* web_contents,
+                                     const content::FileChooserParams& params) {
+  std::vector<content::FileChooserFileInfo> result;
+  file_dialog::Filters filters = GetFileTypesFromAcceptType(
+      params.accept_types);
+  if (params.mode == content::FileChooserParams::Save) {
+    base::FilePath path;
+    if (file_dialog::ShowSaveDialog(window_,
+                                    base::UTF16ToUTF8(params.title),
+                                    params.default_file_name,
+                                    filters,
+                                    &path)) {
+      content::FileChooserFileInfo info;
+      info.file_path = path;
+      info.display_name = path.BaseName().value();
+      result.push_back(info);
+    }
+  } else {
+    int flags = file_dialog::FILE_DIALOG_CREATE_DIRECTORY;
+    switch (params.mode) {
+      case content::FileChooserParams::OpenMultiple:
+        flags |= file_dialog::FILE_DIALOG_MULTI_SELECTIONS;
+      case content::FileChooserParams::Open:
+        flags |= file_dialog::FILE_DIALOG_OPEN_FILE;
+        break;
+      case content::FileChooserParams::UploadFolder:
+        flags |= file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
+        break;
+      default:
+        NOTREACHED();
+    }
+
+    std::vector<base::FilePath> paths;
+    ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+        window_->web_contents()->GetBrowserContext());
+    base::FilePath default_file_path = browser_context->prefs()->GetFilePath(
+        prefs::kSelectFileLastDirectory).Append(params.default_file_name);
+    if (file_dialog::ShowOpenDialog(window_,
+                                    base::UTF16ToUTF8(params.title),
+                                    default_file_path,
+                                    filters,
+                                    flags,
+                                    &paths)) {
+      for (auto& path : paths) {
+        content::FileChooserFileInfo info;
+        info.file_path = path;
+        info.display_name = path.BaseName().value();
+        result.push_back(info);
+      }
+      if (!paths.empty()) {
+        browser_context->prefs()->SetFilePath(prefs::kSelectFileLastDirectory,
+                                              paths[0].DirName());
+      }
+    }
+  }
+
+  web_contents->GetRenderViewHost()->FilesSelectedInChooser(
+      result, params.mode);
+}
+
+void WebDialogHelper::EnumerateDirectory(content::WebContents* web_contents,
+                                         int request_id,
+                                         const base::FilePath& dir) {
+  int types = base::FileEnumerator::FILES |
+              base::FileEnumerator::DIRECTORIES |
+              base::FileEnumerator::INCLUDE_DOT_DOT;
+  base::FileEnumerator file_enum(dir, false, types);
+
+  base::FilePath path;
+  std::vector<base::FilePath> paths;
+  while (!(path = file_enum.Next()).empty())
+    paths.push_back(path);
+
+  web_contents->GetRenderViewHost()->DirectoryEnumerationFinished(
+      request_id, paths);
+}
+
+}  // namespace electron
added in remote
  their  100644 1b9553541f826e1fa451b9ac0b2131b57c382b07 electron/browser/web_dialog_helper.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2014 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
+#define ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
+
+#include "base/memory/weak_ptr.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace content {
+struct FileChooserParams;
+class WebContents;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+class WebDialogHelper {
+ public:
+  explicit WebDialogHelper(NativeWindow* window);
+  ~WebDialogHelper();
+
+  void RunFileChooser(content::WebContents* web_contents,
+                      const content::FileChooserParams& params);
+  void EnumerateDirectory(content::WebContents* web_contents,
+                          int request_id,
+                          const base::FilePath& path);
+
+ private:
+  NativeWindow* window_;
+
+  base::WeakPtrFactory<WebDialogHelper> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebDialogHelper);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
added in remote
  their  100644 14f4778359cd08208dbd7d05e1a1a5a10fb523a7 electron/browser/web_view_guest_delegate.cc
@@ -0,0 +1,157 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_view_guest_delegate.h"
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "content/public/browser/guest_host.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+
+namespace electron {
+
+namespace {
+
+const int kDefaultWidth = 300;
+const int kDefaultHeight = 300;
+
+}  // namespace
+
+WebViewGuestDelegate::WebViewGuestDelegate()
+    : guest_host_(nullptr),
+      auto_size_enabled_(false),
+      is_full_page_plugin_(false),
+      api_web_contents_(nullptr) {
+}
+
+WebViewGuestDelegate::~WebViewGuestDelegate() {
+}
+
+void WebViewGuestDelegate::Initialize(api::WebContents* api_web_contents) {
+  api_web_contents_ = api_web_contents;
+  Observe(api_web_contents->GetWebContents());
+}
+
+void WebViewGuestDelegate::Destroy() {
+  // Give the content module an opportunity to perform some cleanup.
+  guest_host_->WillDestroy();
+  guest_host_ = nullptr;
+}
+
+void WebViewGuestDelegate::SetSize(const SetSizeParams& params) {
+  bool enable_auto_size =
+      params.enable_auto_size ? *params.enable_auto_size : auto_size_enabled_;
+  gfx::Size min_size = params.min_size ? *params.min_size : min_auto_size_;
+  gfx::Size max_size = params.max_size ? *params.max_size : max_auto_size_;
+
+  if (params.normal_size)
+    normal_size_ = *params.normal_size;
+
+  min_auto_size_ = min_size;
+  min_auto_size_.SetToMin(max_size);
+  max_auto_size_ = max_size;
+  max_auto_size_.SetToMax(min_size);
+
+  enable_auto_size &= !min_auto_size_.IsEmpty() && !max_auto_size_.IsEmpty();
+
+  auto rvh = web_contents()->GetRenderViewHost();
+  if (enable_auto_size) {
+    // Autosize is being enabled.
+    rvh->EnableAutoResize(min_auto_size_, max_auto_size_);
+    normal_size_.SetSize(0, 0);
+  } else {
+    // Autosize is being disabled.
+    // Use default width/height if missing from partially defined normal size.
+    if (normal_size_.width() && !normal_size_.height())
+      normal_size_.set_height(GetDefaultSize().height());
+    if (!normal_size_.width() && normal_size_.height())
+      normal_size_.set_width(GetDefaultSize().width());
+
+    gfx::Size new_size;
+    if (!normal_size_.IsEmpty()) {
+      new_size = normal_size_;
+    } else if (!guest_size_.IsEmpty()) {
+      new_size = guest_size_;
+    } else {
+      new_size = GetDefaultSize();
+    }
+
+    if (auto_size_enabled_) {
+      // Autosize was previously enabled.
+      rvh->DisableAutoResize(new_size);
+      GuestSizeChangedDueToAutoSize(guest_size_, new_size);
+    } else {
+      // Autosize was already disabled.
+      guest_host_->SizeContents(new_size);
+    }
+
+    guest_size_ = new_size;
+  }
+
+  auto_size_enabled_ = enable_auto_size;
+}
+
+void WebViewGuestDelegate::HandleKeyboardEvent(
+    content::WebContents* source,
+    const content::NativeWebKeyboardEvent& event) {
+  if (embedder_web_contents_)
+    embedder_web_contents_->GetDelegate()->HandleKeyboardEvent(source, event);
+}
+
+void WebViewGuestDelegate::DidCommitProvisionalLoadForFrame(
+    content::RenderFrameHost* render_frame_host,
+    const GURL& url, ui::PageTransition transition_type) {
+  api_web_contents_->Emit("load-commit", url, !render_frame_host->GetParent());
+}
+
+void WebViewGuestDelegate::DidAttach(int guest_proxy_routing_id) {
+  api_web_contents_->Emit("did-attach");
+}
+
+content::WebContents* WebViewGuestDelegate::GetOwnerWebContents() const {
+  return embedder_web_contents_;
+}
+
+void WebViewGuestDelegate::GuestSizeChanged(const gfx::Size& new_size) {
+  if (!auto_size_enabled_)
+    return;
+  GuestSizeChangedDueToAutoSize(guest_size_, new_size);
+  guest_size_ = new_size;
+}
+
+void WebViewGuestDelegate::SetGuestHost(content::GuestHost* guest_host) {
+  guest_host_ = guest_host;
+}
+
+void WebViewGuestDelegate::WillAttach(
+    content::WebContents* embedder_web_contents,
+    int element_instance_id,
+    bool is_full_page_plugin,
+    const base::Closure& completion_callback) {
+  embedder_web_contents_ = embedder_web_contents;
+  is_full_page_plugin_ = is_full_page_plugin;
+  completion_callback.Run();
+}
+
+void WebViewGuestDelegate::GuestSizeChangedDueToAutoSize(
+    const gfx::Size& old_size, const gfx::Size& new_size) {
+  api_web_contents_->Emit("size-changed",
+                          old_size.width(), old_size.height(),
+                          new_size.width(), new_size.height());
+}
+
+gfx::Size WebViewGuestDelegate::GetDefaultSize() const {
+  if (is_full_page_plugin_) {
+    // Full page plugins default to the size of the owner's viewport.
+    return embedder_web_contents_->GetRenderWidgetHostView()
+                                 ->GetVisibleViewportSize();
+  } else {
+    return gfx::Size(kDefaultWidth, kDefaultHeight);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 ead0db7b50c1d913caf2da2f634998af50436014 electron/browser/web_view_guest_delegate.h
@@ -0,0 +1,119 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
+#define ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
+
+#include "content/public/browser/browser_plugin_guest_delegate.h"
+#include "content/public/browser/web_contents_observer.h"
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace electron {
+
+namespace api {
+class WebContents;
+}
+
+// A struct of parameters for SetSize(). The parameters are all declared as
+// scoped pointers since they are all optional. Null pointers indicate that the
+// parameter has not been provided, and the last used value should be used. Note
+// that when |enable_auto_size| is true, providing |normal_size| is not
+// meaningful. This is because the normal size of the guestview is overridden
+// whenever autosizing occurs.
+struct SetSizeParams {
+  SetSizeParams() {}
+  ~SetSizeParams() {}
+
+  scoped_ptr<bool> enable_auto_size;
+  scoped_ptr<gfx::Size> min_size;
+  scoped_ptr<gfx::Size> max_size;
+  scoped_ptr<gfx::Size> normal_size;
+};
+
+class WebViewGuestDelegate : public content::BrowserPluginGuestDelegate,
+                             public content::WebContentsObserver {
+ public:
+  WebViewGuestDelegate();
+  ~WebViewGuestDelegate() override;
+
+  void Initialize(api::WebContents* api_web_contents);
+
+  // Called when the WebContents is going to be destroyed.
+  void Destroy();
+
+  // Used to toggle autosize mode for this GuestView, and set both the automatic
+  // and normal sizes.
+  void SetSize(const SetSizeParams& params);
+
+  // Transfer the keyboard event to embedder.
+  void HandleKeyboardEvent(content::WebContents* source,
+                           const content::NativeWebKeyboardEvent& event);
+
+ protected:
+  // content::WebContentsObserver:
+  void DidCommitProvisionalLoadForFrame(
+      content::RenderFrameHost* render_frame_host,
+      const GURL& url, ui::PageTransition transition_type) override;
+
+  // content::BrowserPluginGuestDelegate:
+  void DidAttach(int guest_proxy_routing_id) final;
+  content::WebContents* GetOwnerWebContents() const final;
+  void GuestSizeChanged(const gfx::Size& new_size) final;
+  void SetGuestHost(content::GuestHost* guest_host) final;
+  void WillAttach(content::WebContents* embedder_web_contents,
+                  int element_instance_id,
+                  bool is_full_page_plugin,
+                  const base::Closure& completion_callback) final;
+
+ private:
+  // This method is invoked when the contents auto-resized to give the container
+  // an opportunity to match it if it wishes.
+  //
+  // This gives the derived class an opportunity to inform its container element
+  // or perform other actions.
+  void GuestSizeChangedDueToAutoSize(const gfx::Size& old_size,
+                                     const gfx::Size& new_size);
+
+  // Returns the default size of the guestview.
+  gfx::Size GetDefaultSize() const;
+
+  // The WebContents that attaches this guest view.
+  content::WebContents* embedder_web_contents_;
+
+  // The size of the container element.
+  gfx::Size element_size_;
+
+  // The size of the guest content. Note: In autosize mode, the container
+  // element may not match the size of the guest.
+  gfx::Size guest_size_;
+
+  // A pointer to the guest_host.
+  content::GuestHost* guest_host_;
+
+  // Indicates whether autosize mode is enabled or not.
+  bool auto_size_enabled_;
+
+  // The maximum size constraints of the container element in autosize mode.
+  gfx::Size max_auto_size_;
+
+  // The minimum size constraints of the container element in autosize mode.
+  gfx::Size min_auto_size_;
+
+  // The size that will be used when autosize mode is disabled.
+  gfx::Size normal_size_;
+
+  // Whether the guest view is inside a plugin document.
+  bool is_full_page_plugin_;
+
+  api::WebContents* api_web_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebViewGuestDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
added in remote
  their  100644 172f2355395c9df73e5d5f7e85a61ca4254ae68f electron/browser/web_view_manager.cc
@@ -0,0 +1,68 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_view_manager.h"
+
+#include "electron/browser/electron_browser_context.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+WebViewManager::WebViewManager() {
+}
+
+WebViewManager::~WebViewManager() {
+}
+
+void WebViewManager::AddGuest(int guest_instance_id,
+                              int element_instance_id,
+                              content::WebContents* embedder,
+                              content::WebContents* web_contents) {
+  web_contents_embedder_map_[guest_instance_id] = { web_contents, embedder };
+
+  // Map the element in embedder to guest.
+  int owner_process_id = embedder->GetRenderProcessHost()->GetID();
+  ElementInstanceKey key(owner_process_id, element_instance_id);
+  element_instance_id_to_guest_map_[key] = guest_instance_id;
+}
+
+void WebViewManager::RemoveGuest(int guest_instance_id) {
+  if (!ContainsKey(web_contents_embedder_map_, guest_instance_id))
+    return;
+
+  web_contents_embedder_map_.erase(guest_instance_id);
+
+  // Remove the record of element in embedder too.
+  for (const auto& element : element_instance_id_to_guest_map_)
+    if (element.second == guest_instance_id) {
+      element_instance_id_to_guest_map_.erase(element.first);
+      break;
+    }
+}
+
+content::WebContents* WebViewManager::GetGuestByInstanceID(
+    int owner_process_id,
+    int element_instance_id) {
+  ElementInstanceKey key(owner_process_id, element_instance_id);
+  if (!ContainsKey(element_instance_id_to_guest_map_, key))
+    return nullptr;
+
+  int guest_instance_id = element_instance_id_to_guest_map_[key];
+  if (ContainsKey(web_contents_embedder_map_, guest_instance_id))
+    return web_contents_embedder_map_[guest_instance_id].web_contents;
+  else
+    return nullptr;
+}
+
+bool WebViewManager::ForEachGuest(content::WebContents* embedder_web_contents,
+                                  const GuestCallback& callback) {
+  for (auto& item : web_contents_embedder_map_)
+    if (item.second.embedder == embedder_web_contents &&
+        callback.Run(item.second.web_contents))
+      return true;
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 a722674cc26d5134e28e9be69d15f307147c01dc electron/browser/web_view_manager.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
+#define ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
+
+#include <map>
+
+#include "content/public/browser/browser_plugin_guest_manager.h"
+
+namespace electron {
+
+class WebViewManager : public content::BrowserPluginGuestManager {
+ public:
+  WebViewManager();
+  ~WebViewManager() override;
+
+  void AddGuest(int guest_instance_id,
+                int element_instance_id,
+                content::WebContents* embedder,
+                content::WebContents* web_contents);
+  void RemoveGuest(int guest_instance_id);
+
+ protected:
+  // content::BrowserPluginGuestManager:
+  content::WebContents* GetGuestByInstanceID(int owner_process_id,
+                                             int element_instance_id) override;
+  bool ForEachGuest(content::WebContents* embedder,
+                    const GuestCallback& callback) override;
+
+ private:
+  struct WebContentsWithEmbedder {
+    content::WebContents* web_contents;
+    content::WebContents* embedder;
+  };
+  // guest_instance_id => (web_contents, embedder)
+  std::map<int, WebContentsWithEmbedder> web_contents_embedder_map_;
+
+  struct ElementInstanceKey {
+    int embedder_process_id;
+    int element_instance_id;
+
+    ElementInstanceKey(int embedder_process_id, int element_instance_id)
+        : embedder_process_id(embedder_process_id),
+          element_instance_id(element_instance_id) {}
+
+    bool operator<(const ElementInstanceKey& other) const {
+      if (embedder_process_id != other.embedder_process_id)
+        return embedder_process_id < other.embedder_process_id;
+      return element_instance_id < other.element_instance_id;
+    }
+
+    bool operator==(const ElementInstanceKey& other) const {
+      return (embedder_process_id == other.embedder_process_id) &&
+          (element_instance_id == other.element_instance_id);
+    }
+  };
+  // (embedder_process_id, element_instance_id) => guest_instance_id
+  std::map<ElementInstanceKey, int> element_instance_id_to_guest_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebViewManager);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
added in remote
  their  100644 17144bbc438be6bac5fe407519dbf78d9c0f1a2f electron/browser/window_list.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/window_list.h"
+
+#include <algorithm>
+
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list_observer.h"
+#include "base/logging.h"
+
+namespace electron {
+
+// static
+base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
+    WindowList::observers_ = LAZY_INSTANCE_INITIALIZER;
+
+// static
+WindowList* WindowList::instance_ = NULL;
+
+// static
+WindowList* WindowList::GetInstance() {
+  if (!instance_)
+    instance_ = new WindowList;
+  return instance_;
+}
+
+// static
+void WindowList::AddWindow(NativeWindow* window) {
+  DCHECK(window);
+  // Push |window| on the appropriate list instance.
+  WindowVector& windows = GetInstance()->windows_;
+  windows.push_back(window);
+
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowAdded(window));
+}
+
+// static
+void WindowList::RemoveWindow(NativeWindow* window) {
+  WindowVector& windows = GetInstance()->windows_;
+  windows.erase(std::remove(windows.begin(), windows.end(), window),
+                windows.end());
+
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowRemoved(window));
+
+  if (windows.size() == 0)
+    FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                      OnWindowAllClosed());
+}
+
+// static
+void WindowList::WindowCloseCancelled(NativeWindow* window) {
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowCloseCancelled(window));
+}
+
+// static
+void WindowList::AddObserver(WindowListObserver* observer) {
+  observers_.Get().AddObserver(observer);
+}
+
+// static
+void WindowList::RemoveObserver(WindowListObserver* observer) {
+  observers_.Get().RemoveObserver(observer);
+}
+
+// static
+void WindowList::CloseAllWindows() {
+  WindowVector windows = GetInstance()->windows_;
+  for (size_t i = 0; i < windows.size(); ++i)
+    windows[i]->Close();
+}
+
+WindowList::WindowList() {
+}
+
+WindowList::~WindowList() {
+}
+
+}  // namespace electron
added in remote
  their  100644 ce25214c7af43af786fd500b1e84aa6098cff507 electron/browser/window_list.h
@@ -0,0 +1,73 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WINDOW_LIST_H_
+#define ELECTRON_BROWSER_WINDOW_LIST_H_
+
+#include <vector>
+
+#include "base/macros.h"
+#include "base/lazy_instance.h"
+#include "base/observer_list.h"
+
+namespace electron {
+
+class NativeWindow;
+class WindowListObserver;
+
+class WindowList {
+ public:
+  typedef std::vector<NativeWindow*> WindowVector;
+  typedef WindowVector::iterator iterator;
+  typedef WindowVector::const_iterator const_iterator;
+
+  // Windows are added to the list before they have constructed windows,
+  // so the |window()| member function may return NULL.
+  const_iterator begin() const { return windows_.begin(); }
+  const_iterator end() const { return windows_.end(); }
+
+  iterator begin() { return windows_.begin(); }
+  iterator end() { return windows_.end(); }
+
+  bool empty() const { return windows_.empty(); }
+  size_t size() const { return windows_.size(); }
+
+  NativeWindow* get(size_t index) const { return windows_[index]; }
+
+  static WindowList* GetInstance();
+
+  // Adds or removes |window| from the list it is associated with.
+  static void AddWindow(NativeWindow* window);
+  static void RemoveWindow(NativeWindow* window);
+
+  // Called by window when a close is cancelled by beforeunload handler.
+  static void WindowCloseCancelled(NativeWindow* window);
+
+  // Adds and removes |observer| from the observer list.
+  static void AddObserver(WindowListObserver* observer);
+  static void RemoveObserver(WindowListObserver* observer);
+
+  // Closes all windows.
+  static void CloseAllWindows();
+
+ private:
+  WindowList();
+  ~WindowList();
+
+  // A vector of the windows in this list, in the order they were added.
+  WindowVector windows_;
+
+  // A list of observers which will be notified of every window addition and
+  // removal across all WindowLists.
+  static base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
+      observers_;
+
+  static WindowList* instance_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowList);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WINDOW_LIST_H_
added in remote
  their  100644 e59cebaeb41225e02fb36cb642ba5609921e4561 electron/browser/window_list_observer.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
+#define ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
+
+namespace electron {
+
+class NativeWindow;
+
+class WindowListObserver {
+ public:
+  // Called immediately after a window is added to the list.
+  virtual void OnWindowAdded(NativeWindow* window) {}
+
+  // Called immediately after a window is removed from the list.
+  virtual void OnWindowRemoved(NativeWindow* window) {}
+
+  // Called when a window close is cancelled by beforeunload handler.
+  virtual void OnWindowCloseCancelled(NativeWindow* window) {}
+
+  // Called immediately after all windows are closed.
+  virtual void OnWindowAllClosed() {}
+
+ protected:
+  virtual ~WindowListObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
added in remote
  their  100644 ab6471ec9cc417da3c8ae93ffeed0b57bbaf104e electron/common/api/api_messages.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, no traditional include guard.
+
+#include "electron/common/draggable_region.h"
+#include "base/strings/string16.h"
+#include "base/values.h"
+#include "content/public/common/common_param_traits.h"
+#include "ipc/ipc_message_macros.h"
+#include "ui/gfx/ipc/gfx_param_traits.h"
+
+// The message starter should be declared in ipc/ipc_message_start.h. Since
+// we don't want to patch Chromium, we just pretend to be Content Shell.
+
+#define IPC_MESSAGE_START ShellMsgStart
+
+IPC_STRUCT_TRAITS_BEGIN(electron::DraggableRegion)
+  IPC_STRUCT_TRAITS_MEMBER(draggable)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_MESSAGE_ROUTED2(ElectronViewHostMsg_Message,
+                    base::string16 /* channel */,
+                    base::ListValue /* arguments */)
+
+IPC_SYNC_MESSAGE_ROUTED2_1(ElectronViewHostMsg_Message_Sync,
+                           base::string16 /* channel */,
+                           base::ListValue /* arguments */,
+                           base::string16 /* result (in JSON) */)
+
+IPC_MESSAGE_ROUTED2(ElectronViewMsg_Message,
+                    base::string16 /* channel */,
+                    base::ListValue /* arguments */)
+
+// Sent by the renderer when the draggable regions are updated.
+IPC_MESSAGE_ROUTED1(ElectronViewHostMsg_UpdateDraggableRegions,
+                    std::vector<electron::DraggableRegion> /* regions */)
added in remote
  their  100644 cb3975c4eb54115c36486a9154c3228fcf544bec electron/common/api/electron_api_asar.cc
@@ -0,0 +1,163 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include <vector>
+
+#include "electron_natives.h"  // NOLINT: This file is generated with coffee2c.
+#include "electron/common/asar/archive.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "native_mate/wrappable.h"
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+class Archive : public mate::Wrappable {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate,
+                                      const base::FilePath& path) {
+    scoped_ptr<asar::Archive> archive(new asar::Archive(path));
+    if (!archive->Init())
+      return v8::False(isolate);
+    return (new Archive(std::move(archive)))->GetWrapper(isolate);
+  }
+
+ protected:
+  explicit Archive(scoped_ptr<asar::Archive> archive)
+      : archive_(std::move(archive)) {}
+
+  // Reads the offset and size of file.
+  v8::Local<v8::Value> GetFileInfo(v8::Isolate* isolate,
+                                    const base::FilePath& path) {
+    asar::Archive::FileInfo info;
+    if (!archive_ || !archive_->GetFileInfo(path, &info))
+      return v8::False(isolate);
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("size", info.size);
+    dict.Set("unpacked", info.unpacked);
+    dict.Set("offset", info.offset);
+    return dict.GetHandle();
+  }
+
+  // Returns a fake result of fs.stat(path).
+  v8::Local<v8::Value> Stat(v8::Isolate* isolate,
+                             const base::FilePath& path) {
+    asar::Archive::Stats stats;
+    if (!archive_ || !archive_->Stat(path, &stats))
+      return v8::False(isolate);
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("size", stats.size);
+    dict.Set("offset", stats.offset);
+    dict.Set("isFile", stats.is_file);
+    dict.Set("isDirectory", stats.is_directory);
+    dict.Set("isLink", stats.is_link);
+    return dict.GetHandle();
+  }
+
+  // Returns all files under a directory.
+  v8::Local<v8::Value> Readdir(v8::Isolate* isolate,
+                                const base::FilePath& path) {
+    std::vector<base::FilePath> files;
+    if (!archive_ || !archive_->Readdir(path, &files))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, files);
+  }
+
+  // Returns the path of file with symbol link resolved.
+  v8::Local<v8::Value> Realpath(v8::Isolate* isolate,
+                                 const base::FilePath& path) {
+    base::FilePath realpath;
+    if (!archive_ || !archive_->Realpath(path, &realpath))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, realpath);
+  }
+
+  // Copy the file out into a temporary file and returns the new path.
+  v8::Local<v8::Value> CopyFileOut(v8::Isolate* isolate,
+                                    const base::FilePath& path) {
+    base::FilePath new_path;
+    if (!archive_ || !archive_->CopyFileOut(path, &new_path))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, new_path);
+  }
+
+  // Return the file descriptor.
+  int GetFD() const {
+    if (!archive_)
+      return -1;
+    return archive_->GetFD();
+  }
+
+  // Free the resources used by archive.
+  void Destroy() {
+    archive_.reset();
+  }
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate* isolate) {
+    if (template_.IsEmpty())
+      template_.Reset(isolate, mate::ObjectTemplateBuilder(isolate)
+          .SetValue("path", archive_->path())
+          .SetMethod("getFileInfo", &Archive::GetFileInfo)
+          .SetMethod("stat", &Archive::Stat)
+          .SetMethod("readdir", &Archive::Readdir)
+          .SetMethod("realpath", &Archive::Realpath)
+          .SetMethod("copyFileOut", &Archive::CopyFileOut)
+          .SetMethod("getFd", &Archive::GetFD)
+          .SetMethod("destroy", &Archive::Destroy)
+          .Build());
+
+    return mate::ObjectTemplateBuilder(
+        isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+  }
+
+ private:
+  scoped_ptr<asar::Archive> archive_;
+
+  DISALLOW_COPY_AND_ASSIGN(Archive);
+};
+
+void InitAsarSupport(v8::Isolate* isolate,
+                     v8::Local<v8::Value> process,
+                     v8::Local<v8::Value> require) {
+  // Evaluate asar_init.js.
+  const char* asar_init_native = reinterpret_cast<const char*>(
+      static_cast<const unsigned char*>(node::asar_init_native));
+  v8::Local<v8::Script> asar_init = v8::Script::Compile(v8::String::NewFromUtf8(
+      isolate,
+      asar_init_native,
+      v8::String::kNormalString,
+      sizeof(node::asar_init_native) -1));
+  v8::Local<v8::Value> result = asar_init->Run();
+
+  // Initialize asar support.
+  base::Callback<void(v8::Local<v8::Value>,
+                      v8::Local<v8::Value>,
+                      std::string)> init;
+  if (mate::ConvertFromV8(isolate, result, &init)) {
+    const char* asar_native = reinterpret_cast<const char*>(
+        static_cast<const unsigned char*>(node::asar_native));
+    init.Run(process,
+             require,
+             std::string(asar_native, sizeof(node::asar_native) - 1));
+  }
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("createArchive", &Archive::Create);
+  dict.SetMethod("initAsarSupport", &InitAsarSupport);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_asar, Initialize)
added in remote
  their  100644 7aadf8a26bc4179206ca6987a1c7be4dc5152b8a electron/common/api/electron_api_clipboard.cc
@@ -0,0 +1,160 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <vector>
+
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/strings/utf_string_conversions.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/gfx/image/image.h"
+
+#include "electron/common/node_includes.h"
+
+namespace {
+
+ui::ClipboardType GetClipboardType(mate::Arguments* args) {
+  std::string type;
+  if (args->GetNext(&type) && type == "selection")
+    return ui::CLIPBOARD_TYPE_SELECTION;
+  else
+    return ui::CLIPBOARD_TYPE_COPY_PASTE;
+}
+
+std::vector<base::string16> AvailableFormats(mate::Arguments* args) {
+  std::vector<base::string16> format_types;
+  bool ignore;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadAvailableTypes(GetClipboardType(args), &format_types, &ignore);
+  return format_types;
+}
+
+bool Has(const std::string& format_string, mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
+  return clipboard->IsFormatAvailable(format, GetClipboardType(args));
+}
+
+std::string Read(const std::string& format_string,
+                 mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
+
+  std::string data;
+  clipboard->ReadData(format, &data);
+  return data;
+}
+
+void Write(const mate::Dictionary& data,
+           mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  base::string16 text, html;
+  gfx::Image image;
+
+  if (data.Get("text", &text))
+    writer.WriteText(text);
+
+  if (data.Get("rtf", &text)) {
+    std::string rtf = base::UTF16ToUTF8(text);
+    writer.WriteRTF(rtf);
+  }
+
+  if (data.Get("html", &html))
+    writer.WriteHTML(html, std::string());
+
+  if (data.Get("image", &image))
+    writer.WriteImage(image.AsBitmap());
+}
+
+base::string16 ReadText(mate::Arguments* args) {
+  base::string16 data;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  auto type = GetClipboardType(args);
+  if (clipboard->IsFormatAvailable(
+      ui::Clipboard::GetPlainTextWFormatType(), type)) {
+    clipboard->ReadText(type, &data);
+  } else if (clipboard->IsFormatAvailable(
+             ui::Clipboard::GetPlainTextFormatType(), type)) {
+    std::string result;
+    clipboard->ReadAsciiText(type, &result);
+    data = base::ASCIIToUTF16(result);
+  }
+  return data;
+}
+
+void WriteText(const base::string16& text, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteText(text);
+}
+
+base::string16 ReadRtf(mate::Arguments* args) {
+  std::string data;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadRTF(GetClipboardType(args), &data);
+  return base::UTF8ToUTF16(data);
+}
+
+void WriteRtf(const std::string& text, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteRTF(text);
+}
+
+base::string16 ReadHtml(mate::Arguments* args) {
+  base::string16 data;
+  base::string16 html;
+  std::string url;
+  uint32_t start;
+  uint32_t end;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadHTML(GetClipboardType(args), &html, &url, &start, &end);
+  data = html.substr(start, end - start);
+  return data;
+}
+
+void WriteHtml(const base::string16& html, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteHTML(html, std::string());
+}
+
+gfx::Image ReadImage(mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  SkBitmap bitmap = clipboard->ReadImage(GetClipboardType(args));
+  return gfx::Image::CreateFrom1xBitmap(bitmap);
+}
+
+void WriteImage(const gfx::Image& image, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteImage(image.AsBitmap());
+}
+
+void Clear(mate::Arguments* args) {
+  ui::Clipboard::GetForCurrentThread()->Clear(GetClipboardType(args));
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("availableFormats", &AvailableFormats);
+  dict.SetMethod("has", &Has);
+  dict.SetMethod("read", &Read);
+  dict.SetMethod("write", &Write);
+  dict.SetMethod("readText", &ReadText);
+  dict.SetMethod("writeText", &WriteText);
+  dict.SetMethod("readRtf", &ReadRtf);
+  dict.SetMethod("writeRtf", &WriteRtf);
+  dict.SetMethod("readHtml", &ReadHtml);
+  dict.SetMethod("writeHtml", &WriteHtml);
+  dict.SetMethod("readImage", &ReadImage);
+  dict.SetMethod("writeImage", &WriteImage);
+  dict.SetMethod("clear", &Clear);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_clipboard, Initialize)
added in remote
  their  100644 96997a96246310087fed827727eaaae7407c5fe3 electron/common/api/electron_api_crash_reporter.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <map>
+#include <string>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/bind.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+using crash_reporter::CrashReporter;
+
+namespace mate {
+
+template<>
+struct Converter<std::map<std::string, std::string> > {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     std::map<std::string, std::string>* out) {
+    if (!val->IsObject())
+      return false;
+
+    v8::Local<v8::Object> dict = val->ToObject();
+    v8::Local<v8::Array> keys = dict->GetOwnPropertyNames();
+    for (uint32_t i = 0; i < keys->Length(); ++i) {
+      v8::Local<v8::Value> key = keys->Get(i);
+      (*out)[V8ToString(key)] = V8ToString(dict->Get(key));
+    }
+    return true;
+  }
+};
+
+template<>
+struct Converter<CrashReporter::UploadReportResult> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+      const CrashReporter::UploadReportResult& reports) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("date", v8::Date::New(isolate, reports.first*1000.0));
+    dict.Set("id", reports.second);
+    return dict.GetHandle();
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  auto report = base::Unretained(CrashReporter::GetInstance());
+  dict.SetMethod("start",
+                 base::Bind(&CrashReporter::Start, report));
+  dict.SetMethod("_getUploadedReports",
+                 base::Bind(&CrashReporter::GetUploadedReports, report));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_crash_reporter, Initialize)
added in remote
  their  100644 6cc5ea385267dee88b182b610ebe84624d9a1354 electron/common/api/electron_api_id_weak_map.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_id_weak_map.h"
+
+#include "electron/common/node_includes.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace api {
+
+IDWeakMap::IDWeakMap() {
+}
+
+IDWeakMap::~IDWeakMap() {
+}
+
+void IDWeakMap::Set(v8::Isolate* isolate,
+                    int32_t id,
+                    v8::Local<v8::Object> object) {
+  id_weak_map_.Set(isolate, id, object);
+}
+
+v8::Local<v8::Object> IDWeakMap::Get(v8::Isolate* isolate, int32_t id) {
+  return id_weak_map_.Get(isolate, id).ToLocalChecked();
+}
+
+bool IDWeakMap::Has(int32_t id) {
+  return id_weak_map_.Has(id);
+}
+
+void IDWeakMap::Remove(int32_t id) {
+  id_weak_map_.Remove(id);
+}
+
+void IDWeakMap::Clear() {
+  id_weak_map_.Clear();
+}
+
+// static
+void IDWeakMap::BuildPrototype(v8::Isolate* isolate,
+                               v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("set", &IDWeakMap::Set)
+      .SetMethod("get", &IDWeakMap::Get)
+      .SetMethod("has", &IDWeakMap::Has)
+      .SetMethod("remove", &IDWeakMap::Remove)
+      .SetMethod("clear", &IDWeakMap::Clear);
+}
+
+// static
+mate::Wrappable* IDWeakMap::Create(v8::Isolate* isolate) {
+  return new IDWeakMap;
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+using electron::api::IDWeakMap;
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<IDWeakMap>(
+      isolate, "IDWeakMap", base::Bind(&IDWeakMap::Create));
+  mate::Dictionary id_weak_map(isolate, constructor);
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("IDWeakMap", id_weak_map);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_id_weak_map, Initialize)
added in remote
  their  100644 c761450a1d7ebc5e483931f0cb173257db82b10a electron/common/api/electron_api_id_weak_map.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
+#define ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
+
+#include "electron/common/id_weak_map.h"
+#include "native_mate/object_template_builder.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class IDWeakMap : public mate::Wrappable {
+ public:
+  static mate::Wrappable* Create(v8::Isolate* isolate);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  IDWeakMap();
+  ~IDWeakMap();
+
+ private:
+  // Api for IDWeakMap.
+  void Set(v8::Isolate* isolate, int32_t id, v8::Local<v8::Object> object);
+  v8::Local<v8::Object> Get(v8::Isolate* isolate, int32_t id);
+  bool Has(int32_t id);
+  void Remove(int32_t id);
+  void Clear();
+
+  electron::IDWeakMap id_weak_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDWeakMap);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
added in remote
  their  100644 a0d9b69ba01d4ec566fc29be37656e2b1c2dcab5 electron/common/api/electron_api_native_image.cc
@@ -0,0 +1,352 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_native_image.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/asar_util.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/base64.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/pattern.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/base/data_url.h"
+#include "ui/base/layout.h"
+#include "ui/gfx/codec/jpeg_codec.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/image/image_util.h"
+
+#if defined(OS_WIN)
+#include "electron/common/asar/archive.h"
+#include "base/win/scoped_gdi_object.h"
+#include "ui/gfx/icon_util.h"
+#endif
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+struct ScaleFactorPair {
+  const char* name;
+  float scale;
+};
+
+ScaleFactorPair kScaleFactorPairs[] = {
+  // The "@2x" is put as first one to make scale matching faster.
+  { "@2x"    , 2.0f },
+  { "@3x"    , 3.0f },
+  { "@1x"    , 1.0f },
+  { "@4x"    , 4.0f },
+  { "@5x"    , 5.0f },
+  { "@1.25x" , 1.25f },
+  { "@1.33x" , 1.33f },
+  { "@1.4x"  , 1.4f },
+  { "@1.5x"  , 1.5f },
+  { "@1.8x"  , 1.8f },
+  { "@2.5x"  , 2.5f },
+};
+
+float GetScaleFactorFromPath(const base::FilePath& path) {
+  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
+
+  // We don't try to convert string to float here because it is very very
+  // expensive.
+  for (unsigned i = 0; i < arraysize(kScaleFactorPairs); ++i) {
+    if (base::EndsWith(filename, kScaleFactorPairs[i].name,
+                       base::CompareCase::INSENSITIVE_ASCII))
+      return kScaleFactorPairs[i].scale;
+  }
+
+  return 1.0f;
+}
+
+bool AddImageSkiaRep(gfx::ImageSkia* image,
+                     const unsigned char* data,
+                     size_t size,
+                     double scale_factor) {
+  scoped_ptr<SkBitmap> decoded(new SkBitmap());
+
+  // Try PNG first.
+  if (!gfx::PNGCodec::Decode(data, size, decoded.get()))
+    // Try JPEG.
+    decoded.reset(gfx::JPEGCodec::Decode(data, size));
+
+  if (!decoded)
+    return false;
+
+  image->AddRepresentation(gfx::ImageSkiaRep(*decoded, scale_factor));
+  return true;
+}
+
+bool AddImageSkiaRep(gfx::ImageSkia* image,
+                     const base::FilePath& path,
+                     double scale_factor) {
+  std::string file_contents;
+  if (!asar::ReadFileToString(path, &file_contents))
+    return false;
+
+  const unsigned char* data =
+      reinterpret_cast<const unsigned char*>(file_contents.data());
+  size_t size = file_contents.size();
+  return AddImageSkiaRep(image, data, size, scale_factor);
+}
+
+bool PopulateImageSkiaRepsFromPath(gfx::ImageSkia* image,
+                                   const base::FilePath& path) {
+  bool succeed = false;
+  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
+  if (base::MatchPattern(filename, "*@*x"))
+    // Don't search for other representations if the DPI has been specified.
+    return AddImageSkiaRep(image, path, GetScaleFactorFromPath(path));
+  else
+    succeed |= AddImageSkiaRep(image, path, 1.0f);
+
+  for (const ScaleFactorPair& pair : kScaleFactorPairs)
+    succeed |= AddImageSkiaRep(image,
+                               path.InsertBeforeExtensionASCII(pair.name),
+                               pair.scale);
+  return succeed;
+}
+
+base::FilePath NormalizePath(const base::FilePath& path) {
+  if (!path.ReferencesParent()) {
+    return path;
+  }
+
+  base::FilePath absolute_path = MakeAbsoluteFilePath(path);
+  // MakeAbsoluteFilePath returns an empty path on failures so use original path
+  if (absolute_path.empty()) {
+    return path;
+  } else {
+    return absolute_path;
+  }
+}
+
+#if defined(OS_MACOSX)
+bool IsTemplateFilename(const base::FilePath& path) {
+  return (base::MatchPattern(path.value(), "*Template.*") ||
+          base::MatchPattern(path.value(), "*Template@*x.*"));
+}
+#endif
+
+#if defined(OS_WIN)
+bool ReadImageSkiaFromICO(gfx::ImageSkia* image, const base::FilePath& path) {
+  // If file is in asar archive, we extract it to a temp file so LoadImage can
+  // load it.
+  base::FilePath asar_path, relative_path;
+  base::FilePath image_path(path);
+  if (asar::GetAsarArchivePath(image_path, &asar_path, &relative_path)) {
+    std::shared_ptr<asar::Archive> archive =
+        asar::GetOrCreateAsarArchive(asar_path);
+    if (archive)
+      archive->CopyFileOut(relative_path, &image_path);
+  }
+
+  // Load the icon from file.
+  base::win::ScopedHICON icon(static_cast<HICON>(
+      LoadImage(NULL, image_path.value().c_str(), IMAGE_ICON, 0, 0,
+                LR_DEFAULTSIZE | LR_LOADFROMFILE)));
+  if (!icon.get())
+    return false;
+
+  // Convert the icon from the Windows specific HICON to gfx::ImageSkia.
+  scoped_ptr<SkBitmap> bitmap(IconUtil::  CreateSkBitmapFromHICON(icon.get()));
+  image->AddRepresentation(gfx::ImageSkiaRep(*bitmap, 1.0f));
+  return true;
+}
+#endif
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+}  // namespace
+
+NativeImage::NativeImage() {}
+
+NativeImage::NativeImage(const gfx::Image& image) : image_(image) {}
+
+NativeImage::~NativeImage() {}
+
+mate::ObjectTemplateBuilder NativeImage::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  if (template_.IsEmpty())
+    template_.Reset(isolate, mate::ObjectTemplateBuilder(isolate)
+        .SetMethod("toPng", &NativeImage::ToPNG)
+        .SetMethod("toJpeg", &NativeImage::ToJPEG)
+        .SetMethod("getNativeHandle", &NativeImage::GetNativeHandle)
+        .SetMethod("toDataURL", &NativeImage::ToDataURL)
+        .SetMethod("toDataUrl", &NativeImage::ToDataURL)  // deprecated.
+        .SetMethod("isEmpty", &NativeImage::IsEmpty)
+        .SetMethod("getSize", &NativeImage::GetSize)
+        .SetMethod("setTemplateImage", &NativeImage::SetTemplateImage)
+        .SetMethod("isTemplateImage", &NativeImage::IsTemplateImage)
+        .Build());
+
+  return mate::ObjectTemplateBuilder(
+      isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+}
+
+v8::Local<v8::Value> NativeImage::ToPNG(v8::Isolate* isolate) {
+  scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
+  return node::Buffer::Copy(isolate,
+                            reinterpret_cast<const char*>(png->front()),
+                            static_cast<size_t>(png->size())).ToLocalChecked();
+}
+
+v8::Local<v8::Value> NativeImage::ToJPEG(v8::Isolate* isolate, int quality) {
+  std::vector<unsigned char> output;
+  gfx::JPEG1xEncodedDataFromImage(image_, quality, &output);
+  return node::Buffer::Copy(
+      isolate,
+      reinterpret_cast<const char*>(&output.front()),
+      static_cast<size_t>(output.size())).ToLocalChecked();
+}
+
+std::string NativeImage::ToDataURL() {
+  scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
+  std::string data_url;
+  data_url.insert(data_url.end(), png->front(), png->front() + png->size());
+  base::Base64Encode(data_url, &data_url);
+  data_url.insert(0, "data:image/png;base64,");
+  return data_url;
+}
+
+v8::Local<v8::Value> NativeImage::GetNativeHandle(v8::Isolate* isolate,
+                                                  mate::Arguments* args) {
+#if defined(OS_MACOSX)
+  NSImage* ptr = image_.AsNSImage();
+  return node::Buffer::Copy(
+      isolate,
+      reinterpret_cast<char*>(ptr),
+      sizeof(void*)).ToLocalChecked();
+#else
+  args->ThrowError("Not implemented");
+  return v8::Undefined(isolate);
+#endif
+}
+
+bool NativeImage::IsEmpty() {
+  return image_.IsEmpty();
+}
+
+gfx::Size NativeImage::GetSize() {
+  return image_.Size();
+}
+
+#if !defined(OS_MACOSX)
+void NativeImage::SetTemplateImage(bool setAsTemplate) {
+}
+
+bool NativeImage::IsTemplateImage() {
+  return false;
+}
+#endif
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateEmpty(v8::Isolate* isolate) {
+  return mate::CreateHandle(isolate, new NativeImage);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::Create(
+    v8::Isolate* isolate, const gfx::Image& image) {
+  return mate::CreateHandle(isolate, new NativeImage(image));
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromPNG(
+    v8::Isolate* isolate, const char* buffer, size_t length) {
+  gfx::Image image = gfx::Image::CreateFrom1xPNGBytes(
+      reinterpret_cast<const unsigned char*>(buffer), length);
+  return Create(isolate, image);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromJPEG(
+    v8::Isolate* isolate, const char* buffer, size_t length) {
+  gfx::Image image = gfx::ImageFrom1xJPEGEncodedData(
+      reinterpret_cast<const unsigned char*>(buffer), length);
+  return Create(isolate, image);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromPath(
+    v8::Isolate* isolate, const base::FilePath& path) {
+  gfx::ImageSkia image_skia;
+  base::FilePath image_path = NormalizePath(path);
+
+  if (image_path.MatchesExtension(FILE_PATH_LITERAL(".ico"))) {
+#if defined(OS_WIN)
+    ReadImageSkiaFromICO(&image_skia, image_path);
+#endif
+  } else {
+    PopulateImageSkiaRepsFromPath(&image_skia, image_path);
+  }
+  gfx::Image image(image_skia);
+  mate::Handle<NativeImage> handle = Create(isolate, image);
+#if defined(OS_MACOSX)
+  if (IsTemplateFilename(image_path))
+    handle->SetTemplateImage(true);
+#endif
+  return handle;
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromBuffer(
+    mate::Arguments* args, v8::Local<v8::Value> buffer) {
+  double scale_factor = 1.;
+  args->GetNext(&scale_factor);
+
+  gfx::ImageSkia image_skia;
+  AddImageSkiaRep(&image_skia,
+                  reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
+                  node::Buffer::Length(buffer),
+                  scale_factor);
+  return Create(args->isolate(), gfx::Image(image_skia));
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromDataURL(
+    v8::Isolate* isolate, const GURL& url) {
+  std::string mime_type, charset, data;
+  if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
+    if (mime_type == "image/png")
+      return CreateFromPNG(isolate, data.c_str(), data.size());
+    else if (mime_type == "image/jpeg")
+      return CreateFromJPEG(isolate, data.c_str(), data.size());
+  }
+
+  return CreateEmpty(isolate);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("createEmpty", &electron::api::NativeImage::CreateEmpty);
+  dict.SetMethod("createFromPath", &electron::api::NativeImage::CreateFromPath);
+  dict.SetMethod("createFromBuffer", &electron::api::NativeImage::CreateFromBuffer);
+  dict.SetMethod("createFromDataURL",
+                 &electron::api::NativeImage::CreateFromDataURL);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_native_image, Initialize)
added in remote
  their  100644 29ccec20538730abb365bec3bbfcf59d23ecd5f5 electron/common/api/electron_api_native_image.h
@@ -0,0 +1,85 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
+#define ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
+
+#include <string>
+
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+#include "ui/gfx/image/image.h"
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace gfx {
+class Size;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class NativeImage : public mate::Wrappable {
+ public:
+  static mate::Handle<NativeImage> CreateEmpty(v8::Isolate* isolate);
+  static mate::Handle<NativeImage> Create(
+      v8::Isolate* isolate, const gfx::Image& image);
+  static mate::Handle<NativeImage> CreateFromPNG(
+      v8::Isolate* isolate, const char* buffer, size_t length);
+  static mate::Handle<NativeImage> CreateFromJPEG(
+      v8::Isolate* isolate, const char* buffer, size_t length);
+  static mate::Handle<NativeImage> CreateFromPath(
+      v8::Isolate* isolate, const base::FilePath& path);
+  static mate::Handle<NativeImage> CreateFromBuffer(
+      mate::Arguments* args, v8::Local<v8::Value> buffer);
+  static mate::Handle<NativeImage> CreateFromDataURL(
+      v8::Isolate* isolate, const GURL& url);
+
+  // The default constructor should only be used by image_converter.cc.
+  NativeImage();
+
+  const gfx::Image& image() const { return image_; }
+
+ protected:
+  explicit NativeImage(const gfx::Image& image);
+  virtual ~NativeImage();
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  v8::Local<v8::Value> ToPNG(v8::Isolate* isolate);
+  v8::Local<v8::Value> ToJPEG(v8::Isolate* isolate, int quality);
+  v8::Local<v8::Value> GetNativeHandle(
+    v8::Isolate* isolate,
+    mate::Arguments* args);
+  std::string ToDataURL();
+  bool IsEmpty();
+  gfx::Size GetSize();
+
+  // Mark the image as template image.
+  void SetTemplateImage(bool setAsTemplate);
+  // Determine if the image is a template image.
+  bool IsTemplateImage();
+
+  gfx::Image image_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeImage);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
added in remote
  their  100644 4ebdcefa764e1227069ce0c642140d12028122b0 electron/common/api/electron_api_native_image_mac.mm
@@ -0,0 +1,23 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_native_image.h"
+
+#import <Cocoa/Cocoa.h>
+
+namespace electron {
+
+namespace api {
+
+void NativeImage::SetTemplateImage(bool setAsTemplate) {
+  [image_.AsNSImage() setTemplate:setAsTemplate];
+}
+
+bool NativeImage::IsTemplateImage() {
+  return [image_.AsNSImage() isTemplate];
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 53ad7c44b0c401460f65faf64c3c1b9355252ab8 electron/common/api/electron_api_shell.cc
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/platform_util.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+
+namespace {
+
+bool OpenExternal(const GURL& url, mate::Arguments* args) {
+  bool activate = true;
+  if (args->Length() == 2) {
+    mate::Dictionary options;
+    if (args->GetNext(&options)) {
+      options.Get("activate", &activate);
+    }
+  }
+  return platform_util::OpenExternal(url, activate);
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("showItemInFolder", &platform_util::ShowItemInFolder);
+  dict.SetMethod("openItem", &platform_util::OpenItem);
+  dict.SetMethod("openExternal", &OpenExternal);
+  dict.SetMethod("moveItemToTrash", &platform_util::MoveItemToTrash);
+  dict.SetMethod("beep", &platform_util::Beep);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_shell, Initialize)
added in remote
  their  100644 efec51533b73a5814701f28c478fbacfa106261d electron/common/api/electron_api_v8_util.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/api/object_life_monitor.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+#include "v8/include/v8-profiler.h"
+
+namespace {
+
+v8::Local<v8::Value> GetHiddenValue(v8::Isolate* isolate,
+                                    v8::Local<v8::Object> object,
+                                    v8::Local<v8::String> key) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  v8::Local<v8::Value> value;
+  v8::Maybe<bool> result = object->HasPrivate(context, privateKey);
+  if (!(result.IsJust() && result.FromJust()))
+    return v8::Local<v8::Value>();
+  if (object->GetPrivate(context, privateKey).ToLocal(&value))
+    return value;
+  return v8::Local<v8::Value>();
+}
+
+void SetHiddenValue(v8::Isolate* isolate,
+                    v8::Local<v8::Object> object,
+                    v8::Local<v8::String> key,
+                    v8::Local<v8::Value> value) {
+  if (value.IsEmpty())
+    return;
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  object->SetPrivate(context, privateKey, value);
+}
+
+void DeleteHiddenValue(v8::Isolate* isolate,
+                       v8::Local<v8::Object> object,
+                       v8::Local<v8::String> key) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  // Actually deleting the value would make force the object into
+  // dictionary mode which is unnecessarily slow. Instead, we replace
+  // the hidden value with "undefined".
+  object->SetPrivate(context, privateKey, v8::Undefined(isolate));
+}
+
+int32_t GetObjectHash(v8::Local<v8::Object> object) {
+  return object->GetIdentityHash();
+}
+
+void SetDestructor(v8::Isolate* isolate,
+                   v8::Local<v8::Object> object,
+                   v8::Local<v8::Function> callback) {
+  electron::ObjectLifeMonitor::BindTo(isolate, object, callback);
+}
+
+void TakeHeapSnapshot(v8::Isolate* isolate) {
+  isolate->GetHeapProfiler()->TakeHeapSnapshot();
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("getHiddenValue", &GetHiddenValue);
+  dict.SetMethod("setHiddenValue", &SetHiddenValue);
+  dict.SetMethod("deleteHiddenValue", &DeleteHiddenValue);
+  dict.SetMethod("getObjectHash", &GetObjectHash);
+  dict.SetMethod("setDestructor", &SetDestructor);
+  dict.SetMethod("takeHeapSnapshot", &TakeHeapSnapshot);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_v8_util, Initialize)
added in remote
  their  100644 9771481bf75a34af826bf588e85b6ed99fb1e616 electron/common/api/electron_bindings.cc
@@ -0,0 +1,108 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_bindings.h"
+
+#include <algorithm>
+#include <string>
+#include <iostream>
+
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/logging.h"
+#include "base/process/process_metrics.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace {
+
+// Dummy class type that used for crashing the program.
+struct DummyClass { bool crash; };
+
+void Crash() {
+  static_cast<DummyClass*>(NULL)->crash = true;
+}
+
+void Hang() {
+  for (;;)
+    base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(1));
+}
+
+// Called when there is a fatal error in V8, we just crash the process here so
+// we can get the stack trace.
+void FatalErrorCallback(const char* location, const char* message) {
+  LOG(ERROR) << "Fatal error in V8: " << location << " " << message;
+  Crash();
+}
+
+void Log(const base::string16& message) {
+  std::cout << message << std::flush;
+}
+
+}  // namespace
+
+
+ElectronBindings::ElectronBindings() {
+  uv_async_init(uv_default_loop(), &call_next_tick_async_, OnCallNextTick);
+  call_next_tick_async_.data = this;
+}
+
+ElectronBindings::~ElectronBindings() {
+}
+
+void ElectronBindings::BindTo(v8::Isolate* isolate,
+                          v8::Local<v8::Object> process) {
+  v8::V8::SetFatalErrorHandler(FatalErrorCallback);
+
+  mate::Dictionary dict(isolate, process);
+  dict.SetMethod("crash", &Crash);
+  dict.SetMethod("hang", &Hang);
+  dict.SetMethod("log", &Log);
+#if defined(OS_POSIX)
+  dict.SetMethod("setFdLimit", &base::SetFdLimit);
+#endif
+  dict.SetMethod("activateUvLoop",
+      base::Bind(&ElectronBindings::ActivateUVLoop, base::Unretained(this)));
+
+#if defined(MAS_BUILD)
+  dict.Set("mas", true);
+#endif
+
+  mate::Dictionary versions;
+  if (dict.Get("versions", &versions)) {
+    versions.Set(ELECTRON_PROJECT_NAME, ELECTRON_VERSION_STRING);
+    versions.Set("atom-shell", ELECTRON_VERSION_STRING);  // For compatibility.
+    versions.Set("chrome", CHROME_VERSION_STRING);
+  }
+}
+
+void ElectronBindings::ActivateUVLoop(v8::Isolate* isolate) {
+  node::Environment* env = node::Environment::GetCurrent(isolate);
+  if (std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env) !=
+      pending_next_ticks_.end())
+    return;
+
+  pending_next_ticks_.push_back(env);
+  uv_async_send(&call_next_tick_async_);
+}
+
+// static
+void ElectronBindings::OnCallNextTick(uv_async_t* handle) {
+  ElectronBindings* self = static_cast<ElectronBindings*>(handle->data);
+  for (std::list<node::Environment*>::const_iterator it =
+           self->pending_next_ticks_.begin();
+       it != self->pending_next_ticks_.end(); ++it) {
+    node::Environment* env = *it;
+    node::Environment::AsyncCallbackScope callback_scope(env);
+    env->KickNextTick(&callback_scope);
+  }
+
+  self->pending_next_ticks_.clear();
+}
+
+}  // namespace electron
added in remote
  their  100644 9febb32a6ff1306fd129c0b82edd330fdd25c4b7 electron/common/api/electron_bindings.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
+#define ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
+
+#include <list>
+
+#include "base/macros.h"
+#include "base/strings/string16.h"
+#include "v8/include/v8.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace node {
+class Environment;
+}
+
+namespace electron {
+
+class ElectronBindings {
+ public:
+  ElectronBindings();
+  virtual ~ElectronBindings();
+
+  // Add process.atomBinding function, which behaves like process.binding but
+  // load native code from Electron instead.
+  void BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process);
+
+ private:
+  void ActivateUVLoop(v8::Isolate* isolate);
+
+  static void OnCallNextTick(uv_async_t* handle);
+
+  uv_async_t call_next_tick_async_;
+  std::list<node::Environment*> pending_next_ticks_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBindings);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
added in remote
  their  100644 e25bb7cb88379ff473911f7fbe964e0d249698c2 electron/common/api/event_emitter_caller.cc
@@ -0,0 +1,31 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/event_emitter_caller.h"
+
+#include "electron/common/api/locker.h"
+#include "electron/common/node_includes.h"
+#include "base/memory/scoped_ptr.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+namespace mate {
+
+namespace internal {
+
+v8::Local<v8::Value> CallEmitWithArgs(v8::Isolate* isolate,
+                                      v8::Local<v8::Object> obj,
+                                      ValueVector* args) {
+  // Perform microtask checkpoint after running JavaScript.
+  scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+      Locker::IsBrowserProcess() ?
+      nullptr : new blink::WebScopedRunV8Script);
+  // Use node::MakeCallback to call the callback, and it will also run pending
+  // tasks in Node.js.
+  return node::MakeCallback(
+      isolate, obj, "emit", args->size(), &args->front());
+}
+
+}  // namespace internal
+
+}  // namespace mate
added in remote
  their  100644 2a40a5b92a2a27cc2100f333213a610c7903a90d electron/common/api/event_emitter_caller.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
+#define ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
+
+#include <vector>
+
+#include "native_mate/converter.h"
+
+namespace mate {
+
+namespace internal {
+
+using ValueVector = std::vector<v8::Local<v8::Value>>;
+
+v8::Local<v8::Value> CallEmitWithArgs(v8::Isolate* isolate,
+                                      v8::Local<v8::Object> obj,
+                                      ValueVector* args);
+
+}  // namespace internal
+
+// obj.emit.apply(obj, name, args...);
+// The caller is responsible of allocating a HandleScope.
+template<typename StringType, typename... Args>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               const internal::ValueVector& args) {
+  internal::ValueVector concatenated_args = { StringToV8(isolate, name) };
+  concatenated_args.reserve(1 + args.size());
+  concatenated_args.insert(concatenated_args.end(), args.begin(), args.end());
+  return internal::CallEmitWithArgs(isolate, obj, &concatenated_args);
+}
+
+// obj.emit(name, args...);
+// The caller is responsible of allocating a HandleScope.
+template<typename StringType, typename... Args>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               const Args&... args) {
+  internal::ValueVector converted_args = {
+      StringToV8(isolate, name),
+      ConvertToV8(isolate, args)...,
+  };
+  return internal::CallEmitWithArgs(isolate, obj, &converted_args);
+}
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
added in remote
  their  100644 96b9fa63326c48422d0cf5172682174cdbf4c650 electron/common/api/locker.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "electron/common/api/locker.h"
+
+namespace mate {
+
+Locker::Locker(v8::Isolate* isolate) {
+  if (IsBrowserProcess())
+    locker_.reset(new v8::Locker(isolate));
+}
+
+Locker::~Locker() {
+}
+
+}  // namespace mate
added in remote
  their  100644 80203fb942851db437007821d372fbe8ad1ed9ee electron/common/api/locker.h
@@ -0,0 +1,34 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_COMMON_API_LOCKER_H_
+#define ELECTRON_COMMON_API_LOCKER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "v8/include/v8.h"
+
+namespace mate {
+
+// Only lock when lockers are used in current thread.
+class Locker {
+ public:
+  explicit Locker(v8::Isolate* isolate);
+  ~Locker();
+
+  // Returns whether current process is browser process, currently we detect it
+  // by checking whether current has used V8 Lock, but it might be a bad idea.
+  static inline bool IsBrowserProcess() { return v8::Locker::IsActive(); }
+
+ private:
+  void* operator new(size_t size);
+  void operator delete(void*, size_t);
+
+  scoped_ptr<v8::Locker> locker_;
+
+  DISALLOW_COPY_AND_ASSIGN(Locker);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_API_LOCKER_H_
added in remote
  their  100644 c5d219dfcdbee8480a418ce09ca75b15994747a8 electron/common/api/object_life_monitor.cc
@@ -0,0 +1,55 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 Intel Corp. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/object_life_monitor.h"
+
+#include "base/bind.h"
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+// static
+void ObjectLifeMonitor::BindTo(v8::Isolate* isolate,
+                               v8::Local<v8::Object> target,
+                               v8::Local<v8::Function> destructor) {
+  new ObjectLifeMonitor(isolate, target, destructor);
+}
+
+ObjectLifeMonitor::ObjectLifeMonitor(v8::Isolate* isolate,
+                                     v8::Local<v8::Object> target,
+                                     v8::Local<v8::Function> destructor)
+    : isolate_(isolate),
+      context_(isolate, isolate->GetCurrentContext()),
+      target_(isolate, target),
+      destructor_(isolate, destructor),
+      weak_ptr_factory_(this) {
+  target_.SetWeak(this, OnObjectGC, v8::WeakCallbackType::kParameter);
+}
+
+// static
+void ObjectLifeMonitor::OnObjectGC(
+    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
+  ObjectLifeMonitor* self = data.GetParameter();
+  self->target_.Reset();
+  self->RunCallback();
+  data.SetSecondPassCallback(Free);
+}
+
+// static
+void ObjectLifeMonitor::Free(
+    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
+  delete data.GetParameter();
+}
+
+void ObjectLifeMonitor::RunCallback() {
+  v8::HandleScope handle_scope(isolate_);
+  v8::Local<v8::Context> context = v8::Local<v8::Context>::New(
+      isolate_, context_);
+  v8::Context::Scope context_scope(context);
+  v8::Local<v8::Function>::New(isolate_, destructor_)->Call(
+      context->Global(), 0, nullptr);
+}
+
+}  // namespace electron
added in remote
  their  100644 487a4b288ccb8571acc7e98bfbaeac1afa6fb141 electron/common/api/object_life_monitor.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
+#define ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+class ObjectLifeMonitor {
+ public:
+  static void BindTo(v8::Isolate* isolate,
+                     v8::Local<v8::Object> target,
+                     v8::Local<v8::Function> destructor);
+
+ private:
+  ObjectLifeMonitor(v8::Isolate* isolate,
+                    v8::Local<v8::Object> target,
+                    v8::Local<v8::Function> destructor);
+
+  static void OnObjectGC(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
+  static void Free(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
+
+  void RunCallback();
+
+  v8::Isolate* isolate_;
+  v8::Global<v8::Context> context_;
+  v8::Global<v8::Object> target_;
+  v8::Global<v8::Function> destructor_;
+
+  base::WeakPtrFactory<ObjectLifeMonitor> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ObjectLifeMonitor);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
added in remote
  their  100644 34250f9e824a5606d837e1e26b7697f4dec8b126 electron/common/asar/archive.cc
@@ -0,0 +1,307 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/archive.h"
+
+#if defined(OS_WIN)
+#include <io.h>
+#endif
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/scoped_temporary_file.h"
+#include "base/files/file.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/pickle.h"
+#include "base/json/json_reader.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/values.h"
+
+namespace asar {
+
+namespace {
+
+#if defined(OS_WIN)
+const char kSeparators[] = "\\/";
+#else
+const char kSeparators[] = "/";
+#endif
+
+bool GetNodeFromPath(std::string path,
+                     const base::DictionaryValue* root,
+                     const base::DictionaryValue** out);
+
+// Gets the "files" from "dir".
+bool GetFilesNode(const base::DictionaryValue* root,
+                  const base::DictionaryValue* dir,
+                  const base::DictionaryValue** out) {
+  // Test for symbol linked directory.
+  std::string link;
+  if (dir->GetStringWithoutPathExpansion("link", &link)) {
+    const base::DictionaryValue* linked_node = NULL;
+    if (!GetNodeFromPath(link, root, &linked_node))
+      return false;
+    dir = linked_node;
+  }
+
+  return dir->GetDictionaryWithoutPathExpansion("files", out);
+}
+
+// Gets sub-file "name" from "dir".
+bool GetChildNode(const base::DictionaryValue* root,
+                  const std::string& name,
+                  const base::DictionaryValue* dir,
+                  const base::DictionaryValue** out) {
+  if (name == "") {
+    *out = root;
+    return true;
+  }
+
+  const base::DictionaryValue* files = NULL;
+  return GetFilesNode(root, dir, &files) &&
+         files->GetDictionaryWithoutPathExpansion(name, out);
+}
+
+// Gets the node of "path" from "root".
+bool GetNodeFromPath(std::string path,
+                     const base::DictionaryValue* root,
+                     const base::DictionaryValue** out) {
+  if (path == "") {
+    *out = root;
+    return true;
+  }
+
+  const base::DictionaryValue* dir = root;
+  for (size_t delimiter_position = path.find_first_of(kSeparators);
+       delimiter_position != std::string::npos;
+       delimiter_position = path.find_first_of(kSeparators)) {
+    const base::DictionaryValue* child = NULL;
+    if (!GetChildNode(root, path.substr(0, delimiter_position), dir, &child))
+      return false;
+
+    dir = child;
+    path.erase(0, delimiter_position + 1);
+  }
+
+  return GetChildNode(root, path, dir, out);
+}
+
+bool FillFileInfoWithNode(Archive::FileInfo* info,
+                          uint32_t header_size,
+                          const base::DictionaryValue* node) {
+  int size;
+  if (!node->GetInteger("size", &size))
+    return false;
+  info->size = static_cast<uint32_t>(size);
+
+  if (node->GetBoolean("unpacked", &info->unpacked) && info->unpacked)
+    return true;
+
+  std::string offset;
+  if (!node->GetString("offset", &offset))
+    return false;
+  if (!base::StringToUint64(offset, &info->offset))
+    return false;
+  info->offset += header_size;
+
+  node->GetBoolean("executable", &info->executable);
+
+  return true;
+}
+
+}  // namespace
+
+Archive::Archive(const base::FilePath& path)
+    : path_(path),
+      file_(path_, base::File::FLAG_OPEN | base::File::FLAG_READ),
+#if defined(OS_WIN)
+      fd_(_open_osfhandle(
+              reinterpret_cast<intptr_t>(file_.GetPlatformFile()), 0)),
+#elif defined(OS_POSIX)
+      fd_(file_.GetPlatformFile()),
+#else
+      fd_(-1),
+#endif
+      header_size_(0) {
+}
+
+Archive::~Archive() {
+#if defined(OS_WIN)
+  if (fd_ != -1) {
+    _close(fd_);
+    // Don't close the handle since we already closed the fd.
+    file_.TakePlatformFile();
+  }
+#endif
+}
+
+bool Archive::Init() {
+  if (!file_.IsValid()) {
+    if (file_.error_details() != base::File::FILE_ERROR_NOT_FOUND) {
+      LOG(WARNING) << "Opening " << path_.value()
+                   << ": " << base::File::ErrorToString(file_.error_details());
+    }
+    return false;
+  }
+
+  std::vector<char> buf;
+  int len;
+
+  buf.resize(8);
+  len = file_.ReadAtCurrentPos(buf.data(), buf.size());
+  if (len != static_cast<int>(buf.size())) {
+    PLOG(ERROR) << "Failed to read header size from " << path_.value();
+    return false;
+  }
+
+  uint32_t size;
+  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size())).ReadUInt32(
+          &size)) {
+    LOG(ERROR) << "Failed to parse header size from " << path_.value();
+    return false;
+  }
+
+  buf.resize(size);
+  len = file_.ReadAtCurrentPos(buf.data(), buf.size());
+  if (len != static_cast<int>(buf.size())) {
+    PLOG(ERROR) << "Failed to read header from " << path_.value();
+    return false;
+  }
+
+  std::string header;
+  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size())).ReadString(
+        &header)) {
+    LOG(ERROR) << "Failed to parse header from " << path_.value();
+    return false;
+  }
+
+  std::string error;
+  base::JSONReader reader;
+  scoped_ptr<base::Value> value(reader.ReadToValue(header));
+  if (!value || !value->IsType(base::Value::TYPE_DICTIONARY)) {
+    LOG(ERROR) << "Failed to parse header: " << error;
+    return false;
+  }
+
+  header_size_ = 8 + size;
+  header_.reset(static_cast<base::DictionaryValue*>(value.release()));
+  return true;
+}
+
+bool Archive::GetFileInfo(const base::FilePath& path, FileInfo* info) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  std::string link;
+  if (node->GetString("link", &link))
+    return GetFileInfo(base::FilePath::FromUTF8Unsafe(link), info);
+
+  return FillFileInfoWithNode(info, header_size_, node);
+}
+
+bool Archive::Stat(const base::FilePath& path, Stats* stats) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  if (node->HasKey("link")) {
+    stats->is_file = false;
+    stats->is_link = true;
+    return true;
+  }
+
+  if (node->HasKey("files")) {
+    stats->is_file = false;
+    stats->is_directory = true;
+    return true;
+  }
+
+  return FillFileInfoWithNode(stats, header_size_, node);
+}
+
+bool Archive::Readdir(const base::FilePath& path,
+                      std::vector<base::FilePath>* list) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  const base::DictionaryValue* files;
+  if (!GetFilesNode(header_.get(), node, &files))
+    return false;
+
+  base::DictionaryValue::Iterator iter(*files);
+  while (!iter.IsAtEnd()) {
+    list->push_back(base::FilePath::FromUTF8Unsafe(iter.key()));
+    iter.Advance();
+  }
+  return true;
+}
+
+bool Archive::Realpath(const base::FilePath& path, base::FilePath* realpath) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  std::string link;
+  if (node->GetString("link", &link)) {
+    *realpath = base::FilePath::FromUTF8Unsafe(link);
+    return true;
+  }
+
+  *realpath = path;
+  return true;
+}
+
+bool Archive::CopyFileOut(const base::FilePath& path, base::FilePath* out) {
+  if (external_files_.contains(path)) {
+    *out = external_files_.get(path)->path();
+    return true;
+  }
+
+  FileInfo info;
+  if (!GetFileInfo(path, &info))
+    return false;
+
+  if (info.unpacked) {
+    *out = path_.AddExtension(FILE_PATH_LITERAL("unpacked")).Append(path);
+    return true;
+  }
+
+  scoped_ptr<ScopedTemporaryFile> temp_file(new ScopedTemporaryFile);
+  base::FilePath::StringType ext = path.Extension();
+  if (!temp_file->InitFromFile(&file_, ext, info.offset, info.size))
+    return false;
+
+#if defined(OS_POSIX)
+  if (info.executable) {
+    // chmod a+x temp_file;
+    base::SetPosixFilePermissions(temp_file->path(), 0755);
+  }
+#endif
+
+  *out = temp_file->path();
+  external_files_.set(path, std::move(temp_file));
+  return true;
+}
+
+int Archive::GetFD() const {
+  return fd_;
+}
+
+}  // namespace asar
added in remote
  their  100644 4468f1ccda7b1de4c3ed87a176c9615453075002 electron/common/asar/archive.h
@@ -0,0 +1,86 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_ARCHIVE_H_
+#define ELECTRON_COMMON_ASAR_ARCHIVE_H_
+
+#include <vector>
+
+#include "base/containers/scoped_ptr_hash_map.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace base {
+class DictionaryValue;
+}
+
+namespace asar {
+
+class ScopedTemporaryFile;
+
+// This class represents an asar package, and provides methods to read
+// information from it.
+class Archive {
+ public:
+  struct FileInfo {
+    FileInfo() : unpacked(false), executable(false), size(0), offset(0) {}
+    bool unpacked;
+    bool executable;
+    uint32_t size;
+    uint64_t offset;
+  };
+
+  struct Stats : public FileInfo {
+    Stats() : is_file(true), is_directory(false), is_link(false) {}
+    bool is_file;
+    bool is_directory;
+    bool is_link;
+  };
+
+  explicit Archive(const base::FilePath& path);
+  virtual ~Archive();
+
+  // Read and parse the header.
+  bool Init();
+
+  // Get the info of a file.
+  bool GetFileInfo(const base::FilePath& path, FileInfo* info);
+
+  // Fs.stat(path).
+  bool Stat(const base::FilePath& path, Stats* stats);
+
+  // Fs.readdir(path).
+  bool Readdir(const base::FilePath& path, std::vector<base::FilePath>* files);
+
+  // Fs.realpath(path).
+  bool Realpath(const base::FilePath& path, base::FilePath* realpath);
+
+  // Copy the file into a temporary file, and return the new path.
+  // For unpacked file, this method will return its real path.
+  bool CopyFileOut(const base::FilePath& path, base::FilePath* out);
+
+  // Returns the file's fd.
+  int GetFD() const;
+
+  base::FilePath path() const { return path_; }
+  base::DictionaryValue* header() const { return header_.get(); }
+
+ private:
+  base::FilePath path_;
+  base::File file_;
+  int fd_;
+  uint32_t header_size_;
+  scoped_ptr<base::DictionaryValue> header_;
+
+  // Cached external temporary files.
+  base::ScopedPtrHashMap<base::FilePath, scoped_ptr<ScopedTemporaryFile>>
+      external_files_;
+
+  DISALLOW_COPY_AND_ASSIGN(Archive);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_ARCHIVE_H_
added in remote
  their  100644 56939ce43e1e3b780523838c21db4ee29f58c501 electron/common/asar/asar_util.cc
@@ -0,0 +1,90 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/asar_util.h"
+
+#include <map>
+#include <string>
+
+#include "electron/common/asar/archive.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/lazy_instance.h"
+#include "base/stl_util.h"
+
+namespace asar {
+
+namespace {
+
+// The global instance of ArchiveMap, will be destroyed on exit.
+typedef std::map<base::FilePath, std::shared_ptr<Archive>> ArchiveMap;
+static base::LazyInstance<ArchiveMap> g_archive_map = LAZY_INSTANCE_INITIALIZER;
+
+const base::FilePath::CharType kAsarExtension[] = FILE_PATH_LITERAL(".asar");
+
+}  // namespace
+
+std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path) {
+  ArchiveMap& archive_map = *g_archive_map.Pointer();
+  if (!ContainsKey(archive_map, path)) {
+    std::shared_ptr<Archive> archive(new Archive(path));
+    if (!archive->Init())
+      return nullptr;
+    archive_map[path] = archive;
+  }
+  return archive_map[path];
+}
+
+bool GetAsarArchivePath(const base::FilePath& full_path,
+                        base::FilePath* asar_path,
+                        base::FilePath* relative_path) {
+  base::FilePath iter = full_path;
+  while (true) {
+    base::FilePath dirname = iter.DirName();
+    if (iter.MatchesExtension(kAsarExtension))
+      break;
+    else if (iter == dirname)
+      return false;
+    iter = dirname;
+  }
+
+  base::FilePath tail;
+  if (!iter.AppendRelativePath(full_path, &tail))
+    return false;
+
+  *asar_path = iter;
+  *relative_path = tail;
+  return true;
+}
+
+bool ReadFileToString(const base::FilePath& path, std::string* contents) {
+  base::FilePath asar_path, relative_path;
+  if (!GetAsarArchivePath(path, &asar_path, &relative_path))
+    return base::ReadFileToString(path, contents);
+
+  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
+  if (!archive)
+    return false;
+
+  Archive::FileInfo info;
+  if (!archive->GetFileInfo(relative_path, &info))
+    return false;
+
+  if (info.unpacked) {
+    base::FilePath real_path;
+    // For unpacked file it will return the real path instead of doing the copy.
+    archive->CopyFileOut(relative_path, &real_path);
+    return base::ReadFileToString(real_path, contents);
+  }
+
+  base::File src(asar_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!src.IsValid())
+    return false;
+
+  contents->resize(info.size);
+  return static_cast<int>(info.size) == src.Read(
+      info.offset, const_cast<char*>(contents->data()), contents->size());
+}
+
+}  // namespace asar
added in remote
  their  100644 062ef848f12694243a7a216f9016a26c9e6c319a electron/common/asar/asar_util.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
+#define ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
+
+#include <memory>
+#include <string>
+
+namespace base {
+class FilePath;
+}
+
+namespace asar {
+
+class Archive;
+
+// Gets or creates a new Archive from the path.
+std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path);
+
+// Separates the path to Archive out.
+bool GetAsarArchivePath(const base::FilePath& full_path,
+                        base::FilePath* asar_path,
+                        base::FilePath* relative_path);
+
+// Same with base::ReadFileToString but supports asar Archive.
+bool ReadFileToString(const base::FilePath& path, std::string* contents);
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
added in remote
  their  100644 8feea02a4a99ebbf70c39d32a1f7bb3c7572c9b0 electron/common/asar/scoped_temporary_file.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/scoped_temporary_file.h"
+
+#include <vector>
+
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
+namespace asar {
+
+ScopedTemporaryFile::ScopedTemporaryFile() {
+}
+
+ScopedTemporaryFile::~ScopedTemporaryFile() {
+  if (!path_.empty()) {
+    base::ThreadRestrictions::ScopedAllowIO allow_io;
+    // On Windows it is very likely the file is already in use (because it is
+    // mostly used for Node native modules), so deleting it now will halt the
+    // program.
+#if defined(OS_WIN)
+    base::DeleteFileAfterReboot(path_);
+#else
+    base::DeleteFile(path_, false);
+#endif
+  }
+}
+
+bool ScopedTemporaryFile::Init(const base::FilePath::StringType& ext) {
+  if (!path_.empty())
+    return true;
+
+  base::ThreadRestrictions::ScopedAllowIO allow_io;
+  if (!base::CreateTemporaryFile(&path_))
+    return false;
+
+#if defined(OS_WIN)
+  // Keep the original extension.
+  if (!ext.empty()) {
+    base::FilePath new_path = path_.AddExtension(ext);
+    if (!base::Move(path_, new_path))
+      return false;
+    path_ = new_path;
+  }
+#endif
+
+  return true;
+}
+
+bool ScopedTemporaryFile::InitFromFile(base::File* src,
+                                       const base::FilePath::StringType& ext,
+                                       uint64_t offset, uint64_t size) {
+  if (!src->IsValid())
+    return false;
+
+  if (!Init(ext))
+    return false;
+
+  std::vector<char> buf(size);
+  int len = src->Read(offset, buf.data(), buf.size());
+  if (len != static_cast<int>(size))
+    return false;
+
+  base::File dest(path_, base::File::FLAG_OPEN | base::File::FLAG_WRITE);
+  if (!dest.IsValid())
+    return false;
+
+  return dest.WriteAtCurrentPos(buf.data(), buf.size()) ==
+      static_cast<int>(size);
+}
+
+}  // namespace asar
added in remote
  their  100644 5200bb7184a29c98fde1fa048449ff8d211c0d7c electron/common/asar/scoped_temporary_file.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
+#define ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
+
+#include "base/files/file_path.h"
+
+namespace base {
+class File;
+}
+
+namespace asar {
+
+// An object representing a temporary file that should be cleaned up when this
+// object goes out of scope.  Note that since deletion occurs during the
+// destructor, no further error handling is possible if the directory fails to
+// be deleted.  As a result, deletion is not guaranteed by this class.
+class ScopedTemporaryFile {
+ public:
+  ScopedTemporaryFile();
+  virtual ~ScopedTemporaryFile();
+
+  // Init an empty temporary file with a certain extension.
+  bool Init(const base::FilePath::StringType& ext);
+
+  // Init an temporary file and fill it with content of |path|.
+  bool InitFromFile(base::File* src,
+                    const base::FilePath::StringType& ext,
+                    uint64_t offset, uint64_t size);
+
+  base::FilePath path() const { return path_; }
+
+ private:
+  base::FilePath path_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScopedTemporaryFile);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
added in remote
  their  100644 1ad11067dcb3f03bd010af7bb5dbc1965b067b59 electron/common/chrome_version.h
@@ -0,0 +1,14 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// This file is generated by script/bootstrap.py, you should never modify it
+// by hand.
+
+#ifndef ELECTRON_COMMON_CHROME_VERSION_H_
+#define ELECTRON_COMMON_CHROME_VERSION_H_
+
+#define CHROME_VERSION_STRING "49.0.2623.75"
+#define CHROME_VERSION "v" CHROME_VERSION_STRING
+
+#endif  // ELECTRON_COMMON_CHROME_VERSION_H_
added in remote
  their  100644 2385f590a98f950df2628a9273a8969c25fa2fd6 electron/common/common_message_generator.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Get basic type definitions.
+#define IPC_MESSAGE_IMPL
+#include "electron/common/common_message_generator.h"
+
+// Generate constructors.
+#include "ipc/struct_constructor_macros.h"
+#include "electron/common/common_message_generator.h"
+
+// Generate destructors.
+#include "ipc/struct_destructor_macros.h"
+#include "electron/common/common_message_generator.h"
+
+// Generate param traits write methods.
+#include "ipc/param_traits_write_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits read methods.
+#include "ipc/param_traits_read_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits log methods.
+#include "ipc/param_traits_log_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
added in remote
  their  100644 32dfbe347bfb9d1c7730e9563c99d2a6b5d1839c electron/common/common_message_generator.h
@@ -0,0 +1,10 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, no traditional include guard.
+
+#include "electron/common/api/api_messages.h"
+#include "chrome/common/print_messages.h"
+#include "chrome/common/tts_messages.h"
+#include "chrome/common/widevine_cdm_messages.h"
added in remote
  their  100644 96b281887edfa08d9c37fddf8ba9cc55ad957903 electron/common/crash_reporter/crash_reporter.cc
@@ -0,0 +1,86 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/electron_version.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/common/content_switches.h"
+
+namespace crash_reporter {
+
+CrashReporter::CrashReporter() {
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  is_browser_ = cmd->GetSwitchValueASCII(switches::kProcessType).empty();
+}
+
+CrashReporter::~CrashReporter() {
+}
+
+void CrashReporter::Start(const std::string& product_name,
+                          const std::string& company_name,
+                          const std::string& submit_url,
+                          bool auto_submit,
+                          bool skip_system_crash_handler,
+                          const StringMap& extra_parameters) {
+  SetUploadParameters(extra_parameters);
+
+  InitBreakpad(product_name, ELECTRON_VERSION_STRING, company_name, submit_url,
+               auto_submit, skip_system_crash_handler);
+}
+
+void CrashReporter::SetUploadParameters(const StringMap& parameters) {
+  upload_parameters_ = parameters;
+  upload_parameters_["process_type"] = is_browser_ ? "browser" : "renderer";
+
+  // Setting platform dependent parameters.
+  SetUploadParameters();
+}
+
+std::vector<CrashReporter::UploadReportResult>
+CrashReporter::GetUploadedReports(const std::string& path) {
+  std::string file_content;
+  std::vector<CrashReporter::UploadReportResult> result;
+  if (base::ReadFileToString(base::FilePath::FromUTF8Unsafe(path),
+        &file_content)) {
+    std::vector<std::string> reports = base::SplitString(
+        file_content, "\n", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+    for (const std::string& report : reports) {
+      std::vector<std::string> report_item = base::SplitString(
+          report, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+      int report_time = 0;
+      if (report_item.size() >= 2 && base::StringToInt(report_item[0],
+            &report_time)) {
+        result.push_back(CrashReporter::UploadReportResult(report_time,
+            report_item[1]));
+      }
+    }
+  }
+  return result;
+}
+
+void CrashReporter::InitBreakpad(const std::string& product_name,
+                                 const std::string& version,
+                                 const std::string& company_name,
+                                 const std::string& submit_url,
+                                 bool auto_submit,
+                                 bool skip_system_crash_handler) {
+}
+
+void CrashReporter::SetUploadParameters() {
+}
+
+#if defined(OS_MACOSX) && defined(MAS_BUILD)
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  static CrashReporter crash_reporter;
+  return &crash_reporter;
+}
+#endif
+
+}  // namespace crash_reporter
added in remote
  their  100644 2f997fab83f3c1ce2369675c6c75084406e16ae4 electron/common/crash_reporter/crash_reporter.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
+
+#include <map>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+
+namespace crash_reporter {
+
+class CrashReporter {
+ public:
+  typedef std::map<std::string, std::string> StringMap;
+  typedef std::pair<int, std::string> UploadReportResult;  // upload-date, id
+
+  static CrashReporter* GetInstance();
+
+  void Start(const std::string& product_name,
+             const std::string& company_name,
+             const std::string& submit_url,
+             bool auto_submit,
+             bool skip_system_crash_handler,
+             const StringMap& extra_parameters);
+
+  virtual std::vector<CrashReporter::UploadReportResult> GetUploadedReports(
+      const std::string& path);
+
+ protected:
+  CrashReporter();
+  virtual ~CrashReporter();
+
+  virtual void InitBreakpad(const std::string& product_name,
+                            const std::string& version,
+                            const std::string& company_name,
+                            const std::string& submit_url,
+                            bool auto_submit,
+                            bool skip_system_crash_handler);
+  virtual void SetUploadParameters();
+
+  StringMap upload_parameters_;
+  bool is_browser_;
+
+ private:
+  void SetUploadParameters(const StringMap& parameters);
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporter);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
added in remote
  their  100644 d9a5463a965604dface5a0056d12eb54bdcf0d4d electron/common/crash_reporter/crash_reporter_linux.cc
@@ -0,0 +1,141 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_linux.h"
+
+#include <sys/time.h>
+#include <unistd.h>
+
+#include <string>
+
+#include "base/debug/crash_logging.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/linux_util.h"
+#include "base/logging.h"
+#include "base/process/memory.h"
+#include "base/memory/singleton.h"
+#include "base/strings/stringprintf.h"
+#include "vendor/breakpad/src/client/linux/handler/exception_handler.h"
+#include "vendor/breakpad/src/common/linux/linux_libc_support.h"
+
+using google_breakpad::ExceptionHandler;
+using google_breakpad::MinidumpDescriptor;
+
+namespace crash_reporter {
+
+namespace {
+
+static const size_t kDistroSize = 128;
+
+// Define a preferred limit on minidump sizes, because Crash Server currently
+// throws away any larger than 1.2MB (1.2 * 1024 * 1024).  A value of -1 means
+// no limit.
+static const off_t kMaxMinidumpFileSize = 1258291;
+
+}  // namespace
+
+CrashReporterLinux::CrashReporterLinux()
+    : process_start_time_(0),
+      pid_(getpid()) {
+  // Set the base process start time value.
+  struct timeval tv;
+  if (!gettimeofday(&tv, NULL)) {
+    uint64_t ret = tv.tv_sec;
+    ret *= 1000;
+    ret += tv.tv_usec / 1000;
+    process_start_time_ = ret;
+  }
+
+  // Make base::g_linux_distro work.
+  base::SetLinuxDistro(base::GetLinuxDistro());
+}
+
+CrashReporterLinux::~CrashReporterLinux() {
+}
+
+void CrashReporterLinux::InitBreakpad(const std::string& product_name,
+                                      const std::string& version,
+                                      const std::string& company_name,
+                                      const std::string& submit_url,
+                                      bool auto_submit,
+                                      bool skip_system_crash_handler) {
+  EnableCrashDumping(product_name);
+
+  crash_keys_.SetKeyValue("prod", ELECTRON_PRODUCT_NAME);
+  crash_keys_.SetKeyValue("ver", version.c_str());
+  upload_url_ = submit_url;
+
+  for (StringMap::const_iterator iter = upload_parameters_.begin();
+       iter != upload_parameters_.end(); ++iter)
+    crash_keys_.SetKeyValue(iter->first.c_str(), iter->second.c_str());
+}
+
+void CrashReporterLinux::SetUploadParameters() {
+  upload_parameters_["platform"] = "linux";
+}
+
+void CrashReporterLinux::EnableCrashDumping(const std::string& product_name) {
+  std::string dump_dir = "/tmp/" + product_name + " Crashes";
+  base::FilePath dumps_path(dump_dir);
+  base::CreateDirectory(dumps_path);
+
+  std::string log_file = base::StringPrintf(
+      "%s/%s", dump_dir.c_str(), "uploads.log");
+  strncpy(g_crash_log_path, log_file.c_str(), sizeof(g_crash_log_path));
+
+  MinidumpDescriptor minidump_descriptor(dumps_path.value());
+  minidump_descriptor.set_size_limit(kMaxMinidumpFileSize);
+
+  breakpad_.reset(new ExceptionHandler(
+      minidump_descriptor,
+      NULL,
+      CrashDone,
+      this,
+      true,  // Install handlers.
+      -1));
+}
+
+bool CrashReporterLinux::CrashDone(const MinidumpDescriptor& minidump,
+                                   void* context,
+                                   const bool succeeded) {
+  CrashReporterLinux* self = static_cast<CrashReporterLinux*>(context);
+
+  // WARNING: this code runs in a compromised context. It may not call into
+  // libc nor allocate memory normally.
+  if (!succeeded) {
+    const char msg[] = "Failed to generate minidump.";
+    WriteLog(msg, sizeof(msg) - 1);
+    return false;
+  }
+
+  DCHECK(!minidump.IsFD());
+
+  BreakpadInfo info = {0};
+  info.filename = minidump.path();
+  info.fd = minidump.fd();
+  info.distro = base::g_linux_distro;
+  info.distro_length = my_strlen(base::g_linux_distro);
+  info.upload = true;
+  info.process_start_time = self->process_start_time_;
+  info.oom_size = base::g_oom_size;
+  info.pid = self->pid_;
+  info.upload_url = self->upload_url_.c_str();
+  info.crash_keys = &self->crash_keys_;
+  HandleCrashDump(info);
+  return true;
+}
+
+// static
+CrashReporterLinux* CrashReporterLinux::GetInstance() {
+  return base::Singleton<CrashReporterLinux>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterLinux::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 3378b248088f28978fc91f8a305cf7aa7c5e51ab electron/common/crash_reporter/crash_reporter_linux.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
+
+#include <string>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "electron/common/crash_reporter/linux/crash_dump_handler.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace google_breakpad {
+class ExceptionHandler;
+class MinidumpDescriptor;
+}
+
+namespace crash_reporter {
+
+class CrashReporterLinux : public CrashReporter {
+ public:
+  static CrashReporterLinux* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterLinux>;
+
+  CrashReporterLinux();
+  virtual ~CrashReporterLinux();
+
+  void EnableCrashDumping(const std::string& product_name);
+
+  static bool CrashDone(const google_breakpad::MinidumpDescriptor& minidump,
+                        void* context,
+                        const bool succeeded);
+
+  scoped_ptr<google_breakpad::ExceptionHandler> breakpad_;
+  CrashKeyStorage crash_keys_;
+
+  uint64_t process_start_time_;
+  pid_t pid_;
+  std::string upload_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterLinux);
+};
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
added in remote
  their  100644 de92f09c9e24cabe515c54227815d225c91ad1fd electron/common/crash_reporter/crash_reporter_mac.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/strings/string_piece.h"
+#include "vendor/crashpad/client/simple_string_dictionary.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace crash_reporter {
+
+class CrashReporterMac : public CrashReporter {
+ public:
+  static CrashReporterMac* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterMac>;
+
+  CrashReporterMac();
+  virtual ~CrashReporterMac();
+
+  void SetUploadsEnabled(bool enable_uploads);
+  void SetCrashKeyValue(const base::StringPiece& key,
+                        const base::StringPiece& value);
+
+  std::vector<UploadReportResult> GetUploadedReports(
+      const std::string& path) override;
+
+  scoped_ptr<crashpad::SimpleStringDictionary> simple_string_dictionary_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterMac);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
added in remote
  their  100644 4ecbc5472a0397227e8be8f816ded73b41a681e2 electron/common/crash_reporter/crash_reporter_mac.mm
@@ -0,0 +1,138 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_mac.h"
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/mac_util.h"
+#include "base/memory/singleton.h"
+#include "base/strings/string_piece.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/sys_string_conversions.h"
+#include "vendor/crashpad/client/crash_report_database.h"
+#include "vendor/crashpad/client/crashpad_client.h"
+#include "vendor/crashpad/client/crashpad_info.h"
+#include "vendor/crashpad/client/settings.h"
+
+namespace crash_reporter {
+
+CrashReporterMac::CrashReporterMac() {
+}
+
+CrashReporterMac::~CrashReporterMac() {
+}
+
+void CrashReporterMac::InitBreakpad(const std::string& product_name,
+                                    const std::string& version,
+                                    const std::string& company_name,
+                                    const std::string& submit_url,
+                                    bool auto_submit,
+                                    bool skip_system_crash_handler) {
+  // check whether crashpad has been initilized.
+  // Only need to initilize once.
+  if (simple_string_dictionary_)
+    return;
+
+  std::string dump_dir = "/tmp/" + product_name + " Crashes";
+  base::FilePath database_path(dump_dir);
+  if (is_browser_) {
+    @autoreleasepool {
+      base::FilePath framework_bundle_path = base::mac::FrameworkBundlePath();
+      base::FilePath handler_path =
+          framework_bundle_path.Append("Resources").Append("crashpad_handler");
+
+      crashpad::CrashpadClient crashpad_client;
+      if (crashpad_client.StartHandler(handler_path, database_path,
+                                       submit_url,
+                                       StringMap(),
+                                       std::vector<std::string>(),
+                                       true)) {
+        crashpad_client.UseHandler();
+      }
+    }  // @autoreleasepool
+  }
+
+  crashpad::CrashpadInfo* crashpad_info =
+      crashpad::CrashpadInfo::GetCrashpadInfo();
+  if (skip_system_crash_handler) {
+    crashpad_info->set_system_crash_reporter_forwarding(
+        crashpad::TriState::kDisabled);
+  }
+
+  simple_string_dictionary_.reset(new crashpad::SimpleStringDictionary());
+  crashpad_info->set_simple_annotations(simple_string_dictionary_.get());
+
+  SetCrashKeyValue("prod", ELECTRON_PRODUCT_NAME);
+  SetCrashKeyValue("process_type", is_browser_ ? "browser" : "renderer");
+  SetCrashKeyValue("ver", version);
+
+  for (const auto& upload_parameter: upload_parameters_) {
+    SetCrashKeyValue(upload_parameter.first, upload_parameter.second);
+  }
+  if (is_browser_) {
+    scoped_ptr<crashpad::CrashReportDatabase> database =
+        crashpad::CrashReportDatabase::Initialize(database_path);
+    if (database) {
+      database->GetSettings()->SetUploadsEnabled(auto_submit);
+    }
+  }
+}
+
+void CrashReporterMac::SetUploadParameters() {
+  upload_parameters_["platform"] = "darwin";
+}
+
+void CrashReporterMac::SetCrashKeyValue(const base::StringPiece& key,
+                                        const base::StringPiece& value) {
+  simple_string_dictionary_->SetKeyValue(key.data(), value.data());
+}
+
+std::vector<CrashReporter::UploadReportResult>
+CrashReporterMac::GetUploadedReports(const std::string& path) {
+  std::vector<CrashReporter::UploadReportResult> uploaded_reports;
+
+  base::FilePath file_path(path);
+  if (!base::PathExists(file_path)) {
+    return uploaded_reports;
+  }
+  // Load crashpad database.
+  scoped_ptr<crashpad::CrashReportDatabase> database =
+    crashpad::CrashReportDatabase::Initialize(file_path);
+  DCHECK(database);
+
+  std::vector<crashpad::CrashReportDatabase::Report> completed_reports;
+  crashpad::CrashReportDatabase::OperationStatus status =
+      database->GetCompletedReports(&completed_reports);
+  if (status != crashpad::CrashReportDatabase::kNoError) {
+    return uploaded_reports;
+  }
+
+  for (const crashpad::CrashReportDatabase::Report& completed_report :
+       completed_reports) {
+    if (completed_report.uploaded) {
+      uploaded_reports.push_back(
+          UploadReportResult(static_cast<int>(completed_report.creation_time),
+                             completed_report.id));
+    }
+  }
+
+  auto sort_by_time = [](const UploadReportResult& a,
+      const UploadReportResult& b) {return a.first >= b.first;};
+  std::sort(uploaded_reports.begin(), uploaded_reports.end(), sort_by_time);
+  return uploaded_reports;
+}
+
+// static
+CrashReporterMac* CrashReporterMac::GetInstance() {
+  return base::Singleton<CrashReporterMac>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterMac::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 0fd6ef32731daa9f760980acf673fe94d2eb2e50 electron/common/crash_reporter/crash_reporter_win.cc
@@ -0,0 +1,270 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_win.h"
+
+#include <string>
+
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/common/result_codes.h"
+#include "gin/public/debug.h"
+#include "sandbox/win/src/nt_internals.h"
+
+#pragma intrinsic(_AddressOfReturnAddress)
+#pragma intrinsic(_ReturnAddress)
+
+#ifdef _WIN64
+// See http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx
+typedef struct _UNWIND_INFO {
+  unsigned char Version : 3;
+  unsigned char Flags : 5;
+  unsigned char SizeOfProlog;
+  unsigned char CountOfCodes;
+  unsigned char FrameRegister : 4;
+  unsigned char FrameOffset : 4;
+  ULONG ExceptionHandler;
+} UNWIND_INFO, *PUNWIND_INFO;
+#endif
+
+namespace crash_reporter {
+
+namespace {
+
+// Minidump with stacks, PEB, TEB, and unloaded module list.
+const MINIDUMP_TYPE kSmallDumpType = static_cast<MINIDUMP_TYPE>(
+    MiniDumpWithProcessThreadData |  // Get PEB and TEB.
+    MiniDumpWithUnloadedModules);  // Get unloaded modules when available.
+
+const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
+const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
+
+typedef NTSTATUS (WINAPI* NtTerminateProcessPtr)(HANDLE ProcessHandle,
+                                                 NTSTATUS ExitStatus);
+char* g_real_terminate_process_stub = NULL;
+
+void TerminateProcessWithoutDump() {
+  // Patched stub exists based on conditions (See InitCrashReporter).
+  // As a side note this function also gets called from
+  // WindowProcExceptionFilter.
+  if (g_real_terminate_process_stub == NULL) {
+    ::TerminateProcess(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
+  } else {
+    NtTerminateProcessPtr real_terminate_proc =
+        reinterpret_cast<NtTerminateProcessPtr>(
+            static_cast<char*>(g_real_terminate_process_stub));
+    real_terminate_proc(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
+  }
+}
+
+#ifdef _WIN64
+int CrashForExceptionInNonABICompliantCodeRange(
+    PEXCEPTION_RECORD ExceptionRecord,
+    ULONG64 EstablisherFrame,
+    PCONTEXT ContextRecord,
+    PDISPATCHER_CONTEXT DispatcherContext) {
+  EXCEPTION_POINTERS info = { ExceptionRecord, ContextRecord };
+  if (!CrashReporter::GetInstance())
+    return EXCEPTION_CONTINUE_SEARCH;
+  return static_cast<CrashReporterWin*>(CrashReporter::GetInstance())->
+      CrashForException(&info);
+}
+
+struct ExceptionHandlerRecord {
+  RUNTIME_FUNCTION runtime_function;
+  UNWIND_INFO unwind_info;
+  unsigned char thunk[12];
+};
+
+bool RegisterNonABICompliantCodeRange(void* start, size_t size_in_bytes) {
+  ExceptionHandlerRecord* record =
+      reinterpret_cast<ExceptionHandlerRecord*>(start);
+
+  // We assume that the first page of the code range is executable and
+  // committed and reserved for breakpad. What could possibly go wrong?
+
+  // All addresses are 32bit relative offsets to start.
+  record->runtime_function.BeginAddress = 0;
+  record->runtime_function.EndAddress =
+      base::checked_cast<DWORD>(size_in_bytes);
+  record->runtime_function.UnwindData =
+      offsetof(ExceptionHandlerRecord, unwind_info);
+
+  // Create unwind info that only specifies an exception handler.
+  record->unwind_info.Version = 1;
+  record->unwind_info.Flags = UNW_FLAG_EHANDLER;
+  record->unwind_info.SizeOfProlog = 0;
+  record->unwind_info.CountOfCodes = 0;
+  record->unwind_info.FrameRegister = 0;
+  record->unwind_info.FrameOffset = 0;
+  record->unwind_info.ExceptionHandler =
+      offsetof(ExceptionHandlerRecord, thunk);
+
+  // Hardcoded thunk.
+  // mov imm64, rax
+  record->thunk[0] = 0x48;
+  record->thunk[1] = 0xb8;
+  void* handler = &CrashForExceptionInNonABICompliantCodeRange;
+  memcpy(&record->thunk[2], &handler, 8);
+
+  // jmp rax
+  record->thunk[10] = 0xff;
+  record->thunk[11] = 0xe0;
+
+  // Protect reserved page against modifications.
+  DWORD old_protect;
+  return VirtualProtect(start, sizeof(ExceptionHandlerRecord),
+                        PAGE_EXECUTE_READ, &old_protect) &&
+         RtlAddFunctionTable(&record->runtime_function, 1,
+                             reinterpret_cast<DWORD64>(start));
+}
+
+void UnregisterNonABICompliantCodeRange(void* start) {
+  ExceptionHandlerRecord* record =
+      reinterpret_cast<ExceptionHandlerRecord*>(start);
+
+  RtlDeleteFunctionTable(&record->runtime_function);
+}
+#endif  // _WIN64
+
+}  // namespace
+
+CrashReporterWin::CrashReporterWin() {
+}
+
+CrashReporterWin::~CrashReporterWin() {
+}
+
+void CrashReporterWin::InitBreakpad(const std::string& product_name,
+                                    const std::string& version,
+                                    const std::string& company_name,
+                                    const std::string& submit_url,
+                                    bool auto_submit,
+                                    bool skip_system_crash_handler) {
+  skip_system_crash_handler_ = skip_system_crash_handler;
+
+  base::FilePath temp_dir;
+  if (!base::GetTempDir(&temp_dir)) {
+    LOG(ERROR) << "Cannot get temp directory";
+    return;
+  }
+
+  base::string16 pipe_name = base::ReplaceStringPlaceholders(
+      kPipeNameFormat, base::UTF8ToUTF16(product_name), NULL);
+  base::string16 wait_name = base::ReplaceStringPlaceholders(
+      kWaitEventFormat, base::UTF8ToUTF16(product_name), NULL);
+
+  // Wait until the crash service is started.
+  HANDLE wait_event = ::CreateEventW(NULL, TRUE, FALSE, wait_name.c_str());
+  if (wait_event != NULL) {
+    WaitForSingleObject(wait_event, 1000);
+    CloseHandle(wait_event);
+  }
+
+  // ExceptionHandler() attaches our handler and ~ExceptionHandler() detaches
+  // it, so we must explicitly reset *before* we instantiate our new handler
+  // to allow any previous handler to detach in the correct order.
+  breakpad_.reset();
+
+  breakpad_.reset(new google_breakpad::ExceptionHandler(
+      temp_dir.value(),
+      FilterCallback,
+      MinidumpCallback,
+      this,
+      google_breakpad::ExceptionHandler::HANDLER_ALL,
+      kSmallDumpType,
+      pipe_name.c_str(),
+      GetCustomInfo(product_name, version, company_name)));
+
+  if (!breakpad_->IsOutOfProcess())
+    LOG(ERROR) << "Cannot initialize out-of-process crash handler";
+
+#ifdef _WIN64
+  bool registered = false;
+  // Hook up V8 to breakpad.
+  {
+    // gin::Debug::SetCodeRangeCreatedCallback only runs the callback when
+    // Isolate is just created, so we have to manually run following code here.
+    void* code_range = nullptr;
+    size_t size = 0;
+    v8::Isolate::GetCurrent()->GetCodeRange(&code_range, &size);
+    if (code_range && size)
+      registered = RegisterNonABICompliantCodeRange(code_range, size);
+  }
+  if (registered)
+    gin::Debug::SetCodeRangeDeletedCallback(UnregisterNonABICompliantCodeRange);
+#endif
+}
+
+void CrashReporterWin::SetUploadParameters() {
+  upload_parameters_["platform"] = "win32";
+}
+
+int CrashReporterWin::CrashForException(EXCEPTION_POINTERS* info) {
+  if (breakpad_) {
+    breakpad_->WriteMinidumpForException(info);
+    TerminateProcessWithoutDump();
+  }
+  return EXCEPTION_CONTINUE_SEARCH;
+}
+
+// static
+bool CrashReporterWin::FilterCallback(void* context,
+                                      EXCEPTION_POINTERS* exinfo,
+                                      MDRawAssertionInfo* assertion) {
+  return true;
+}
+
+// static
+bool CrashReporterWin::MinidumpCallback(const wchar_t* dump_path,
+                                        const wchar_t* minidump_id,
+                                        void* context,
+                                        EXCEPTION_POINTERS* exinfo,
+                                        MDRawAssertionInfo* assertion,
+                                        bool succeeded) {
+  CrashReporterWin* self = static_cast<CrashReporterWin*>(context);
+  if (succeeded && !self->skip_system_crash_handler_)
+    return true;
+  else
+    return false;
+}
+
+google_breakpad::CustomClientInfo* CrashReporterWin::GetCustomInfo(
+    const std::string& product_name,
+    const std::string& version,
+    const std::string& company_name) {
+  custom_info_entries_.clear();
+  custom_info_entries_.reserve(2 + upload_parameters_.size());
+
+  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+      L"prod", L"Electron"));
+  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+      L"ver", base::UTF8ToWide(version).c_str()));
+
+  for (StringMap::const_iterator iter = upload_parameters_.begin();
+       iter != upload_parameters_.end(); ++iter) {
+    custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+        base::UTF8ToWide(iter->first).c_str(),
+        base::UTF8ToWide(iter->second).c_str()));
+  }
+
+  custom_info_.entries = &custom_info_entries_.front();
+  custom_info_.count = custom_info_entries_.size();
+  return &custom_info_;
+}
+
+// static
+CrashReporterWin* CrashReporterWin::GetInstance() {
+  return base::Singleton<CrashReporterWin>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterWin::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 c0a00afca62ce8c01149aa66dd8f18ac4ffbac73 electron/common/crash_reporter/crash_reporter_win.h
@@ -0,0 +1,72 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "vendor/breakpad/src/client/windows/handler/exception_handler.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace crash_reporter {
+
+class CrashReporterWin : public CrashReporter {
+ public:
+  static CrashReporterWin* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+  // Crashes the process after generating a dump for the provided exception.
+  int CrashForException(EXCEPTION_POINTERS* info);
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterWin>;
+
+  CrashReporterWin();
+  virtual ~CrashReporterWin();
+
+  static bool FilterCallback(void* context,
+                             EXCEPTION_POINTERS* exinfo,
+                             MDRawAssertionInfo* assertion);
+
+  static bool MinidumpCallback(const wchar_t* dump_path,
+                               const wchar_t* minidump_id,
+                               void* context,
+                               EXCEPTION_POINTERS* exinfo,
+                               MDRawAssertionInfo* assertion,
+                               bool succeeded);
+
+  // Returns the custom info structure based on parameters.
+  google_breakpad::CustomClientInfo* GetCustomInfo(
+      const std::string& product_name,
+      const std::string& version,
+      const std::string& company_name);
+
+  // Custom information to be passed to crash handler.
+  std::vector<google_breakpad::CustomInfoEntry> custom_info_entries_;
+  google_breakpad::CustomClientInfo custom_info_;
+
+  bool skip_system_crash_handler_;
+  scoped_ptr<google_breakpad::ExceptionHandler> breakpad_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterWin);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
added in remote
  their  100644 736ab5e849adbb932a37183a66a396628507cade electron/common/crash_reporter/linux/crash_dump_handler.cc
@@ -0,0 +1,746 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// For linux_syscall_support.h. This makes it safe to call embedded system
+// calls when in seccomp mode.
+
+#include "electron/common/crash_reporter/linux/crash_dump_handler.h"
+
+#include <poll.h>
+
+#include <algorithm>
+
+#include "base/posix/eintr_wrapper.h"
+#include "vendor/breakpad/src/client/linux/minidump_writer/directory_reader.h"
+#include "vendor/breakpad/src/common/linux/linux_libc_support.h"
+#include "vendor/breakpad/src/common/memory.h"
+
+#include "third_party/lss/linux_syscall_support.h"
+
+// Some versions of gcc are prone to warn about unused return values. In cases
+// where we either a) know the call cannot fail, or b) there is nothing we
+// can do when a call fails, we mark the return code as ignored. This avoids
+// spurious compiler warnings.
+#define IGNORE_RET(x) do { if (x); } while (0)
+
+namespace crash_reporter {
+
+namespace {
+
+// String buffer size to use to convert a uint64_t to string.
+const size_t kUint64StringSize = 21;
+
+// Writes the value |v| as 16 hex characters to the memory pointed at by
+// |output|.
+void write_uint64_hex(char* output, uint64_t v) {
+  static const char hextable[] = "0123456789abcdef";
+
+  for (int i = 15; i >= 0; --i) {
+    output[i] = hextable[v & 15];
+    v >>= 4;
+  }
+}
+
+// uint64_t version of my_int_len() from
+// breakpad/src/common/linux/linux_libc_support.h. Return the length of the
+// given, non-negative integer when expressed in base 10.
+unsigned my_uint64_len(uint64_t i) {
+  if (!i)
+    return 1;
+
+  unsigned len = 0;
+  while (i) {
+    len++;
+    i /= 10;
+  }
+
+  return len;
+}
+
+// uint64_t version of my_uitos() from
+// breakpad/src/common/linux/linux_libc_support.h. Convert a non-negative
+// integer to a string (not null-terminated).
+void my_uint64tos(char* output, uint64_t i, unsigned i_len) {
+  for (unsigned index = i_len; index; --index, i /= 10)
+    output[index - 1] = '0' + (i % 10);
+}
+
+// Converts a struct timeval to milliseconds.
+uint64_t kernel_timeval_to_ms(struct kernel_timeval *tv) {
+  uint64_t ret = tv->tv_sec;  // Avoid overflow by explicitly using a uint64_t.
+  ret *= 1000;
+  ret += tv->tv_usec / 1000;
+  return ret;
+}
+
+bool my_isxdigit(char c) {
+  return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f');
+}
+
+size_t LengthWithoutTrailingSpaces(const char* str, size_t len) {
+  while (len > 0 && str[len - 1] == ' ') {
+    len--;
+  }
+  return len;
+}
+
+// MIME substrings.
+const char g_rn[] = "\r\n";
+const char g_form_data_msg[] = "Content-Disposition: form-data; name=\"";
+const char g_quote_msg[] = "\"";
+const char g_dashdash_msg[] = "--";
+const char g_dump_msg[] = "upload_file_minidump\"; filename=\"dump\"";
+const char g_content_type_msg[] = "Content-Type: application/octet-stream";
+
+// MimeWriter manages an iovec for writing MIMEs to a file.
+class MimeWriter {
+ public:
+  static const int kIovCapacity = 30;
+  static const size_t kMaxCrashChunkSize = 64;
+
+  MimeWriter(int fd, const char* const mime_boundary);
+  ~MimeWriter();
+
+  // Append boundary.
+  virtual void AddBoundary();
+
+  // Append end of file boundary.
+  virtual void AddEnd();
+
+  // Append key/value pair with specified sizes.
+  virtual void AddPairData(const char* msg_type,
+                           size_t msg_type_size,
+                           const char* msg_data,
+                           size_t msg_data_size);
+
+  // Append key/value pair.
+  void AddPairString(const char* msg_type,
+                     const char* msg_data) {
+    AddPairData(msg_type, my_strlen(msg_type), msg_data, my_strlen(msg_data));
+  }
+
+  // Append key/value pair, splitting value into chunks no larger than
+  // |chunk_size|. |chunk_size| cannot be greater than |kMaxCrashChunkSize|.
+  // The msg_type string will have a counter suffix to distinguish each chunk.
+  virtual void AddPairDataInChunks(const char* msg_type,
+                                   size_t msg_type_size,
+                                   const char* msg_data,
+                                   size_t msg_data_size,
+                                   size_t chunk_size,
+                                   bool strip_trailing_spaces);
+
+  // Add binary file contents to be uploaded with the specified filename.
+  virtual void AddFileContents(const char* filename_msg,
+                               uint8_t* file_data,
+                               size_t file_size);
+
+  // Flush any pending iovecs to the output file.
+  void Flush() {
+    IGNORE_RET(sys_writev(fd_, iov_, iov_index_));
+    iov_index_ = 0;
+  }
+
+ protected:
+  void AddItem(const void* base, size_t size);
+  // Minor performance trade-off for easier-to-maintain code.
+  void AddString(const char* str) {
+    AddItem(str, my_strlen(str));
+  }
+  void AddItemWithoutTrailingSpaces(const void* base, size_t size);
+
+  struct kernel_iovec iov_[kIovCapacity];
+  int iov_index_;
+
+  // Output file descriptor.
+  int fd_;
+
+  const char* const mime_boundary_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MimeWriter);
+};
+
+MimeWriter::MimeWriter(int fd, const char* const mime_boundary)
+    : iov_index_(0),
+      fd_(fd),
+      mime_boundary_(mime_boundary) {
+}
+
+MimeWriter::~MimeWriter() {
+}
+
+void MimeWriter::AddBoundary() {
+  AddString(mime_boundary_);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddEnd() {
+  AddString(mime_boundary_);
+  AddString(g_dashdash_msg);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddPairData(const char* msg_type,
+                             size_t msg_type_size,
+                             const char* msg_data,
+                             size_t msg_data_size) {
+  AddString(g_form_data_msg);
+  AddItem(msg_type, msg_type_size);
+  AddString(g_quote_msg);
+  AddString(g_rn);
+  AddString(g_rn);
+  AddItem(msg_data, msg_data_size);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddPairDataInChunks(const char* msg_type,
+                                     size_t msg_type_size,
+                                     const char* msg_data,
+                                     size_t msg_data_size,
+                                     size_t chunk_size,
+                                     bool strip_trailing_spaces) {
+  if (chunk_size > kMaxCrashChunkSize)
+    return;
+
+  unsigned i = 0;
+  size_t done = 0, msg_length = msg_data_size;
+
+  while (msg_length) {
+    char num[kUint64StringSize];
+    const unsigned num_len = my_uint_len(++i);
+    my_uitos(num, i, num_len);
+
+    size_t chunk_len = std::min(chunk_size, msg_length);
+
+    AddString(g_form_data_msg);
+    AddItem(msg_type, msg_type_size);
+    AddItem(num, num_len);
+    AddString(g_quote_msg);
+    AddString(g_rn);
+    AddString(g_rn);
+    if (strip_trailing_spaces) {
+      AddItemWithoutTrailingSpaces(msg_data + done, chunk_len);
+    } else {
+      AddItem(msg_data + done, chunk_len);
+    }
+    AddString(g_rn);
+    AddBoundary();
+    Flush();
+
+    done += chunk_len;
+    msg_length -= chunk_len;
+  }
+}
+
+void MimeWriter::AddFileContents(const char* filename_msg, uint8_t* file_data,
+                                 size_t file_size) {
+  AddString(g_form_data_msg);
+  AddString(filename_msg);
+  AddString(g_rn);
+  AddString(g_content_type_msg);
+  AddString(g_rn);
+  AddString(g_rn);
+  AddItem(file_data, file_size);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddItem(const void* base, size_t size) {
+  // Check if the iovec is full and needs to be flushed to output file.
+  if (iov_index_ == kIovCapacity) {
+    Flush();
+  }
+  iov_[iov_index_].iov_base = const_cast<void*>(base);
+  iov_[iov_index_].iov_len = size;
+  ++iov_index_;
+}
+
+void MimeWriter::AddItemWithoutTrailingSpaces(const void* base, size_t size) {
+  AddItem(base, LengthWithoutTrailingSpaces(static_cast<const char*>(base),
+                                            size));
+}
+
+void LoadDataFromFD(google_breakpad::PageAllocator* allocator,
+                    int fd, bool close_fd, uint8_t** file_data, size_t* size) {
+  struct kernel_stat st;
+  if (sys_fstat(fd, &st) != 0) {
+    static const char msg[] = "Cannot upload crash dump: stat failed\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+
+  *file_data = reinterpret_cast<uint8_t*>(allocator->Alloc(st.st_size));
+  if (!(*file_data)) {
+    static const char msg[] = "Cannot upload crash dump: cannot alloc\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+  my_memset(*file_data, 0xf, st.st_size);
+
+  *size = st.st_size;
+  int byte_read = sys_read(fd, *file_data, *size);
+  if (byte_read == -1) {
+    static const char msg[] = "Cannot upload crash dump: read failed\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+
+  if (close_fd)
+    IGNORE_RET(sys_close(fd));
+}
+
+void LoadDataFromFile(google_breakpad::PageAllocator* allocator,
+                      const char* filename,
+                      int* fd, uint8_t** file_data, size_t* size) {
+  // WARNING: this code runs in a compromised context. It may not call into
+  // libc nor allocate memory normally.
+  *fd = sys_open(filename, O_RDONLY, 0);
+  *size = 0;
+
+  if (*fd < 0) {
+    static const char msg[] = "Cannot upload crash dump: failed to open\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    return;
+  }
+
+  LoadDataFromFD(allocator, *fd, true, file_data, size);
+}
+
+// Spawn the appropriate upload process for the current OS:
+// - generic Linux invokes wget.
+// - ChromeOS invokes crash_reporter.
+// |dumpfile| is the path to the dump data file.
+// |mime_boundary| is only used on Linux.
+// |exe_buf| is only used on CrOS and is the crashing process' name.
+void ExecUploadProcessOrTerminate(const BreakpadInfo& info,
+                                  const char* dumpfile,
+                                  const char* mime_boundary,
+                                  const char* exe_buf,
+                                  google_breakpad::PageAllocator* allocator) {
+  // The --header argument to wget looks like:
+  //   --header=Content-Type: multipart/form-data; boundary=XYZ
+  // where the boundary has two fewer leading '-' chars
+  static const char header_msg[] =
+      "--header=Content-Type: multipart/form-data; boundary=";
+  char* const header = reinterpret_cast<char*>(allocator->Alloc(
+      sizeof(header_msg) - 1 + strlen(mime_boundary) - 2 + 1));
+  memcpy(header, header_msg, sizeof(header_msg) - 1);
+  memcpy(header + sizeof(header_msg) - 1, mime_boundary + 2,
+         strlen(mime_boundary) - 2);
+  // We grab the NUL byte from the end of |mime_boundary|.
+
+  // The --post-file argument to wget looks like:
+  //   --post-file=/tmp/...
+  static const char post_file_msg[] = "--post-file=";
+  char* const post_file = reinterpret_cast<char*>(allocator->Alloc(
+       sizeof(post_file_msg) - 1 + strlen(dumpfile) + 1));
+  memcpy(post_file, post_file_msg, sizeof(post_file_msg) - 1);
+  memcpy(post_file + sizeof(post_file_msg) - 1, dumpfile, strlen(dumpfile));
+
+  static const char kWgetBinary[] = "/usr/bin/wget";
+  const char* args[] = {
+    kWgetBinary,
+    header,
+    post_file,
+    info.upload_url,
+    "--timeout=60",  // Set a timeout so we don't hang forever.
+    "--tries=1",     // Don't retry if the upload fails.
+    "--quiet",       // Be silent.
+    "-O",            // output reply to /dev/null.
+    "/dev/fd/3",
+    NULL,
+  };
+  static const char msg[] = "Cannot upload crash dump: cannot exec "
+                            "/usr/bin/wget\n";
+  execve(args[0], const_cast<char**>(args), environ);
+  WriteLog(msg, sizeof(msg) - 1);
+  sys__exit(1);
+}
+
+// Runs in the helper process to wait for the upload process running
+// ExecUploadProcessOrTerminate() to finish. Returns the number of bytes written
+// to |fd| and save the written contents to |buf|.
+// |buf| needs to be big enough to hold |bytes_to_read| + 1 characters.
+size_t WaitForCrashReportUploadProcess(int fd, size_t bytes_to_read,
+                                       char* buf) {
+  size_t bytes_read = 0;
+
+  // Upload should finish in about 10 seconds. Add a few more 500 ms
+  // internals to account for process startup time.
+  for (size_t wait_count = 0; wait_count < 24; ++wait_count) {
+    struct kernel_pollfd poll_fd;
+    poll_fd.fd = fd;
+    poll_fd.events = POLLIN | POLLPRI | POLLERR;
+    int ret = sys_poll(&poll_fd, 1, 500);
+    if (ret < 0) {
+      // Error
+      break;
+    } else if (ret > 0) {
+      // There is data to read.
+      ssize_t len = HANDLE_EINTR(
+          sys_read(fd, buf + bytes_read, bytes_to_read - bytes_read));
+      if (len < 0)
+        break;
+      bytes_read += len;
+      if (bytes_read == bytes_to_read)
+        break;
+    }
+    // |ret| == 0 -> timed out, continue waiting.
+    // or |bytes_read| < |bytes_to_read| still, keep reading.
+  }
+  buf[bytes_to_read] = 0;  // Always NUL terminate the buffer.
+  return bytes_read;
+}
+
+// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
+bool IsValidCrashReportId(const char* buf, size_t bytes_read,
+                          size_t expected_len) {
+  if (bytes_read != expected_len)
+    return false;
+  for (size_t i = 0; i < bytes_read; ++i) {
+    if (!my_isxdigit(buf[i]) && buf[i] != '-')
+      return false;
+  }
+  return true;
+}
+
+// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
+void HandleCrashReportId(const char* buf, size_t bytes_read,
+                         size_t expected_len) {
+  if (!IsValidCrashReportId(buf, bytes_read, expected_len)) {
+    static const char msg[] = "Failed to get crash dump id.";
+    WriteLog(msg, sizeof(msg) - 1);
+    WriteNewline();
+
+    static const char id_msg[] = "Report Id: ";
+    WriteLog(id_msg, sizeof(id_msg) - 1);
+    WriteLog(buf, bytes_read);
+    WriteNewline();
+    return;
+  }
+
+  // Write crash dump id to stderr.
+  static const char msg[] = "Crash dump id: ";
+  WriteLog(msg, sizeof(msg) - 1);
+  WriteLog(buf, my_strlen(buf));
+  WriteNewline();
+
+  // Write crash dump id to crash log as: seconds_since_epoch,crash_id
+  struct kernel_timeval tv;
+  if (!sys_gettimeofday(&tv, NULL)) {
+    uint64_t time = kernel_timeval_to_ms(&tv) / 1000;
+    char time_str[kUint64StringSize];
+    const unsigned time_len = my_uint64_len(time);
+    my_uint64tos(time_str, time, time_len);
+
+    const int kLogOpenFlags = O_CREAT | O_WRONLY | O_APPEND | O_CLOEXEC;
+    int log_fd = sys_open(g_crash_log_path, kLogOpenFlags, 0600);
+    if (log_fd > 0) {
+      sys_write(log_fd, time_str, time_len);
+      sys_write(log_fd, ",", 1);
+      sys_write(log_fd, buf, my_strlen(buf));
+      sys_write(log_fd, "\n", 1);
+      IGNORE_RET(sys_close(log_fd));
+    }
+  }
+}
+
+}  // namespace
+
+char g_crash_log_path[256];
+
+void HandleCrashDump(const BreakpadInfo& info) {
+  int dumpfd;
+  bool keep_fd = false;
+  size_t dump_size;
+  uint8_t* dump_data;
+  google_breakpad::PageAllocator allocator;
+  const char* exe_buf = NULL;
+
+  if (info.fd != -1) {
+    // Dump is provided with an open FD.
+    keep_fd = true;
+    dumpfd = info.fd;
+
+    // The FD is pointing to the end of the file.
+    // Rewind, we'll read the data next.
+    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
+      static const char msg[] = "Cannot upload crash dump: failed to "
+          "reposition minidump FD\n";
+      WriteLog(msg, sizeof(msg) - 1);
+      IGNORE_RET(sys_close(dumpfd));
+      return;
+    }
+    LoadDataFromFD(&allocator, info.fd, false, &dump_data, &dump_size);
+  } else {
+    // Dump is provided with a path.
+    keep_fd = false;
+    LoadDataFromFile(
+        &allocator, info.filename, &dumpfd, &dump_data, &dump_size);
+  }
+
+  // We need to build a MIME block for uploading to the server. Since we are
+  // going to fork and run wget, it needs to be written to a temp file.
+  const int ufd = sys_open("/dev/urandom", O_RDONLY, 0);
+  if (ufd < 0) {
+    static const char msg[] = "Cannot upload crash dump because /dev/urandom"
+                              " is missing\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    return;
+  }
+
+  static const char temp_file_template[] =
+      "/tmp/chromium-upload-XXXXXXXXXXXXXXXX";
+  char temp_file[sizeof(temp_file_template)];
+  int temp_file_fd = -1;
+  if (keep_fd) {
+    temp_file_fd = dumpfd;
+    // Rewind the destination, we are going to overwrite it.
+    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
+      static const char msg[] = "Cannot upload crash dump: failed to "
+          "reposition minidump FD (2)\n";
+      WriteLog(msg, sizeof(msg) - 1);
+      IGNORE_RET(sys_close(dumpfd));
+      return;
+    }
+  } else {
+    if (info.upload) {
+      memcpy(temp_file, temp_file_template, sizeof(temp_file_template));
+
+      for (unsigned i = 0; i < 10; ++i) {
+        uint64_t t;
+        sys_read(ufd, &t, sizeof(t));
+        write_uint64_hex(temp_file + sizeof(temp_file) - (16 + 1), t);
+
+        temp_file_fd = sys_open(temp_file, O_WRONLY | O_CREAT | O_EXCL, 0600);
+        if (temp_file_fd >= 0)
+          break;
+      }
+
+      if (temp_file_fd < 0) {
+        static const char msg[] = "Failed to create temporary file in /tmp: "
+            "cannot upload crash dump\n";
+        WriteLog(msg, sizeof(msg) - 1);
+        IGNORE_RET(sys_close(ufd));
+        return;
+      }
+    } else {
+      temp_file_fd = sys_open(info.filename, O_WRONLY, 0600);
+      if (temp_file_fd < 0) {
+        static const char msg[] = "Failed to save crash dump: failed to open\n";
+        WriteLog(msg, sizeof(msg) - 1);
+        IGNORE_RET(sys_close(ufd));
+        return;
+      }
+    }
+  }
+
+  // The MIME boundary is 28 hyphens, followed by a 64-bit nonce and a NUL.
+  char mime_boundary[28 + 16 + 1];
+  my_memset(mime_boundary, '-', 28);
+  uint64_t boundary_rand;
+  sys_read(ufd, &boundary_rand, sizeof(boundary_rand));
+  write_uint64_hex(mime_boundary + 28, boundary_rand);
+  mime_boundary[28 + 16] = 0;
+  IGNORE_RET(sys_close(ufd));
+
+  // The MIME block looks like this:
+  //   BOUNDARY \r\n
+  //   Content-Disposition: form-data; name="prod" \r\n \r\n
+  //   Chrome_Linux \r\n
+  //   BOUNDARY \r\n
+  //   Content-Disposition: form-data; name="ver" \r\n \r\n
+  //   1.2.3.4 \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="ptime" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="ptype" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="lsb-release" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="oom-size" \r\n \r\n
+  //   1234567890 \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or more (up to CrashKeyStorage::num_entries = 64):
+  //   Content-Disposition: form-data; name=crash-key-name \r\n
+  //   crash-key-value \r\n
+  //   BOUNDARY \r\n
+  //
+  //   Content-Disposition: form-data; name="dump"; filename="dump" \r\n
+  //   Content-Type: application/octet-stream \r\n \r\n
+  //   <dump contents>
+  //   \r\n BOUNDARY -- \r\n
+
+  MimeWriter writer(temp_file_fd, mime_boundary);
+  {
+    writer.AddBoundary();
+    if (info.pid > 0) {
+      char pid_value_buf[kUint64StringSize];
+      uint64_t pid_value_len = my_uint64_len(info.pid);
+      my_uint64tos(pid_value_buf, info.pid, pid_value_len);
+      static const char pid_key_name[] = "pid";
+      writer.AddPairData(pid_key_name, sizeof(pid_key_name) - 1,
+                         pid_value_buf, pid_value_len);
+      writer.AddBoundary();
+    }
+    writer.Flush();
+  }
+
+  if (info.process_start_time > 0) {
+    struct kernel_timeval tv;
+    if (!sys_gettimeofday(&tv, NULL)) {
+      uint64_t time = kernel_timeval_to_ms(&tv);
+      if (time > info.process_start_time) {
+        time -= info.process_start_time;
+        char time_str[kUint64StringSize];
+        const unsigned time_len = my_uint64_len(time);
+        my_uint64tos(time_str, time, time_len);
+
+        static const char process_time_msg[] = "ptime";
+        writer.AddPairData(process_time_msg, sizeof(process_time_msg) - 1,
+                           time_str, time_len);
+        writer.AddBoundary();
+        writer.Flush();
+      }
+    }
+  }
+
+  if (info.distro_length) {
+    static const char distro_msg[] = "lsb-release";
+    writer.AddPairString(distro_msg, info.distro);
+    writer.AddBoundary();
+    writer.Flush();
+  }
+
+  if (info.oom_size) {
+    char oom_size_str[kUint64StringSize];
+    const unsigned oom_size_len = my_uint64_len(info.oom_size);
+    my_uint64tos(oom_size_str, info.oom_size, oom_size_len);
+    static const char oom_size_msg[] = "oom-size";
+    writer.AddPairData(oom_size_msg, sizeof(oom_size_msg) - 1,
+                       oom_size_str, oom_size_len);
+    writer.AddBoundary();
+    writer.Flush();
+  }
+
+  if (info.crash_keys) {
+    CrashKeyStorage::Iterator crash_key_iterator(*info.crash_keys);
+    const CrashKeyStorage::Entry* entry;
+    while ((entry = crash_key_iterator.Next())) {
+      writer.AddPairString(entry->key, entry->value);
+      writer.AddBoundary();
+      writer.Flush();
+    }
+  }
+
+  writer.AddFileContents(g_dump_msg, dump_data, dump_size);
+  writer.AddEnd();
+  writer.Flush();
+
+  IGNORE_RET(sys_close(temp_file_fd));
+
+  if (!info.upload)
+    return;
+
+  const pid_t child = sys_fork();
+  if (!child) {
+    // Spawned helper process.
+    //
+    // This code is called both when a browser is crashing (in which case,
+    // nothing really matters any more) and when a renderer/plugin crashes, in
+    // which case we need to continue.
+    //
+    // Since we are a multithreaded app, if we were just to fork(), we might
+    // grab file descriptors which have just been created in another thread and
+    // hold them open for too long.
+    //
+    // Thus, we have to loop and try and close everything.
+    const int fd = sys_open("/proc/self/fd", O_DIRECTORY | O_RDONLY, 0);
+    if (fd < 0) {
+      for (unsigned i = 3; i < 8192; ++i)
+        IGNORE_RET(sys_close(i));
+    } else {
+      google_breakpad::DirectoryReader reader(fd);
+      const char* name;
+      while (reader.GetNextEntry(&name)) {
+        int i;
+        if (my_strtoui(&i, name) && i > 2 && i != fd)
+          IGNORE_RET(sys_close(i));
+        reader.PopEntry();
+      }
+
+      IGNORE_RET(sys_close(fd));
+    }
+
+    IGNORE_RET(sys_setsid());
+
+    // Leave one end of a pipe in the upload process and watch for it getting
+    // closed by the upload process exiting.
+    int fds[2];
+    if (sys_pipe(fds) >= 0) {
+      const pid_t upload_child = sys_fork();
+      if (!upload_child) {
+        // Upload process.
+        IGNORE_RET(sys_close(fds[0]));
+        IGNORE_RET(sys_dup2(fds[1], 3));
+        ExecUploadProcessOrTerminate(info, temp_file, mime_boundary, exe_buf,
+                                     &allocator);
+      }
+
+      // Helper process.
+      if (upload_child > 0) {
+        IGNORE_RET(sys_close(fds[1]));
+
+        const size_t kCrashIdLength = 36;
+        char id_buf[kCrashIdLength + 1];
+        size_t bytes_read =
+            WaitForCrashReportUploadProcess(fds[0], kCrashIdLength, id_buf);
+        HandleCrashReportId(id_buf, bytes_read, kCrashIdLength);
+
+        if (sys_waitpid(upload_child, NULL, WNOHANG) == 0) {
+          // Upload process is still around, kill it.
+          sys_kill(upload_child, SIGKILL);
+        }
+      }
+    }
+
+    // Helper process.
+    IGNORE_RET(sys_unlink(info.filename));
+    IGNORE_RET(sys_unlink(temp_file));
+    sys__exit(0);
+  }
+
+  // Main browser process.
+  if (child <= 0)
+    return;
+  (void) HANDLE_EINTR(sys_waitpid(child, NULL, 0));
+}
+
+size_t WriteLog(const char* buf, size_t nbytes) {
+  return sys_write(2, buf, nbytes);
+}
+
+size_t WriteNewline() {
+  return WriteLog("\n", 1);
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 a0ae98704a204fb6d88ee9ee7eb630d5e5d75d80 electron/common/crash_reporter/linux/crash_dump_handler.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "base/macros.h"
+#include "vendor/breakpad/src/common/simple_string_dictionary.h"
+
+namespace crash_reporter {
+
+typedef google_breakpad::NonAllocatingMap<256, 256, 64> CrashKeyStorage;
+
+// BreakpadInfo describes a crash report.
+// The minidump information can either be contained in a file descriptor (fd) or
+// in a file (whose path is in filename).
+struct BreakpadInfo {
+  int fd;                          // File descriptor to the Breakpad dump data.
+  const char* filename;            // Path to the Breakpad dump data.
+  const char* distro;              // Linux distro string.
+  unsigned distro_length;          // Length of |distro|.
+  bool upload;                     // Whether to upload or save crash dump.
+  uint64_t process_start_time;     // Uptime of the crashing process.
+  size_t oom_size;                 // Amount of memory requested if OOM.
+  uint64_t pid;                    // PID where applicable.
+  const char* upload_url;          // URL to upload the minidump.
+  CrashKeyStorage* crash_keys;
+};
+
+void HandleCrashDump(const BreakpadInfo& info);
+
+size_t WriteLog(const char* buf, size_t nbytes);
+size_t WriteNewline();
+
+// Global variable storing the path of upload log.
+extern char g_crash_log_path[256];
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
added in remote
  their  100644 c8bc9c70f4055b1774a06e91f261f157a5763a47 electron/common/crash_reporter/win/crash_service.cc
@@ -0,0 +1,526 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/win/crash_service.h"
+
+#include <windows.h>
+
+#include <sddl.h>
+#include <fstream>  // NOLINT
+#include <map>
+
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/time/time.h"
+#include "base/win/windows_version.h"
+#include "vendor/breakpad/src/client/windows/crash_generation/client_info.h"
+#include "vendor/breakpad/src/client/windows/crash_generation/crash_generation_server.h"
+#include "vendor/breakpad/src/client/windows/sender/crash_report_sender.h"
+
+namespace breakpad {
+
+namespace {
+
+const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
+const wchar_t kClassNameFormat[] = L"$1CrashServiceWindow";
+
+const wchar_t kTestPipeName[] = L"\\\\.\\pipe\\ChromeCrashServices";
+
+const wchar_t kGoogleReportURL[] = L"https://clients2.google.com/cr/report";
+const wchar_t kCheckPointFile[] = L"crash_checkpoint.txt";
+
+typedef std::map<std::wstring, std::wstring> CrashMap;
+
+bool CustomInfoToMap(const google_breakpad::ClientInfo* client_info,
+                     const std::wstring& reporter_tag, CrashMap* map) {
+  google_breakpad::CustomClientInfo info = client_info->GetCustomInfo();
+
+  for (uintptr_t i = 0; i < info.count; ++i) {
+    (*map)[info.entries[i].name] = info.entries[i].value;
+  }
+
+  (*map)[L"rept"] = reporter_tag;
+
+  return !map->empty();
+}
+
+bool WriteCustomInfoToFile(const std::wstring& dump_path, const CrashMap& map) {
+  std::wstring file_path(dump_path);
+  size_t last_dot = file_path.rfind(L'.');
+  if (last_dot == std::wstring::npos)
+    return false;
+  file_path.resize(last_dot);
+  file_path += L".txt";
+
+  std::wofstream file(file_path.c_str(),
+      std::ios_base::out | std::ios_base::app | std::ios::binary);
+  if (!file.is_open())
+    return false;
+
+  CrashMap::const_iterator pos;
+  for (pos = map.begin(); pos != map.end(); ++pos) {
+    std::wstring line = pos->first;
+    line += L':';
+    line += pos->second;
+    line += L'\n';
+    file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
+  }
+  return true;
+}
+
+bool WriteReportIDToFile(const std::wstring& dump_path,
+                         const std::wstring& report_id) {
+  std::wstring file_path(dump_path);
+  size_t last_slash = file_path.rfind(L'\\');
+  if (last_slash == std::wstring::npos)
+    return false;
+  file_path.resize(last_slash);
+  file_path += L"\\uploads.log";
+
+  std::wofstream file(file_path.c_str(),
+      std::ios_base::out | std::ios_base::app | std::ios::binary);
+  if (!file.is_open())
+    return false;
+
+  int64_t seconds_since_epoch =
+      (base::Time::Now() - base::Time::UnixEpoch()).InSeconds();
+  std::wstring line = base::Int64ToString16(seconds_since_epoch);
+  line += L',';
+  line += report_id;
+  line += L'\n';
+  file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
+  return true;
+}
+
+// The window procedure task is to handle when a) the user logs off.
+// b) the system shuts down or c) when the user closes the window.
+LRESULT __stdcall CrashSvcWndProc(HWND hwnd, UINT message,
+                                  WPARAM wparam, LPARAM lparam) {
+  switch (message) {
+    case WM_CLOSE:
+    case WM_ENDSESSION:
+    case WM_DESTROY:
+      PostQuitMessage(0);
+      break;
+    default:
+      return DefWindowProc(hwnd, message, wparam, lparam);
+  }
+  return 0;
+}
+
+// This is the main and only application window.
+HWND g_top_window = NULL;
+
+bool CreateTopWindow(HINSTANCE instance,
+                     const base::string16& application_name,
+                     bool visible) {
+  base::string16 class_name = base::ReplaceStringPlaceholders(
+      kClassNameFormat, application_name, NULL);
+
+  WNDCLASSEXW wcx = {0};
+  wcx.cbSize = sizeof(wcx);
+  wcx.style = CS_HREDRAW | CS_VREDRAW;
+  wcx.lpfnWndProc = CrashSvcWndProc;
+  wcx.hInstance = instance;
+  wcx.lpszClassName = class_name.c_str();
+  ATOM atom = ::RegisterClassExW(&wcx);
+  DWORD style = visible ? WS_POPUPWINDOW | WS_VISIBLE : WS_OVERLAPPED;
+
+  // The window size is zero but being a popup window still shows in the
+  // task bar and can be closed using the system menu or using task manager.
+  HWND window = CreateWindowExW(0, wcx.lpszClassName, L"crash service", style,
+                                CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
+                                NULL, NULL, instance, NULL);
+  if (!window)
+    return false;
+
+  ::UpdateWindow(window);
+  VLOG(1) << "window handle is " << window;
+  g_top_window = window;
+  return true;
+}
+
+// Simple helper class to keep the process alive until the current request
+// finishes.
+class ProcessingLock {
+ public:
+  ProcessingLock() {
+    ::InterlockedIncrement(&op_count_);
+  }
+  ~ProcessingLock() {
+    ::InterlockedDecrement(&op_count_);
+  }
+  static bool IsWorking() {
+    return (op_count_ != 0);
+  }
+ private:
+  static volatile LONG op_count_;
+};
+
+volatile LONG ProcessingLock::op_count_ = 0;
+
+// This structure contains the information that the worker thread needs to
+// send a crash dump to the server.
+struct DumpJobInfo {
+  DWORD pid;
+  CrashService* self;
+  CrashMap map;
+  std::wstring dump_path;
+
+  DumpJobInfo(DWORD process_id, CrashService* service,
+              const CrashMap& crash_map, const std::wstring& path)
+      : pid(process_id), self(service), map(crash_map), dump_path(path) {
+  }
+};
+
+}  // namespace
+
+// Command line switches:
+const char CrashService::kMaxReports[]        = "max-reports";
+const char CrashService::kNoWindow[]          = "no-window";
+const char CrashService::kReporterTag[]       = "reporter";
+const char CrashService::kDumpsDir[]          = "dumps-dir";
+const char CrashService::kPipeName[]          = "pipe-name";
+const char CrashService::kReporterURL[]       = "reporter-url";
+
+CrashService::CrashService()
+    : sender_(NULL),
+      dumper_(NULL),
+      requests_handled_(0),
+      requests_sent_(0),
+      clients_connected_(0),
+      clients_terminated_(0) {
+}
+
+CrashService::~CrashService() {
+  base::AutoLock lock(sending_);
+  delete dumper_;
+  delete sender_;
+}
+
+bool CrashService::Initialize(const base::string16& application_name,
+                              const base::FilePath& operating_dir,
+                              const base::FilePath& dumps_path) {
+  using google_breakpad::CrashReportSender;
+  using google_breakpad::CrashGenerationServer;
+
+  std::wstring pipe_name = kTestPipeName;
+  int max_reports = -1;
+
+  // The checkpoint file allows CrashReportSender to enforce the maximum
+  // reports per day quota. Does not seem to serve any other purpose.
+  base::FilePath checkpoint_path = operating_dir.Append(kCheckPointFile);
+
+  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
+
+  base::FilePath dumps_path_to_use = dumps_path;
+
+  if (cmd_line.HasSwitch(kDumpsDir)) {
+    dumps_path_to_use =
+        base::FilePath(cmd_line.GetSwitchValueNative(kDumpsDir));
+  }
+
+  // We can override the send reports quota with a command line switch.
+  if (cmd_line.HasSwitch(kMaxReports))
+    max_reports = _wtoi(cmd_line.GetSwitchValueNative(kMaxReports).c_str());
+
+  // Allow the global pipe name to be overridden for better testability.
+  if (cmd_line.HasSwitch(kPipeName))
+    pipe_name = cmd_line.GetSwitchValueNative(kPipeName);
+
+  if (max_reports > 0) {
+    // Create the http sender object.
+    sender_ = new CrashReportSender(checkpoint_path.value());
+    sender_->set_max_reports_per_day(max_reports);
+  }
+
+  SECURITY_ATTRIBUTES security_attributes = {0};
+  SECURITY_ATTRIBUTES* security_attributes_actual = NULL;
+
+  if (base::win::GetVersion() >= base::win::VERSION_VISTA) {
+    SECURITY_DESCRIPTOR* security_descriptor =
+        reinterpret_cast<SECURITY_DESCRIPTOR*>(
+            GetSecurityDescriptorForLowIntegrity());
+    DCHECK(security_descriptor != NULL);
+
+    security_attributes.nLength = sizeof(security_attributes);
+    security_attributes.lpSecurityDescriptor = security_descriptor;
+    security_attributes.bInheritHandle = FALSE;
+
+    security_attributes_actual = &security_attributes;
+  }
+
+  // Create the OOP crash generator object.
+  dumper_ = new CrashGenerationServer(pipe_name, security_attributes_actual,
+                                      &CrashService::OnClientConnected, this,
+                                      &CrashService::OnClientDumpRequest, this,
+                                      &CrashService::OnClientExited, this,
+                                      NULL, NULL,
+                                      true, &dumps_path_to_use.value());
+
+  if (!dumper_) {
+    LOG(ERROR) << "could not create dumper";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  if (!CreateTopWindow(::GetModuleHandleW(NULL),
+                       application_name,
+                       !cmd_line.HasSwitch(kNoWindow))) {
+    LOG(ERROR) << "could not create window";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  reporter_tag_ = L"crash svc";
+  if (cmd_line.HasSwitch(kReporterTag))
+    reporter_tag_ = cmd_line.GetSwitchValueNative(kReporterTag);
+
+  reporter_url_ = kGoogleReportURL;
+  if (cmd_line.HasSwitch(kReporterURL))
+    reporter_url_ = cmd_line.GetSwitchValueNative(kReporterURL);
+
+  // Log basic information.
+  VLOG(1) << "pipe name is " << pipe_name
+          << "\ndumps at " << dumps_path_to_use.value();
+
+  if (sender_) {
+    VLOG(1) << "checkpoint is " << checkpoint_path.value()
+            << "\nserver is " << reporter_url_
+            << "\nmaximum " << sender_->max_reports_per_day() << " reports/day"
+            << "\nreporter is " << reporter_tag_;
+  }
+  // Start servicing clients.
+  if (!dumper_->Start()) {
+    LOG(ERROR) << "could not start dumper";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  if (security_attributes.lpSecurityDescriptor)
+    LocalFree(security_attributes.lpSecurityDescriptor);
+
+  // Create or open an event to signal the browser process that the crash
+  // service is initialized.
+  base::string16 wait_name = base::ReplaceStringPlaceholders(
+      kWaitEventFormat, application_name, NULL);
+  HANDLE wait_event = ::CreateEventW(NULL, TRUE, TRUE, wait_name.c_str());
+  ::SetEvent(wait_event);
+
+  return true;
+}
+
+void CrashService::OnClientConnected(void* context,
+    const google_breakpad::ClientInfo* client_info) {
+  ProcessingLock lock;
+  VLOG(1) << "client start. pid = " << client_info->pid();
+  CrashService* self = static_cast<CrashService*>(context);
+  ::InterlockedIncrement(&self->clients_connected_);
+}
+
+void CrashService::OnClientExited(void* context,
+    const google_breakpad::ClientInfo* client_info) {
+  ProcessingLock lock;
+  VLOG(1) << "client end. pid = " << client_info->pid();
+  CrashService* self = static_cast<CrashService*>(context);
+  ::InterlockedIncrement(&self->clients_terminated_);
+
+  if (!self->sender_)
+    return;
+
+  // When we are instructed to send reports we need to exit if there are
+  // no more clients to service. The next client that runs will start us.
+  // Only chrome.exe starts crash_service with a non-zero max_reports.
+  if (self->clients_connected_ > self->clients_terminated_)
+    return;
+  if (self->sender_->max_reports_per_day() > 0) {
+    // Wait for the other thread to send crashes, if applicable. The sender
+    // thread takes the sending_ lock, so the sleep is just to give it a
+    // chance to start.
+    ::Sleep(1000);
+    base::AutoLock lock(self->sending_);
+    // Some people can restart chrome very fast, check again if we have
+    // a new client before exiting for real.
+    if (self->clients_connected_ == self->clients_terminated_) {
+      VLOG(1) << "zero clients. exiting";
+      ::PostMessage(g_top_window, WM_CLOSE, 0, 0);
+    }
+  }
+}
+
+void CrashService::OnClientDumpRequest(void* context,
+    const google_breakpad::ClientInfo* client_info,
+    const std::wstring* file_path) {
+  ProcessingLock lock;
+
+  if (!file_path) {
+    LOG(ERROR) << "dump with no file path";
+    return;
+  }
+  if (!client_info) {
+    LOG(ERROR) << "dump with no client info";
+    return;
+  }
+
+  CrashService* self = static_cast<CrashService*>(context);
+  if (!self) {
+    LOG(ERROR) << "dump with no context";
+    return;
+  }
+
+  CrashMap map;
+  CustomInfoToMap(client_info, self->reporter_tag_, &map);
+
+  // Move dump file to the directory under client breakpad dump location.
+  base::FilePath dump_location = base::FilePath(*file_path);
+  CrashMap::const_iterator it = map.find(L"breakpad-dump-location");
+  if (it != map.end()) {
+    base::FilePath alternate_dump_location = base::FilePath(it->second);
+    base::CreateDirectoryW(alternate_dump_location);
+    alternate_dump_location = alternate_dump_location.Append(
+        dump_location.BaseName());
+    base::Move(dump_location, alternate_dump_location);
+    dump_location = alternate_dump_location;
+  }
+
+  DWORD pid = client_info->pid();
+  VLOG(1) << "dump for pid = " << pid << " is " << dump_location.value();
+
+  if (!WriteCustomInfoToFile(dump_location.value(), map)) {
+    LOG(ERROR) << "could not write custom info file";
+  }
+
+  if (!self->sender_)
+    return;
+
+  // Send the crash dump using a worker thread. This operation has retry
+  // logic in case there is no internet connection at the time.
+  DumpJobInfo* dump_job = new DumpJobInfo(pid, self, map,
+                                          dump_location.value());
+  if (!::QueueUserWorkItem(&CrashService::AsyncSendDump,
+                           dump_job, WT_EXECUTELONGFUNCTION)) {
+    LOG(ERROR) << "could not queue job";
+  }
+}
+
+// We are going to try sending the report several times. If we can't send,
+// we sleep from one minute to several hours depending on the retry round.
+DWORD CrashService::AsyncSendDump(void* context) {
+  if (!context)
+    return 0;
+
+  DumpJobInfo* info = static_cast<DumpJobInfo*>(context);
+
+  std::wstring report_id = L"<unsent>";
+
+  const DWORD kOneMinute = 60*1000;
+  const DWORD kOneHour = 60*kOneMinute;
+
+  const DWORD kSleepSchedule[] = {
+      24*kOneHour,
+      8*kOneHour,
+      4*kOneHour,
+      kOneHour,
+      15*kOneMinute,
+      0};
+
+  int retry_round = arraysize(kSleepSchedule) - 1;
+
+  do {
+    ::Sleep(kSleepSchedule[retry_round]);
+    {
+      // Take the server lock while sending. This also prevent early
+      // termination of the service object.
+      base::AutoLock lock(info->self->sending_);
+      VLOG(1) << "trying to send report for pid = " << info->pid;
+      google_breakpad::ReportResult send_result
+          = info->self->sender_->SendCrashReport(info->self->reporter_url_,
+                                                 info->map,
+                                                 info->dump_path,
+                                                 &report_id);
+      switch (send_result) {
+        case google_breakpad::RESULT_FAILED:
+          report_id = L"<network issue>";
+          break;
+        case google_breakpad::RESULT_REJECTED:
+          report_id = L"<rejected>";
+          ++info->self->requests_handled_;
+          retry_round = 0;
+          break;
+        case google_breakpad::RESULT_SUCCEEDED:
+          ++info->self->requests_sent_;
+          ++info->self->requests_handled_;
+          retry_round = 0;
+          WriteReportIDToFile(info->dump_path, report_id);
+          break;
+        case google_breakpad::RESULT_THROTTLED:
+          report_id = L"<throttled>";
+          break;
+        default:
+          report_id = L"<unknown>";
+          break;
+      }
+    }
+
+    VLOG(1) << "dump for pid =" << info->pid << " crash2 id =" << report_id;
+    --retry_round;
+  } while (retry_round >= 0);
+
+  if (!::DeleteFileW(info->dump_path.c_str()))
+    LOG(WARNING) << "could not delete " << info->dump_path;
+
+  delete info;
+  return 0;
+}
+
+int CrashService::ProcessingLoop() {
+  MSG msg;
+  while (GetMessage(&msg, NULL, 0, 0)) {
+    TranslateMessage(&msg);
+    DispatchMessage(&msg);
+  }
+
+  VLOG(1) << "session ending..";
+  while (ProcessingLock::IsWorking()) {
+    ::Sleep(50);
+  }
+
+  VLOG(1) << "clients connected :" << clients_connected_
+          << "\nclients terminated :" << clients_terminated_
+          << "\ndumps serviced :" << requests_handled_
+          << "\ndumps reported :" << requests_sent_;
+
+  return static_cast<int>(msg.wParam);
+}
+
+PSECURITY_DESCRIPTOR CrashService::GetSecurityDescriptorForLowIntegrity() {
+  // Build the SDDL string for the label.
+  std::wstring sddl = L"S:(ML;;NW;;;S-1-16-4096)";
+
+  DWORD error = ERROR_SUCCESS;
+  PSECURITY_DESCRIPTOR sec_desc = NULL;
+
+  PACL sacl = NULL;
+  BOOL sacl_present = FALSE;
+  BOOL sacl_defaulted = FALSE;
+
+  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl.c_str(),
+                                                             SDDL_REVISION,
+                                                             &sec_desc, NULL)) {
+    if (::GetSecurityDescriptorSacl(sec_desc, &sacl_present, &sacl,
+                                    &sacl_defaulted)) {
+      return sec_desc;
+    }
+  }
+
+  return NULL;
+}
+
+}  // namespace breakpad
added in remote
  their  100644 10fde6374b1b58bc4789f5342fbacce75e54fadf electron/common/crash_reporter/win/crash_service.h
@@ -0,0 +1,132 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/files/file_path.h"
+#include "base/synchronization/lock.h"
+
+namespace google_breakpad {
+
+class CrashReportSender;
+class CrashGenerationServer;
+class ClientInfo;
+
+}
+
+namespace breakpad {
+
+// This class implements an out-of-process crash server. It uses breakpad's
+// CrashGenerationServer and CrashReportSender to generate and then send the
+// crash dumps. Internally, it uses OS specific pipe to allow applications to
+// register for crash dumps and later on when a registered application crashes
+// it will signal an event that causes this code to wake up and perform a
+// crash dump on the signaling process. The dump is then stored on disk and
+// possibly sent to the crash2 servers.
+class CrashService {
+ public:
+  CrashService();
+  ~CrashService();
+
+  // Starts servicing crash dumps. Returns false if it failed. Do not use
+  // other members in that case. |operating_dir| is where the CrashService
+  // should store breakpad's checkpoint file. |dumps_path| is the directory
+  // where the crash dumps should be stored.
+  bool Initialize(const base::string16& application_name,
+                  const base::FilePath& operating_dir,
+                  const base::FilePath& dumps_path);
+
+  // Command line switches:
+  //
+  // --max-reports=<number>
+  // Allows to override the maximum number for reports per day. Normally
+  // the crash dumps are never sent so if you want to send any you must
+  // specify a positive number here.
+  static const char kMaxReports[];
+  // --no-window
+  // Does not create a visible window on the desktop. The window does not have
+  // any other functionality other than allowing the crash service to be
+  // gracefully closed.
+  static const char kNoWindow[];
+  // --reporter=<string>
+  // Allows to specify a custom string that appears on the detail crash report
+  // page in the crash server. This should be a 25 chars or less string.
+  // The default tag if not specified is 'crash svc'.
+  static const char kReporterTag[];
+  // --dumps-dir=<directory-path>
+  // Override the directory to which crash dump files will be written.
+  static const char kDumpsDir[];
+  // --pipe-name=<string>
+  // Override the name of the Windows named pipe on which we will
+  // listen for crash dump request messages.
+  static const char kPipeName[];
+  // --reporter-url=<string>
+  // Override the URL to which crash reports will be sent to.
+  static const char kReporterURL[];
+
+  // Returns number of crash dumps handled.
+  int requests_handled() const {
+    return requests_handled_;
+  }
+  // Returns number of crash clients registered.
+  int clients_connected() const {
+    return clients_connected_;
+  }
+  // Returns number of crash clients terminated.
+  int clients_terminated() const {
+    return clients_terminated_;
+  }
+
+  // Starts the processing loop. This function does not return unless the
+  // user is logging off or the user closes the crash service window. The
+  // return value is a good number to pass in ExitProcess().
+  int ProcessingLoop();
+
+ private:
+  static void OnClientConnected(void* context,
+                                const google_breakpad::ClientInfo* client_info);
+
+  static void OnClientDumpRequest(
+      void* context,
+      const google_breakpad::ClientInfo* client_info,
+      const std::wstring* file_path);
+
+  static void OnClientExited(void* context,
+                             const google_breakpad::ClientInfo* client_info);
+
+  // This routine sends the crash dump to the server. It takes the sending_
+  // lock when it is performing the send.
+  static DWORD __stdcall AsyncSendDump(void* context);
+
+  // Returns the security descriptor which access to low integrity processes
+  // The caller is supposed to free the security descriptor by calling
+  // LocalFree.
+  PSECURITY_DESCRIPTOR GetSecurityDescriptorForLowIntegrity();
+
+  google_breakpad::CrashGenerationServer* dumper_;
+  google_breakpad::CrashReportSender* sender_;
+
+  // the extra tag sent to the server with each dump.
+  std::wstring reporter_tag_;
+
+  // receiver URL of crash reports.
+  std::wstring reporter_url_;
+
+  // clients serviced statistics:
+  int requests_handled_;
+  int requests_sent_;
+  volatile LONG clients_connected_;
+  volatile LONG clients_terminated_;
+  base::Lock sending_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashService);
+};
+
+}  // namespace breakpad
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
added in remote
  their  100644 014c230788b605041c1c63821a05bff641071935 electron/common/crash_reporter/win/crash_service_main.cc
@@ -0,0 +1,93 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/win/crash_service_main.h"
+
+#include "electron/common/crash_reporter/win/crash_service.h"
+#include "base/at_exit.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+
+namespace crash_service {
+
+namespace {
+
+const char kApplicationName[] = "application-name";
+
+const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
+const wchar_t kStandardLogFile[] = L"operation_log.txt";
+
+bool GetCrashServiceDirectory(const std::wstring& application_name,
+                              base::FilePath* dir) {
+  base::FilePath temp_dir;
+  if (!base::GetTempDir(&temp_dir))
+    return false;
+  temp_dir = temp_dir.Append(application_name + L" Crashes");
+  if (!base::PathExists(temp_dir)) {
+    if (!base::CreateDirectory(temp_dir))
+      return false;
+  }
+  *dir = temp_dir;
+  return true;
+}
+
+}  // namespace.
+
+int Main(const wchar_t* cmd) {
+  // Initialize all Chromium things.
+  base::AtExitManager exit_manager;
+  base::CommandLine::Init(0, NULL);
+  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
+
+  // Use the application's name as pipe name and output directory.
+  if (!cmd_line.HasSwitch(kApplicationName)) {
+    LOG(ERROR) << "Application's name must be specified with --"
+               << kApplicationName;
+    return 1;
+  }
+  std::wstring application_name = cmd_line.GetSwitchValueNative(
+      kApplicationName);
+
+  // We use/create a directory under the user's temp folder, for logging.
+  base::FilePath operating_dir;
+  GetCrashServiceDirectory(application_name, &operating_dir);
+  base::FilePath log_file = operating_dir.Append(kStandardLogFile);
+
+  // Logging to stderr (to help with debugging failures on the
+  // buildbots) and to a file.
+  logging::LoggingSettings settings;
+  settings.logging_dest = logging::LOG_TO_ALL;
+  settings.log_file = log_file.value().c_str();
+  logging::InitLogging(settings);
+  // Logging with pid, tid and timestamp.
+  logging::SetLogItems(true, true, true, false);
+
+  VLOG(1) << "Session start. cmdline is [" << cmd << "]";
+
+  // Setting the crash reporter.
+  base::string16 pipe_name = base::ReplaceStringPlaceholders(kPipeNameFormat,
+                                                 application_name,
+                                                 NULL);
+  cmd_line.AppendSwitch("no-window");
+  cmd_line.AppendSwitchASCII("max-reports", "128");
+  cmd_line.AppendSwitchASCII("reporter", ELECTRON_PROJECT_NAME "-crash-service");
+  cmd_line.AppendSwitchNative("pipe-name", pipe_name);
+
+  breakpad::CrashService crash_service;
+  if (!crash_service.Initialize(application_name, operating_dir,
+                                operating_dir))
+    return 2;
+
+  VLOG(1) << "Ready to process crash requests";
+
+  // Enter the message loop.
+  int retv = crash_service.ProcessingLoop();
+  // Time to exit.
+  VLOG(1) << "Session end. return code is " << retv;
+  return retv;
+}
+
+}  // namespace crash_service
added in remote
  their  100644 53aab9ecdd0d7003e78f4168a0a1d5ac23e68941 electron/common/crash_reporter/win/crash_service_main.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
+
+namespace crash_service {
+
+// Program entry, should be called by main();
+int Main(const wchar_t* cmd_line);
+
+}  // namespace crash_service
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
added in remote
  their  100644 7888c249217dc32e90e0a8ebdf3e20664c406ed3 electron/common/draggable_region.cc
@@ -0,0 +1,13 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/draggable_region.h"
+
+namespace electron {
+
+DraggableRegion::DraggableRegion()
+    : draggable(false) {
+}
+
+}  // namespace electron
added in remote
  their  100644 5ef7ef60c38392701ef0e5850190ada56d3c283e electron/common/draggable_region.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_DRAGGABLE_REGION_H_
+#define ELECTRON_COMMON_DRAGGABLE_REGION_H_
+
+#include "ui/gfx/geometry/rect.h"
+
+namespace electron {
+
+struct DraggableRegion {
+  bool draggable;
+  gfx::Rect bounds;
+
+  DraggableRegion();
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_DRAGGABLE_REGION_H_
added in remote
  their  100644 c4039a67c8ab00f25c3a94dce4733266d5101a54 electron/common/electron_command_line.cc
@@ -0,0 +1,31 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/electron_command_line.h"
+
+#include "base/command_line.h"
+#include "node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// static
+std::vector<std::string> ElectronCommandLine::argv_;
+
+// static
+void ElectronCommandLine::Init(int argc, const char* const* argv) {
+  // Hack around with the argv pointer. Used for process.title = "blah"
+  char** new_argv = uv_setup_args(argc, const_cast<char**>(argv));
+  for (int i = 0; i < argc; ++i) {
+    argv_.push_back(new_argv[i]);
+  }
+}
+
+#if defined(OS_LINUX)
+// static
+void ElectronCommandLine::InitializeFromCommandLine() {
+  argv_ = base::CommandLine::ForCurrentProcess()->argv();
+}
+#endif
+
+}  // namespace electron
added in remote
  their  100644 157dfc7f57838f076e0e281e51b1c2158611bb6a electron/common/electron_command_line.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
+#define ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
+
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "build/build_config.h"
+
+namespace electron {
+
+// Singleton to remember the original "argc" and "argv".
+class ElectronCommandLine {
+ public:
+  static void Init(int argc, const char* const* argv);
+  static std::vector<std::string> argv() { return argv_; }
+
+#if defined(OS_LINUX)
+  // On Linux the command line has to be read from base::CommandLine since
+  // it is using zygote.
+  static void InitializeFromCommandLine();
+#endif
+
+ private:
+  static std::vector<std::string> argv_;
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(ElectronCommandLine);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
added in remote
  their  100644 d32ed92c9e2b7a5636ed2b538720091cff1e414e electron/common/electron_constants.cc
@@ -0,0 +1,11 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/electron_constants.h"
+
+namespace electron {
+
+const char* kCORSHeader = "Access-Control-Allow-Origin: *";
+
+}  // namespace electron
added in remote
  their  100644 277ef6f41e81aba66843f77317c1974817202517 electron/common/electron_constants.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
+#define ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
+
+namespace electron {
+
+// Header to ignore CORS.
+extern const char* kCORSHeader;
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
added in remote
  their  100644 adb282d5dfd420fe6c037e7b7e1a25caa5cd7e55 electron/common/electron_version.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_VERSION_H
+#define ELECTRON_VERSION_H
+
+#define ELECTRON_MAJOR_VERSION 0
+#define ELECTRON_MINOR_VERSION 37
+#define ELECTRON_PATCH_VERSION 3
+
+#define ELECTRON_VERSION_IS_RELEASE 1
+
+#ifndef ELECTRON_TAG
+# define ELECTRON_TAG ""
+#endif
+
+#ifndef ELECTRON_STRINGIFY
+#define ELECTRON_STRINGIFY(n) ELECTRON_STRINGIFY_HELPER(n)
+#define ELECTRON_STRINGIFY_HELPER(n) #n
+#endif
+
+#if ELECTRON_VERSION_IS_RELEASE
+# define ELECTRON_VERSION_STRING  ELECTRON_STRINGIFY(ELECTRON_MAJOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_MINOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_PATCH_VERSION)     \
+                              ELECTRON_TAG
+#else
+# define ELECTRON_VERSION_STRING  ELECTRON_STRINGIFY(ELECTRON_MAJOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_MINOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_PATCH_VERSION)     \
+                              ELECTRON_TAG "-pre"
+#endif
+
+#define ELECTRON_VERSION "v" ELECTRON_VERSION_STRING
+
+
+#define ELECTRON_VERSION_AT_LEAST(major, minor, patch) \
+  (( (major) < ELECTRON_MAJOR_VERSION) \
+  || ((major) == ELECTRON_MAJOR_VERSION && (minor) < ELECTRON_MINOR_VERSION) \
+  || ((major) == ELECTRON_MAJOR_VERSION && (minor) == ELECTRON_MINOR_VERSION && (patch) <= ELECTRON_PATCH_VERSION))
+
+#endif /* ELECTRON_VERSION_H */
added in remote
  their  100644 15b242c336468a263da8a390300e9a36bc6dfee6 electron/common/google_api_key.h
@@ -0,0 +1,12 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_GOOGLE_API_KEY_H_
+#define ELECTRON_COMMON_GOOGLE_API_KEY_H_
+
+#ifndef GOOGLEAPIS_API_KEY
+#define GOOGLEAPIS_API_KEY "AIzaSyAQfxPJiounkhOjODEO5ZieffeBv6yft2Q"
+#endif
+
+#endif  // ELECTRON_COMMON_GOOGLE_API_KEY_H_
added in remote
  their  100644 33456dd68c15d84ef2b1444161f026bd4bc93fac electron/common/id_weak_map.cc
@@ -0,0 +1,94 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/id_weak_map.h"
+
+#include <utility>
+
+#include "native_mate/converter.h"
+
+namespace electron {
+
+namespace {
+
+struct ObjectKey {
+  ObjectKey(int id, IDWeakMap* map) : id(id), map(map) {}
+  int id;
+  IDWeakMap* map;
+};
+
+void OnObjectGC(const v8::WeakCallbackInfo<ObjectKey>& data) {
+  ObjectKey* key = data.GetParameter();
+  key->map->Remove(key->id);
+  delete key;
+}
+
+}  // namespace
+
+IDWeakMap::IDWeakMap() : next_id_(0) {
+}
+
+IDWeakMap::~IDWeakMap() {
+}
+
+void IDWeakMap::Set(v8::Isolate* isolate,
+                    int32_t id,
+                    v8::Local<v8::Object> object) {
+  auto global = make_linked_ptr(new v8::Global<v8::Object>(isolate, object));
+  ObjectKey* key = new ObjectKey(id, this);
+  global->SetWeak(key, OnObjectGC, v8::WeakCallbackType::kParameter);
+  map_[id] = global;
+}
+
+int32_t IDWeakMap::Add(v8::Isolate* isolate, v8::Local<v8::Object> object) {
+  int32_t id = GetNextID();
+  Set(isolate, id, object);
+  return id;
+}
+
+v8::MaybeLocal<v8::Object> IDWeakMap::Get(v8::Isolate* isolate, int32_t id) {
+  auto iter = map_.find(id);
+  if (iter == map_.end())
+    return v8::MaybeLocal<v8::Object>();
+  else
+    return v8::Local<v8::Object>::New(isolate, *iter->second);
+}
+
+bool IDWeakMap::Has(int32_t id) const {
+  return map_.find(id) != map_.end();
+}
+
+std::vector<int32_t> IDWeakMap::Keys() const {
+  std::vector<int32_t> keys;
+  keys.reserve(map_.size());
+  for (const auto& iter : map_)
+    keys.emplace_back(iter.first);
+  return keys;
+}
+
+std::vector<v8::Local<v8::Object>> IDWeakMap::Values(v8::Isolate* isolate) {
+  std::vector<v8::Local<v8::Object>> keys;
+  keys.reserve(map_.size());
+  for (const auto& iter : map_)
+    keys.emplace_back(v8::Local<v8::Object>::New(isolate, *iter.second));
+  return keys;
+}
+
+void IDWeakMap::Remove(int32_t id) {
+  auto iter = map_.find(id);
+  if (iter == map_.end())
+    LOG(WARNING) << "Removing unexist object with ID " << id;
+  else
+    map_.erase(iter);
+}
+
+void IDWeakMap::Clear() {
+  map_.clear();
+}
+
+int32_t IDWeakMap::GetNextID() {
+  return ++next_id_;
+}
+
+}  // namespace electron
added in remote
  their  100644 1ba179fab601d6d29940da2b1deda5d1f95aaf76 electron/common/id_weak_map.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ID_WEAK_MAP_H_
+#define ELECTRON_COMMON_ID_WEAK_MAP_H_
+
+#include <unordered_map>
+#include <vector>
+
+#include "base/memory/linked_ptr.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+// Like ES6's WeakMap, but the key is Integer and the value is Weak Pointer.
+class IDWeakMap {
+ public:
+  IDWeakMap();
+  ~IDWeakMap();
+
+  // Sets the object to WeakMap with the given |id|.
+  void Set(v8::Isolate* isolate, int32_t id, v8::Local<v8::Object> object);
+
+  // Adds |object| to WeakMap and returns its allocated |id|.
+  int32_t Add(v8::Isolate* isolate, v8::Local<v8::Object> object);
+
+  // Gets the object from WeakMap by its |id|.
+  v8::MaybeLocal<v8::Object> Get(v8::Isolate* isolate, int32_t id);
+
+  // Whethere there is an object with |id| in this WeakMap.
+  bool Has(int32_t id) const;
+
+  // Returns IDs of all available objects.
+  std::vector<int32_t> Keys() const;
+
+  // Returns all objects.
+  std::vector<v8::Local<v8::Object>> Values(v8::Isolate* isolate);
+
+  // Remove object with |id| in the WeakMap.
+  void Remove(int32_t key);
+
+  // Clears the weak map.
+  void Clear();
+
+ private:
+  // Returns next available ID.
+  int32_t GetNextID();
+
+  // ID of next stored object.
+  int32_t next_id_;
+
+  // Map of stored objects.
+  std::unordered_map<int32_t, linked_ptr<v8::Global<v8::Object>>> map_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDWeakMap);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ID_WEAK_MAP_H_
added in remote
  their  100644 4504df65bc043c77aa77274fe8d5d57c71c8e16b electron/common/keyboard_util.cc
@@ -0,0 +1,176 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/keyboard_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+
+namespace electron {
+
+namespace {
+
+// Return key code of the char, and also determine whether the SHIFT key is
+// pressed.
+ui::KeyboardCode KeyboardCodeFromCharCode(base::char16 c, bool* shifted) {
+  c = base::ToLowerASCII(c);
+  *shifted = false;
+  switch (c) {
+    case 0x08: return ui::VKEY_BACK;
+    case 0x7F: return ui::VKEY_DELETE;
+    case 0x09: return ui::VKEY_TAB;
+    case 0x0D: return ui::VKEY_RETURN;
+    case 0x1B: return ui::VKEY_ESCAPE;
+    case ' ': return ui::VKEY_SPACE;
+
+    case 'a': return ui::VKEY_A;
+    case 'b': return ui::VKEY_B;
+    case 'c': return ui::VKEY_C;
+    case 'd': return ui::VKEY_D;
+    case 'e': return ui::VKEY_E;
+    case 'f': return ui::VKEY_F;
+    case 'g': return ui::VKEY_G;
+    case 'h': return ui::VKEY_H;
+    case 'i': return ui::VKEY_I;
+    case 'j': return ui::VKEY_J;
+    case 'k': return ui::VKEY_K;
+    case 'l': return ui::VKEY_L;
+    case 'm': return ui::VKEY_M;
+    case 'n': return ui::VKEY_N;
+    case 'o': return ui::VKEY_O;
+    case 'p': return ui::VKEY_P;
+    case 'q': return ui::VKEY_Q;
+    case 'r': return ui::VKEY_R;
+    case 's': return ui::VKEY_S;
+    case 't': return ui::VKEY_T;
+    case 'u': return ui::VKEY_U;
+    case 'v': return ui::VKEY_V;
+    case 'w': return ui::VKEY_W;
+    case 'x': return ui::VKEY_X;
+    case 'y': return ui::VKEY_Y;
+    case 'z': return ui::VKEY_Z;
+
+    case ')': *shifted = true; case '0': return ui::VKEY_0;
+    case '!': *shifted = true; case '1': return ui::VKEY_1;
+    case '@': *shifted = true; case '2': return ui::VKEY_2;
+    case '#': *shifted = true; case '3': return ui::VKEY_3;
+    case '$': *shifted = true; case '4': return ui::VKEY_4;
+    case '%': *shifted = true; case '5': return ui::VKEY_5;
+    case '^': *shifted = true; case '6': return ui::VKEY_6;
+    case '&': *shifted = true; case '7': return ui::VKEY_7;
+    case '*': *shifted = true; case '8': return ui::VKEY_8;
+    case '(': *shifted = true; case '9': return ui::VKEY_9;
+
+    case ':': *shifted = true; case ';': return ui::VKEY_OEM_1;
+    case '+': *shifted = true; case '=': return ui::VKEY_OEM_PLUS;
+    case '<': *shifted = true; case ',': return ui::VKEY_OEM_COMMA;
+    case '_': *shifted = true; case '-': return ui::VKEY_OEM_MINUS;
+    case '>': *shifted = true; case '.': return ui::VKEY_OEM_PERIOD;
+    case '?': *shifted = true; case '/': return ui::VKEY_OEM_2;
+    case '~': *shifted = true; case '`': return ui::VKEY_OEM_3;
+    case '{': *shifted = true; case '[': return ui::VKEY_OEM_4;
+    case '|': *shifted = true; case '\\': return ui::VKEY_OEM_5;
+    case '}': *shifted = true; case ']': return ui::VKEY_OEM_6;
+    case '"': *shifted = true; case '\'': return ui::VKEY_OEM_7;
+
+    default: return ui::VKEY_UNKNOWN;
+  }
+}
+
+// Return key code represented by |str|.
+ui::KeyboardCode KeyboardCodeFromKeyIdentifier(const std::string& s,
+                                               bool* shifted) {
+  std::string str = base::ToLowerASCII(s);
+  if (str == "ctrl" || str == "control") {
+    return ui::VKEY_CONTROL;
+  } else if (str == "super" || str == "cmd" || str == "command" ||
+             str == "meta") {
+    return ui::VKEY_COMMAND;
+  } else if (str == "commandorcontrol" || str == "cmdorctrl") {
+#if defined(OS_MACOSX)
+    return ui::VKEY_COMMAND;
+#else
+    return ui::VKEY_CONTROL;
+#endif
+  } else if (str == "alt" || str == "option") {
+    return ui::VKEY_MENU;
+  } else if (str == "shift") {
+    return ui::VKEY_SHIFT;
+  } else if (str == "altgr") {
+    return ui::VKEY_ALTGR;
+  } else if (str == "plus") {
+    *shifted = true;
+    return ui::VKEY_OEM_PLUS;
+  } else if (str == "tab") {
+    return ui::VKEY_TAB;
+  } else if (str == "space") {
+    return ui::VKEY_SPACE;
+  } else if (str == "backspace") {
+    return ui::VKEY_BACK;
+  } else if (str == "delete") {
+    return ui::VKEY_DELETE;
+  } else if (str == "insert") {
+    return ui::VKEY_INSERT;
+  } else if (str == "enter" || str == "return") {
+    return ui::VKEY_RETURN;
+  } else if (str == "up") {
+    return ui::VKEY_UP;
+  } else if (str == "down") {
+    return ui::VKEY_DOWN;
+  } else if (str == "left") {
+    return ui::VKEY_LEFT;
+  } else if (str == "right") {
+    return ui::VKEY_RIGHT;
+  } else if (str == "home") {
+    return ui::VKEY_HOME;
+  } else if (str == "end") {
+    return ui::VKEY_END;
+  } else if (str == "pageup") {
+    return ui::VKEY_PRIOR;
+  } else if (str == "pagedown") {
+    return ui::VKEY_NEXT;
+  } else if (str == "esc" || str == "escape") {
+    return ui::VKEY_ESCAPE;
+  } else if (str == "volumemute") {
+    return ui::VKEY_VOLUME_MUTE;
+  } else if (str == "volumeup") {
+    return ui::VKEY_VOLUME_UP;
+  } else if (str == "volumedown") {
+    return ui::VKEY_VOLUME_DOWN;
+  } else if (str == "medianexttrack") {
+    return ui::VKEY_MEDIA_NEXT_TRACK;
+  } else if (str == "mediaprevioustrack") {
+    return ui::VKEY_MEDIA_PREV_TRACK;
+  } else if (str == "mediastop") {
+    return ui::VKEY_MEDIA_STOP;
+  } else if (str == "mediaplaypause") {
+    return ui::VKEY_MEDIA_PLAY_PAUSE;
+  } else if (str == "printscreen") {
+    return ui::VKEY_SNAPSHOT;
+  } else if (str.size() > 1 && str[0] == 'f') {
+    // F1 - F24.
+    int n;
+    if (base::StringToInt(str.c_str() + 1, &n) && n > 0 && n < 25) {
+      return static_cast<ui::KeyboardCode>(ui::VKEY_F1 + n - 1);
+    } else {
+      LOG(WARNING) << str << "is not available on keyboard";
+      return ui::VKEY_UNKNOWN;
+    }
+  } else {
+    LOG(WARNING) << "Invalid accelerator token: " << str;
+    return ui::VKEY_UNKNOWN;
+  }
+}
+
+}  // namespace
+
+ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted) {
+  if (str.size() == 1)
+    return KeyboardCodeFromCharCode(str[0], shifted);
+  else
+    return KeyboardCodeFromKeyIdentifier(str, shifted);
+}
+
+}  // namespace electron
added in remote
  their  100644 0dec464f4c0f5de1c9e49edd819a9b0fa3352f00 electron/common/keyboard_util.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_KEYBOARD_UTIL_H_
+#define ELECTRON_COMMON_KEYBOARD_UTIL_H_
+
+#include <string>
+
+#include "ui/events/keycodes/keyboard_codes.h"
+
+namespace electron {
+
+// Return key code of the |str|, and also determine whether the SHIFT key is
+// pressed.
+ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_KEYBOARD_UTIL_H_
added in remote
  their  100644 498cc377154bf0d1fb9ed0c6ad5959a0b5d1a5f3 electron/common/linux/application_info.cc
@@ -0,0 +1,19 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/electron_version.h"
+
+namespace brightray {
+
+std::string GetApplicationName() {
+  return ELECTRON_PRODUCT_NAME;
+}
+
+std::string GetApplicationVersion() {
+  return ELECTRON_VERSION_STRING;
+}
+
+}  // namespace brightray
added in remote
  their  100644 f920d2b36cfca98a9bf1d9f44e738e58a59ee65a electron/common/mouse_util.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include "electron/common/mouse_util.h"
+
+using Cursor = blink::WebCursorInfo::Type;
+
+namespace electron {
+
+std::string CursorTypeToString(const content::WebCursor::CursorInfo& info) {
+  switch (info.type) {
+    case Cursor::TypePointer: return "default";
+    case Cursor::TypeCross: return "crosshair";
+    case Cursor::TypeHand: return "pointer";
+    case Cursor::TypeIBeam: return "text";
+    case Cursor::TypeWait: return "wait";
+    case Cursor::TypeHelp: return "help";
+    case Cursor::TypeEastResize: return "e-resize";
+    case Cursor::TypeNorthResize: return "n-resize";
+    case Cursor::TypeNorthEastResize: return "ne-resize";
+    case Cursor::TypeNorthWestResize: return "nw-resize";
+    case Cursor::TypeSouthResize: return "s-resize";
+    case Cursor::TypeSouthEastResize: return "se-resize";
+    case Cursor::TypeSouthWestResize: return "sw-resize";
+    case Cursor::TypeWestResize: return "w-resize";
+    case Cursor::TypeNorthSouthResize: return "ns-resize";
+    case Cursor::TypeEastWestResize: return "ew-resize";
+    case Cursor::TypeNorthEastSouthWestResize: return "nesw-resize";
+    case Cursor::TypeNorthWestSouthEastResize: return "nwse-resize";
+    case Cursor::TypeColumnResize: return "col-resize";
+    case Cursor::TypeRowResize: return "row-resize";
+    case Cursor::TypeMiddlePanning: return "m-panning";
+    case Cursor::TypeEastPanning: return "e-panning";
+    case Cursor::TypeNorthPanning: return "n-panning";
+    case Cursor::TypeNorthEastPanning: return "ne-panning";
+    case Cursor::TypeNorthWestPanning: return "nw-panning";
+    case Cursor::TypeSouthPanning: return "s-panning";
+    case Cursor::TypeSouthEastPanning: return "se-panning";
+    case Cursor::TypeSouthWestPanning: return "sw-panning";
+    case Cursor::TypeWestPanning: return "w-panning";
+    case Cursor::TypeMove: return "move";
+    case Cursor::TypeVerticalText: return "vertical-text";
+    case Cursor::TypeCell: return "cell";
+    case Cursor::TypeContextMenu: return "context-menu";
+    case Cursor::TypeAlias: return "alias";
+    case Cursor::TypeProgress: return "progress";
+    case Cursor::TypeNoDrop: return "nodrop";
+    case Cursor::TypeCopy: return "copy";
+    case Cursor::TypeNone: return "none";
+    case Cursor::TypeNotAllowed: return "not-allowed";
+    case Cursor::TypeZoomIn: return "zoom-in";
+    case Cursor::TypeZoomOut: return "zoom-out";
+    case Cursor::TypeGrab: return "grab";
+    case Cursor::TypeGrabbing: return "grabbing";
+    case Cursor::TypeCustom: return "custom";
+    default: return "default";
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 54e549b4ac7b592d5eccea6e447d1bcf132a9fee electron/common/mouse_util.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_MOUSE_UTIL_H_
+#define ELECTRON_COMMON_MOUSE_UTIL_H_
+
+#include <string>
+#include "content/common/cursors/webcursor.h"
+#include "ipc/ipc_message_macros.h"
+
+// IPC macros similar to the already existing ones in the chromium source.
+// We need these to listen to the cursor change IPC message while still
+// letting chromium handle the actual cursor change by setting handled = false.
+#define IPC_MESSAGE_HANDLER_CODE(msg_class, member_func, code)                 \
+  IPC_MESSAGE_FORWARD_CODE(msg_class, this,                                    \
+    _IpcMessageHandlerClass::member_func, code)
+
+#define IPC_MESSAGE_FORWARD_CODE(msg_class, obj, member_func, code)            \
+    case msg_class::ID: {                                                      \
+        TRACK_RUN_IN_THIS_SCOPED_REGION(member_func);                          \
+        if (!msg_class::Dispatch(&ipc_message__, obj, this, param__,           \
+                                 &member_func))                                \
+          ipc_message__.set_dispatch_error();                                  \
+        code;                                                                  \
+      }                                                                        \
+      break;
+
+namespace electron {
+
+// Returns the cursor's type as a string.
+std::string CursorTypeToString(const content::WebCursor::CursorInfo& info);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_MOUSE_UTIL_H_
added in remote
  their  100644 142a2e73a6559b29d2f14c111b779253470b5638 electron/common/native_mate_converters/accelerator_converter.cc
@@ -0,0 +1,22 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+
+#include <string>
+
+#include "electron/browser/ui/accelerator_util.h"
+
+namespace mate {
+
+// static
+bool Converter<ui::Accelerator>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, ui::Accelerator* out) {
+  std::string keycode;
+  if (!ConvertFromV8(isolate, val, &keycode))
+    return false;
+  return accelerator_util::StringToAccelerator(keycode, out);
+}
+
+}  // namespace mate
added in remote
  their  100644 2941bcb7a9e24728b3cefcb3b9f805d7bdba4e43 electron/common/native_mate_converters/accelerator_converter.h
@@ -0,0 +1,24 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace ui {
+class Accelerator;
+}
+
+namespace mate {
+
+template<>
+struct Converter<ui::Accelerator> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     ui::Accelerator* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
added in remote
  their  100644 6307bad231e6754231304f8f99dd1b80b309d236 electron/common/native_mate_converters/blink_converter.cc
@@ -0,0 +1,299 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/blink_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/keyboard_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebDeviceEmulationParams.h"
+#include "third_party/WebKit/public/web/WebFindOptions.h"
+#include "third_party/WebKit/public/web/WebInputEvent.h"
+
+namespace {
+
+template<typename T>
+int VectorToBitArray(const std::vector<T>& vec) {
+  int bits = 0;
+  for (const T& item : vec)
+    bits |= item;
+  return bits;
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<base::char16> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     base::char16* out) {
+    base::string16 code = base::UTF8ToUTF16(V8ToString(val));
+    if (code.length() != 1)
+      return false;
+    *out = code[0];
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebInputEvent::Type> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Type* out) {
+    std::string type = base::ToLowerASCII(V8ToString(val));
+    if (type == "mousedown")
+      *out = blink::WebInputEvent::MouseDown;
+    else if (type == "mouseup")
+      *out = blink::WebInputEvent::MouseUp;
+    else if (type == "mousemove")
+      *out = blink::WebInputEvent::MouseMove;
+    else if (type == "mouseenter")
+      *out = blink::WebInputEvent::MouseEnter;
+    else if (type == "mouseleave")
+      *out = blink::WebInputEvent::MouseLeave;
+    else if (type == "contextmenu")
+      *out = blink::WebInputEvent::ContextMenu;
+    else if (type == "mousewheel")
+      *out = blink::WebInputEvent::MouseWheel;
+    else if (type == "keydown")
+      *out = blink::WebInputEvent::RawKeyDown;
+    else if (type == "keyup")
+      *out = blink::WebInputEvent::KeyUp;
+    else if (type == "char")
+      *out = blink::WebInputEvent::Char;
+    else if (type == "touchstart")
+      *out = blink::WebInputEvent::TouchStart;
+    else if (type == "touchmove")
+      *out = blink::WebInputEvent::TouchMove;
+    else if (type == "touchend")
+      *out = blink::WebInputEvent::TouchEnd;
+    else if (type == "touchcancel")
+      *out = blink::WebInputEvent::TouchCancel;
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebMouseEvent::Button> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebMouseEvent::Button* out) {
+    std::string button = base::ToLowerASCII(V8ToString(val));
+    if (button == "left")
+      *out = blink::WebMouseEvent::Button::ButtonLeft;
+    else if (button == "middle")
+      *out = blink::WebMouseEvent::Button::ButtonMiddle;
+    else if (button == "right")
+      *out = blink::WebMouseEvent::Button::ButtonRight;
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebInputEvent::Modifiers> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Modifiers* out) {
+    std::string modifier = base::ToLowerASCII(V8ToString(val));
+    if (modifier == "shift")
+      *out = blink::WebInputEvent::ShiftKey;
+    else if (modifier == "control" || modifier == "ctrl")
+      *out = blink::WebInputEvent::ControlKey;
+    else if (modifier == "alt")
+      *out = blink::WebInputEvent::AltKey;
+    else if (modifier == "meta" || modifier == "command" || modifier == "cmd")
+      *out = blink::WebInputEvent::MetaKey;
+    else if (modifier == "iskeypad")
+      *out = blink::WebInputEvent::IsKeyPad;
+    else if (modifier == "isautorepeat")
+      *out = blink::WebInputEvent::IsAutoRepeat;
+    else if (modifier == "leftbuttondown")
+      *out = blink::WebInputEvent::LeftButtonDown;
+    else if (modifier == "middlebuttondown")
+      *out = blink::WebInputEvent::MiddleButtonDown;
+    else if (modifier == "rightbuttondown")
+      *out = blink::WebInputEvent::RightButtonDown;
+    else if (modifier == "capslock")
+      *out = blink::WebInputEvent::CapsLockOn;
+    else if (modifier == "numlock")
+      *out = blink::WebInputEvent::NumLockOn;
+    else if (modifier == "left")
+      *out = blink::WebInputEvent::IsLeft;
+    else if (modifier == "right")
+      *out = blink::WebInputEvent::IsRight;
+    return true;
+  }
+};
+
+int GetWebInputEventType(v8::Isolate* isolate, v8::Local<v8::Value> val) {
+  blink::WebInputEvent::Type type = blink::WebInputEvent::Undefined;
+  mate::Dictionary dict;
+  ConvertFromV8(isolate, val, &dict) && dict.Get("type", &type);
+  return type;
+}
+
+bool Converter<blink::WebInputEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebInputEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!dict.Get("type", &out->type))
+    return false;
+  std::vector<blink::WebInputEvent::Modifiers> modifiers;
+  if (dict.Get("modifiers", &modifiers))
+    out->modifiers = VectorToBitArray(modifiers);
+  out->timeStampSeconds = base::Time::Now().ToDoubleT();
+  return true;
+}
+
+bool Converter<blink::WebKeyboardEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebKeyboardEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+
+  std::string str;
+  bool shifted = false;
+  if (dict.Get("keyCode", &str))
+    out->windowsKeyCode = electron::KeyboardCodeFromStr(str, &shifted);
+  else
+    return false;
+
+  if (shifted)
+    out->modifiers |= blink::WebInputEvent::ShiftKey;
+  out->setKeyIdentifierFromWindowsKeyCode();
+  if ((out->type == blink::WebInputEvent::Char ||
+       out->type == blink::WebInputEvent::RawKeyDown) &&
+      str.size() == 1) {
+    out->text[0] = str[0];
+    out->unmodifiedText[0] = str[0];
+  }
+  return true;
+}
+
+bool Converter<content::NativeWebKeyboardEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    content::NativeWebKeyboardEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebKeyboardEvent*>(out)))
+    return false;
+  dict.Get("skipInBrowser", &out->skip_in_browser);
+  return true;
+}
+
+bool Converter<blink::WebMouseEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebMouseEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+  if (!dict.Get("x", &out->x) || !dict.Get("y", &out->y))
+    return false;
+  dict.Get("button", &out->button);
+  dict.Get("globalX", &out->globalX);
+  dict.Get("globalY", &out->globalY);
+  dict.Get("movementX", &out->movementX);
+  dict.Get("movementY", &out->movementY);
+  dict.Get("clickCount", &out->clickCount);
+  return true;
+}
+
+bool Converter<blink::WebMouseWheelEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebMouseWheelEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebMouseEvent*>(out)))
+    return false;
+  dict.Get("deltaX", &out->deltaX);
+  dict.Get("deltaY", &out->deltaY);
+  dict.Get("wheelTicksX", &out->wheelTicksX);
+  dict.Get("wheelTicksY", &out->wheelTicksY);
+  dict.Get("accelerationRatioX", &out->accelerationRatioX);
+  dict.Get("accelerationRatioY", &out->accelerationRatioY);
+  dict.Get("hasPreciseScrollingDeltas", &out->hasPreciseScrollingDeltas);
+  dict.Get("canScroll", &out->canScroll);
+  return true;
+}
+
+bool Converter<blink::WebFloatPoint>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebFloatPoint* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
+}
+
+bool Converter<blink::WebPoint>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebPoint* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
+}
+
+bool Converter<blink::WebSize>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebSize* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("width", &out->width) && dict.Get("height", &out->height);
+}
+
+bool Converter<blink::WebDeviceEmulationParams>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebDeviceEmulationParams* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  std::string screen_position;
+  if (dict.Get("screenPosition", &screen_position)) {
+    screen_position = base::ToLowerASCII(screen_position);
+    if (screen_position == "mobile")
+      out->screenPosition = blink::WebDeviceEmulationParams::Mobile;
+    else if (screen_position == "desktop")
+      out->screenPosition = blink::WebDeviceEmulationParams::Desktop;
+    else
+      return false;
+  }
+
+  dict.Get("screenSize", &out->screenSize);
+  dict.Get("viewPosition", &out->viewPosition);
+  dict.Get("deviceScaleFactor", &out->deviceScaleFactor);
+  dict.Get("viewSize", &out->viewSize);
+  dict.Get("fitToView", &out->fitToView);
+  dict.Get("offset", &out->offset);
+  dict.Get("scale", &out->scale);
+  return true;
+}
+
+bool Converter<blink::WebFindOptions>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    blink::WebFindOptions* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  dict.Get("forward", &out->forward);
+  dict.Get("matchCase", &out->matchCase);
+  dict.Get("findNext", &out->findNext);
+  dict.Get("wordStart", &out->wordStart);
+  dict.Get("medialCapitalAsWordStart", &out->medialCapitalAsWordStart);
+  return true;
+}
+
+}  // namespace mate
added in remote
  their  100644 421306f8a83bf7843e96a7e2174cbeba61f86eb6 electron/common/native_mate_converters/blink_converter.h
@@ -0,0 +1,92 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace blink {
+class WebInputEvent;
+class WebMouseEvent;
+class WebMouseWheelEvent;
+class WebKeyboardEvent;
+struct WebDeviceEmulationParams;
+struct WebFindOptions;
+struct WebFloatPoint;
+struct WebPoint;
+struct WebSize;
+}  // namespace blink
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace mate {
+
+int GetWebInputEventType(v8::Isolate* isolate, v8::Local<v8::Value> val);
+
+template<>
+struct Converter<blink::WebInputEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebInputEvent* out);
+};
+
+template<>
+struct Converter<blink::WebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebKeyboardEvent* out);
+};
+
+template<>
+struct Converter<content::NativeWebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::NativeWebKeyboardEvent* out);
+};
+
+template<>
+struct Converter<blink::WebMouseEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebMouseEvent* out);
+};
+
+template<>
+struct Converter<blink::WebMouseWheelEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebMouseWheelEvent* out);
+};
+
+template<>
+struct Converter<blink::WebFloatPoint> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebFloatPoint* out);
+};
+
+template<>
+struct Converter<blink::WebPoint> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebPoint* out);
+};
+
+template<>
+struct Converter<blink::WebSize> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebSize* out);
+};
+
+template<>
+struct Converter<blink::WebDeviceEmulationParams> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebDeviceEmulationParams* out);
+};
+
+template<>
+struct Converter<blink::WebFindOptions> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebFindOptions* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
added in remote
  their  100644 2c4d31ae293aebe6c4e660c9d85138bc97d39b89 electron/common/native_mate_converters/callback.cc
@@ -0,0 +1,137 @@
+// Copyright (c) 2015 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/callback.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+namespace internal {
+
+namespace {
+
+struct TranslaterHolder {
+  Translater translater;
+};
+
+// Cached JavaScript version of |CallTranslater|.
+v8::Persistent<v8::FunctionTemplate> g_call_translater;
+
+void CallTranslater(v8::Local<v8::External> external,
+                    v8::Local<v8::Object> state,
+                    mate::Arguments* args) {
+  v8::Isolate* isolate = args->isolate();
+
+  // Check if the callback has already been called.
+  v8::Local<v8::String> called_symbol = mate::StringToSymbol(isolate, "called");
+  if (state->Has(called_symbol)) {
+    args->ThrowError("callback can only be called for once");
+    return;
+  } else {
+    state->Set(called_symbol, v8::Boolean::New(isolate, true));
+  }
+
+  TranslaterHolder* holder = static_cast<TranslaterHolder*>(external->Value());
+  holder->translater.Run(args);
+  delete holder;
+}
+
+// func.bind(func, arg1).
+// NB(zcbenz): Using C++11 version crashes VS.
+v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
+                                      v8::Local<v8::Context> context,
+                                      v8::Local<v8::Function> func,
+                                      v8::Local<v8::Value> arg1,
+                                      v8::Local<v8::Value> arg2) {
+  v8::MaybeLocal<v8::Value> bind = func->Get(mate::StringToV8(isolate, "bind"));
+  CHECK(!bind.IsEmpty());
+  v8::Local<v8::Function> bind_func =
+      v8::Local<v8::Function>::Cast(bind.ToLocalChecked());
+  v8::Local<v8::Value> converted[] = { func, arg1, arg2 };
+  return bind_func->Call(
+      context, func, arraysize(converted), converted).ToLocalChecked();
+}
+
+}  // namespace
+
+// Destroy the class on UI thread when possible.
+struct DeleteOnUIThread {
+  template<typename T>
+  static void Destruct(const T* x) {
+    if (Locker::IsBrowserProcess() &&
+        !BrowserThread::CurrentlyOn(BrowserThread::UI)) {
+      BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, x);
+    } else {
+      delete x;
+    }
+  }
+};
+
+// Like v8::Global, but ref-counted.
+template<typename T>
+class RefCountedGlobal : public base::RefCountedThreadSafe<RefCountedGlobal<T>,
+                                                           DeleteOnUIThread> {
+ public:
+  RefCountedGlobal(v8::Isolate* isolate, v8::Local<v8::Value> value)
+      : handle_(isolate, v8::Local<T>::Cast(value)) {
+  }
+
+  bool IsAlive() const {
+    return !handle_.IsEmpty();
+  }
+
+  v8::Local<T> NewHandle(v8::Isolate* isolate) const {
+    return v8::Local<T>::New(isolate, handle_);
+  }
+
+ private:
+  v8::Global<T> handle_;
+
+  DISALLOW_COPY_AND_ASSIGN(RefCountedGlobal);
+};
+
+SafeV8Function::SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value)
+    : v8_function_(new RefCountedGlobal<v8::Function>(isolate, value)) {
+}
+
+SafeV8Function::SafeV8Function(const SafeV8Function& other)
+    : v8_function_(other.v8_function_) {
+}
+
+SafeV8Function::~SafeV8Function() {
+}
+
+bool SafeV8Function::IsAlive() const {
+  return v8_function_.get() && v8_function_->IsAlive();
+}
+
+v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
+  return v8_function_->NewHandle(isolate);
+}
+
+v8::Local<v8::Value> CreateFunctionFromTranslater(
+    v8::Isolate* isolate, const Translater& translater) {
+  // The FunctionTemplate is cached.
+  if (g_call_translater.IsEmpty())
+    g_call_translater.Reset(
+        isolate,
+        mate::CreateFunctionTemplate(isolate, base::Bind(&CallTranslater)));
+
+  v8::Local<v8::FunctionTemplate> call_translater =
+      v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
+  TranslaterHolder* holder = new TranslaterHolder;
+  holder->translater = translater;
+  return BindFunctionWith(isolate,
+                          isolate->GetCurrentContext(),
+                          call_translater->GetFunction(),
+                          v8::External::New(isolate, holder),
+                          v8::Object::New(isolate));
+}
+
+}  // namespace internal
+
+}  // namespace mate
added in remote
  their  100644 77c92e191926789c7c2e61de9514caf5a68e63bc electron/common/native_mate_converters/callback.h
@@ -0,0 +1,155 @@
+// Copyright (c) 2015 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
+
+#include <vector>
+
+#include "electron/common/api/locker.h"
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/memory/weak_ptr.h"
+#include "native_mate/function_template.h"
+#include "native_mate/scoped_persistent.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+namespace mate {
+
+namespace internal {
+
+template<typename T>
+class RefCountedGlobal;
+
+// Manages the V8 function with RAII.
+class SafeV8Function {
+ public:
+  SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value);
+  SafeV8Function(const SafeV8Function& other);
+  ~SafeV8Function();
+
+  bool IsAlive() const;
+  v8::Local<v8::Function> NewHandle(v8::Isolate* isolate) const;
+
+ private:
+  scoped_refptr<RefCountedGlobal<v8::Function>> v8_function_;
+};
+
+// Helper to invoke a V8 function with C++ parameters.
+template <typename Sig>
+struct V8FunctionInvoker {};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<v8::Local<v8::Value>(ArgTypes...)> {
+  static v8::Local<v8::Value> Go(v8::Isolate* isolate,
+                                 const SafeV8Function& function,
+                                 ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::EscapableHandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return v8::Null(isolate);
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    v8::Local<v8::Value> ret(holder->Call(holder, args.size(), &args.front()));
+    return handle_scope.Escape(ret);
+  }
+};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<void(ArgTypes...)> {
+  static void Go(v8::Isolate* isolate,
+                 const SafeV8Function& function,
+                 ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return;
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    holder->Call(holder, args.size(), &args.front());
+  }
+};
+
+template <typename ReturnType, typename... ArgTypes>
+struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
+  static ReturnType Go(v8::Isolate* isolate,
+                       const SafeV8Function& function,
+                       ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    ReturnType ret = ReturnType();
+    if (!function.IsAlive())
+      return ret;
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    v8::Local<v8::Value> result;
+    auto maybe_result =
+        holder->Call(context, holder, args.size(), &args.front());
+    if (maybe_result.ToLocal(&result))
+      Converter<ReturnType>::FromV8(isolate, result, &ret);
+    return ret;
+  }
+};
+
+// Helper to pass a C++ funtion to JavaScript.
+using Translater = base::Callback<void(Arguments* args)>;
+v8::Local<v8::Value> CreateFunctionFromTranslater(
+    v8::Isolate* isolate, const Translater& translater);
+
+// Calls callback with Arguments.
+template <typename Sig>
+struct NativeFunctionInvoker {};
+
+template <typename ReturnType, typename... ArgTypes>
+struct NativeFunctionInvoker<ReturnType(ArgTypes...)> {
+  static void Go(base::Callback<ReturnType(ArgTypes...)> val, Arguments* args) {
+    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
+    Invoker<Indices, ArgTypes...> invoker(args, 0);
+    if (invoker.IsOK())
+      invoker.DispatchToCallback(val);
+  }
+};
+
+}  // namespace internal
+
+template<typename Sig>
+struct Converter<base::Callback<Sig>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::Callback<Sig>& val) {
+    // We don't use CreateFunctionTemplate here because it creates a new
+    // FunctionTemplate everytime, which is cached by V8 and causes leaks.
+    internal::Translater translater = base::Bind(
+        &internal::NativeFunctionInvoker<Sig>::Go, val);
+    return internal::CreateFunctionFromTranslater(isolate, translater);
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::Callback<Sig>* out) {
+    if (!val->IsFunction())
+      return false;
+
+    *out = base::Bind(&internal::V8FunctionInvoker<Sig>::Go,
+                      isolate, internal::SafeV8Function(isolate, val));
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
added in remote
  their  100644 f32bf20ab95c1481f72e91bd0028ee9ec12cd9d9 electron/common/native_mate_converters/content_converter.cc
@@ -0,0 +1,181 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/content_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/context_menu_params.h"
+#include "native_mate/dictionary.h"
+
+namespace {
+
+void ExecuteCommand(content::WebContents* web_contents,
+                    int action,
+                    const content::CustomContextMenuContext& context) {
+  web_contents->ExecuteCustomContextMenuCommand(action, context);
+}
+
+// Forward declaration for nested recursive call.
+v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
+                              content::WebContents* web_contents,
+                              const content::CustomContextMenuContext& context,
+                              const std::vector<content::MenuItem>& menu);
+
+v8::Local<v8::Value> MenuItemToV8(
+    v8::Isolate* isolate,
+    content::WebContents* web_contents,
+    const content::CustomContextMenuContext& context,
+    const content::MenuItem& item) {
+  mate::Dictionary v8_item = mate::Dictionary::CreateEmpty(isolate);
+  switch (item.type) {
+    case content::MenuItem::CHECKABLE_OPTION:
+    case content::MenuItem::GROUP:
+      v8_item.Set("checked", item.checked);
+    case content::MenuItem::OPTION:
+    case content::MenuItem::SUBMENU:
+      v8_item.Set("label", item.label);
+      v8_item.Set("enabled", item.enabled);
+    default:
+      v8_item.Set("type", item.type);
+  }
+  if (item.type == content::MenuItem::SUBMENU)
+    v8_item.Set("submenu",
+                MenuToV8(isolate, web_contents, context, item.submenu));
+  else if (item.action > 0)
+    v8_item.Set("click",
+                base::Bind(ExecuteCommand, web_contents, item.action, context));
+  return v8_item.GetHandle();
+}
+
+v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
+                              content::WebContents* web_contents,
+                              const content::CustomContextMenuContext& context,
+                              const std::vector<content::MenuItem>& menu) {
+  std::vector<v8::Local<v8::Value>> v8_menu;
+  for (const auto& menu_item : menu)
+    v8_menu.push_back(MenuItemToV8(isolate, web_contents, context, menu_item));
+  return mate::ConvertToV8(isolate, v8_menu);
+}
+
+}  // namespace
+
+namespace mate {
+
+// static
+v8::Local<v8::Value> Converter<content::MenuItem::Type>::ToV8(
+    v8::Isolate* isolate, const content::MenuItem::Type& val) {
+  switch (val) {
+    case content::MenuItem::CHECKABLE_OPTION:
+      return StringToV8(isolate, "checkbox");
+    case content::MenuItem::GROUP:
+      return StringToV8(isolate, "radio");
+    case content::MenuItem::SEPARATOR:
+      return StringToV8(isolate, "separator");
+    case content::MenuItem::SUBMENU:
+      return StringToV8(isolate, "submenu");
+    case content::MenuItem::OPTION:
+    default:
+      return StringToV8(isolate, "normal");
+  }
+}
+
+// static
+v8::Local<v8::Value> Converter<ContextMenuParamsWithWebContents>::ToV8(
+    v8::Isolate* isolate, const ContextMenuParamsWithWebContents& val) {
+  const auto& params = val.first;
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.Set("x", params.x);
+  dict.Set("y", params.y);
+  if (params.custom_context.is_pepper_menu)
+    dict.Set("menu", MenuToV8(isolate, val.second, params.custom_context,
+                              params.custom_items));
+  return mate::ConvertToV8(isolate, dict);
+}
+
+// static
+bool Converter<content::PermissionStatus>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    content::PermissionStatus* out) {
+  bool result;
+  if (!ConvertFromV8(isolate, val, &result))
+    return false;
+
+  if (result)
+    *out = content::PERMISSION_STATUS_GRANTED;
+  else
+    *out = content::PERMISSION_STATUS_DENIED;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::PermissionType>::ToV8(
+    v8::Isolate* isolate, const content::PermissionType& val) {
+  using PermissionType = electron::WebContentsPermissionHelper::PermissionType;
+  switch (val) {
+    case content::PermissionType::MIDI_SYSEX:
+      return StringToV8(isolate, "midiSysex");
+    case content::PermissionType::PUSH_MESSAGING:
+      return StringToV8(isolate, "pushMessaging");
+    case content::PermissionType::NOTIFICATIONS:
+      return StringToV8(isolate, "notifications");
+    case content::PermissionType::GEOLOCATION:
+      return StringToV8(isolate, "geolocation");
+    case content::PermissionType::AUDIO_CAPTURE:
+    case content::PermissionType::VIDEO_CAPTURE:
+      return StringToV8(isolate, "media");
+    case content::PermissionType::PROTECTED_MEDIA_IDENTIFIER:
+      return StringToV8(isolate, "mediaKeySystem");
+    case content::PermissionType::MIDI:
+      return StringToV8(isolate, "midi");
+    default:
+      break;
+  }
+
+  if (val == (content::PermissionType)(PermissionType::POINTER_LOCK))
+    return StringToV8(isolate, "pointerLock");
+  else if (val == (content::PermissionType)(PermissionType::FULLSCREEN))
+    return StringToV8(isolate, "fullscreen");
+
+  return StringToV8(isolate, "unknown");
+}
+
+// static
+bool Converter<content::StopFindAction>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    content::StopFindAction* out) {
+  std::string action;
+  if (!ConvertFromV8(isolate, val, &action))
+    return false;
+
+  if (action == "clearSelection")
+    *out = content::STOP_FIND_ACTION_CLEAR_SELECTION;
+  else if (action == "keepSelection")
+    *out = content::STOP_FIND_ACTION_KEEP_SELECTION;
+  else if (action == "activateSelection")
+    *out = content::STOP_FIND_ACTION_ACTIVATE_SELECTION;
+  else
+    return false;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::WebContents*>::ToV8(
+    v8::Isolate* isolate, content::WebContents* val) {
+  if (!val)
+    return v8::Null(isolate);
+  return electron::api::WebContents::CreateFrom(isolate, val).ToV8();
+}
+
+}  // namespace mate
added in remote
  their  100644 00764b15e3257bd4be31c2a9edeb3ff7353d5b44 electron/common/native_mate_converters/content_converter.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
+
+#include <utility>
+
+#include "content/public/browser/permission_type.h"
+#include "content/public/common/menu_item.h"
+#include "content/public/common/permission_status.mojom.h"
+#include "content/public/common/stop_find_action.h"
+#include "native_mate/converter.h"
+
+namespace content {
+struct ContextMenuParams;
+class WebContents;
+}
+
+using ContextMenuParamsWithWebContents =
+    std::pair<content::ContextMenuParams, content::WebContents*>;
+
+namespace mate {
+
+template<>
+struct Converter<content::MenuItem::Type> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::MenuItem::Type& val);
+};
+
+template<>
+struct Converter<ContextMenuParamsWithWebContents> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const ContextMenuParamsWithWebContents& val);
+};
+
+template<>
+struct Converter<content::PermissionStatus> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::PermissionStatus* out);
+};
+
+template<>
+struct Converter<content::PermissionType> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::PermissionType& val);
+};
+
+template<>
+struct Converter<content::StopFindAction> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::StopFindAction* out);
+};
+
+template<>
+struct Converter<content::WebContents*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::WebContents* val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
added in remote
  their  100644 28b965e16055f0968ae3b3dd2f4a706315698caa electron/common/native_mate_converters/file_path_converter.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
+
+#include <string>
+
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/files/file_path.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::FilePath> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const base::FilePath& val) {
+    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::FilePath* out) {
+    if (val->IsNull())
+      return true;
+
+    base::FilePath::StringType path;
+    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {
+      *out = base::FilePath(path);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
added in remote
  their  100644 8de28554eb036b8d6af872bfb772508857b2411f electron/common/native_mate_converters/gfx_converter.cc
@@ -0,0 +1,114 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/gfx_converter.h"
+
+#include "native_mate/dictionary.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/screen.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace mate {
+
+v8::Local<v8::Value> Converter<gfx::Point>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Point& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Point>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Point* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int x, y;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y))
+    return false;
+  *out = gfx::Point(x, y);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Size>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Size& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Size>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Size* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int width, height;
+  if (!dict.Get("width", &width) || !dict.Get("height", &height))
+    return false;
+  *out = gfx::Size(width, height);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Rect>::ToV8(v8::Isolate* isolate,
+                                                 const gfx::Rect& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Rect>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Rect* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int x, y, width, height;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y) ||
+      !dict.Get("width", &width) || !dict.Get("height", &height))
+    return false;
+  *out = gfx::Rect(x, y, width, height);
+  return true;
+}
+
+template<>
+struct Converter<gfx::Display::TouchSupport> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Display::TouchSupport& val) {
+    switch (val) {
+      case gfx::Display::TOUCH_SUPPORT_AVAILABLE:
+        return StringToV8(isolate, "available");
+      case gfx::Display::TOUCH_SUPPORT_UNAVAILABLE:
+        return StringToV8(isolate, "unavailable");
+      default:
+        return StringToV8(isolate, "unknown");
+    }
+  }
+};
+
+v8::Local<v8::Value> Converter<gfx::Display>::ToV8(v8::Isolate* isolate,
+                                                    const gfx::Display& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("id", val.id());
+  dict.Set("bounds", val.bounds());
+  dict.Set("workArea", val.work_area());
+  dict.Set("size", val.size());
+  dict.Set("workAreaSize", val.work_area_size());
+  dict.Set("scaleFactor", val.device_scale_factor());
+  dict.Set("rotation", val.RotationAsDegree());
+  dict.Set("touchSupport", val.touch_support());
+  return dict.GetHandle();
+}
+
+}  // namespace mate
added in remote
  their  100644 eb4a98f93ec7a98160c41f23ae8e79e8bd66ada7 electron/common/native_mate_converters/gfx_converter.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace gfx {
+class Point;
+class Size;
+class Rect;
+class Display;
+}
+
+namespace mate {
+
+template<>
+struct Converter<gfx::Point> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Point& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Point* out);
+};
+
+template<>
+struct Converter<gfx::Size> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Size& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Size* out);
+};
+
+template<>
+struct Converter<gfx::Rect> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Rect& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Rect* out);
+};
+
+template<>
+struct Converter<gfx::Display> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Display& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Display* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
added in remote
  their  100644 343df5d654fe40063e62598281965048b05b0fca electron/common/native_mate_converters/gurl_converter.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
+
+#include <string>
+
+#include "native_mate/converter.h"
+#include "url/gurl.h"
+
+namespace mate {
+
+template<>
+struct Converter<GURL> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const GURL& val) {
+    return ConvertToV8(isolate, val.spec());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     GURL* out) {
+    std::string url;
+    if (Converter<std::string>::FromV8(isolate, val, &url)) {
+      *out = GURL(url);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
added in remote
  their  100644 6998d1bf4c983005120d11473cce6e7a1f0d44ac electron/common/native_mate_converters/image_converter.cc
@@ -0,0 +1,51 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/image_converter.h"
+
+#include "electron/common/api/electron_api_native_image.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace mate {
+
+bool Converter<gfx::ImageSkia>::FromV8(v8::Isolate* isolate,
+                                       v8::Local<v8::Value> val,
+                                       gfx::ImageSkia* out) {
+  gfx::Image image;
+  if (!ConvertFromV8(isolate, val, &image))
+    return false;
+
+  *out = image.AsImageSkia();
+  return true;
+}
+
+bool Converter<gfx::Image>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Image* out) {
+  if (val->IsNull())
+    return true;
+
+  Handle<electron::api::NativeImage> native_image;
+  if (!ConvertFromV8(isolate, val, &native_image)) {
+    // Try converting from file path.
+    base::FilePath path;
+    if (!Converter<base::FilePath>::FromV8(isolate, val, &path))
+      return false;
+
+    native_image = electron::api::NativeImage::CreateFromPath(isolate, path);
+    if (native_image->image().IsEmpty())
+      return false;
+  }
+
+  *out = native_image->image();
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Image>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Image& val) {
+  return ConvertToV8(isolate, electron::api::NativeImage::Create(isolate, val));
+}
+
+}  // namespace mate
added in remote
  their  100644 d9a5739303088f38ecee5e978fc473bd2089e69c electron/common/native_mate_converters/image_converter.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace gfx {
+class Image;
+class ImageSkia;
+}
+
+namespace mate {
+
+template<>
+struct Converter<gfx::ImageSkia> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::ImageSkia* out);
+};
+
+template<>
+struct Converter<gfx::Image> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Image* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Image& val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
added in remote
  their  100644 3d63cadbec97e8b36131b4e0616444b915d6a485 electron/common/native_mate_converters/net_converter.cc
@@ -0,0 +1,99 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/net_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/node_includes.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "base/values.h"
+#include "native_mate/dictionary.h"
+#include "net/base/upload_bytes_element_reader.h"
+#include "net/base/upload_data_stream.h"
+#include "net/base/upload_element_reader.h"
+#include "net/base/upload_file_element_reader.h"
+#include "net/cert/x509_certificate.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_request.h"
+
+namespace mate {
+
+// static
+v8::Local<v8::Value> Converter<const net::URLRequest*>::ToV8(
+    v8::Isolate* isolate, const net::URLRequest* val) {
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  dict->SetString("method", val->method());
+  std::string url;
+  if (!val->url_chain().empty()) url = val->url().spec();
+  dict->SetStringWithoutPathExpansion("url", url);
+  dict->SetString("referrer", val->referrer());
+  scoped_ptr<base::ListValue> list(new base::ListValue);
+  electron::GetUploadData(list.get(), val);
+  if (!list->empty())
+    dict->Set("uploadData", std::move(list));
+  return mate::ConvertToV8(isolate, *(dict.get()));
+}
+
+// static
+v8::Local<v8::Value> Converter<const net::AuthChallengeInfo*>::ToV8(
+    v8::Isolate* isolate, const net::AuthChallengeInfo* val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.Set("isProxy", val->is_proxy);
+  dict.Set("scheme", val->scheme);
+  dict.Set("host", val->challenger.host());
+  dict.Set("port", static_cast<uint32_t>(val->challenger.port()));
+  dict.Set("realm", val->realm);
+  return mate::ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<scoped_refptr<net::X509Certificate>>::ToV8(
+    v8::Isolate* isolate, const scoped_refptr<net::X509Certificate>& val) {
+  mate::Dictionary dict(isolate, v8::Object::New(isolate));
+  std::string encoded_data;
+  net::X509Certificate::GetPEMEncoded(
+      val->os_cert_handle(), &encoded_data);
+  auto buffer = node::Buffer::Copy(isolate,
+                                   encoded_data.data(),
+                                   encoded_data.size()).ToLocalChecked();
+  dict.Set("data", buffer);
+  dict.Set("issuerName", val->issuer().GetDisplayName());
+  return dict.GetHandle();
+}
+
+}  // namespace mate
+
+namespace electron {
+
+void GetUploadData(base::ListValue* upload_data_list,
+                   const net::URLRequest* request) {
+  const net::UploadDataStream* upload_data = request->get_upload();
+  if (!upload_data)
+    return;
+  const std::vector<scoped_ptr<net::UploadElementReader>>* readers =
+      upload_data->GetElementReaders();
+  for (const auto& reader : *readers) {
+    scoped_ptr<base::DictionaryValue> upload_data_dict(
+        new base::DictionaryValue);
+    if (reader->AsBytesReader()) {
+      const net::UploadBytesElementReader* bytes_reader =
+          reader->AsBytesReader();
+      scoped_ptr<base::Value> bytes(
+          base::BinaryValue::CreateWithCopiedBuffer(bytes_reader->bytes(),
+                                                    bytes_reader->length()));
+      upload_data_dict->Set("bytes", std::move(bytes));
+    } else if (reader->AsFileReader()) {
+      const net::UploadFileElementReader* file_reader =
+          reader->AsFileReader();
+      auto file_path = file_reader->path().AsUTF8Unsafe();
+      upload_data_dict->SetStringWithoutPathExpansion("file", file_path);
+    }
+    upload_data_list->Append(std::move(upload_data_dict));
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 5527ae4195242262dc2ba1263f0443e2810e2ece electron/common/native_mate_converters/net_converter.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
+
+#include "base/memory/ref_counted.h"
+#include "native_mate/converter.h"
+
+namespace base {
+class ListValue;
+}
+
+namespace net {
+class AuthChallengeInfo;
+class URLRequest;
+class X509Certificate;
+}
+
+namespace mate {
+
+template<>
+struct Converter<const net::URLRequest*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::URLRequest* val);
+};
+
+template<>
+struct Converter<const net::AuthChallengeInfo*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::AuthChallengeInfo* val);
+};
+
+template<>
+struct Converter<scoped_refptr<net::X509Certificate>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+      const scoped_refptr<net::X509Certificate>& val);
+};
+
+}  // namespace mate
+
+namespace electron {
+
+void GetUploadData(base::ListValue* upload_data_list,
+                   const net::URLRequest* request);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
added in remote
  their  100644 db6fb3f5f729b1db5ef0fb4acef3b22a18ee5449 electron/common/native_mate_converters/string16_converter.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
+
+#include "base/strings/string16.h"
+#include "native_mate/converter.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::string16> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const base::string16& val) {
+    return MATE_STRING_NEW_FROM_UTF16(
+        isolate, reinterpret_cast<const uint16_t*>(val.data()), val.size());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::string16* out) {
+    if (!val->IsString())
+      return false;
+
+    v8::String::Value s(val);
+    out->assign(reinterpret_cast<const base::char16*>(*s), s.length());
+    return true;
+  }
+};
+
+inline v8::Local<v8::String> StringToV8(
+    v8::Isolate* isolate,
+    const base::string16& input) {
+  return ConvertToV8(isolate, input).As<v8::String>();
+}
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
added in remote
  their  100644 40d71b0e694d24e5ddce7ccbe699795cf1ecf598 electron/common/native_mate_converters/v8_value_converter.cc
@@ -0,0 +1,410 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+
+#include <map>
+#include <string>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/values.h"
+#include "native_mate/dictionary.h"
+#include "vendor/node/src/node_buffer.h"
+
+namespace electron {
+
+namespace {
+
+const int kMaxRecursionDepth = 100;
+
+}  // namespace
+
+// The state of a call to FromV8Value.
+class V8ValueConverter::FromV8ValueState {
+ public:
+  // Level scope which updates the current depth of some FromV8ValueState.
+  class Level {
+   public:
+    explicit Level(FromV8ValueState* state) : state_(state) {
+      state_->max_recursion_depth_--;
+    }
+    ~Level() {
+      state_->max_recursion_depth_++;
+    }
+
+   private:
+    FromV8ValueState* state_;
+  };
+
+  FromV8ValueState() : max_recursion_depth_(kMaxRecursionDepth) {}
+
+  // If |handle| is not in |unique_map_|, then add it to |unique_map_| and
+  // return true.
+  //
+  // Otherwise do nothing and return false. Here "A is unique" means that no
+  // other handle B in the map points to the same object as A. Note that A can
+  // be unique even if there already is another handle with the same identity
+  // hash (key) in the map, because two objects can have the same hash.
+  bool UpdateAndCheckUniqueness(v8::Local<v8::Object> handle) {
+    typedef HashToHandleMap::const_iterator Iterator;
+    int hash = handle->GetIdentityHash();
+    // We only compare using == with handles to objects with the same identity
+    // hash. Different hash obviously means different objects, but two objects
+    // in a couple of thousands could have the same identity hash.
+    std::pair<Iterator, Iterator> range = unique_map_.equal_range(hash);
+    for (Iterator it = range.first; it != range.second; ++it) {
+      // Operator == for handles actually compares the underlying objects.
+      if (it->second == handle)
+        return false;
+    }
+    unique_map_.insert(std::make_pair(hash, handle));
+    return true;
+  }
+
+  bool HasReachedMaxRecursionDepth() {
+    return max_recursion_depth_ < 0;
+  }
+
+ private:
+  typedef std::multimap<int, v8::Local<v8::Object> > HashToHandleMap;
+  HashToHandleMap unique_map_;
+
+  int max_recursion_depth_;
+};
+
+V8ValueConverter::V8ValueConverter()
+    : reg_exp_allowed_(false),
+      function_allowed_(false),
+      strip_null_from_objects_(false) {}
+
+void V8ValueConverter::SetRegExpAllowed(bool val) {
+  reg_exp_allowed_ = val;
+}
+
+void V8ValueConverter::SetFunctionAllowed(bool val) {
+  function_allowed_ = val;
+}
+
+void V8ValueConverter::SetStripNullFromObjects(bool val) {
+  strip_null_from_objects_ = val;
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Value(
+    const base::Value* value, v8::Local<v8::Context> context) const {
+  v8::Context::Scope context_scope(context);
+  v8::EscapableHandleScope handle_scope(context->GetIsolate());
+  return handle_scope.Escape(ToV8ValueImpl(context->GetIsolate(), value));
+}
+
+base::Value* V8ValueConverter::FromV8Value(
+    v8::Local<v8::Value> val,
+    v8::Local<v8::Context> context) const {
+  v8::Context::Scope context_scope(context);
+  v8::HandleScope handle_scope(context->GetIsolate());
+  FromV8ValueState state;
+  return FromV8ValueImpl(&state, val, context->GetIsolate());
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8ValueImpl(
+     v8::Isolate* isolate, const base::Value* value) const {
+  CHECK(value);
+  switch (value->GetType()) {
+    case base::Value::TYPE_NULL:
+      return v8::Null(isolate);
+
+    case base::Value::TYPE_BOOLEAN: {
+      bool val = false;
+      CHECK(value->GetAsBoolean(&val));
+      return v8::Boolean::New(isolate, val);
+    }
+
+    case base::Value::TYPE_INTEGER: {
+      int val = 0;
+      CHECK(value->GetAsInteger(&val));
+      return v8::Integer::New(isolate, val);
+    }
+
+    case base::Value::TYPE_DOUBLE: {
+      double val = 0.0;
+      CHECK(value->GetAsDouble(&val));
+      return v8::Number::New(isolate, val);
+    }
+
+    case base::Value::TYPE_STRING: {
+      std::string val;
+      CHECK(value->GetAsString(&val));
+      return v8::String::NewFromUtf8(
+          isolate, val.c_str(), v8::String::kNormalString, val.length());
+    }
+
+    case base::Value::TYPE_LIST:
+      return ToV8Array(isolate, static_cast<const base::ListValue*>(value));
+
+    case base::Value::TYPE_DICTIONARY:
+      return ToV8Object(isolate,
+                        static_cast<const base::DictionaryValue*>(value));
+
+    case base::Value::TYPE_BINARY:
+      return ToArrayBuffer(isolate,
+                           static_cast<const base::BinaryValue*>(value));
+
+    default:
+      LOG(ERROR) << "Unexpected value type: " << value->GetType();
+      return v8::Null(isolate);
+  }
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Array(
+    v8::Isolate* isolate, const base::ListValue* val) const {
+  v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
+
+  for (size_t i = 0; i < val->GetSize(); ++i) {
+    const base::Value* child = NULL;
+    CHECK(val->Get(i, &child));
+
+    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, child);
+    CHECK(!child_v8.IsEmpty());
+
+    v8::TryCatch try_catch;
+    result->Set(static_cast<uint32_t>(i), child_v8);
+    if (try_catch.HasCaught())
+      LOG(ERROR) << "Setter for index " << i << " threw an exception.";
+  }
+
+  return result;
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Object(
+    v8::Isolate* isolate, const base::DictionaryValue* val) const {
+  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate);
+  result.SetHidden("simple", true);
+
+  for (base::DictionaryValue::Iterator iter(*val);
+       !iter.IsAtEnd(); iter.Advance()) {
+    const std::string& key = iter.key();
+    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, &iter.value());
+    CHECK(!child_v8.IsEmpty());
+
+    v8::TryCatch try_catch;
+    result.Set(key, child_v8);
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Setter for property " << key.c_str() << " threw an "
+                 << "exception.";
+    }
+  }
+
+  return result.GetHandle();
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToArrayBuffer(
+    v8::Isolate* isolate, const base::BinaryValue* value) const {
+  return node::Buffer::Copy(isolate,
+                            value->GetBuffer(),
+                            value->GetSize()).ToLocalChecked();
+}
+
+base::Value* V8ValueConverter::FromV8ValueImpl(
+    FromV8ValueState* state,
+    v8::Local<v8::Value> val,
+    v8::Isolate* isolate) const {
+  CHECK(!val.IsEmpty());
+
+  FromV8ValueState::Level state_level(state);
+  if (state->HasReachedMaxRecursionDepth())
+    return NULL;
+
+  if (val->IsNull())
+    return base::Value::CreateNullValue().release();
+
+  if (val->IsBoolean())
+    return new base::FundamentalValue(val->ToBoolean()->Value());
+
+  if (val->IsInt32())
+    return new base::FundamentalValue(val->ToInt32()->Value());
+
+  if (val->IsNumber())
+    return new base::FundamentalValue(val->ToNumber()->Value());
+
+  if (val->IsString()) {
+    v8::String::Utf8Value utf8(val->ToString());
+    return new base::StringValue(std::string(*utf8, utf8.length()));
+  }
+
+  if (val->IsUndefined())
+    // JSON.stringify ignores undefined.
+    return NULL;
+
+  if (val->IsDate()) {
+    v8::Date* date = v8::Date::Cast(*val);
+    v8::Local<v8::Value> toISOString =
+        date->Get(v8::String::NewFromUtf8(isolate, "toISOString"));
+    if (toISOString->IsFunction()) {
+      v8::Local<v8::Value> result =
+          toISOString.As<v8::Function>()->Call(val, 0, nullptr);
+      if (!result.IsEmpty()) {
+        v8::String::Utf8Value utf8(result->ToString());
+        return new base::StringValue(std::string(*utf8, utf8.length()));
+      }
+    }
+  }
+
+  if (val->IsRegExp()) {
+    if (!reg_exp_allowed_)
+      // JSON.stringify converts to an object.
+      return FromV8Object(val->ToObject(), state, isolate);
+    return new base::StringValue(*v8::String::Utf8Value(val->ToString()));
+  }
+
+  // v8::Value doesn't have a ToArray() method for some reason.
+  if (val->IsArray())
+    return FromV8Array(val.As<v8::Array>(), state, isolate);
+
+  if (val->IsFunction()) {
+    if (!function_allowed_)
+      // JSON.stringify refuses to convert function(){}.
+      return NULL;
+    return FromV8Object(val->ToObject(), state, isolate);
+  }
+
+  if (node::Buffer::HasInstance(val)) {
+    return FromNodeBuffer(val, state, isolate);
+  }
+
+  if (val->IsObject()) {
+    return FromV8Object(val->ToObject(), state, isolate);
+  }
+
+  LOG(ERROR) << "Unexpected v8 value type encountered.";
+  return NULL;
+}
+
+base::Value* V8ValueConverter::FromV8Array(
+    v8::Local<v8::Array> val,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  if (!state->UpdateAndCheckUniqueness(val))
+    return base::Value::CreateNullValue().release();
+
+  scoped_ptr<v8::Context::Scope> scope;
+  // If val was created in a different context than our current one, change to
+  // that context, but change back after val is converted.
+  if (!val->CreationContext().IsEmpty() &&
+      val->CreationContext() != isolate->GetCurrentContext())
+    scope.reset(new v8::Context::Scope(val->CreationContext()));
+
+  base::ListValue* result = new base::ListValue();
+
+  // Only fields with integer keys are carried over to the ListValue.
+  for (uint32_t i = 0; i < val->Length(); ++i) {
+    v8::TryCatch try_catch;
+    v8::Local<v8::Value> child_v8 = val->Get(i);
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Getter for index " << i << " threw an exception.";
+      child_v8 = v8::Null(isolate);
+    }
+
+    if (!val->HasRealIndexedProperty(i))
+      continue;
+
+    base::Value* child = FromV8ValueImpl(state, child_v8, isolate);
+    if (child)
+      result->Append(child);
+    else
+      // JSON.stringify puts null in places where values don't serialize, for
+      // example undefined and functions. Emulate that behavior.
+      result->Append(base::Value::CreateNullValue());
+  }
+  return result;
+}
+
+base::Value* V8ValueConverter::FromNodeBuffer(
+    v8::Local<v8::Value> value,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  return base::BinaryValue::CreateWithCopiedBuffer(
+      node::Buffer::Data(value), node::Buffer::Length(value));
+}
+
+base::Value* V8ValueConverter::FromV8Object(
+    v8::Local<v8::Object> val,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  if (!state->UpdateAndCheckUniqueness(val))
+    return base::Value::CreateNullValue().release();
+
+  scoped_ptr<v8::Context::Scope> scope;
+  // If val was created in a different context than our current one, change to
+  // that context, but change back after val is converted.
+  if (!val->CreationContext().IsEmpty() &&
+      val->CreationContext() != isolate->GetCurrentContext())
+    scope.reset(new v8::Context::Scope(val->CreationContext()));
+
+  scoped_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  v8::Local<v8::Array> property_names(val->GetOwnPropertyNames());
+
+  for (uint32_t i = 0; i < property_names->Length(); ++i) {
+    v8::Local<v8::Value> key(property_names->Get(i));
+
+    // Extend this test to cover more types as necessary and if sensible.
+    if (!key->IsString() &&
+        !key->IsNumber()) {
+      NOTREACHED() << "Key \"" << *v8::String::Utf8Value(key) << "\" "
+                      "is neither a string nor a number";
+      continue;
+    }
+
+    // Skip all callbacks: crbug.com/139933
+    if (val->HasRealNamedCallbackProperty(key->ToString()))
+      continue;
+
+    v8::String::Utf8Value name_utf8(key->ToString());
+
+    v8::TryCatch try_catch;
+    v8::Local<v8::Value> child_v8 = val->Get(key);
+
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Getter for property " << *name_utf8
+                 << " threw an exception.";
+      child_v8 = v8::Null(isolate);
+    }
+
+    scoped_ptr<base::Value> child(FromV8ValueImpl(state, child_v8, isolate));
+    if (!child.get())
+      // JSON.stringify skips properties whose values don't serialize, for
+      // example undefined and functions. Emulate that behavior.
+      continue;
+
+    // Strip null if asked (and since undefined is turned into null, undefined
+    // too). The use case for supporting this is JSON-schema support,
+    // specifically for extensions, where "optional" JSON properties may be
+    // represented as null, yet due to buggy legacy code elsewhere isn't
+    // treated as such (potentially causing crashes). For example, the
+    // "tabs.create" function takes an object as its first argument with an
+    // optional "windowId" property.
+    //
+    // Given just
+    //
+    //   tabs.create({})
+    //
+    // this will work as expected on code that only checks for the existence of
+    // a "windowId" property (such as that legacy code). However given
+    //
+    //   tabs.create({windowId: null})
+    //
+    // there *is* a "windowId" property, but since it should be an int, code
+    // on the browser which doesn't additionally check for null will fail.
+    // We can avoid all bugs related to this by stripping null.
+    if (strip_null_from_objects_ && child->IsType(base::Value::TYPE_NULL))
+      continue;
+
+    result->SetWithoutPathExpansion(std::string(*name_utf8, name_utf8.length()),
+                                    child.release());
+  }
+
+  return result.release();
+}
+
+}  // namespace electron
added in remote
  their  100644 9b1d76d15de1bd8354b4715b05c15a1ee64595c0 electron/common/native_mate_converters/v8_value_converter.h
@@ -0,0 +1,75 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "v8/include/v8.h"
+
+namespace base {
+class BinaryValue;
+class DictionaryValue;
+class ListValue;
+class Value;
+}
+
+namespace electron {
+
+class V8ValueConverter {
+ public:
+  V8ValueConverter();
+
+  void SetRegExpAllowed(bool val);
+  void SetFunctionAllowed(bool val);
+  void SetStripNullFromObjects(bool val);
+  v8::Local<v8::Value> ToV8Value(const base::Value* value,
+                                 v8::Local<v8::Context> context) const;
+  base::Value* FromV8Value(v8::Local<v8::Value> value,
+                           v8::Local<v8::Context> context) const;
+
+ private:
+  class FromV8ValueState;
+
+  v8::Local<v8::Value> ToV8ValueImpl(v8::Isolate* isolate,
+                                     const base::Value* value) const;
+  v8::Local<v8::Value> ToV8Array(v8::Isolate* isolate,
+                                 const base::ListValue* list) const;
+  v8::Local<v8::Value> ToV8Object(
+      v8::Isolate* isolate,
+      const base::DictionaryValue* dictionary) const;
+  v8::Local<v8::Value> ToArrayBuffer(
+      v8::Isolate* isolate,
+      const base::BinaryValue* value) const;
+
+  base::Value* FromV8ValueImpl(FromV8ValueState* state,
+                               v8::Local<v8::Value> value,
+                               v8::Isolate* isolate) const;
+  base::Value* FromV8Array(v8::Local<v8::Array> array,
+                           FromV8ValueState* state,
+                           v8::Isolate* isolate) const;
+  base::Value* FromNodeBuffer(v8::Local<v8::Value> value,
+                              FromV8ValueState* state,
+                              v8::Isolate* isolate) const;
+  base::Value* FromV8Object(v8::Local<v8::Object> object,
+                            FromV8ValueState* state,
+                            v8::Isolate* isolate) const;
+
+  // If true, we will convert RegExp JavaScript objects to string.
+  bool reg_exp_allowed_;
+
+  // If true, we will convert Function JavaScript objects to dictionaries.
+  bool function_allowed_;
+
+  // If true, undefined and null values are ignored when converting v8 objects
+  // into Values.
+  bool strip_null_from_objects_;
+
+  DISALLOW_COPY_AND_ASSIGN(V8ValueConverter);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
added in remote
  their  100644 25689927d9c4edaf1229ddbf424b94e9461a886e electron/common/native_mate_converters/value_converter.cc
@@ -0,0 +1,54 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/value_converter.h"
+
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+#include "base/values.h"
+
+namespace mate {
+
+bool Converter<base::DictionaryValue>::FromV8(v8::Isolate* isolate,
+                                              v8::Local<v8::Value> val,
+                                              base::DictionaryValue* out) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  scoped_ptr<base::Value> value(converter->FromV8Value(
+      val, isolate->GetCurrentContext()));
+  if (value && value->IsType(base::Value::TYPE_DICTIONARY)) {
+    out->Swap(static_cast<base::DictionaryValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::DictionaryValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::DictionaryValue& val) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  return converter->ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+bool Converter<base::ListValue>::FromV8(v8::Isolate* isolate,
+                                        v8::Local<v8::Value> val,
+                                        base::ListValue* out) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  scoped_ptr<base::Value> value(converter->FromV8Value(
+      val, isolate->GetCurrentContext()));
+  if (value->IsType(base::Value::TYPE_LIST)) {
+    out->Swap(static_cast<base::ListValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::ListValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::ListValue& val) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  return converter->ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+}  // namespace mate
added in remote
  their  100644 661cbcc37968bc47994e95f64d66c8cbc2110af7 electron/common/native_mate_converters/value_converter.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace base {
+class DictionaryValue;
+class ListValue;
+}
+
+namespace mate {
+
+template<>
+struct Converter<base::DictionaryValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::DictionaryValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::DictionaryValue& val);
+};
+
+template<>
+struct Converter<base::ListValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::ListValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::ListValue& val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
added in remote
  their  100644 eb5f2255261f0d185291279482eda55548167426 electron/common/node_bindings.cc
@@ -0,0 +1,272 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/api/locker.h"
+#include "electron/common/electron_command_line.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/command_line.h"
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/message_loop/message_loop.h"
+#include "base/path_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/content_paths.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+using content::BrowserThread;
+
+// Force all builtin modules to be referenced so they can actually run their
+// DSO constructors, see http://git.io/DRIqCg.
+#define REFERENCE_MODULE(name) \
+  extern "C" void _register_ ## name(void); \
+  void (*fp_register_ ## name)(void) = _register_ ## name
+// Electron's builtin modules.
+REFERENCE_MODULE(electron_browser_app);
+REFERENCE_MODULE(electron_browser_auto_updater);
+REFERENCE_MODULE(electron_browser_content_tracing);
+REFERENCE_MODULE(electron_browser_dialog);
+REFERENCE_MODULE(electron_browser_debugger);
+REFERENCE_MODULE(electron_browser_desktop_capturer);
+REFERENCE_MODULE(electron_browser_download_item);
+REFERENCE_MODULE(electron_browser_menu);
+REFERENCE_MODULE(electron_browser_power_monitor);
+REFERENCE_MODULE(electron_browser_power_save_blocker);
+REFERENCE_MODULE(electron_browser_protocol);
+REFERENCE_MODULE(electron_browser_global_shortcut);
+REFERENCE_MODULE(electron_browser_session);
+REFERENCE_MODULE(electron_browser_tray);
+REFERENCE_MODULE(electron_browser_web_contents);
+REFERENCE_MODULE(electron_browser_web_view_manager);
+REFERENCE_MODULE(electron_browser_window);
+REFERENCE_MODULE(electron_common_asar);
+REFERENCE_MODULE(electron_common_clipboard);
+REFERENCE_MODULE(electron_common_crash_reporter);
+REFERENCE_MODULE(electron_common_id_weak_map);
+REFERENCE_MODULE(electron_common_native_image);
+REFERENCE_MODULE(electron_common_screen);
+REFERENCE_MODULE(electron_common_shell);
+REFERENCE_MODULE(electron_common_v8_util);
+REFERENCE_MODULE(electron_renderer_ipc);
+REFERENCE_MODULE(electron_renderer_web_frame);
+#undef REFERENCE_MODULE
+
+// The "v8::Function::kLineOffsetNotFound" is exported in node.dll, but the
+// linker can not find it, could be a bug of VS.
+#if defined(OS_WIN) && !defined(DEBUG)
+namespace v8 {
+const int Function::kLineOffsetNotFound = -1;
+}
+#endif
+
+namespace electron {
+
+namespace {
+
+// Empty callback for async handle.
+void UvNoOp(uv_async_t* handle) {
+}
+
+// Convert the given vector to an array of C-strings. The strings in the
+// returned vector are only guaranteed valid so long as the vector of strings
+// is not modified.
+scoped_ptr<const char*[]> StringVectorToArgArray(
+    const std::vector<std::string>& vector) {
+  scoped_ptr<const char*[]> array(new const char*[vector.size()]);
+  for (size_t i = 0; i < vector.size(); ++i) {
+    array[i] = vector[i].c_str();
+  }
+  return array;
+}
+
+base::FilePath GetResourcesPath(bool is_browser) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  base::FilePath exec_path(command_line->GetProgram());
+  PathService::Get(base::FILE_EXE, &exec_path);
+
+  base::FilePath resources_path =
+#if defined(OS_MACOSX)
+      is_browser ? exec_path.DirName().DirName().Append("Resources") :
+                   exec_path.DirName().DirName().DirName().DirName().DirName()
+                            .Append("Resources");
+#else
+      exec_path.DirName().Append(FILE_PATH_LITERAL("resources"));
+#endif
+  return resources_path;
+}
+
+}  // namespace
+
+NodeBindings::NodeBindings(bool is_browser)
+    : is_browser_(is_browser),
+      message_loop_(nullptr),
+      uv_loop_(uv_default_loop()),
+      embed_closed_(false),
+      uv_env_(nullptr),
+      weak_factory_(this) {
+}
+
+NodeBindings::~NodeBindings() {
+  // Quit the embed thread.
+  embed_closed_ = true;
+  uv_sem_post(&embed_sem_);
+  WakeupEmbedThread();
+
+  // Wait for everything to be done.
+  uv_thread_join(&embed_thread_);
+
+  // Clear uv.
+  uv_sem_destroy(&embed_sem_);
+}
+
+void NodeBindings::Initialize() {
+  // Open node's error reporting system for browser process.
+  node::g_standalone_mode = is_browser_;
+  node::g_upstream_node_mode = false;
+
+#if defined(OS_LINUX)
+  // Get real command line in renderer process forked by zygote.
+  if (!is_browser_)
+    ElectronCommandLine::InitializeFromCommandLine();
+#endif
+
+  // Init node.
+  // (we assume node::Init would not modify the parameters under embedded mode).
+  node::Init(nullptr, nullptr, nullptr, nullptr);
+
+#if defined(OS_WIN)
+  // uv_init overrides error mode to suppress the default crash dialog, bring
+  // it back if user wants to show it.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (env->HasVar("ELECTRON_DEFAULT_ERROR_MODE"))
+    SetErrorMode(0);
+#endif
+}
+
+node::Environment* NodeBindings::CreateEnvironment(
+    v8::Handle<v8::Context> context) {
+  auto args = ElectronCommandLine::argv();
+
+  // Feed node the path to initialization script.
+  base::FilePath::StringType process_type = is_browser_ ?
+      FILE_PATH_LITERAL("browser") : FILE_PATH_LITERAL("renderer");
+  base::FilePath resources_path = GetResourcesPath(is_browser_);
+  base::FilePath script_path =
+      resources_path.Append(FILE_PATH_LITERAL("electron.asar"))
+                    .Append(process_type)
+                    .Append(FILE_PATH_LITERAL("init.js"));
+  std::string script_path_str = script_path.AsUTF8Unsafe();
+  args.insert(args.begin() + 1, script_path_str.c_str());
+
+  scoped_ptr<const char*[]> c_argv = StringVectorToArgArray(args);
+  node::Environment* env = node::CreateEnvironment(
+      context->GetIsolate(), uv_default_loop(), context,
+      args.size(), c_argv.get(), 0, nullptr);
+
+  mate::Dictionary process(context->GetIsolate(), env->process_object());
+  process.Set("type", process_type);
+  process.Set("resourcesPath", resources_path);
+  // The path to helper app.
+  base::FilePath helper_exec_path;
+  PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);
+  process.Set("helperExecPath", helper_exec_path);
+  return env;
+}
+
+void NodeBindings::LoadEnvironment(node::Environment* env) {
+  node::LoadEnvironment(env);
+  mate::EmitEvent(env->isolate(), env->process_object(), "loaded");
+}
+
+void NodeBindings::PrepareMessageLoop() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // Add dummy handle for libuv, otherwise libuv would quit when there is
+  // nothing to do.
+  uv_async_init(uv_loop_, &dummy_uv_handle_, UvNoOp);
+
+  // Start worker that will interrupt main loop when having uv events.
+  uv_sem_init(&embed_sem_, 0);
+  uv_thread_create(&embed_thread_, EmbedThreadRunner, this);
+}
+
+void NodeBindings::RunMessageLoop() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // The MessageLoop should have been created, remember the one in main thread.
+  message_loop_ = base::MessageLoop::current();
+
+  // Run uv loop for once to give the uv__io_poll a chance to add all events.
+  UvRunOnce();
+}
+
+void NodeBindings::UvRunOnce() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  node::Environment* env = uv_env();
+  CHECK(env);
+
+  // Use Locker in browser process.
+  mate::Locker locker(env->isolate());
+  v8::HandleScope handle_scope(env->isolate());
+
+  // Enter node context while dealing with uv events.
+  v8::Context::Scope context_scope(env->context());
+
+  // Perform microtask checkpoint after running JavaScript.
+  scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+      is_browser_ ? nullptr : new blink::WebScopedRunV8Script);
+
+  // Deal with uv events.
+  int r = uv_run(uv_loop_, UV_RUN_NOWAIT);
+  if (r == 0 || uv_loop_->stop_flag != 0)
+    message_loop_->QuitWhenIdle();  // Quit from uv.
+
+  // Tell the worker thread to continue polling.
+  uv_sem_post(&embed_sem_);
+}
+
+void NodeBindings::WakeupMainThread() {
+  DCHECK(message_loop_);
+  message_loop_->PostTask(FROM_HERE, base::Bind(&NodeBindings::UvRunOnce,
+                                                weak_factory_.GetWeakPtr()));
+}
+
+void NodeBindings::WakeupEmbedThread() {
+  uv_async_send(&dummy_uv_handle_);
+}
+
+// static
+void NodeBindings::EmbedThreadRunner(void *arg) {
+  NodeBindings* self = static_cast<NodeBindings*>(arg);
+
+  while (true) {
+    // Wait for the main loop to deal with events.
+    uv_sem_wait(&self->embed_sem_);
+    if (self->embed_closed_)
+      break;
+
+    // Wait for something to happen in uv loop.
+    // Note that the PollEvents() is implemented by derived classes, so when
+    // this class is being destructed the PollEvents() would not be available
+    // anymore. Because of it we must make sure we only invoke PollEvents()
+    // when this class is alive.
+    self->PollEvents();
+    if (self->embed_closed_)
+      break;
+
+    // Deal with event in main thread.
+    self->WakeupMainThread();
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 39f471883b143caab1502d04157ace731128b74a electron/common/node_bindings.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_H_
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "v8/include/v8.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace base {
+class MessageLoop;
+}
+
+namespace node {
+class Environment;
+}
+
+namespace electron {
+
+class NodeBindings {
+ public:
+  static NodeBindings* Create(bool is_browser);
+
+  virtual ~NodeBindings();
+
+  // Setup V8, libuv.
+  void Initialize();
+
+  // Create the environment and load node.js.
+  node::Environment* CreateEnvironment(v8::Handle<v8::Context> context);
+
+  // Load node.js in the environment.
+  void LoadEnvironment(node::Environment* env);
+
+  // Prepare for message loop integration.
+  void PrepareMessageLoop();
+
+  // Do message loop integration.
+  virtual void RunMessageLoop();
+
+  // Gets/sets the environment to wrap uv loop.
+  void set_uv_env(node::Environment* env) { uv_env_ = env; }
+  node::Environment* uv_env() const { return uv_env_; }
+
+ protected:
+  explicit NodeBindings(bool is_browser);
+
+  // Called to poll events in new thread.
+  virtual void PollEvents() = 0;
+
+  // Run the libuv loop for once.
+  void UvRunOnce();
+
+  // Make the main thread run libuv loop.
+  void WakeupMainThread();
+
+  // Interrupt the PollEvents.
+  void WakeupEmbedThread();
+
+  // Are we running in browser.
+  bool is_browser_;
+
+  // Main thread's MessageLoop.
+  base::MessageLoop* message_loop_;
+
+  // Main thread's libuv loop.
+  uv_loop_t* uv_loop_;
+
+ private:
+  // Thread to poll uv events.
+  static void EmbedThreadRunner(void *arg);
+
+  // Whether the libuv loop has ended.
+  bool embed_closed_;
+
+  // Dummy handle to make uv's loop not quit.
+  uv_async_t dummy_uv_handle_;
+
+  // Thread for polling events.
+  uv_thread_t embed_thread_;
+
+  // Semaphore to wait for main loop in the embed thread.
+  uv_sem_t embed_sem_;
+
+  // Environment that to wrap the uv loop.
+  node::Environment* uv_env_;
+
+  base::WeakPtrFactory<NodeBindings> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindings);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_H_
added in remote
  their  100644 9c3e4f7606e94203b044e099a96bcdd005de1b10 electron/common/node_bindings_linux.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_linux.h"
+
+#include <sys/epoll.h>
+
+namespace electron {
+
+NodeBindingsLinux::NodeBindingsLinux(bool is_browser)
+    : NodeBindings(is_browser),
+      epoll_(epoll_create(1)) {
+  int backend_fd = uv_backend_fd(uv_loop_);
+  struct epoll_event ev = { 0 };
+  ev.events = EPOLLIN;
+  ev.data.fd = backend_fd;
+  epoll_ctl(epoll_, EPOLL_CTL_ADD, backend_fd, &ev);
+}
+
+NodeBindingsLinux::~NodeBindingsLinux() {
+}
+
+void NodeBindingsLinux::RunMessageLoop() {
+  // Get notified when libuv's watcher queue changes.
+  uv_loop_->data = this;
+  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
+
+  NodeBindings::RunMessageLoop();
+}
+
+// static
+void NodeBindingsLinux::OnWatcherQueueChanged(uv_loop_t* loop) {
+  NodeBindingsLinux* self = static_cast<NodeBindingsLinux*>(loop->data);
+
+  // We need to break the io polling in the epoll thread when loop's watcher
+  // queue changes, otherwise new events cannot be notified.
+  self->WakeupEmbedThread();
+}
+
+void NodeBindingsLinux::PollEvents() {
+  int timeout = uv_backend_timeout(uv_loop_);
+
+  // Wait for new libuv events.
+  int r;
+  do {
+    struct epoll_event ev;
+    r = epoll_wait(epoll_, &ev, 1, timeout);
+  } while (r == -1 && errno == EINTR);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsLinux(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 b2e77d1aeaa894f97273b8eec7f63e3492f1178d electron/common/node_bindings_linux.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
+
+#include "base/compiler_specific.h"
+#include "electron/common/node_bindings.h"
+
+namespace electron {
+
+class NodeBindingsLinux : public NodeBindings {
+ public:
+  explicit NodeBindingsLinux(bool is_browser);
+  virtual ~NodeBindingsLinux();
+
+  void RunMessageLoop() override;
+
+ private:
+  // Called when uv's watcher queue changes.
+  static void OnWatcherQueueChanged(uv_loop_t* loop);
+
+  void PollEvents() override;
+
+  // Epoll to poll for uv's backend fd.
+  int epoll_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsLinux);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
added in remote
  their  100644 fce1852f2946aa2533a559c1c465f0dbaa7a97d8 electron/common/node_bindings_mac.cc
@@ -0,0 +1,68 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_mac.h"
+
+#include <errno.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+NodeBindingsMac::NodeBindingsMac(bool is_browser)
+    : NodeBindings(is_browser),
+      kqueue_(kqueue()) {
+  // Add uv's backend fd to kqueue.
+  struct kevent ev;
+  EV_SET(&ev, uv_backend_fd(uv_loop_), EVFILT_READ, EV_ADD | EV_ENABLE,
+         0, 0, 0);
+  kevent(kqueue_, &ev, 1, NULL, 0, NULL);
+}
+
+NodeBindingsMac::~NodeBindingsMac() {
+}
+
+void NodeBindingsMac::RunMessageLoop() {
+  // Get notified when libuv's watcher queue changes.
+  uv_loop_->data = this;
+  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
+
+  NodeBindings::RunMessageLoop();
+}
+
+// static
+void NodeBindingsMac::OnWatcherQueueChanged(uv_loop_t* loop) {
+  NodeBindingsMac* self = static_cast<NodeBindingsMac*>(loop->data);
+
+  // We need to break the io polling in the kqueue thread when loop's watcher
+  // queue changes, otherwise new events cannot be notified.
+  self->WakeupEmbedThread();
+}
+
+void NodeBindingsMac::PollEvents() {
+  struct timespec spec;
+  int timeout = uv_backend_timeout(uv_loop_);
+  if (timeout != -1) {
+    spec.tv_sec = timeout / 1000;
+    spec.tv_nsec = (timeout % 1000) * 1000000;
+  }
+
+  // Wait for new libuv events.
+  int r;
+  do {
+    struct kevent ev;
+    r = ::kevent(kqueue_, NULL, 0, &ev, 1,
+                 timeout == -1 ? NULL : &spec);
+  } while (r == -1 && errno == EINTR);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsMac(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 e4c8c7c11e1c2b75d9994f876c8f5d2fbce0a9a2 electron/common/node_bindings_mac.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
+
+#include "electron/common/node_bindings.h"
+#include "base/compiler_specific.h"
+
+namespace electron {
+
+class NodeBindingsMac : public NodeBindings {
+ public:
+  explicit NodeBindingsMac(bool is_browser);
+  virtual ~NodeBindingsMac();
+
+  void RunMessageLoop() override;
+
+ private:
+  // Called when uv's watcher queue changes.
+  static void OnWatcherQueueChanged(uv_loop_t* loop);
+
+  void PollEvents() override;
+
+  // Kqueue to poll for uv's backend fd.
+  int kqueue_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsMac);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
added in remote
  their  100644 ca0b40490c698ca833f109208c9ba5c533a0874d electron/common/node_bindings_win.cc
@@ -0,0 +1,52 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_win.h"
+
+#include <windows.h>
+
+#include "base/logging.h"
+
+extern "C" {
+#include "vendor/node/deps/uv/src/win/internal.h"
+}
+
+namespace electron {
+
+NodeBindingsWin::NodeBindingsWin(bool is_browser)
+    : NodeBindings(is_browser) {
+}
+
+NodeBindingsWin::~NodeBindingsWin() {
+}
+
+void NodeBindingsWin::PollEvents() {
+  // If there are other kinds of events pending, uv_backend_timeout will
+  // instruct us not to wait.
+  DWORD bytes, timeout;
+  ULONG_PTR key;
+  OVERLAPPED* overlapped;
+
+  timeout = uv_backend_timeout(uv_loop_);
+
+  GetQueuedCompletionStatus(uv_loop_->iocp,
+                            &bytes,
+                            &key,
+                            &overlapped,
+                            timeout);
+
+  // Give the event back so libuv can deal with it.
+  if (overlapped != NULL)
+    PostQueuedCompletionStatus(uv_loop_->iocp,
+                               bytes,
+                               key,
+                               overlapped);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsWin(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 c6599fe682c3bbc91abb6c619bce46605ca7a747 electron/common/node_bindings_win.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
+
+#include "electron/common/node_bindings.h"
+#include "base/compiler_specific.h"
+
+namespace electron {
+
+class NodeBindingsWin : public NodeBindings {
+ public:
+  explicit NodeBindingsWin(bool is_browser);
+  virtual ~NodeBindingsWin();
+
+ private:
+  void PollEvents() override;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsWin);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
added in remote
  their  100644 57c82cb5ba4555bd957f764656fd2c9964703111 electron/common/node_includes.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_INCLUDES_H_
+#define ELECTRON_COMMON_NODE_INCLUDES_H_
+
+#include "base/logging.h"
+
+// Include common headers for using node APIs.
+
+#define BUILDING_NODE_EXTENSION
+
+#undef ASSERT
+#undef CHECK
+#undef CHECK_EQ
+#undef CHECK_NE
+#undef CHECK_GE
+#undef CHECK_GT
+#undef CHECK_LE
+#undef CHECK_LT
+#undef DISALLOW_COPY_AND_ASSIGN
+#undef NO_RETURN
+#undef debug_string  // This is defined in OS X 10.9 SDK in AssertMacros.h.
+#include "vendor/node/src/env.h"
+#include "vendor/node/src/env-inl.h"
+#include "vendor/node/src/node.h"
+#include "vendor/node/src/node_buffer.h"
+#include "vendor/node/src/node_internals.h"
+
+#endif  // ELECTRON_COMMON_NODE_INCLUDES_H_
added in remote
  their  100644 1aa8c5e403f2468b076a0098532cb9e6d40ccff8 electron/common/options_switches.cc
@@ -0,0 +1,160 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/options_switches.h"
+
+namespace electron {
+
+namespace options {
+
+const char kTitle[]          = "title";
+const char kIcon[]           = "icon";
+const char kFrame[]          = "frame";
+const char kShow[]           = "show";
+const char kCenter[]         = "center";
+const char kX[]              = "x";
+const char kY[]              = "y";
+const char kWidth[]          = "width";
+const char kHeight[]         = "height";
+const char kMinWidth[]       = "minWidth";
+const char kMinHeight[]      = "minHeight";
+const char kMaxWidth[]       = "maxWidth";
+const char kMaxHeight[]      = "maxHeight";
+const char kResizable[]      = "resizable";
+const char kMovable[]        = "movable";
+const char kMinimizable[]    = "minimizable";
+const char kMaximizable[]    = "maximizable";
+const char kFullScreenable[] = "fullscreenable";
+const char kClosable[]       = "closable";
+const char kFullscreen[]     = "fullscreen";
+
+// Whether the window should show in taskbar.
+const char kSkipTaskbar[] = "skipTaskbar";
+
+// Start with the kiosk mode, see Opera's page for description:
+// http://www.opera.com/support/mastering/kiosk/
+const char kKiosk[] = "kiosk";
+
+// Make windows stays on the top of all other windows.
+const char kAlwaysOnTop[] = "alwaysOnTop";
+
+// Enable the NSView to accept first mouse event.
+const char kAcceptFirstMouse[] = "acceptFirstMouse";
+
+// Whether window size should include window frame.
+const char kUseContentSize[] = "useContentSize";
+
+// The requested title bar style for the window
+const char kTitleBarStyle[] = "titleBarStyle";
+
+// The menu bar is hidden unless "Alt" is pressed.
+const char kAutoHideMenuBar[] = "autoHideMenuBar";
+
+// Enable window to be resized larger than screen.
+const char kEnableLargerThanScreen[] = "enableLargerThanScreen";
+
+// Forces to use dark theme on Linux.
+const char kDarkTheme[] = "darkTheme";
+
+// Whether the window should be transparent.
+const char kTransparent[] = "transparent";
+
+// Window type hint.
+const char kType[] = "type";
+
+// Disable auto-hiding cursor.
+const char kDisableAutoHideCursor[] = "disableAutoHideCursor";
+
+// Use the OS X's standard window instead of the textured window.
+const char kStandardWindow[] = "standardWindow";
+
+// Default browser window background color.
+const char kBackgroundColor[] = "backgroundColor";
+
+// Whether the window should have a shadow.
+const char kHasShadow[] = "hasShadow";
+
+// The WebPreferences.
+const char kWebPreferences[] = "webPreferences";
+
+// The factor of which page should be zoomed.
+const char kZoomFactor[] = "zoomFactor";
+
+// Script that will be loaded by guest WebContents before other scripts.
+const char kPreloadScript[] = "preload";
+
+// Like --preload, but the passed argument is an URL.
+const char kPreloadURL[] = "preloadURL";
+
+// Enable the node integration.
+const char kNodeIntegration[] = "nodeIntegration";
+
+// Instancd ID of guest WebContents.
+const char kGuestInstanceID[] = "guestInstanceId";
+
+// Enable DirectWrite on Windows.
+const char kDirectWrite[] = "directWrite";
+
+// Web runtime features.
+const char kExperimentalFeatures[]       = "experimentalFeatures";
+const char kExperimentalCanvasFeatures[] = "experimentalCanvasFeatures";
+
+// Opener window's ID.
+const char kOpenerID[] = "openerId";
+
+// Enable blink features.
+const char kBlinkFeatures[] = "blinkFeatures";
+
+}  // namespace options
+
+namespace switches {
+
+// Enable plugins.
+const char kEnablePlugins[] = "enable-plugins";
+
+// Ppapi Flash path.
+const char kPpapiFlashPath[] = "ppapi-flash-path";
+
+// Ppapi Flash version.
+const char kPpapiFlashVersion[] = "ppapi-flash-version";
+
+// Path to client certificate.
+const char kClientCertificate[] = "client-certificate";
+
+// Disable HTTP cache.
+const char kDisableHttpCache[] = "disable-http-cache";
+
+// Register schemes to standard.
+const char kRegisterStandardSchemes[] = "register-standard-schemes";
+
+// Register schemes to handle service worker.
+const char kRegisterServiceWorkerSchemes[] = "register-service-worker-schemes";
+
+// The minimum SSL/TLS version ("tls1", "tls1.1", or "tls1.2") that
+// TLS fallback will accept.
+const char kSSLVersionFallbackMin[] = "ssl-version-fallback-min";
+
+// Comma-separated list of SSL cipher suites to disable.
+const char kCipherSuiteBlacklist[] = "cipher-suite-blacklist";
+
+// The browser process app model ID
+const char kAppUserModelId[] = "app-user-model-id";
+
+// The command line switch versions of the options.
+const char kZoomFactor[]                 = "zoom-factor";
+const char kPreloadScript[]              = "preload";
+const char kPreloadURL[]                 = "preload-url";
+const char kNodeIntegration[]            = "node-integration";
+const char kGuestInstanceID[]            = "guest-instance-id";
+const char kOpenerID[]                   = "opener-id";
+
+// Widevine options
+// Path to Widevine CDM binaries.
+const char kWidevineCdmPath[] = "widevine-cdm-path";
+// Widevine CDM version.
+const char kWidevineCdmVersion[] = "widevine-cdm-version";
+
+}  // namespace switches
+
+}  // namespace electron
added in remote
  their  100644 d7fee063f7e2fc2c07e725d1b05f79ec104e1187 electron/common/options_switches.h
@@ -0,0 +1,93 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_OPTIONS_SWITCHES_H_
+#define ELECTRON_COMMON_OPTIONS_SWITCHES_H_
+
+namespace electron {
+
+namespace options {
+
+extern const char kTitle[];
+extern const char kIcon[];
+extern const char kFrame[];
+extern const char kShow[];
+extern const char kCenter[];
+extern const char kX[];
+extern const char kY[];
+extern const char kWidth[];
+extern const char kHeight[];
+extern const char kMinWidth[];
+extern const char kMinHeight[];
+extern const char kMaxWidth[];
+extern const char kMaxHeight[];
+extern const char kResizable[];
+extern const char kMovable[];
+extern const char kMinimizable[];
+extern const char kMaximizable[];
+extern const char kFullScreenable[];
+extern const char kClosable[];
+extern const char kFullscreen[];
+extern const char kSkipTaskbar[];
+extern const char kKiosk[];
+extern const char kAlwaysOnTop[];
+extern const char kAcceptFirstMouse[];
+extern const char kUseContentSize[];
+extern const char kTitleBarStyle[];
+extern const char kAutoHideMenuBar[];
+extern const char kEnableLargerThanScreen[];
+extern const char kDarkTheme[];
+extern const char kTransparent[];
+extern const char kType[];
+extern const char kDisableAutoHideCursor[];
+extern const char kStandardWindow[];
+extern const char kBackgroundColor[];
+extern const char kHasShadow[];
+extern const char kWebPreferences[];
+
+// WebPreferences.
+extern const char kDirectWrite[];
+extern const char kZoomFactor[];
+extern const char kPreloadScript[];
+extern const char kPreloadURL[];
+extern const char kNodeIntegration[];
+extern const char kGuestInstanceID[];
+extern const char kExperimentalFeatures[];
+extern const char kExperimentalCanvasFeatures[];
+extern const char kOpenerID[];
+extern const char kBlinkFeatures[];
+
+}   // namespace options
+
+
+// Following are actually command line switches, should be moved to other files.
+
+namespace switches {
+
+extern const char kEnablePlugins[];
+extern const char kPpapiFlashPath[];
+extern const char kPpapiFlashVersion[];
+extern const char kClientCertificate[];
+extern const char kDisableHttpCache[];
+extern const char kRegisterStandardSchemes[];
+extern const char kRegisterServiceWorkerSchemes[];
+extern const char kSSLVersionFallbackMin[];
+extern const char kCipherSuiteBlacklist[];
+extern const char kAppUserModelId[];
+
+extern const char kZoomFactor[];
+extern const char kPreloadScript[];
+extern const char kPreloadURL[];
+extern const char kNodeIntegration[];
+extern const char kGuestInstanceID[];
+extern const char kOpenerID[];
+
+extern const char kWidevineCdmPath[];
+extern const char kWidevineCdmVersion[];
+
+}  // namespace switches
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_OPTIONS_SWITCHES_H_
added in remote
  their  100644 c06f74061cb24f97b6f8937cef2f6ac084d4388c electron/common/platform_util.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_PLATFORM_UTIL_H_
+#define ELECTRON_COMMON_PLATFORM_UTIL_H_
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace platform_util {
+
+// Show the given file in a file manager. If possible, select the file.
+// Must be called from the UI thread.
+void ShowItemInFolder(const base::FilePath& full_path);
+
+// Open the given file in the desktop's default manner.
+// Must be called from the UI thread.
+void OpenItem(const base::FilePath& full_path);
+
+// Open the given external protocol URL in the desktop's default manner.
+// (For example, mailto: URLs in the default mail user agent.)
+bool OpenExternal(const GURL& url, bool activate);
+
+// Move a file to trash.
+bool MoveItemToTrash(const base::FilePath& full_path);
+
+void Beep();
+
+}  // namespace platform_util
+
+#endif  // ELECTRON_COMMON_PLATFORM_UTIL_H_
added in remote
  their  100644 3a9f000c4a8cf579605ced3f0b47cd9ae4535b27 electron/common/platform_util_linux.cc
@@ -0,0 +1,87 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <stdio.h>
+
+#include "base/files/file_util.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "url/gurl.h"
+
+namespace {
+
+bool XDGUtil(const std::string& util, const std::string& arg) {
+  std::vector<std::string> argv;
+  argv.push_back(util);
+  argv.push_back(arg);
+
+  base::LaunchOptions options;
+  options.allow_new_privs = true;
+  // xdg-open can fall back on mailcap which eventually might plumb through
+  // to a command that needs a terminal.  Set the environment variable telling
+  // it that we definitely don't have a terminal available and that it should
+  // bring up a new terminal if necessary.  See "man mailcap".
+  options.environ["MM_NOTTTY"] = "1";
+
+  base::Process process = base::LaunchProcess(argv, options);
+  if (!process.IsValid())
+    return false;
+
+  int exit_code = -1;
+  if (!process.WaitForExit(&exit_code))
+    return false;
+
+  return (exit_code == 0);
+}
+
+bool XDGOpen(const std::string& path) {
+  return XDGUtil("xdg-open", path);
+}
+
+bool XDGEmail(const std::string& email) {
+  return XDGUtil("xdg-email", email);
+}
+
+}  // namespace
+
+namespace platform_util {
+
+// TODO(estade): It would be nice to be able to select the file in the file
+// manager, but that probably requires extending xdg-open. For now just
+// show the folder.
+void ShowItemInFolder(const base::FilePath& full_path) {
+  base::FilePath dir = full_path.DirName();
+  if (!base::DirectoryExists(dir))
+    return;
+
+  XDGOpen(dir.value());
+}
+
+void OpenItem(const base::FilePath& full_path) {
+  XDGOpen(full_path.value());
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  if (url.SchemeIs("mailto"))
+    return XDGEmail(url.spec());
+  else
+    return XDGOpen(url.spec());
+}
+
+bool MoveItemToTrash(const base::FilePath& full_path) {
+  return XDGUtil("gvfs-trash", full_path.value());
+}
+
+void Beep() {
+  // echo '\a' > /dev/console
+  FILE* console = fopen("/dev/console", "r");
+  if (console == NULL)
+    return;
+  fprintf(console, "\a");
+  fclose(console);
+}
+
+}  // namespace platform_util
added in remote
  their  100644 da6b6a80ac2a216d4a0726b2c99ef98595bc28b4 electron/common/platform_util_mac.mm
@@ -0,0 +1,166 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <Carbon/Carbon.h>
+#import <Cocoa/Cocoa.h>
+
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/mac/mac_logging.h"
+#include "base/mac/scoped_aedesc.h"
+#include "base/strings/sys_string_conversions.h"
+#include "net/base/mac/url_conversions.h"
+#include "url/gurl.h"
+
+namespace platform_util {
+
+void ShowItemInFolder(const base::FilePath& full_path) {
+  DCHECK([NSThread isMainThread]);
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  if (!path_string || ![[NSWorkspace sharedWorkspace] selectFile:path_string
+                                        inFileViewerRootedAtPath:@""])
+    LOG(WARNING) << "NSWorkspace failed to select file " << full_path.value();
+}
+
+// This function opens a file.  This doesn't use LaunchServices or NSWorkspace
+// because of two bugs:
+//  1. Incorrect app activation with com.apple.quarantine:
+//     http://crbug.com/32921
+//  2. Silent no-op for unassociated file types: http://crbug.com/50263
+// Instead, an AppleEvent is constructed to tell the Finder to open the
+// document.
+void OpenItem(const base::FilePath& full_path) {
+  DCHECK([NSThread isMainThread]);
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  if (!path_string)
+    return;
+
+  // Create the target of this AppleEvent, the Finder.
+  base::mac::ScopedAEDesc<AEAddressDesc> address;
+  const OSType finderCreatorCode = 'MACS';
+  OSErr status = AECreateDesc(typeApplSignature,  // type
+                              &finderCreatorCode,  // data
+                              sizeof(finderCreatorCode),  // dataSize
+                              address.OutPointer());  // result
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE target";
+    return;
+  }
+
+  // Build the AppleEvent data structure that instructs Finder to open files.
+  base::mac::ScopedAEDesc<AppleEvent> theEvent;
+  status = AECreateAppleEvent(kCoreEventClass,  // theAEEventClass
+                              kAEOpenDocuments,  // theAEEventID
+                              address,  // target
+                              kAutoGenerateReturnID,  // returnID
+                              kAnyTransactionID,  // transactionID
+                              theEvent.OutPointer());  // result
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE event";
+    return;
+  }
+
+  // Create the list of files (only ever one) to open.
+  base::mac::ScopedAEDesc<AEDescList> fileList;
+  status = AECreateList(NULL,  // factoringPtr
+                        0,  // factoredSize
+                        false,  // isRecord
+                        fileList.OutPointer());  // resultList
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE file list";
+    return;
+  }
+
+  // Add the single path to the file list.  C-style cast to avoid both a
+  // static_cast and a const_cast to get across the toll-free bridge.
+  CFURLRef pathURLRef = (CFURLRef)[NSURL fileURLWithPath:path_string];
+  FSRef pathRef;
+  if (CFURLGetFSRef(pathURLRef, &pathRef)) {
+    status = AEPutPtr(fileList.OutPointer(),  // theAEDescList
+                      0,  // index
+                      typeFSRef,  // typeCode
+                      &pathRef,  // dataPtr
+                      sizeof(pathRef));  // dataSize
+    if (status != noErr) {
+      OSSTATUS_LOG(WARNING, status)
+          << "Could not add file path to AE list in OpenItem()";
+      return;
+    }
+  } else {
+    LOG(WARNING) << "Could not get FSRef for path URL in OpenItem()";
+    return;
+  }
+
+  // Attach the file list to the AppleEvent.
+  status = AEPutParamDesc(theEvent.OutPointer(),  // theAppleEvent
+                          keyDirectObject,  // theAEKeyword
+                          fileList);  // theAEDesc
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status)
+        << "Could not put the AE file list the path in OpenItem()";
+    return;
+  }
+
+  // Send the actual event.  Do not care about the reply.
+  base::mac::ScopedAEDesc<AppleEvent> reply;
+  status = AESend(theEvent,  // theAppleEvent
+                  reply.OutPointer(),  // reply
+                  kAENoReply + kAEAlwaysInteract,  // sendMode
+                  kAENormalPriority,  // sendPriority
+                  kAEDefaultTimeout,  // timeOutInTicks
+                  NULL, // idleProc
+                  NULL);  // filterProc
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status)
+        << "Could not send AE to Finder in OpenItem()";
+  }
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  DCHECK([NSThread isMainThread]);
+  NSURL* ns_url = net::NSURLWithGURL(url);
+  if (!ns_url) {
+    return false;
+  }
+
+  CFURLRef openingApp = NULL;
+  OSStatus status = LSGetApplicationForURL((CFURLRef)ns_url,
+                                           kLSRolesAll,
+                                           NULL,
+                                           &openingApp);
+  if (status != noErr) {
+    return false;
+  }
+  CFRelease(openingApp);  // NOT A BUG; LSGetApplicationForURL retains for us
+
+  NSUInteger launchOptions = NSWorkspaceLaunchDefault;
+  if (!activate)
+    launchOptions |= NSWorkspaceLaunchWithoutActivation;
+
+  return [[NSWorkspace sharedWorkspace] openURLs: @[ns_url]
+                                        withAppBundleIdentifier: nil
+                                        options: launchOptions
+                                        additionalEventParamDescriptor: NULL
+                                        launchIdentifiers: NULL];
+}
+
+bool MoveItemToTrash(const base::FilePath& full_path) {
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  BOOL status = [[NSFileManager defaultManager]
+                trashItemAtURL:[NSURL fileURLWithPath:path_string]
+                resultingItemURL:nil
+                error:nil];
+  if (!path_string || !status)
+    LOG(WARNING) << "NSWorkspace failed to move file " << full_path.value()
+                 << " to trash";
+  return status;
+}
+
+void Beep() {
+  NSBeep();
+}
+
+}  // namespace platform_util
added in remote
  their  100644 baf691a4f737f40009b881721145b544d96d3f6f electron/common/platform_util_win.cc
@@ -0,0 +1,392 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <windows.h>
+#include <atlbase.h>
+#include <commdlg.h>
+#include <comdef.h>
+#include <dwmapi.h>
+#include <shellapi.h>
+#include <shlobj.h>
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/registry.h"
+#include "base/win/scoped_co_mem.h"
+#include "base/win/scoped_com_initializer.h"
+#include "base/win/scoped_comptr.h"
+#include "base/win/windows_version.h"
+#include "url/gurl.h"
+#include "ui/base/win/shell.h"
+
+namespace {
+
+// Old ShellExecute crashes the process when the command for a given scheme
+// is empty. This function tells if it is.
+bool ValidateShellCommandForScheme(const std::string& scheme) {
+  base::win::RegKey key;
+  base::string16 registry_path = base::ASCIIToUTF16(scheme) +
+                                 L"\\shell\\open\\command";
+  key.Open(HKEY_CLASSES_ROOT, registry_path.c_str(), KEY_READ);
+  if (!key.Valid())
+    return false;
+  DWORD size = 0;
+  key.ReadValue(NULL, NULL, &size, NULL);
+  if (size <= 2)
+    return false;
+  return true;
+}
+
+// Required COM implementation of IFileOperationProgressSink so we can
+// precheck files before deletion to make sure they can be move to the
+// Recycle Bin.
+class DeleteFileProgressSink : public IFileOperationProgressSink {
+ public:
+  DeleteFileProgressSink();
+
+ private:
+  ULONG STDMETHODCALLTYPE AddRef(void);
+  ULONG STDMETHODCALLTYPE Release(void);
+  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
+  HRESULT STDMETHODCALLTYPE StartOperations(void);
+  HRESULT STDMETHODCALLTYPE FinishOperations(HRESULT);
+  HRESULT STDMETHODCALLTYPE PreRenameItem(
+      DWORD, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostRenameItem(
+      DWORD, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreMoveItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostMoveItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreCopyItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostCopyItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreDeleteItem(DWORD, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PostDeleteItem(
+      DWORD, IShellItem*, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreNewItem(
+      DWORD, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostNewItem(
+      DWORD, IShellItem*, LPCWSTR, LPCWSTR, DWORD, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE UpdateProgress(UINT, UINT);
+  HRESULT STDMETHODCALLTYPE ResetTimer(void);
+  HRESULT STDMETHODCALLTYPE PauseTimer(void);
+  HRESULT STDMETHODCALLTYPE ResumeTimer(void);
+
+  ULONG m_cRef;
+};
+
+DeleteFileProgressSink::DeleteFileProgressSink() {
+  m_cRef = 0;
+}
+
+HRESULT DeleteFileProgressSink::PreDeleteItem(DWORD dwFlags, IShellItem*) {
+  if (!(dwFlags & TSF_DELETE_RECYCLE_IF_POSSIBLE)) {
+    // TSF_DELETE_RECYCLE_IF_POSSIBLE will not be set for items that cannot be
+    // recycled.  In this case, we abort the delete operation.  This bubbles
+    // up and stops the Delete in IFileOperation.
+    return E_ABORT;
+  }
+  // Returns S_OK if successful, or an error value otherwise. In the case of an
+  // error value, the delete operation and all subsequent operations pending
+  // from the call to IFileOperation are canceled.
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::QueryInterface(REFIID riid, LPVOID* ppvObj) {
+  // Always set out parameter to NULL, validating it first.
+  if (!ppvObj)
+    return E_INVALIDARG;
+  *ppvObj = nullptr;
+  if (riid == IID_IUnknown || riid == IID_IFileOperationProgressSink) {
+    // Increment the reference count and return the pointer.
+    *ppvObj = reinterpret_cast<IUnknown*>(this);
+    AddRef();
+    return NOERROR;
+  }
+  return E_NOINTERFACE;
+}
+
+ULONG DeleteFileProgressSink::AddRef() {
+  InterlockedIncrement(&m_cRef);
+  return m_cRef;
+}
+
+ULONG DeleteFileProgressSink::Release() {
+  // Decrement the object's internal counter.
+  ULONG ulRefCount = InterlockedDecrement(&m_cRef);
+  if (0 == m_cRef) {
+    delete this;
+  }
+  return ulRefCount;
+}
+
+HRESULT DeleteFileProgressSink::StartOperations() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::FinishOperations(HRESULT) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PreRenameItem(DWORD, IShellItem*, LPCWSTR) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PostRenameItem(
+    DWORD, IShellItem*, __RPC__in_string LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PreMoveItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostMoveItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PreCopyItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostCopyItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostDeleteItem(
+    DWORD, IShellItem*, HRESULT, IShellItem*) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PreNewItem(
+    DWORD dwFlags, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostNewItem(
+    DWORD, IShellItem*, LPCWSTR, LPCWSTR, DWORD, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::UpdateProgress(UINT, UINT) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::ResetTimer() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PauseTimer() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::ResumeTimer() {
+  return S_OK;
+}
+
+}  // namespace
+
+namespace platform_util {
+
+void ShowItemInFolder(const base::FilePath& full_path) {
+  base::win::ScopedCOMInitializer com_initializer;
+  if (!com_initializer.succeeded())
+    return;
+
+  base::FilePath dir = full_path.DirName().AsEndingWithSeparator();
+  // ParseDisplayName will fail if the directory is "C:", it must be "C:\\".
+  if (dir.empty())
+    return;
+
+  typedef HRESULT (WINAPI *SHOpenFolderAndSelectItemsFuncPtr)(
+      PCIDLIST_ABSOLUTE pidl_Folder,
+      UINT cidl,
+      PCUITEMID_CHILD_ARRAY pidls,
+      DWORD flags);
+
+  static SHOpenFolderAndSelectItemsFuncPtr open_folder_and_select_itemsPtr =
+    NULL;
+  static bool initialize_open_folder_proc = true;
+  if (initialize_open_folder_proc) {
+    initialize_open_folder_proc = false;
+    // The SHOpenFolderAndSelectItems API is exposed by shell32 version 6
+    // and does not exist in Win2K. We attempt to retrieve this function export
+    // from shell32 and if it does not exist, we just invoke ShellExecute to
+    // open the folder thus losing the functionality to select the item in
+    // the process.
+    HMODULE shell32_base = GetModuleHandle(L"shell32.dll");
+    if (!shell32_base) {
+      NOTREACHED() << " " << __FUNCTION__ << "(): Can't open shell32.dll";
+      return;
+    }
+    open_folder_and_select_itemsPtr =
+        reinterpret_cast<SHOpenFolderAndSelectItemsFuncPtr>
+            (GetProcAddress(shell32_base, "SHOpenFolderAndSelectItems"));
+  }
+  if (!open_folder_and_select_itemsPtr) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  base::win::ScopedComPtr<IShellFolder> desktop;
+  HRESULT hr = SHGetDesktopFolder(desktop.Receive());
+  if (FAILED(hr))
+    return;
+
+  base::win::ScopedCoMem<ITEMIDLIST> dir_item;
+  hr = desktop->ParseDisplayName(NULL, NULL,
+                                 const_cast<wchar_t *>(dir.value().c_str()),
+                                 NULL, &dir_item, NULL);
+  if (FAILED(hr)) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  base::win::ScopedCoMem<ITEMIDLIST> file_item;
+  hr = desktop->ParseDisplayName(NULL, NULL,
+      const_cast<wchar_t *>(full_path.value().c_str()),
+      NULL, &file_item, NULL);
+  if (FAILED(hr)) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  const ITEMIDLIST* highlight[] = { file_item };
+
+  hr = (*open_folder_and_select_itemsPtr)(dir_item, arraysize(highlight),
+                                          highlight, NULL);
+
+  if (FAILED(hr)) {
+    // On some systems, the above call mysteriously fails with "file not
+    // found" even though the file is there.  In these cases, ShellExecute()
+    // seems to work as a fallback (although it won't select the file).
+    if (hr == ERROR_FILE_NOT_FOUND) {
+      ui::win::OpenFolderViaShell(dir);
+    } else {
+      LPTSTR message = NULL;
+      DWORD message_length = FormatMessage(
+          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+          0, hr, 0, reinterpret_cast<LPTSTR>(&message), 0, NULL);
+      LOG(WARNING) << " " << __FUNCTION__
+                   << "(): Can't open full_path = \""
+                   << full_path.value() << "\""
+                   << " hr = " << hr
+                   << " " << reinterpret_cast<LPTSTR>(&message);
+      if (message)
+        LocalFree(message);
+
+      ui::win::OpenFolderViaShell(dir);
+    }
+  }
+}
+
+void OpenItem(const base::FilePath& full_path) {
+  if (base::DirectoryExists(full_path))
+    ui::win::OpenFolderViaShell(full_path);
+  else
+    ui::win::OpenFileViaShell(full_path);
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  // Quote the input scheme to be sure that the command does not have
+  // parameters unexpected by the external program. This url should already
+  // have been escaped.
+  std::string escaped_url = url.spec();
+  escaped_url.insert(0, "\"");
+  escaped_url += "\"";
+
+  // According to Mozilla in uriloader/exthandler/win/nsOSHelperAppService.cpp:
+  // "Some versions of windows (Win2k before SP3, Win XP before SP1) crash in
+  // ShellExecute on long URLs (bug 161357 on bugzilla.mozilla.org). IE 5 and 6
+  // support URLS of 2083 chars in length, 2K is safe."
+  const size_t kMaxURLLength = 2048;
+  if (escaped_url.length() > kMaxURLLength) {
+    NOTREACHED();
+    return false;
+  }
+
+  if (base::win::GetVersion() < base::win::VERSION_WIN7) {
+    if (!ValidateShellCommandForScheme(url.scheme()))
+      return false;
+  }
+
+  if (reinterpret_cast<ULONG_PTR>(ShellExecuteA(NULL, "open",
+                                                escaped_url.c_str(), NULL, NULL,
+                                                SW_SHOWNORMAL)) <= 32) {
+    // We fail to execute the call. We could display a message to the user.
+    // TODO(nsylvain): we should also add a dialog to warn on errors. See
+    // bug 1136923.
+    return false;
+  }
+  return true;
+}
+
+bool MoveItemToTrash(const base::FilePath& path) {
+  base::win::ScopedCOMInitializer com_initializer;
+  if (!com_initializer.succeeded())
+    return false;
+
+  base::win::ScopedComPtr<IFileOperation> pfo;
+  if (FAILED(pfo.CreateInstance(CLSID_FileOperation)))
+    return false;
+
+  // Elevation prompt enabled for UAC protected files.  This overrides the
+  // SILENT, NO_UI and NOERRORUI flags.
+
+  if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
+    // Windows 8 introduces the flag RECYCLEONDELETE and deprecates the
+    // ALLOWUNDO in favor of ADDUNDORECORD.
+    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI |
+                                      FOFX_ADDUNDORECORD |
+                                      FOF_NOERRORUI |
+                                      FOF_SILENT |
+                                      FOFX_SHOWELEVATIONPROMPT |
+                                      FOFX_RECYCLEONDELETE)))
+      return false;
+  } else {
+    // For Windows 7 and Vista, RecycleOnDelete is the default behavior.
+    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI |
+                                      FOF_ALLOWUNDO |
+                                      FOF_NOERRORUI |
+                                      FOF_SILENT |
+                                      FOFX_SHOWELEVATIONPROMPT)))
+      return false;
+  }
+
+  // Create an IShellItem from the supplied source path.
+  base::win::ScopedComPtr<IShellItem> delete_item;
+  if (FAILED(SHCreateItemFromParsingName(path.value().c_str(),
+                                         NULL,
+                                         IID_PPV_ARGS(delete_item.Receive()))))
+    return false;
+
+  base::win::ScopedComPtr<IFileOperationProgressSink> delete_sink(
+      new DeleteFileProgressSink);
+  if (!delete_sink)
+    return false;
+
+  // Processes the queued command DeleteItem. This will trigger
+  // the DeleteFileProgressSink to check for Recycle Bin.
+  return SUCCEEDED(pfo->DeleteItem(delete_item.get(), delete_sink.get())) &&
+         SUCCEEDED(pfo->PerformOperations());
+}
+
+void Beep() {
+  MessageBeep(MB_OK);
+}
+
+}  // namespace platform_util
added in remote
  their  100644 e39b2b84171ce2ebdef3cbe22597bd68fb822c08 electron/common/resources/mac/Info.plist
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleIdentifier</key>
+	<string>${ELECTRON_BUNDLE_ID}</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>NSSupportsAutomaticGraphicsSwitching</key>
+	<true/>
+</dict>
+</plist>
added in remote
  their  100644 8cb57c709237496ee9b263834d0f10b1455f42d3 electron/common/resources/mac/MainMenu.xib
@@ -0,0 +1,180 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="8.00">
+	<data>
+		<int key="IBDocument.SystemTarget">101000</int>
+		<string key="IBDocument.SystemVersion">14D136</string>
+		<string key="IBDocument.InterfaceBuilderVersion">7531</string>
+		<string key="IBDocument.AppKitVersion">1347.57</string>
+		<string key="IBDocument.HIToolboxVersion">758.70</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin</string>
+			<string key="NS.object.0">7531</string>
+		</object>
+		<array key="IBDocument.IntegratedClassDependencies">
+			<string>NSCustomObject</string>
+			<string>NSMenu</string>
+			<string>NSMenuItem</string>
+		</array>
+		<array key="IBDocument.PluginDependencies">
+			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+		</array>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<string key="NS.key.0">PluginDependencyRecalculationVersion</string>
+			<integer value="1" key="NS.object.0"/>
+		</object>
+		<array class="NSMutableArray" key="IBDocument.RootObjects" id="1048">
+			<object class="NSCustomObject" id="1021">
+				<string key="NSClassName">ElectronApplication</string>
+			</object>
+			<object class="NSCustomObject" id="1014">
+				<string key="NSClassName">FirstResponder</string>
+			</object>
+			<object class="NSCustomObject" id="1050">
+				<string key="NSClassName">NSApplication</string>
+			</object>
+			<object class="NSCustomObject" id="903638069">
+				<string key="NSClassName">NSFontManager</string>
+			</object>
+			<object class="NSMenu" id="649796088">
+				<string key="NSTitle">Main Menu</string>
+				<array class="NSMutableArray" key="NSMenuItems">
+					<object class="NSMenuItem" id="694149608">
+						<reference key="NSMenu" ref="649796088"/>
+						<string key="NSTitle">Electron</string>
+						<string key="NSKeyEquiv"/>
+						<int key="NSMnemonicLoc">2147483647</int>
+						<object class="NSCustomResource" key="NSOnImage" id="229763992">
+							<string key="NSClassName">NSImage</string>
+							<string key="NSResourceName">NSMenuCheckmark</string>
+						</object>
+						<object class="NSCustomResource" key="NSMixedImage" id="909111550">
+							<string key="NSClassName">NSImage</string>
+							<string key="NSResourceName">NSMenuMixedState</string>
+						</object>
+						<string key="NSAction">submenuAction:</string>
+						<reference key="NSTarget" ref="110575045"/>
+						<object class="NSMenu" key="NSSubmenu" id="110575045">
+							<string key="NSTitle">Electron</string>
+							<array class="NSMutableArray" key="NSMenuItems">
+								<object class="NSMenuItem" id="632727374">
+									<reference key="NSMenu" ref="110575045"/>
+									<string key="NSTitle">Quit</string>
+									<string key="NSKeyEquiv">q</string>
+									<int key="NSKeyEquivModMask">1048576</int>
+									<int key="NSMnemonicLoc">2147483647</int>
+									<reference key="NSOnImage" ref="229763992"/>
+									<reference key="NSMixedImage" ref="909111550"/>
+								</object>
+							</array>
+							<string key="NSName">_NSAppleMenu</string>
+						</object>
+					</object>
+				</array>
+				<string key="NSName">_NSMainMenu</string>
+			</object>
+		</array>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<array key="connectionRecords">
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">terminate:</string>
+						<reference key="source" ref="1014"/>
+						<reference key="destination" ref="632727374"/>
+					</object>
+					<int key="connectionID">807</int>
+				</object>
+			</array>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<array key="orderedObjects">
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<array key="object" id="0"/>
+						<reference key="children" ref="1048"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="1021"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="1014"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">First Responder</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-3</int>
+						<reference key="object" ref="1050"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">Application</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">371</int>
+						<reference key="object" ref="903638069"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">29</int>
+						<reference key="object" ref="649796088"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="694149608"/>
+						</array>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">56</int>
+						<reference key="object" ref="694149608"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="110575045"/>
+						</array>
+						<reference key="parent" ref="649796088"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">57</int>
+						<reference key="object" ref="110575045"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="632727374"/>
+						</array>
+						<reference key="parent" ref="694149608"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">136</int>
+						<reference key="object" ref="632727374"/>
+						<reference key="parent" ref="110575045"/>
+					</object>
+				</array>
+			</object>
+			<dictionary class="NSMutableDictionary" key="flattenedProperties">
+				<string key="-1.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="-2.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="-3.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="136.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="29.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="371.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="56.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="57.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+			</dictionary>
+			<dictionary class="NSMutableDictionary" key="unlocalizedProperties"/>
+			<nil key="activeLocalization"/>
+			<dictionary class="NSMutableDictionary" key="localizations"/>
+			<nil key="sourceID"/>
+			<int key="maxID">807</int>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaFramework</string>
+		<bool key="IBDocument.previouslyAttemptedUpgradeToXcode5">NO</bool>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.InterfaceBuilder3</string>
+			<integer value="4600" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<dictionary class="NSMutableDictionary" key="IBDocument.LastKnownImageSizes">
+			<string key="NSMenuCheckmark">{12, 12}</string>
+			<string key="NSMenuMixedState">{10, 2}</string>
+		</dictionary>
+		<bool key="IBDocument.UseAutolayout">YES</bool>
+	</data>
+</archive>
added in remote
  their  100644 9ec1b0cf2470f653d8df7f103f82c6ecaf8ed73c electron/renderer/api/electron_api_renderer_ipc.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "content/public/renderer/render_view.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+using content::RenderView;
+using blink::WebLocalFrame;
+using blink::WebView;
+
+namespace {
+
+RenderView* GetCurrentRenderView() {
+  WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();
+  if (!frame)
+    return NULL;
+
+  WebView* view = frame->view();
+  if (!view)
+    return NULL;  // can happen during closing.
+
+  return RenderView::FromWebView(view);
+}
+
+void Send(mate::Arguments* args,
+          const base::string16& channel,
+          const base::ListValue& arguments) {
+  RenderView* render_view = GetCurrentRenderView();
+  if (render_view == NULL)
+    return;
+
+  bool success = render_view->Send(new ElectronViewHostMsg_Message(
+      render_view->GetRoutingID(), channel, arguments));
+
+  if (!success)
+    args->ThrowError("Unable to send ElectronViewHostMsg_Message");
+}
+
+base::string16 SendSync(mate::Arguments* args,
+                        const base::string16& channel,
+                        const base::ListValue& arguments) {
+  base::string16 json;
+
+  RenderView* render_view = GetCurrentRenderView();
+  if (render_view == NULL)
+    return json;
+
+  IPC::SyncMessage* message = new ElectronViewHostMsg_Message_Sync(
+      render_view->GetRoutingID(), channel, arguments, &json);
+  bool success = render_view->Send(message);
+
+  if (!success)
+    args->ThrowError("Unable to send ElectronViewHostMsg_Message_Sync");
+
+  return json;
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("send", &Send);
+  dict.SetMethod("sendSync", &SendSync);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_renderer_ipc, Initialize)
added in remote
  their  100644 8e704aa729fe453b2f4863517b94631990fe81d9 electron/renderer/api/electron_api_spell_check_client.cc
@@ -0,0 +1,189 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/api/electron_api_spell_check_client.h"
+
+#include <algorithm>
+#include <vector>
+
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/logging.h"
+#include "native_mate/converter.h"
+#include "native_mate/dictionary.h"
+#include "third_party/icu/source/common/unicode/uscript.h"
+#include "third_party/WebKit/public/web/WebTextCheckingCompletion.h"
+#include "third_party/WebKit/public/web/WebTextCheckingResult.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+bool HasWordCharacters(const base::string16& text, int index) {
+  const base::char16* data = text.data();
+  int length = text.length();
+  while (index < length) {
+    uint32_t code = 0;
+    U16_NEXT(data, index, length, code);
+    UErrorCode error = U_ZERO_ERROR;
+    if (uscript_getScript(code, &error) != USCRIPT_COMMON)
+      return true;
+  }
+  return false;
+}
+
+}  // namespace
+
+SpellCheckClient::SpellCheckClient(const std::string& language,
+                                   bool auto_spell_correct_turned_on,
+                                   v8::Isolate* isolate,
+                                   v8::Local<v8::Object> provider)
+    : isolate_(isolate),
+      provider_(isolate, provider) {
+  character_attributes_.SetDefaultLanguage(language);
+
+  // Persistent the method.
+  mate::Dictionary dict(isolate, provider);
+  dict.Get("spellCheck", &spell_check_);
+}
+
+SpellCheckClient::~SpellCheckClient() {}
+
+void SpellCheckClient::spellCheck(
+    const blink::WebString& text,
+    int& misspelling_start,
+    int& misspelling_len,
+    blink::WebVector<blink::WebString>* optional_suggestions) {
+  std::vector<blink::WebTextCheckingResult> results;
+  SpellCheckText(base::string16(text), true, &results);
+  if (results.size() == 1) {
+    misspelling_start = results[0].location;
+    misspelling_len = results[0].length;
+  }
+}
+
+void SpellCheckClient::checkTextOfParagraph(
+    const blink::WebString& text,
+    blink::WebTextCheckingTypeMask mask,
+    blink::WebVector<blink::WebTextCheckingResult>* results) {
+  if (!results)
+    return;
+
+  if (!(mask & blink::WebTextCheckingTypeSpelling))
+    return;
+
+  NOTREACHED() << "checkTextOfParagraph should never be called";
+}
+
+void SpellCheckClient::requestCheckingOfText(
+    const blink::WebString& textToCheck,
+    const blink::WebVector<uint32_t>& markersInText,
+    const blink::WebVector<unsigned>& markerOffsets,
+    blink::WebTextCheckingCompletion* completionCallback) {
+  base::string16 text(textToCheck);
+  if (text.empty() || !HasWordCharacters(text, 0)) {
+    completionCallback->didCancelCheckingText();
+    return;
+  }
+
+  std::vector<blink::WebTextCheckingResult> results;
+  SpellCheckText(text, false, &results);
+  completionCallback->didFinishCheckingText(results);
+}
+
+void SpellCheckClient::showSpellingUI(bool show) {
+}
+
+bool SpellCheckClient::isShowingSpellingUI() {
+  return false;
+}
+
+void SpellCheckClient::updateSpellingUIWithMisspelledWord(
+    const blink::WebString& word) {
+}
+
+void SpellCheckClient::SpellCheckText(
+    const base::string16& text,
+    bool stop_at_first_result,
+    std::vector<blink::WebTextCheckingResult>* results) {
+  if (text.length() == 0 || spell_check_.IsEmpty())
+    return;
+
+  base::string16 word;
+  int word_start;
+  int word_length;
+  if (!text_iterator_.IsInitialized() &&
+      !text_iterator_.Initialize(&character_attributes_, true)) {
+      // We failed to initialize text_iterator_, return as spelled correctly.
+      VLOG(1) << "Failed to initialize SpellcheckWordIterator";
+      return;
+  }
+
+  base::string16 in_word(text);
+  text_iterator_.SetText(in_word.c_str(), in_word.size());
+  while (text_iterator_.GetNextWord(&word, &word_start, &word_length)) {
+    // Found a word (or a contraction) that the spellchecker can check the
+    // spelling of.
+    if (SpellCheckWord(word))
+      continue;
+
+    // If the given word is a concatenated word of two or more valid words
+    // (e.g. "hello:hello"), we should treat it as a valid word.
+    if (IsValidContraction(word))
+      continue;
+
+    blink::WebTextCheckingResult result;
+    result.location = word_start;
+    result.length = word_length;
+    results->push_back(result);
+
+    if (stop_at_first_result)
+      return;
+  }
+}
+
+bool SpellCheckClient::SpellCheckWord(const base::string16& word_to_check) {
+  if (spell_check_.IsEmpty())
+    return true;
+
+  v8::HandleScope handle_scope(isolate_);
+  v8::Local<v8::Value> word = mate::ConvertToV8(isolate_, word_to_check);
+  v8::Local<v8::Value> result = spell_check_.NewHandle()->Call(
+      provider_.NewHandle(), 1, &word);
+
+  if (result->IsBoolean())
+    return result->BooleanValue();
+  else
+    return true;
+}
+
+// Returns whether or not the given string is a valid contraction.
+// This function is a fall-back when the SpellcheckWordIterator class
+// returns a concatenated word which is not in the selected dictionary
+// (e.g. "in'n'out") but each word is valid.
+bool SpellCheckClient::IsValidContraction(const base::string16& contraction) {
+  if (!contraction_iterator_.IsInitialized() &&
+      !contraction_iterator_.Initialize(&character_attributes_, false)) {
+    // We failed to initialize the word iterator, return as spelled correctly.
+    VLOG(1) << "Failed to initialize contraction_iterator_";
+    return true;
+  }
+
+  contraction_iterator_.SetText(contraction.c_str(), contraction.length());
+
+  base::string16 word;
+  int word_start;
+  int word_length;
+
+  while (contraction_iterator_.GetNextWord(&word, &word_start, &word_length)) {
+    if (!SpellCheckWord(word))
+      return false;
+  }
+  return true;
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 85f7541857b00affa935eca56ac1bd530ee9718a electron/renderer/api/electron_api_spell_check_client.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
+#define ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
+#include "native_mate/scoped_persistent.h"
+#include "third_party/WebKit/public/web/WebSpellCheckClient.h"
+
+namespace electron {
+
+namespace api {
+
+class SpellCheckClient : public blink::WebSpellCheckClient {
+ public:
+  SpellCheckClient(const std::string& language,
+                   bool auto_spell_correct_turned_on,
+                   v8::Isolate* isolate,
+                   v8::Local<v8::Object> provider);
+  virtual ~SpellCheckClient();
+
+ private:
+  // blink::WebSpellCheckClient:
+  void spellCheck(
+      const blink::WebString& text,
+      int& misspelledOffset,
+      int& misspelledLength,
+      blink::WebVector<blink::WebString>* optionalSuggestions) override;
+  void checkTextOfParagraph(
+      const blink::WebString&,
+      blink::WebTextCheckingTypeMask mask,
+      blink::WebVector<blink::WebTextCheckingResult>* results) override;
+  void requestCheckingOfText(
+      const blink::WebString& textToCheck,
+      const blink::WebVector<uint32_t>& markersInText,
+      const blink::WebVector<unsigned>& markerOffsets,
+      blink::WebTextCheckingCompletion* completionCallback) override;
+  void showSpellingUI(bool show) override;
+  bool isShowingSpellingUI() override;
+  void updateSpellingUIWithMisspelledWord(
+      const blink::WebString& word) override;
+
+  // Check the spelling of text.
+  void SpellCheckText(const base::string16& text,
+                      bool stop_at_first_result,
+                      std::vector<blink::WebTextCheckingResult>* results);
+
+  // Call JavaScript to check spelling a word.
+  bool SpellCheckWord(const base::string16& word_to_check);
+
+  // Find a possible correctly spelled word for a misspelled word. Computes an
+  // empty string if input misspelled word is too long, there is ambiguity, or
+  // the correct spelling cannot be determined.
+  base::string16 GetAutoCorrectionWord(const base::string16& word);
+
+  // Returns whether or not the given word is a contraction of valid words
+  // (e.g. "word:word").
+  bool IsValidContraction(const base::string16& word);
+
+  // Represents character attributes used for filtering out characters which
+  // are not supported by this SpellCheck object.
+  SpellcheckCharAttribute character_attributes_;
+
+  // Represents word iterators used in this spellchecker. The |text_iterator_|
+  // splits text provided by WebKit into words, contractions, or concatenated
+  // words. The |contraction_iterator_| splits a concatenated word extracted by
+  // |text_iterator_| into word components so we can treat a concatenated word
+  // consisting only of correct words as a correct word.
+  SpellcheckWordIterator text_iterator_;
+  SpellcheckWordIterator contraction_iterator_;
+
+  bool auto_spell_correct_turned_on_;
+
+  v8::Isolate* isolate_;
+  mate::ScopedPersistent<v8::Object> provider_;
+  mate::ScopedPersistent<v8::Function> spell_check_;
+
+  DISALLOW_COPY_AND_ASSIGN(SpellCheckClient);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
added in remote
  their  100644 184b597d27b12619e2fba2387ce2c4250e74a669 electron/renderer/api/electron_api_web_frame.cc
@@ -0,0 +1,210 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/api/electron_api_web_frame.h"
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/renderer/api/electron_api_spell_check_client.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_view.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "third_party/WebKit/public/web/WebDocument.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebScriptExecutionCallback.h"
+#include "third_party/WebKit/public/web/WebScriptSource.h"
+#include "third_party/WebKit/public/web/WebSecurityPolicy.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+class ScriptExecutionCallback : public blink::WebScriptExecutionCallback {
+ public:
+  using CompletionCallback =
+      base::Callback<void(
+          const v8::Local<v8::Value>& result)>;
+
+  explicit ScriptExecutionCallback(const CompletionCallback& callback)
+      : callback_(callback) {}
+  ~ScriptExecutionCallback() {}
+
+  void completed(
+      const blink::WebVector<v8::Local<v8::Value>>& result) override {
+    if (!callback_.is_null() && !result.isEmpty() && !result[0].IsEmpty())
+      // Right now only single results per frame is supported.
+      callback_.Run(result[0]);
+    delete this;
+  }
+
+ private:
+  CompletionCallback callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptExecutionCallback);
+};
+
+}  // namespace
+
+WebFrame::WebFrame()
+    : web_frame_(blink::WebLocalFrame::frameForCurrentContext()) {
+}
+
+WebFrame::~WebFrame() {
+}
+
+void WebFrame::SetName(const std::string& name) {
+  web_frame_->setName(blink::WebString::fromUTF8(name));
+}
+
+double WebFrame::SetZoomLevel(double level) {
+  double ret = web_frame_->view()->setZoomLevel(level);
+  mate::EmitEvent(isolate(), GetWrapper(isolate()), "zoom-level-changed", ret);
+  return ret;
+}
+
+double WebFrame::GetZoomLevel() const {
+  return web_frame_->view()->zoomLevel();
+}
+
+double WebFrame::SetZoomFactor(double factor) {
+  return blink::WebView::zoomLevelToZoomFactor(SetZoomLevel(
+      blink::WebView::zoomFactorToZoomLevel(factor)));
+}
+
+double WebFrame::GetZoomFactor() const {
+  return blink::WebView::zoomLevelToZoomFactor(GetZoomLevel());
+}
+
+void WebFrame::SetZoomLevelLimits(double min_level, double max_level) {
+  web_frame_->view()->setDefaultPageScaleLimits(min_level, max_level);
+}
+
+v8::Local<v8::Value> WebFrame::RegisterEmbedderCustomElement(
+    const base::string16& name, v8::Local<v8::Object> options) {
+  blink::WebExceptionCode c = 0;
+  return web_frame_->document().registerEmbedderCustomElement(name, options, c);
+}
+
+void WebFrame::RegisterElementResizeCallback(
+    int element_instance_id,
+    const GuestViewContainer::ResizeCallback& callback) {
+  auto guest_view_container = GuestViewContainer::FromID(element_instance_id);
+  if (guest_view_container)
+    guest_view_container->RegisterElementResizeCallback(callback);
+}
+
+void WebFrame::AttachGuest(int id) {
+  content::RenderFrame::FromWebFrame(web_frame_)->AttachGuest(id);
+}
+
+void WebFrame::SetSpellCheckProvider(mate::Arguments* args,
+                                     const std::string& language,
+                                     bool auto_spell_correct_turned_on,
+                                     v8::Local<v8::Object> provider) {
+  if (!provider->Has(mate::StringToV8(args->isolate(), "spellCheck"))) {
+    args->ThrowError("\"spellCheck\" has to be defined");
+    return;
+  }
+
+  spell_check_client_.reset(new SpellCheckClient(
+      language, auto_spell_correct_turned_on, args->isolate(), provider));
+  web_frame_->view()->setSpellCheckClient(spell_check_client_.get());
+}
+
+void WebFrame::RegisterURLSchemeAsSecure(const std::string& scheme) {
+  // Register scheme to secure list (https, wss, data).
+  blink::WebSecurityPolicy::registerURLSchemeAsSecure(
+      blink::WebString::fromUTF8(scheme));
+}
+
+void WebFrame::RegisterURLSchemeAsBypassingCSP(const std::string& scheme) {
+  // Register scheme to bypass pages's Content Security Policy.
+  blink::WebSecurityPolicy::registerURLSchemeAsBypassingContentSecurityPolicy(
+      blink::WebString::fromUTF8(scheme));
+}
+
+void WebFrame::RegisterURLSchemeAsPrivileged(const std::string& scheme) {
+  // Register scheme to privileged list (https, wss, data, chrome-extension)
+  blink::WebString privileged_scheme(blink::WebString::fromUTF8(scheme));
+  blink::WebSecurityPolicy::registerURLSchemeAsSecure(privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsBypassingContentSecurityPolicy(
+      privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsAllowingServiceWorkers(
+      privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsSupportingFetchAPI(
+      privileged_scheme);
+}
+
+void WebFrame::InsertText(const std::string& text) {
+  web_frame_->insertText(blink::WebString::fromUTF8(text));
+}
+
+void WebFrame::ExecuteJavaScript(const base::string16& code,
+                                 mate::Arguments* args) {
+  bool has_user_gesture = false;
+  args->GetNext(&has_user_gesture);
+  ScriptExecutionCallback::CompletionCallback completion_callback;
+  args->GetNext(&completion_callback);
+  scoped_ptr<blink::WebScriptExecutionCallback> callback(
+      new ScriptExecutionCallback(completion_callback));
+  web_frame_->requestExecuteScriptAndReturnValue(
+      blink::WebScriptSource(code),
+      has_user_gesture,
+      callback.release());
+}
+
+mate::ObjectTemplateBuilder WebFrame::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("setName", &WebFrame::SetName)
+      .SetMethod("setZoomLevel", &WebFrame::SetZoomLevel)
+      .SetMethod("getZoomLevel", &WebFrame::GetZoomLevel)
+      .SetMethod("setZoomFactor", &WebFrame::SetZoomFactor)
+      .SetMethod("getZoomFactor", &WebFrame::GetZoomFactor)
+      .SetMethod("setZoomLevelLimits", &WebFrame::SetZoomLevelLimits)
+      .SetMethod("registerEmbedderCustomElement",
+                 &WebFrame::RegisterEmbedderCustomElement)
+      .SetMethod("registerElementResizeCallback",
+                 &WebFrame::RegisterElementResizeCallback)
+      .SetMethod("attachGuest", &WebFrame::AttachGuest)
+      .SetMethod("setSpellCheckProvider", &WebFrame::SetSpellCheckProvider)
+      .SetMethod("registerURLSchemeAsSecure",
+                 &WebFrame::RegisterURLSchemeAsSecure)
+      .SetMethod("registerURLSchemeAsBypassingCSP",
+                 &WebFrame::RegisterURLSchemeAsBypassingCSP)
+      .SetMethod("registerURLSchemeAsPrivileged",
+                 &WebFrame::RegisterURLSchemeAsPrivileged)
+      .SetMethod("insertText", &WebFrame::InsertText)
+      .SetMethod("executeJavaScript", &WebFrame::ExecuteJavaScript);
+}
+
+// static
+mate::Handle<WebFrame> WebFrame::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new WebFrame);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("webFrame", electron::api::WebFrame::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_renderer_web_frame, Initialize)
added in remote
  their  100644 7723e08a579bef948d2139e066a42783377ab1d0 electron/renderer/api/electron_api_web_frame.h
@@ -0,0 +1,84 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
+#define ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
+
+#include <string>
+
+#include "electron/renderer/guest_view_container.h"
+#include "base/memory/scoped_ptr.h"
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class SpellCheckClient;
+
+class WebFrame : public mate::Wrappable {
+ public:
+  static mate::Handle<WebFrame> Create(v8::Isolate* isolate);
+
+ private:
+  WebFrame();
+  virtual ~WebFrame();
+
+  void SetName(const std::string& name);
+
+  double SetZoomLevel(double level);
+  double GetZoomLevel() const;
+  double SetZoomFactor(double factor);
+  double GetZoomFactor() const;
+
+  void SetZoomLevelLimits(double min_level, double max_level);
+
+  v8::Local<v8::Value> RegisterEmbedderCustomElement(
+      const base::string16& name, v8::Local<v8::Object> options);
+  void RegisterElementResizeCallback(
+      int element_instance_id,
+      const GuestViewContainer::ResizeCallback& callback);
+  void AttachGuest(int element_instance_id);
+
+  // Set the provider that will be used by SpellCheckClient for spell check.
+  void SetSpellCheckProvider(mate::Arguments* args,
+                             const std::string& language,
+                             bool auto_spell_correct_turned_on,
+                             v8::Local<v8::Object> provider);
+
+  void RegisterURLSchemeAsSecure(const std::string& scheme);
+  void RegisterURLSchemeAsBypassingCSP(const std::string& scheme);
+  void RegisterURLSchemeAsPrivileged(const std::string& scheme);
+
+  // Editing.
+  void InsertText(const std::string& text);
+
+  // Excecuting scripts.
+  void ExecuteJavaScript(const base::string16& code, mate::Arguments* args);
+
+  // mate::Wrappable:
+  virtual mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate);
+
+  scoped_ptr<SpellCheckClient> spell_check_client_;
+
+  blink::WebLocalFrame* web_frame_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebFrame);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
added in remote
  their  100644 9caa7dec200dbfb466a528213e09023834989cd4 electron/renderer/electron_render_view_observer.cc
@@ -0,0 +1,155 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/electron_render_view_observer.h"
+
+#include <string>
+#include <vector>
+
+// Put this before event_emitter_caller.h to have string16 support.
+#include "electron/common/native_mate_converters/string16_converter.h"
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "electron/renderer/electron_renderer_client.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/renderer/render_view.h"
+#include "ipc/ipc_message_macros.h"
+#include "net/base/net_module.h"
+#include "net/grit/net_resources.h"
+#include "third_party/WebKit/public/web/WebDraggableRegion.h"
+#include "third_party/WebKit/public/web/WebDocument.h"
+#include "third_party/WebKit/public/web/WebFrame.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebKit.h"
+#include "third_party/WebKit/public/web/WebView.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace {
+
+bool GetIPCObject(v8::Isolate* isolate,
+                  v8::Local<v8::Context> context,
+                  v8::Local<v8::Object>* ipc) {
+  v8::Local<v8::String> key = mate::StringToV8(isolate, "ipc");
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  v8::Local<v8::Object> global_object = context->Global();
+  v8::Local<v8::Value> value;
+  if (!global_object->GetPrivate(context, privateKey).ToLocal(&value))
+    return false;
+  if (value.IsEmpty() || !value->IsObject())
+    return false;
+  *ipc = value->ToObject();
+  return true;
+}
+
+std::vector<v8::Local<v8::Value>> ListValueToVector(
+    v8::Isolate* isolate,
+    const base::ListValue& list) {
+  v8::Local<v8::Value> array = mate::ConvertToV8(isolate, list);
+  std::vector<v8::Local<v8::Value>> result;
+  mate::ConvertFromV8(isolate, array, &result);
+  return result;
+}
+
+base::StringPiece NetResourceProvider(int key) {
+  if (key == IDR_DIR_HEADER_HTML) {
+    base::StringPiece html_data =
+        ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
+            IDR_DIR_HEADER_HTML);
+    return html_data;
+  }
+  return base::StringPiece();
+}
+
+}  // namespace
+
+ElectronRenderViewObserver::ElectronRenderViewObserver(
+    content::RenderView* render_view,
+    ElectronRendererClient* renderer_client)
+    : content::RenderViewObserver(render_view),
+      renderer_client_(renderer_client),
+      document_created_(false) {
+  // Initialise resource for directory listing.
+  net::NetModule::SetResourceProvider(NetResourceProvider);
+}
+
+ElectronRenderViewObserver::~ElectronRenderViewObserver() {
+}
+
+void ElectronRenderViewObserver::DidCreateDocumentElement(
+    blink::WebLocalFrame* frame) {
+  document_created_ = true;
+
+  // Read --zoom-factor from command line.
+  std::string zoom_factor_str = base::CommandLine::ForCurrentProcess()->
+      GetSwitchValueASCII(switches::kZoomFactor);
+  if (zoom_factor_str.empty())
+    return;
+  double zoom_factor;
+  if (!base::StringToDouble(zoom_factor_str, &zoom_factor))
+    return;
+  double zoom_level = blink::WebView::zoomFactorToZoomLevel(zoom_factor);
+  frame->view()->setZoomLevel(zoom_level);
+}
+
+void ElectronRenderViewObserver::DraggableRegionsChanged(blink::WebFrame* frame) {
+  blink::WebVector<blink::WebDraggableRegion> webregions =
+      frame->document().draggableRegions();
+  std::vector<DraggableRegion> regions;
+  for (size_t i = 0; i < webregions.size(); ++i) {
+    DraggableRegion region;
+    region.bounds = webregions[i].bounds;
+    region.draggable = webregions[i].draggable;
+    regions.push_back(region);
+  }
+  Send(new ElectronViewHostMsg_UpdateDraggableRegions(routing_id(), regions));
+}
+
+bool ElectronRenderViewObserver::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(ElectronRenderViewObserver, message)
+    IPC_MESSAGE_HANDLER(ElectronViewMsg_Message, OnBrowserMessage)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+void ElectronRenderViewObserver::OnBrowserMessage(const base::string16& channel,
+                                              const base::ListValue& args) {
+  if (!document_created_)
+    return;
+
+  if (!render_view()->GetWebView())
+    return;
+
+  blink::WebFrame* frame = render_view()->GetWebView()->mainFrame();
+  if (!frame || frame->isWebRemoteFrame())
+    return;
+
+  v8::Isolate* isolate = blink::mainThreadIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  v8::Local<v8::Context> context = frame->mainWorldScriptContext();
+  v8::Context::Scope context_scope(context);
+
+  v8::Local<v8::Object> ipc;
+  if (GetIPCObject(isolate, context, &ipc)) {
+    auto args_vector = ListValueToVector(isolate, args);
+    // Insert the Event object, event.sender is ipc.
+    mate::Dictionary event = mate::Dictionary::CreateEmpty(isolate);
+    event.Set("sender", ipc);
+    args_vector.insert(args_vector.begin(), event.GetHandle());
+    mate::EmitEvent(isolate, ipc, channel, args_vector);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 714395305caebceaffba5558cca3930501b3650d electron/renderer/electron_render_view_observer.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
+#define ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
+
+#include "base/strings/string16.h"
+#include "content/public/renderer/render_view_observer.h"
+
+namespace base {
+class ListValue;
+}
+
+namespace electron {
+
+class ElectronRendererClient;
+
+class ElectronRenderViewObserver : public content::RenderViewObserver {
+ public:
+  explicit ElectronRenderViewObserver(content::RenderView* render_view,
+                                  ElectronRendererClient* renderer_client);
+
+ protected:
+  virtual ~ElectronRenderViewObserver();
+
+ private:
+  // content::RenderViewObserver implementation.
+  void DidCreateDocumentElement(blink::WebLocalFrame* frame) override;
+  void DraggableRegionsChanged(blink::WebFrame* frame) override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  void OnBrowserMessage(const base::string16& channel,
+                        const base::ListValue& args);
+
+  // Weak reference to renderer client.
+  ElectronRendererClient* renderer_client_;
+
+  // Whether the document object has been created.
+  bool document_created_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRenderViewObserver);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
added in remote
  their  100644 6eb66e35b8e76b305296e14079e20e0305845ac0 electron/renderer/electron_renderer_client.cc
@@ -0,0 +1,214 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/electron_renderer_client.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/electron_bindings.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/node_bindings.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "electron/renderer/electron_render_view_observer.h"
+#include "electron/renderer/guest_view_container.h"
+#include "electron/renderer/node_array_buffer_bridge.h"
+#include "base/command_line.h"
+#include "chrome/renderer/media/chrome_key_systems.h"
+#include "chrome/renderer/pepper/pepper_helper.h"
+#include "chrome/renderer/printing/print_web_view_helper.h"
+#include "chrome/renderer/tts_dispatcher.h"
+#include "content/public/common/content_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+#include "ipc/ipc_message_macros.h"
+#include "third_party/WebKit/public/web/WebCustomElement.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebPluginParams.h"
+#include "third_party/WebKit/public/web/WebKit.h"
+#include "third_party/WebKit/public/web/WebSecurityPolicy.h"
+#include "third_party/WebKit/public/web/WebRuntimeFeatures.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+#if defined(OS_WIN)
+#include <shlobj.h>
+#endif
+
+namespace electron {
+
+namespace {
+
+// Helper class to forward the messages to the client.
+class ElectronRenderFrameObserver : public content::RenderFrameObserver {
+ public:
+  ElectronRenderFrameObserver(content::RenderFrame* frame,
+                          ElectronRendererClient* renderer_client)
+      : content::RenderFrameObserver(frame),
+        world_id_(-1),
+        renderer_client_(renderer_client) {}
+
+  // content::RenderFrameObserver:
+  void DidCreateScriptContext(v8::Handle<v8::Context> context,
+                              int extension_group,
+                              int world_id) override {
+    if (world_id_ != -1 && world_id_ != world_id)
+      return;
+    world_id_ = world_id;
+    renderer_client_->DidCreateScriptContext(context);
+  }
+  void WillReleaseScriptContext(v8::Local<v8::Context> context,
+                                int world_id) override {
+    if (world_id_ != world_id)
+      return;
+    renderer_client_->WillReleaseScriptContext(context);
+  }
+
+ private:
+  int world_id_;
+  ElectronRendererClient* renderer_client_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRenderFrameObserver);
+};
+
+}  // namespace
+
+ElectronRendererClient::ElectronRendererClient()
+    : node_bindings_(NodeBindings::Create(false)),
+      electron_bindings_(new ElectronBindings) {
+}
+
+ElectronRendererClient::~ElectronRendererClient() {
+}
+
+void ElectronRendererClient::WebKitInitialized() {
+  blink::WebCustomElement::addEmbedderCustomElementName("webview");
+  blink::WebCustomElement::addEmbedderCustomElementName("browserplugin");
+
+  OverrideNodeArrayBuffer();
+}
+
+void ElectronRendererClient::RenderThreadStarted() {
+  content::RenderThread::Get()->AddObserver(this);
+
+#if defined(OS_WIN)
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  base::string16 app_id =
+      command_line->GetSwitchValueNative(switches::kAppUserModelId);
+  if (!app_id.empty()) {
+    SetCurrentProcessExplicitAppUserModelID(app_id.c_str());
+  }
+#endif
+}
+
+void ElectronRendererClient::RenderFrameCreated(
+    content::RenderFrame* render_frame) {
+  new PepperHelper(render_frame);
+
+  // Allow file scheme to handle service worker by default.
+  blink::WebSecurityPolicy::registerURLSchemeAsAllowingServiceWorkers("file");
+
+  // Only insert node integration for the main frame.
+  if (!render_frame->IsMainFrame())
+    return;
+
+  new ElectronRenderFrameObserver(render_frame, this);
+}
+
+void ElectronRendererClient::RenderViewCreated(content::RenderView* render_view) {
+  // Set default UA-dependent background as transparent.
+  render_view->GetWebView()->setBaseBackgroundColor(SK_ColorTRANSPARENT);
+
+  new printing::PrintWebViewHelper(render_view);
+  new ElectronRenderViewObserver(render_view, this);
+}
+
+blink::WebSpeechSynthesizer* ElectronRendererClient::OverrideSpeechSynthesizer(
+    blink::WebSpeechSynthesizerClient* client) {
+  return new TtsDispatcher(client);
+}
+
+bool ElectronRendererClient::OverrideCreatePlugin(
+    content::RenderFrame* render_frame,
+    blink::WebLocalFrame* frame,
+    const blink::WebPluginParams& params,
+    blink::WebPlugin** plugin) {
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (params.mimeType.utf8() == content::kBrowserPluginMimeType ||
+      command_line->HasSwitch(switches::kEnablePlugins))
+    return false;
+
+  *plugin = nullptr;
+  return true;
+}
+
+void ElectronRendererClient::DidCreateScriptContext(
+    v8::Handle<v8::Context> context) {
+  // Whether the node binding has been initialized.
+  bool first_time = node_bindings_->uv_env() == nullptr;
+
+  // Prepare the node bindings.
+  if (first_time) {
+    node_bindings_->Initialize();
+    node_bindings_->PrepareMessageLoop();
+  }
+
+  // Setup node environment for each window.
+  node::Environment* env = node_bindings_->CreateEnvironment(context);
+
+  // Add Electron extended APIs.
+  electron_bindings_->BindTo(env->isolate(), env->process_object());
+
+  // Load everything.
+  node_bindings_->LoadEnvironment(env);
+
+  if (first_time) {
+    // Make uv loop being wrapped by window context.
+    node_bindings_->set_uv_env(env);
+
+    // Give the node loop a run to make sure everything is ready.
+    node_bindings_->RunMessageLoop();
+  }
+}
+
+void ElectronRendererClient::WillReleaseScriptContext(
+    v8::Handle<v8::Context> context) {
+  node::Environment* env = node::Environment::GetCurrent(context);
+  mate::EmitEvent(env->isolate(), env->process_object(), "exit");
+}
+
+bool ElectronRendererClient::ShouldFork(blink::WebLocalFrame* frame,
+                                    const GURL& url,
+                                    const std::string& http_method,
+                                    bool is_initial_navigation,
+                                    bool is_server_redirect,
+                                    bool* send_referrer) {
+  // Handle all the navigations and reloads in browser.
+  // FIXME We only support GET here because http method will be ignored when
+  // the OpenURLFromTab is triggered, which means form posting would not work,
+  // we should solve this by patching Chromium in future.
+  *send_referrer = true;
+  return http_method == "GET";
+}
+
+content::BrowserPluginDelegate* ElectronRendererClient::CreateBrowserPluginDelegate(
+    content::RenderFrame* render_frame,
+    const std::string& mime_type,
+    const GURL& original_url) {
+  if (mime_type == content::kBrowserPluginMimeType) {
+    return new GuestViewContainer(render_frame);
+  } else {
+    return nullptr;
+  }
+}
+
+void ElectronRendererClient::AddKeySystems(
+    std::vector<media::KeySystemInfo>* key_systems) {
+  AddChromeKeySystems(key_systems);
+}
+
+}  // namespace electron
added in remote
  their  100644 9a5440c6b71174f94d37bfa148151b8b862199aa electron/renderer/electron_renderer_client.h
@@ -0,0 +1,69 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
+#define ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
+
+#include <string>
+#include <vector>
+
+#include "content/public/renderer/content_renderer_client.h"
+#include "content/public/renderer/render_process_observer.h"
+
+namespace electron {
+
+class ElectronBindings;
+class NodeBindings;
+
+class ElectronRendererClient : public content::ContentRendererClient,
+                           public content::RenderProcessObserver {
+ public:
+  ElectronRendererClient();
+  virtual ~ElectronRendererClient();
+
+  void DidCreateScriptContext(v8::Handle<v8::Context> context);
+  void WillReleaseScriptContext(v8::Handle<v8::Context> context);
+
+ private:
+  enum NodeIntegration {
+    ALL,
+    EXCEPT_IFRAME,
+    MANUAL_ENABLE_IFRAME,
+    DISABLE,
+  };
+
+  // content::RenderProcessObserver:
+  void WebKitInitialized() override;
+
+  // content::ContentRendererClient:
+  void RenderThreadStarted() override;
+  void RenderFrameCreated(content::RenderFrame*) override;
+  void RenderViewCreated(content::RenderView*) override;
+  blink::WebSpeechSynthesizer* OverrideSpeechSynthesizer(
+      blink::WebSpeechSynthesizerClient* client) override;
+  bool OverrideCreatePlugin(content::RenderFrame* render_frame,
+                            blink::WebLocalFrame* frame,
+                            const blink::WebPluginParams& params,
+                            blink::WebPlugin** plugin) override;
+  bool ShouldFork(blink::WebLocalFrame* frame,
+                  const GURL& url,
+                  const std::string& http_method,
+                  bool is_initial_navigation,
+                  bool is_server_redirect,
+                  bool* send_referrer) override;
+  content::BrowserPluginDelegate* CreateBrowserPluginDelegate(
+      content::RenderFrame* render_frame,
+      const std::string& mime_type,
+      const GURL& original_url) override;
+  void AddKeySystems(std::vector<media::KeySystemInfo>* key_systems) override;
+
+  scoped_ptr<NodeBindings> node_bindings_;
+  scoped_ptr<ElectronBindings> electron_bindings_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRendererClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
added in remote
  their  100644 40541fccd4e27021915b2290b2aff68ee1b962aa electron/renderer/guest_view_container.cc
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/guest_view_container.h"
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/lazy_instance.h"
+#include "base/message_loop/message_loop.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace electron {
+
+namespace {
+
+using GuestViewContainerMap = std::map<int, GuestViewContainer*>;
+static base::LazyInstance<GuestViewContainerMap> g_guest_view_container_map =
+    LAZY_INSTANCE_INITIALIZER;
+
+}  // namespace
+
+GuestViewContainer::GuestViewContainer(content::RenderFrame* render_frame)
+    : render_frame_(render_frame),
+      weak_ptr_factory_(this) {
+}
+
+GuestViewContainer::~GuestViewContainer() {
+  if (element_instance_id_ > 0)
+    g_guest_view_container_map.Get().erase(element_instance_id_);
+}
+
+// static
+GuestViewContainer* GuestViewContainer::FromID(int element_instance_id) {
+  GuestViewContainerMap* guest_view_containers =
+      g_guest_view_container_map.Pointer();
+  auto it = guest_view_containers->find(element_instance_id);
+  return it == guest_view_containers->end() ? nullptr : it->second;
+}
+
+void GuestViewContainer::RegisterElementResizeCallback(
+    const ResizeCallback& callback) {
+  element_resize_callback_ = callback;
+}
+
+void GuestViewContainer::SetElementInstanceID(int element_instance_id) {
+  element_instance_id_ = element_instance_id;
+  g_guest_view_container_map.Get().insert(
+      std::make_pair(element_instance_id, this));
+}
+
+void GuestViewContainer::DidResizeElement(const gfx::Size& new_size) {
+  if (element_resize_callback_.is_null())
+    return;
+
+  base::MessageLoop::current()->PostTask(
+      FROM_HERE, base::Bind(element_resize_callback_, new_size));
+}
+
+base::WeakPtr<content::BrowserPluginDelegate> GuestViewContainer::GetWeakPtr() {
+  return weak_ptr_factory_.GetWeakPtr();
+}
+
+}  // namespace electron
added in remote
  their  100644 3fd4dc87aff131b320551b3cb4c31d59f9fc3e57 electron/renderer/guest_view_container.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
+#define ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
+
+#include "base/callback.h"
+#include "content/public/renderer/browser_plugin_delegate.h"
+
+namespace gfx {
+class Size;
+}
+
+namespace electron {
+
+class GuestViewContainer : public content::BrowserPluginDelegate {
+ public:
+  typedef base::Callback<void(const gfx::Size&)> ResizeCallback;
+
+  explicit GuestViewContainer(content::RenderFrame* render_frame);
+  ~GuestViewContainer() override;
+
+  static GuestViewContainer* FromID(int element_instance_id);
+
+  void RegisterElementResizeCallback(const ResizeCallback& callback);
+
+  // content::BrowserPluginDelegate:
+  void SetElementInstanceID(int element_instance_id) final;
+  void DidResizeElement(const gfx::Size& new_size) final;
+  base::WeakPtr<BrowserPluginDelegate> GetWeakPtr() final;
+
+ private:
+  int element_instance_id_;
+  content::RenderFrame* render_frame_;
+
+  ResizeCallback element_resize_callback_;
+
+  base::WeakPtrFactory<GuestViewContainer> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(GuestViewContainer);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
added in remote
  their  100644 3c5f7df558e9ec455f35596d7fdd626298ce38ed electron/renderer/node_array_buffer_bridge.cc
@@ -0,0 +1,66 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/node_array_buffer_bridge.h"
+
+#include "base/macros.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/converter.h"
+#include "third_party/WebKit/public/web/WebArrayBuffer.h"
+#include "third_party/WebKit/public/web/WebArrayBufferConverter.h"
+
+namespace electron {
+
+namespace {
+
+// global.Uint8Array;
+v8::Local<v8::Function> GetUint8ArrayConstructor(
+    v8::Isolate* isolate, v8::Local<v8::Context> context) {
+  v8::Local<v8::Value> constructor = context->Global()->Get(
+      mate::StringToV8(isolate, "Uint8Array"));
+  return v8::Local<v8::Function>::Cast(constructor);
+}
+
+// new ArrayBuffer(size);
+v8::Local<v8::ArrayBuffer> BlinkArrayBufferNew(
+    v8::Isolate* isolate, size_t size) {
+  blink::WebArrayBuffer buffer = blink::WebArrayBuffer::create(size, 1);
+  return v8::Local<v8::ArrayBuffer>::Cast(
+      blink::WebArrayBufferConverter::toV8Value(
+          &buffer, isolate->GetCurrentContext()->Global(), isolate));
+}
+
+// new ArrayBuffer(data, size);
+v8::Local<v8::ArrayBuffer> BlinkArrayBufferNewWith(
+    v8::Isolate* isolate, void* data, size_t size) {
+  blink::WebArrayBuffer buffer = blink::WebArrayBuffer::createExternal(
+      data, size);
+  return v8::Local<v8::ArrayBuffer>::Cast(
+      blink::WebArrayBufferConverter::toV8Value(
+          &buffer, isolate->GetCurrentContext()->Global(), isolate));
+}
+
+// new Uint8Array(array_buffer, offset, size);
+v8::Local<v8::Uint8Array> BlinkUint8ArrayNew(
+    v8::Local<v8::ArrayBuffer> ab, size_t offset, size_t size) {
+  // Use the DOM's Uint8Array constructor to create Uint8Array.
+  v8::Local<v8::Context> context = ab->CreationContext();
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor =
+      GetUint8ArrayConstructor(isolate, context);
+  v8::Local<v8::Value> args[] = {
+      ab, mate::ConvertToV8(isolate, offset), mate::ConvertToV8(isolate, size)
+  };
+  return v8::Local<v8::Uint8Array>::Cast(constructor->NewInstance(
+      context, arraysize(args), args).ToLocalChecked());
+}
+
+}  // namespace
+
+void OverrideNodeArrayBuffer() {
+  node::Buffer::SetArrayBufferCreator(
+      BlinkArrayBufferNew, BlinkArrayBufferNewWith, BlinkUint8ArrayNew);
+}
+
+}  // namespace electron
added in remote
  their  100644 182f19e8ec16c8312fa70ea67c2376a74043bd5b electron/renderer/node_array_buffer_bridge.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
+#define ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
+
+namespace electron {
+
+// Override Node's ArrayBuffer with DOM's ArrayBuffer.
+void OverrideNodeArrayBuffer();
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
added in remote
  their  100644 2d39d2a9845a90a066120fa302b031641faa11b9 electron/renderer/resources/mac/Info.plist
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleIdentifier</key>
+  <string>${ELECTRON_BUNDLE_ID}</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>APPL</string>
+  <key>LSUIElement</key>
+  <true/>
+  <key>NSSupportsAutomaticGraphicsSwitching</key>
+  <true/>
+</dict>
+</plist>
added in remote
  their  100644 879c3ffccdd878603c11d69bb754690d936b531a electron/utility/electron_content_utility_client.cc
@@ -0,0 +1,81 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/utility/electron_content_utility_client.h"
+
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/time/time.h"
+#include "chrome/common/chrome_utility_messages.h"
+#include "chrome/utility/utility_message_handler.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/utility/utility_thread.h"
+#include "ipc/ipc_channel.h"
+#include "ipc/ipc_message_macros.h"
+
+
+#if defined(OS_WIN)
+#include "chrome/utility/printing_handler_win.h"
+#endif
+
+
+namespace {
+
+bool Send(IPC::Message* message) {
+  return content::UtilityThread::Get()->Send(message);
+}
+
+}  // namespace
+
+namespace electron {
+
+int64_t ElectronContentUtilityClient::max_ipc_message_size_ =
+    IPC::Channel::kMaximumMessageSize;
+
+ElectronContentUtilityClient::ElectronContentUtilityClient()
+    : filter_messages_(false) {
+#if defined(OS_WIN)
+  handlers_.push_back(new PrintingHandlerWin());
+#endif
+}
+
+ElectronContentUtilityClient::~ElectronContentUtilityClient() {
+}
+
+void ElectronContentUtilityClient::UtilityThreadStarted() {
+}
+
+bool ElectronContentUtilityClient::OnMessageReceived(
+    const IPC::Message& message) {
+  if (filter_messages_ && !ContainsKey(message_id_whitelist_, message.type()))
+    return false;
+
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(ElectronContentUtilityClient, message)
+    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_StartupPing, OnStartupPing)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  for (Handlers::iterator it = handlers_.begin();
+       !handled && it != handlers_.end(); ++it) {
+    handled = (*it)->OnMessageReceived(message);
+  }
+
+  return handled;
+}
+
+void ElectronContentUtilityClient::OnStartupPing() {
+  Send(new ChromeUtilityHostMsg_ProcessStarted);
+  // Don't release the process, we assume further messages are on the way.
+}
+
+// static
+void ElectronContentUtilityClient::PreSandboxStartup() {
+#if defined(OS_WIN)
+  PrintingHandlerWin::PreSandboxStartup();
+#endif
+}
+
+}  // namespace electron
added in remote
  their  100644 29700bb05c8e8ae9fa408096cd0da806b9cc232a electron/utility/electron_content_utility_client.h
@@ -0,0 +1,58 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
+#define ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_vector.h"
+#include "content/public/utility/content_utility_client.h"
+#include "ipc/ipc_platform_file.h"
+
+namespace base {
+class FilePath;
+struct FileDescriptor;
+}
+
+class UtilityMessageHandler;
+
+namespace electron {
+
+class ElectronContentUtilityClient : public content::ContentUtilityClient {
+ public:
+  ElectronContentUtilityClient();
+  ~ElectronContentUtilityClient() override;
+
+  void UtilityThreadStarted() override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  static void PreSandboxStartup();
+
+  static void set_max_ipc_message_size_for_test(int64_t max_message_size) {
+    max_ipc_message_size_ = max_message_size;
+  }
+
+ private:
+  void OnStartupPing();
+
+  typedef ScopedVector<UtilityMessageHandler> Handlers;
+  Handlers handlers_;
+
+  // Flag to enable whitelisting.
+  bool filter_messages_;
+  // A list of message_ids to filter.
+  std::set<int> message_id_whitelist_;
+  // Maximum IPC msg size (default to kMaximumMessageSize; override for testing)
+  static int64_t max_ipc_message_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronContentUtilityClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
changed in both
  base   100644 baf0202f3eca9811577c06ca30e215eae1da888a filenames.gypi
  our    100644 f57860558f06b7e5d8a50f48cfc7e53044df0bc6 filenames.gypi
  their  100644 75c0fbc18740d07f20b3cdbe5075e233f2ac3856 filenames.gypi
@@ -1,11 +1,15 @@
 {
   'variables': {
     'app_sources': [
-      'atom/app/atom_main.cc',
-      'atom/app/atom_main.h',
+      'electron/app/electron_main.cc',
+      'electron/app/electron_main.h',
     ],
     'bundle_sources': [
+<<<<<<< .our
       'atom/browser/resources/mac/electron.icns',
+=======
+      'electron/browser/resources/mac/electron.icns',
+>>>>>>> .their
     ],
     'js_sources': [
       'lib/browser/api/app.js',
@@ -107,6 +111,7 @@
       'node_modules/octicons/build/svg/gift.svg',
     ],
     'lib_sources': [
+<<<<<<< .our
       'atom/app/atom_content_client.cc',
       'atom/app/atom_content_client.h',
       'atom/app/atom_main_delegate.cc',
@@ -563,6 +568,318 @@
       'atom/renderer/web_worker_observer.h',
       'atom/utility/atom_content_utility_client.cc',
       'atom/utility/atom_content_utility_client.h',
+=======
+      'electron/app/electron_content_client.cc',
+      'electron/app/electron_content_client.h',
+      'electron/app/electron_main_delegate.cc',
+      'electron/app/electron_main_delegate.h',
+      'electron/app/electron_main_delegate_mac.mm',
+      'electron/app/node_main.cc',
+      'electron/app/node_main.h',
+      'electron/app/uv_task_runner.cc',
+      'electron/app/uv_task_runner.h',
+      'electron/browser/api/electron_api_app.cc',
+      'electron/browser/api/electron_api_app.h',
+      'electron/browser/api/electron_api_auto_updater.cc',
+      'electron/browser/api/electron_api_auto_updater.h',
+      'electron/browser/api/electron_api_content_tracing.cc',
+      'electron/browser/api/electron_api_cookies.cc',
+      'electron/browser/api/electron_api_cookies.h',
+      'electron/browser/api/electron_api_debugger.cc',
+      'electron/browser/api/electron_api_debugger.h',
+      'electron/browser/api/electron_api_desktop_capturer.cc',
+      'electron/browser/api/electron_api_desktop_capturer.h',
+      'electron/browser/api/electron_api_download_item.cc',
+      'electron/browser/api/electron_api_download_item.h',
+      'electron/browser/api/electron_api_dialog.cc',
+      'electron/browser/api/electron_api_global_shortcut.cc',
+      'electron/browser/api/electron_api_global_shortcut.h',
+      'electron/browser/api/electron_api_menu.cc',
+      'electron/browser/api/electron_api_menu.h',
+      'electron/browser/api/electron_api_menu_views.cc',
+      'electron/browser/api/electron_api_menu_views.h',
+      'electron/browser/api/electron_api_menu_mac.h',
+      'electron/browser/api/electron_api_menu_mac.mm',
+      'electron/browser/api/electron_api_power_monitor.cc',
+      'electron/browser/api/electron_api_power_monitor.h',
+      'electron/browser/api/electron_api_power_save_blocker.cc',
+      'electron/browser/api/electron_api_power_save_blocker.h',
+      'electron/browser/api/electron_api_protocol.cc',
+      'electron/browser/api/electron_api_protocol.h',
+      'electron/browser/api/electron_api_screen.cc',
+      'electron/browser/api/electron_api_screen.h',
+      'electron/browser/api/electron_api_session.cc',
+      'electron/browser/api/electron_api_session.h',
+      'electron/browser/api/electron_api_tray.cc',
+      'electron/browser/api/electron_api_tray.h',
+      'electron/browser/api/electron_api_web_contents.cc',
+      'electron/browser/api/electron_api_web_contents.h',
+      'electron/browser/api/electron_api_web_request.cc',
+      'electron/browser/api/electron_api_web_request.h',
+      'electron/browser/api/electron_api_web_view_manager.cc',
+      'electron/browser/api/electron_api_window.cc',
+      'electron/browser/api/electron_api_window.h',
+      'electron/browser/api/event.cc',
+      'electron/browser/api/event.h',
+      'electron/browser/api/event_emitter.cc',
+      'electron/browser/api/event_emitter.h',
+      'electron/browser/api/trackable_object.cc',
+      'electron/browser/api/trackable_object.h',
+      'electron/browser/api/frame_subscriber.cc',
+      'electron/browser/api/frame_subscriber.h',
+      'electron/browser/api/save_page_handler.cc',
+      'electron/browser/api/save_page_handler.h',
+      'electron/browser/auto_updater.cc',
+      'electron/browser/auto_updater.h',
+      'electron/browser/auto_updater_mac.mm',
+      'electron/browser/electron_access_token_store.cc',
+      'electron/browser/electron_access_token_store.h',
+      'electron/browser/electron_browser_client.cc',
+      'electron/browser/electron_browser_client.h',
+      'electron/browser/electron_browser_context.cc',
+      'electron/browser/electron_browser_context.h',
+      'electron/browser/electron_download_manager_delegate.cc',
+      'electron/browser/electron_download_manager_delegate.h',
+      'electron/browser/electron_browser_main_parts.cc',
+      'electron/browser/electron_browser_main_parts.h',
+      'electron/browser/electron_browser_main_parts_mac.mm',
+      'electron/browser/electron_browser_main_parts_posix.cc',
+      'electron/browser/electron_javascript_dialog_manager.cc',
+      'electron/browser/electron_javascript_dialog_manager.h',
+      'electron/browser/electron_permission_manager.cc',
+      'electron/browser/electron_permission_manager.h',
+      'electron/browser/electron_quota_permission_context.cc',
+      'electron/browser/electron_quota_permission_context.h',
+      'electron/browser/electron_resource_dispatcher_host_delegate.cc',
+      'electron/browser/electron_resource_dispatcher_host_delegate.h',
+      'electron/browser/electron_speech_recognition_manager_delegate.cc',
+      'electron/browser/electron_speech_recognition_manager_delegate.h',
+      'electron/browser/bridge_task_runner.cc',
+      'electron/browser/bridge_task_runner.h',
+      'electron/browser/browser.cc',
+      'electron/browser/browser.h',
+      'electron/browser/browser_linux.cc',
+      'electron/browser/browser_mac.mm',
+      'electron/browser/browser_win.cc',
+      'electron/browser/browser_observer.h',
+      'electron/browser/common_web_contents_delegate.cc',
+      'electron/browser/common_web_contents_delegate.h',
+      'electron/browser/javascript_environment.cc',
+      'electron/browser/javascript_environment.h',
+      'electron/browser/login_handler.cc',
+      'electron/browser/login_handler.h',
+      'electron/browser/mac/electron_application.h',
+      'electron/browser/mac/electron_application.mm',
+      'electron/browser/mac/electron_application_delegate.h',
+      'electron/browser/mac/electron_application_delegate.mm',
+      'electron/browser/native_window.cc',
+      'electron/browser/native_window.h',
+      'electron/browser/native_window_views_win.cc',
+      'electron/browser/native_window_views.cc',
+      'electron/browser/native_window_views.h',
+      'electron/browser/native_window_mac.h',
+      'electron/browser/native_window_mac.mm',
+      'electron/browser/native_window_observer.h',
+      'electron/browser/net/asar/asar_protocol_handler.cc',
+      'electron/browser/net/asar/asar_protocol_handler.h',
+      'electron/browser/net/asar/url_request_asar_job.cc',
+      'electron/browser/net/asar/url_request_asar_job.h',
+      'electron/browser/net/electron_cert_verifier.cc',
+      'electron/browser/net/electron_cert_verifier.h',
+      'electron/browser/net/electron_network_delegate.cc',
+      'electron/browser/net/electron_network_delegate.h',
+      'electron/browser/net/electron_ssl_config_service.cc',
+      'electron/browser/net/electron_ssl_config_service.h',
+      'electron/browser/net/electron_url_request_job_factory.cc',
+      'electron/browser/net/electron_url_request_job_factory.h',
+      'electron/browser/net/http_protocol_handler.cc',
+      'electron/browser/net/http_protocol_handler.h',
+      'electron/browser/net/js_asker.cc',
+      'electron/browser/net/js_asker.h',
+      'electron/browser/net/url_request_async_asar_job.cc',
+      'electron/browser/net/url_request_async_asar_job.h',
+      'electron/browser/net/url_request_string_job.cc',
+      'electron/browser/net/url_request_string_job.h',
+      'electron/browser/net/url_request_buffer_job.cc',
+      'electron/browser/net/url_request_buffer_job.h',
+      'electron/browser/net/url_request_fetch_job.cc',
+      'electron/browser/net/url_request_fetch_job.h',
+      'electron/browser/node_debugger.cc',
+      'electron/browser/node_debugger.h',
+      'electron/browser/ui/accelerator_util.cc',
+      'electron/browser/ui/accelerator_util.h',
+      'electron/browser/ui/accelerator_util_mac.mm',
+      'electron/browser/ui/accelerator_util_views.cc',
+      'electron/browser/ui/electron_menu_model.cc',
+      'electron/browser/ui/electron_menu_model.h',
+      'electron/browser/ui/cocoa/electron_menu_controller.h',
+      'electron/browser/ui/cocoa/electron_menu_controller.mm',
+      'electron/browser/ui/file_dialog.h',
+      'electron/browser/ui/file_dialog_gtk.cc',
+      'electron/browser/ui/file_dialog_mac.mm',
+      'electron/browser/ui/file_dialog_win.cc',
+      'electron/browser/ui/message_box.h',
+      'electron/browser/ui/message_box_gtk.cc',
+      'electron/browser/ui/message_box_mac.mm',
+      'electron/browser/ui/message_box_win.cc',
+      'electron/browser/ui/tray_icon.cc',
+      'electron/browser/ui/tray_icon.h',
+      'electron/browser/ui/tray_icon_gtk.cc',
+      'electron/browser/ui/tray_icon_gtk.h',
+      'electron/browser/ui/tray_icon_cocoa.h',
+      'electron/browser/ui/tray_icon_cocoa.mm',
+      'electron/browser/ui/tray_icon_observer.h',
+      'electron/browser/ui/tray_icon_win.cc',
+      'electron/browser/ui/views/frameless_view.cc',
+      'electron/browser/ui/views/frameless_view.h',
+      'electron/browser/ui/views/global_menu_bar_x11.cc',
+      'electron/browser/ui/views/global_menu_bar_x11.h',
+      'electron/browser/ui/views/menu_bar.cc',
+      'electron/browser/ui/views/menu_bar.h',
+      'electron/browser/ui/views/menu_delegate.cc',
+      'electron/browser/ui/views/menu_delegate.h',
+      'electron/browser/ui/views/menu_layout.cc',
+      'electron/browser/ui/views/menu_layout.h',
+      'electron/browser/ui/views/native_frame_view.cc',
+      'electron/browser/ui/views/native_frame_view.h',
+      'electron/browser/ui/views/submenu_button.cc',
+      'electron/browser/ui/views/submenu_button.h',
+      'electron/browser/ui/views/win_frame_view.cc',
+      'electron/browser/ui/views/win_frame_view.h',
+      'electron/browser/ui/win/electron_desktop_window_tree_host_win.cc',
+      'electron/browser/ui/win/electron_desktop_window_tree_host_win.h',
+      'electron/browser/ui/win/message_handler_delegate.cc',
+      'electron/browser/ui/win/message_handler_delegate.h',
+      'electron/browser/ui/win/notify_icon_host.cc',
+      'electron/browser/ui/win/notify_icon_host.h',
+      'electron/browser/ui/win/notify_icon.cc',
+      'electron/browser/ui/win/notify_icon.h',
+      'electron/browser/ui/win/taskbar_host.cc',
+      'electron/browser/ui/win/taskbar_host.h',
+      'electron/browser/ui/x/window_state_watcher.cc',
+      'electron/browser/ui/x/window_state_watcher.h',
+      'electron/browser/ui/x/x_window_utils.cc',
+      'electron/browser/ui/x/x_window_utils.h',
+      'electron/browser/web_contents_permission_helper.cc',
+      'electron/browser/web_contents_permission_helper.h',
+      'electron/browser/web_contents_preferences.cc',
+      'electron/browser/web_contents_preferences.h',
+      'electron/browser/web_dialog_helper.cc',
+      'electron/browser/web_dialog_helper.h',
+      'electron/browser/web_view_guest_delegate.cc',
+      'electron/browser/web_view_guest_delegate.h',
+      'electron/browser/web_view_manager.cc',
+      'electron/browser/web_view_manager.h',
+      'electron/browser/window_list.cc',
+      'electron/browser/window_list.h',
+      'electron/browser/window_list_observer.h',
+      'electron/common/api/api_messages.h',
+      'electron/common/api/electron_api_asar.cc',
+      'electron/common/api/electron_api_clipboard.cc',
+      'electron/common/api/electron_api_crash_reporter.cc',
+      'electron/common/api/electron_api_id_weak_map.cc',
+      'electron/common/api/electron_api_id_weak_map.h',
+      'electron/common/api/electron_api_native_image.cc',
+      'electron/common/api/electron_api_native_image.h',
+      'electron/common/api/electron_api_native_image_mac.mm',
+      'electron/common/api/electron_api_shell.cc',
+      'electron/common/api/electron_api_v8_util.cc',
+      'electron/common/api/electron_bindings.cc',
+      'electron/common/api/electron_bindings.h',
+      'electron/common/api/event_emitter_caller.cc',
+      'electron/common/api/event_emitter_caller.h',
+      'electron/common/api/locker.cc',
+      'electron/common/api/locker.h',
+      'electron/common/api/object_life_monitor.cc',
+      'electron/common/api/object_life_monitor.h',
+      'electron/common/asar/archive.cc',
+      'electron/common/asar/archive.h',
+      'electron/common/asar/asar_util.cc',
+      'electron/common/asar/asar_util.h',
+      'electron/common/asar/scoped_temporary_file.cc',
+      'electron/common/asar/scoped_temporary_file.h',
+      'electron/common/electron_command_line.cc',
+      'electron/common/electron_command_line.h',
+      'electron/common/electron_constants.cc',
+      'electron/common/electron_constants.h',
+      'electron/common/common_message_generator.cc',
+      'electron/common/common_message_generator.h',
+      'electron/common/crash_reporter/crash_reporter.cc',
+      'electron/common/crash_reporter/crash_reporter.h',
+      'electron/common/crash_reporter/crash_reporter_linux.cc',
+      'electron/common/crash_reporter/crash_reporter_linux.h',
+      'electron/common/crash_reporter/crash_reporter_mac.h',
+      'electron/common/crash_reporter/crash_reporter_mac.mm',
+      'electron/common/crash_reporter/crash_reporter_win.cc',
+      'electron/common/crash_reporter/crash_reporter_win.h',
+      'electron/common/crash_reporter/linux/crash_dump_handler.cc',
+      'electron/common/crash_reporter/linux/crash_dump_handler.h',
+      'electron/common/crash_reporter/win/crash_service.cc',
+      'electron/common/crash_reporter/win/crash_service.h',
+      'electron/common/crash_reporter/win/crash_service_main.cc',
+      'electron/common/crash_reporter/win/crash_service_main.h',
+      'electron/common/draggable_region.cc',
+      'electron/common/draggable_region.h',
+      'electron/common/google_api_key.h',
+      'electron/common/id_weak_map.cc',
+      'electron/common/id_weak_map.h',
+      'electron/common/keyboard_util.cc',
+      'electron/common/keyboard_util.h',
+      'electron/common/mouse_util.cc',
+      'electron/common/mouse_util.h',
+      'electron/common/linux/application_info.cc',
+      'electron/common/native_mate_converters/accelerator_converter.cc',
+      'electron/common/native_mate_converters/accelerator_converter.h',
+      'electron/common/native_mate_converters/blink_converter.cc',
+      'electron/common/native_mate_converters/blink_converter.h',
+      'electron/common/native_mate_converters/callback.cc',
+      'electron/common/native_mate_converters/callback.h',
+      'electron/common/native_mate_converters/content_converter.cc',
+      'electron/common/native_mate_converters/content_converter.h',
+      'electron/common/native_mate_converters/file_path_converter.h',
+      'electron/common/native_mate_converters/gfx_converter.cc',
+      'electron/common/native_mate_converters/gfx_converter.h',
+      'electron/common/native_mate_converters/gurl_converter.h',
+      'electron/common/native_mate_converters/image_converter.cc',
+      'electron/common/native_mate_converters/image_converter.h',
+      'electron/common/native_mate_converters/net_converter.cc',
+      'electron/common/native_mate_converters/net_converter.h',
+      'electron/common/native_mate_converters/string16_converter.h',
+      'electron/common/native_mate_converters/v8_value_converter.cc',
+      'electron/common/native_mate_converters/v8_value_converter.h',
+      'electron/common/native_mate_converters/value_converter.cc',
+      'electron/common/native_mate_converters/value_converter.h',
+      'electron/common/node_bindings.cc',
+      'electron/common/node_bindings.h',
+      'electron/common/node_bindings_linux.cc',
+      'electron/common/node_bindings_linux.h',
+      'electron/common/node_bindings_mac.cc',
+      'electron/common/node_bindings_mac.h',
+      'electron/common/node_bindings_win.cc',
+      'electron/common/node_bindings_win.h',
+      'electron/common/node_includes.h',
+      'electron/common/options_switches.cc',
+      'electron/common/options_switches.h',
+      'electron/common/platform_util.h',
+      'electron/common/platform_util_linux.cc',
+      'electron/common/platform_util_mac.mm',
+      'electron/common/platform_util_win.cc',
+      'electron/renderer/api/electron_api_renderer_ipc.cc',
+      'electron/renderer/api/electron_api_spell_check_client.cc',
+      'electron/renderer/api/electron_api_spell_check_client.h',
+      'electron/renderer/api/electron_api_web_frame.cc',
+      'electron/renderer/api/electron_api_web_frame.h',
+      'electron/renderer/electron_render_view_observer.cc',
+      'electron/renderer/electron_render_view_observer.h',
+      'electron/renderer/electron_renderer_client.cc',
+      'electron/renderer/electron_renderer_client.h',
+      'electron/renderer/guest_view_container.cc',
+      'electron/renderer/guest_view_container.h',
+      'electron/renderer/node_array_buffer_bridge.cc',
+      'electron/renderer/node_array_buffer_bridge.h',
+      'electron/utility/electron_content_utility_client.cc',
+      'electron/utility/electron_content_utility_client.h',
+>>>>>>> .their
       'chromium_src/chrome/browser/browser_process.cc',
       'chromium_src/chrome/browser/browser_process.h',
       'chromium_src/chrome/browser/chrome_process_finder_win.cc',
@@ -662,7 +979,7 @@
       'chromium_src/library_loaders/libspeechd_loader.cc',
       'chromium_src/library_loaders/libspeechd.h',
       '<@(native_mate_files)',
-      '<(SHARED_INTERMEDIATE_DIR)/atom_natives.h',
+      '<(SHARED_INTERMEDIATE_DIR)/electron_natives.h',
     ],
     'lib_sources_linux': [
       'chromium_src/chrome/browser/icon_loader_auralinux.cc',
@@ -681,8 +998,8 @@
       'chromium_src/chrome/utility/printing_handler_win.h',
     ],
     'framework_sources': [
-      'atom/app/atom_library_main.h',
-      'atom/app/atom_library_main.mm',
+      'electron/app/electron_library_main.h',
+      'electron/app/electron_library_main.mm',
     ],
     'login_helper_sources': [
       'atom/app/atom_login_helper.mm',
@@ -698,9 +1015,9 @@
     'conditions': [
       ['OS=="win"', {
         'app_sources': [
-          'atom/browser/resources/win/resource.h',
-          'atom/browser/resources/win/atom.ico',
-          'atom/browser/resources/win/atom.rc',
+          'electron/browser/resources/win/resource.h',
+          'electron/browser/resources/win/electron.ico',
+          'electron/browser/resources/win/electron.rc',
           # Cursors.
           '<(libchromiumcontent_src_dir)/ui/resources/cursors/aliasb.cur',
           '<(libchromiumcontent_src_dir)/ui/resources/cursors/cell.cur',
changed in both
  base   100644 d5cfd2da8399c2a2b0c2492df5713378747ad82b lib/common/api/callbacks-registry.js
  our    100644 6a1c63b20413753eeb9c5f8d190a9f5d2f303d22 lib/common/api/callbacks-registry.js
  their  100644 91356627865ec6455033a56464da3b9919cb91dc lib/common/api/callbacks-registry.js
@@ -24,6 +24,7 @@
     let match
 
     while ((match = regexp.exec(stackString)) !== null) {
+<<<<<<< .our
       const location = match[1]
       if (location.includes('(native)')) continue
       if (location.includes('(<anonymous>)')) continue
@@ -32,6 +33,18 @@
       const ref = /([^/^)]*)\)?$/gi.exec(location)
       filenameAndLine = ref[1]
       break
+=======
+      location = match[1];
+      if (location.indexOf('(native)') !== -1) {
+        continue;
+      }
+      if (location.indexOf('electron.asar') !== -1) {
+        continue;
+      }
+      ref = /([^\/^\)]*)\)?$/gi.exec(location);
+      filenameAndLine = ref[1];
+      break;
+>>>>>>> .their
     }
     this.callbacks[id] = callback
     v8Util.setHiddenValue(callback, 'callbackId', id)
changed in both
  base   100644 e3996a193aced293e4ed4808f804f39a4150823f lib/common/asar.js
  our    100644 41c3d0c85c69954dddad53c674f84051f25372e4 lib/common/asar.js
  their  100644 6bfe38783a9ea737481b6635e64c8ab56009d600 lib/common/asar.js
@@ -1,9 +1,16 @@
 (function () {
+<<<<<<< .our
   const asar = process.binding('atom_common_asar')
   const {Buffer} = require('buffer')
   const childProcess = require('child_process')
   const path = require('path')
   const util = require('util')
+=======
+  const asar = process.binding('electron_common_asar');
+  const child_process = require('child_process');
+  const path = require('path');
+  const util = require('util');
+>>>>>>> .their
 
   const hasProp = {}.hasOwnProperty
 
changed in both
  base   100644 85bb828583bc25841141d79f3a4bb40af1560f36 lib/common/asar_init.js
  our    100644 33abc155a54e6f78d6d9cd29ccaa182f8bf69647 lib/common/asar_init.js
  their  100644 b758084f9b21112d48f07938946d4d5cc75ce96b lib/common/asar_init.js
@@ -1,6 +1,13 @@
+<<<<<<< .our
 ;(function () {
   return function (process, require, asarSource) {
     const source = process.binding('natives')
+=======
+(function () {
+  return function(process, require, asarSource) {
+    // Make asar.js accessible via "require".
+    process.binding('natives').ATOM_SHELL_ASAR = asarSource;
+>>>>>>> .their
 
     // Expose fs module without asar support.
     source['original-fs'] = source.fs
changed in both
  base   100644 923ef910886de402706f29eccf497ecc5c0a8cea lib/common/init.js
  our    100644 b424768414b857b485bd5e29bfce504de6f1d749 lib/common/init.js
  their  100644 8a4bb1de6872f397007f3e55b8543ebe0edafa15 lib/common/init.js
@@ -1,5 +1,26 @@
+<<<<<<< .our
 const timers = require('timers')
 const util = require('util')
+=======
+const path = require('path');
+const timers = require('timers');
+const Module = require('module');
+
+process.atomBinding = function(name) {
+  try {
+    return process.binding("electron_" + process.type + "_" + name);
+  } catch (error) {
+    if (/No such module/.test(error.message)) {
+      return process.binding("electron_common_" + name);
+    }
+  }
+};
+
+if (!process.env.ELECTRON_HIDE_INTERNAL_MODULES) {
+  // Add common/api/lib to module search paths.
+  Module.globalPaths.push(path.join(__dirname, 'api'));
+}
+>>>>>>> .their
 
 process.atomBinding = require('./atom-binding-setup')(process.binding, process.type)
 
changed in both
  base   100755 1efea3c289731cba4c457ec367083c1e5bd55fc9 script/bootstrap.py
  our    100755 e4aaf89e216b0164f15882a3040e8cac70bf1fd9 script/bootstrap.py
  their  100755 4a1ba528921206a7673b897568e7111c43f9b385 script/bootstrap.py
@@ -238,8 +238,14 @@
     os.remove(tar_name)
 
 def create_chrome_version_h():
+<<<<<<< .our
   version_file = os.path.join(VENDOR_DIR, 'libchromiumcontent', 'VERSION')
   target_file = os.path.join(SOURCE_ROOT, 'atom', 'common', 'chrome_version.h')
+=======
+  version_file = os.path.join(SOURCE_ROOT, 'vendor', 'brightray', 'vendor',
+                              'libchromiumcontent', 'VERSION')
+  target_file = os.path.join(SOURCE_ROOT, 'electron', 'common', 'chrome_version.h')
+>>>>>>> .their
   template_file = os.path.join(SOURCE_ROOT, 'script', 'chrome_version.h.in')
 
   with open(version_file, 'r') as f:
changed in both
  base   100755 e2c22e8cd9d4714ecba9cf8899a01faea14487d0 script/bump-version.py
  our    100755 564adb2116312b0f6d0351096bd89cb373cd3bab script/bump-version.py
  their  100755 679eb28dddcbb235efd77cc9b9786438b7960b8e script/bump-version.py
@@ -115,15 +115,24 @@
   return versions
 
 
+<<<<<<< .our
 def update_electron_gyp(version, suffix):
   pattern = re.compile(" *'version%' *: *'[0-9.]+(-beta[0-9.]*)?(-dev)?"
     + "(-nightly[0-9.]*)?'")
+=======
+def update_atom_gyp(version):
+  pattern = re.compile(" *'version%' *: *'[0-9.]+'")
+>>>>>>> .their
   with open('electron.gyp', 'r') as f:
     lines = f.readlines()
 
   for i in range(0, len(lines)):
     if pattern.match(lines[i]):
+<<<<<<< .our
       lines[i] = "    'version%': '{0}',\n".format(version + suffix)
+=======
+      lines[i] = "    'version%': '{0}',\n".format(version)
+>>>>>>> .their
       with open('electron.gyp', 'w') as f:
         f.write(''.join(lines))
       return
@@ -135,7 +144,7 @@
   pattern_fvs = re.compile(' *VALUE "FileVersion", "[0-9.]+"')
   pattern_pvs = re.compile(' *VALUE "ProductVersion", "[0-9.]+"')
 
-  win_rc = os.path.join('atom', 'browser', 'resources', 'win', 'atom.rc')
+  win_rc = os.path.join('atom', 'browser', 'resources', 'win', 'electron.rc')
   with open(win_rc, 'r') as f:
     lines = f.readlines()
 
@@ -162,10 +171,10 @@
 
   for i in range(0, len(lines)):
     line = lines[i]
-    if 'ATOM_MAJOR_VERSION' in line:
-      lines[i] = '#define ATOM_MAJOR_VERSION {0}\n'.format(versions[0])
-      lines[i + 1] = '#define ATOM_MINOR_VERSION {0}\n'.format(versions[1])
-      lines[i + 2] = '#define ATOM_PATCH_VERSION {0}\n'.format(versions[2])
+    if 'ELECTRON_MAJOR_VERSION' in line:
+      lines[i] = '#define ELECTRON_MAJOR_VERSION {0}\n'.format(versions[0])
+      lines[i + 1] = '#define ELECTRON_MINOR_VERSION {0}\n'.format(versions[1])
+      lines[i + 2] = '#define ELECTRON_PATCH_VERSION {0}\n'.format(versions[2])
 
       if (suffix):
         lines[i + 3] = '#define ATOM_PRE_RELEASE_VERSION {0}\n'.format(suffix)
merged
  result 100644 7cbfdfd87896fc3af08df33b9be616e51ab78e83 script/chrome_version.h.in
  our    100644 be20655ec6d73b6aca9930911a464b96f098e5b9 script/chrome_version.h.in
@@ -5,10 +5,10 @@
 // This file is generated by script/bootstrap.py, you should never modify it
 // by hand.
 
-#ifndef ATOM_COMMON_CHROME_VERSION_H_
-#define ATOM_COMMON_CHROME_VERSION_H_
+#ifndef ELECTRON_COMMON_CHROME_VERSION_H_
+#define ELECTRON_COMMON_CHROME_VERSION_H_
 
 #define CHROME_VERSION_STRING "{PLACEHOLDER}"
 #define CHROME_VERSION "v" CHROME_VERSION_STRING
 
-#endif  // ATOM_COMMON_CHROME_VERSION_H_
+#endif  // ELECTRON_COMMON_CHROME_VERSION_H_
changed in both
  base   100755 d647bed2de4150a251dce6fde1dfb5fc455bdbfc script/cpplint.py
  our    100755 da4b6212f4b1a8ad187f8eae970e4887b71d73da script/cpplint.py
  their  100755 ed9e31b978362d16e392869a2479eeb8a4239aa9 script/cpplint.py
@@ -7,6 +7,7 @@
 from lib.config import enable_verbose_mode
 from lib.util import execute
 
+<<<<<<< .our
 IGNORE_FILES = set(os.path.join(*components) for components in [
   ['atom', 'browser', 'mac', 'atom_application.h'],
   ['atom', 'browser', 'mac', 'atom_application_delegate.h'],
@@ -36,6 +37,25 @@
   ['brightray', 'browser', 'win', 'win32_desktop_notifications', 'toast.h'],
   ['brightray', 'browser', 'win', 'win32_notification.h']
 ])
+=======
+IGNORE_FILES = [
+  os.path.join('electron', 'app', 'electron_main.cc'),
+  os.path.join('electron', 'browser', 'mac', 'electron_application.h'),
+  os.path.join('electron', 'browser', 'mac', 'electron_application_delegate.h'),
+  os.path.join('electron', 'browser', 'native_window_mac.h'),
+  os.path.join('electron', 'browser', 'resources', 'win', 'resource.h'),
+  os.path.join('electron', 'browser', 'ui', 'cocoa', 'event_processing_window.h'),
+  os.path.join('electron', 'browser', 'ui', 'cocoa', 'electron_menu_controller.h'),
+  os.path.join('electron', 'browser', 'ui', 'gtk', 'gtk_custom_menu.cc'),
+  os.path.join('electron', 'browser', 'ui', 'gtk', 'gtk_custom_menu_item.cc'),
+  os.path.join('electron', 'common', 'api', 'api_messages.h'),
+  os.path.join('electron', 'common', 'api', 'electron_extensions.h'),
+  os.path.join('electron', 'common', 'electron_version.h'),
+  os.path.join('electron', 'common', 'common_message_generator.cc'),
+  os.path.join('electron', 'common', 'common_message_generator.h'),
+  os.path.join('electron', 'common', 'swap_or_assign.h'),
+]
+>>>>>>> .their
 
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 
@@ -70,6 +90,7 @@
     enable_verbose_mode()
 
   os.chdir(SOURCE_ROOT)
+<<<<<<< .our
   files = find_files(['atom', 'brightray'], is_cpp_file)
   files -= IGNORE_FILES
   if args.only_changed:
@@ -85,6 +106,20 @@
         filename = os.path.join(parent, child)
         if test(filename):
           matches.add(filename)
+=======
+  files = list_files(['app', 'browser', 'common', 'renderer', 'utility'],
+                     ['*.cc', '*.h'])
+  call_cpplint(list(set(files) - set(IGNORE_FILES)))
+
+
+def list_files(directories, filters):
+  matches = []
+  for directory in directories:
+    for root, _, filenames, in os.walk(os.path.join('electron', directory)):
+      for f in filters:
+        for filename in fnmatch.filter(filenames, f):
+          matches.append(os.path.join(root, filename))
+>>>>>>> .their
   return matches
 
 
changed in both
  base   100755 e25845432c774c33bf718e56b9291293b7eec369 script/create-dist.py
  our    100755 4a6c0c7ce8f275175e48c4c380ff33627f7a5961 script/create-dist.py
  their  100755 b8f40a8bf076a392cd30f0b87a3948e24299d60d script/create-dist.py
@@ -18,10 +18,14 @@
                      execute, get_electron_version, make_zip, \
                      parse_version, rm_rf, scoped_cwd
 
+<<<<<<< .our
 from lib.env_util import get_vs_location
 
 
 ELECTRON_VERSION = get_electron_version()
+=======
+ELECTRON_SHELL_VERSION = get_atom_shell_version()
+>>>>>>> .their
 
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 DIST_DIR = os.path.join(SOURCE_ROOT, 'dist')
@@ -114,8 +118,13 @@
 
   create_version()
   create_dist_zip()
+<<<<<<< .our
   create_chrome_binary_zip('chromedriver', ELECTRON_VERSION)
   create_chrome_binary_zip('mksnapshot', ELECTRON_VERSION)
+=======
+  create_chrome_binary_zip('chromedriver', get_chromedriver_version())
+  create_chrome_binary_zip('mksnapshot', ELECTRON_SHELL_VERSION)
+>>>>>>> .their
   create_ffmpeg_zip()
   create_symbols_zip()
 
@@ -240,7 +249,11 @@
 def create_version():
   version_path = os.path.join(SOURCE_ROOT, 'dist', 'version')
   with open(version_path, 'w') as version_file:
+<<<<<<< .our
     version_file.write(ELECTRON_VERSION)
+=======
+    version_file.write(ELECTRON_SHELL_VERSION)
+>>>>>>> .their
 
 
 def create_symbols():
@@ -262,7 +275,13 @@
 
 
 def create_dist_zip():
+<<<<<<< .our
   dist_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION)
+=======
+  dist_name = '{0}-{1}-{2}-{3}.zip'.format(PROJECT_NAME, ELECTRON_SHELL_VERSION,
+                                           get_platform_key(),
+                                           get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(SOURCE_ROOT, 'dist', dist_name)
 
   with scoped_cwd(DIST_DIR):
@@ -310,7 +329,12 @@
       make_zip(zip_file, files, [])
 
 def create_ffmpeg_zip():
+<<<<<<< .our
   dist_name = get_zip_name('ffmpeg', ELECTRON_VERSION)
+=======
+  dist_name = 'ffmpeg-{0}-{1}-{2}.zip'.format(
+      ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(SOURCE_ROOT, 'dist', dist_name)
 
   if PLATFORM == 'darwin':
@@ -331,10 +355,17 @@
 
 
 def create_symbols_zip():
+<<<<<<< .our
   if get_target_arch() == 'mips64el':
     return
 
   dist_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'symbols')
+=======
+  dist_name = '{0}-{1}-{2}-{3}-symbols.zip'.format(PROJECT_NAME,
+                                                   ELECTRON_SHELL_VERSION,
+                                                   get_platform_key(),
+                                                   get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(DIST_DIR, dist_name)
   licenses = ['LICENSE', 'LICENSES.chromium.html', 'version']
 
@@ -343,7 +374,14 @@
     make_zip(zip_file, licenses, dirs)
 
   if PLATFORM == 'darwin':
+<<<<<<< .our
     dsym_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'dsym')
+=======
+    dsym_name = '{0}-{1}-{2}-{3}-dsym.zip'.format(PROJECT_NAME,
+                                                  ELECTRON_SHELL_VERSION,
+                                                  get_platform_key(),
+                                                  get_target_arch())
+>>>>>>> .their
     with scoped_cwd(DIST_DIR):
       dsyms = glob.glob('*.dSYM')
       make_zip(os.path.join(DIST_DIR, dsym_name), licenses, dsyms)
changed in both
  base   100644 fb1a4b89f27f3eb647638e9183d110287698964a script/lib/config.py
  our    100644 9ad0fbc680e5ecdeb8c13d0f0d6678bbba7d9031 script/lib/config.py
  their  100644 88b560c712316b0ffaac4cb2258f117d7f368146 script/lib/config.py
@@ -56,12 +56,21 @@
 
 
 def s3_config():
+<<<<<<< .our
   config = (get_env_var('S3_BUCKET'),
             get_env_var('S3_ACCESS_KEY'),
             get_env_var('S3_SECRET_KEY'))
   message = ('Error: Please set the $ELECTRON_S3_BUCKET, '
              '$ELECTRON_S3_ACCESS_KEY, and '
              '$ELECTRON_S3_SECRET_KEY environment variables')
+=======
+  config = (os.environ.get('ELECTRON_SHELL_S3_BUCKET', ''),
+            os.environ.get('ELECTRON_SHELL_S3_ACCESS_KEY', ''),
+            os.environ.get('ELECTRON_SHELL_S3_SECRET_KEY', ''))
+  message = ('Error: Please set the $ELECTRON_SHELL_S3_BUCKET, '
+             '$ELECTRON_SHELL_S3_ACCESS_KEY, and '
+             '$ELECTRON_SHELL_S3_SECRET_KEY environment variables')
+>>>>>>> .their
   assert all(len(c) for c in config), message
   return config
 
changed in both
  base   100644 fc52d316d30cc108850f51ec62ea3297161cc86e script/lib/util.py
  our    100644 d479d5a9556534c5d98ae1fdc97397cdd14376f5 script/lib/util.py
  their  100644 4e5fb90988d7382ded1744e35e8df9d786ecc5f9 script/lib/util.py
changed in both
  base   100755 e91e8401cbffca0ed484297ebedacfd0383ea940 script/update.py
  our    100755 5b4e201d76ab3689bc8847d6141b2fff1a852174 script/update.py
  their  100755 33a4cff50f64c16ff696634713b9784d6bb80953 script/update.py
@@ -84,6 +84,7 @@
     '-Dlibrary=static_library',
     '-Dmas_build={0}'.format(mas_build),
   ]
+<<<<<<< .our
 
   # Add the defines passed from command line.
   args = parse_args()
@@ -98,6 +99,9 @@
     generator = 'xcode-ninja'
 
   return subprocess.call([python, gyp, '-f', generator, '--depth', '.',
+=======
+  return subprocess.call([python, gyp, '-f', 'ninja', '--depth', '.',
+>>>>>>> .their
                           'electron.gyp', '-Icommon.gypi'] + defines, env=env)
 
 
changed in both
  base   100755 d23bc554c3ccdd0aacbec84d763cebab55db7b9b script/upload.py
  our    100755 2d9eaa201265971ca01acaea6e84a440e5db0532 script/upload.py
  their  100755 01edd91ccae024fdad884decd7ce16235215cd8e script/upload.py
@@ -17,8 +17,13 @@
                      parse_version, scoped_cwd, s3put
 
 
+<<<<<<< .our
 ELECTRON_REPO = 'electron/electron'
 ELECTRON_VERSION = get_electron_version()
+=======
+ELECTRON_SHELL_REPO = 'atom/electron'
+ELECTRON_SHELL_VERSION = get_atom_shell_version()
+>>>>>>> .their
 
 PROJECT_NAME = electron_gyp()['project_name%']
 PRODUCT_NAME = electron_gyp()['product_name%']
@@ -26,11 +31,26 @@
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 OUT_DIR = os.path.join(SOURCE_ROOT, 'out', 'R')
 DIST_DIR = os.path.join(SOURCE_ROOT, 'dist')
+<<<<<<< .our
 
 DIST_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION)
 SYMBOLS_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'symbols')
 DSYM_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'dsym')
 PDB_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'pdb')
+=======
+DIST_NAME = '{0}-{1}-{2}-{3}.zip'.format(PROJECT_NAME,
+                                         ELECTRON_SHELL_VERSION,
+                                         get_platform_key(),
+                                         get_target_arch())
+SYMBOLS_NAME = '{0}-{1}-{2}-{3}-symbols.zip'.format(PROJECT_NAME,
+                                                    ELECTRON_SHELL_VERSION,
+                                                    get_platform_key(),
+                                                    get_target_arch())
+DSYM_NAME = '{0}-{1}-{2}-{3}-dsym.zip'.format(PROJECT_NAME,
+                                              ELECTRON_SHELL_VERSION,
+                                              get_platform_key(),
+                                              get_target_arch())
+>>>>>>> .their
 
 
 def main():
@@ -39,6 +59,7 @@
     utcnow = datetime.datetime.utcnow()
     args.upload_timestamp = utcnow.strftime('%Y%m%d')
 
+<<<<<<< .our
   if not dist_newer_than_head():
     run_python_script('create-dist.py')
 
@@ -49,6 +70,37 @@
     sys.stderr.write(error)
     sys.stderr.flush()
     return 1
+=======
+  if not args.publish_release:
+    if not dist_newer_than_head():
+      create_dist = os.path.join(SOURCE_ROOT, 'script', 'create-dist.py')
+      execute([sys.executable, create_dist])
+
+    build_version = get_atom_shell_build_version()
+    if not ELECTRON_SHELL_VERSION.startswith(build_version):
+      error = 'Tag name ({0}) should match build version ({1})\n'.format(
+          ELECTRON_SHELL_VERSION, build_version)
+      sys.stderr.write(error)
+      sys.stderr.flush()
+      return 1
+
+  github = GitHub(auth_token())
+  releases = github.repos(ELECTRON_SHELL_REPO).releases.get()
+  tag_exists = False
+  for release in releases:
+    if not release['draft'] and release['tag_name'] == args.version:
+      tag_exists = True
+      break
+
+  release = create_or_get_release_draft(github, releases, args.version,
+                                        tag_exists)
+
+  if args.publish_release:
+    # Upload the SHASUMS.txt.
+    execute([sys.executable,
+             os.path.join(SOURCE_ROOT, 'script', 'upload-checksums.py'),
+             '-v', ELECTRON_SHELL_VERSION])
+>>>>>>> .their
 
   tag_exists = False
   release = get_release(args.version)
@@ -85,6 +137,7 @@
     mksnapshot = get_zip_name('mksnapshot', ELECTRON_VERSION, 'x64')
     upload_electron(release, os.path.join(DIST_DIR, mksnapshot), args)
 
+<<<<<<< .our
   if not tag_exists and not args.upload_to_s3:
     # Upload symbols to symbol server.
     run_python_script('upload-symbols.py')
@@ -92,15 +145,40 @@
       # Upload node headers.
       run_python_script('create-node-headers.py', '-v', args.version)
       run_python_script('upload-node-headers.py', '-v', args.version)
+=======
+  # Upload free version of ffmpeg.
+  ffmpeg = 'ffmpeg-{0}-{1}-{2}.zip'.format(
+      ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+  upload_atom_shell(github, release, os.path.join(DIST_DIR, ffmpeg))
+
+  # Upload chromedriver and mksnapshot for minor version update.
+  if parse_version(args.version)[2] == '0':
+    chromedriver = 'chromedriver-{0}-{1}-{2}.zip'.format(
+        get_chromedriver_version(), get_platform_key(), get_target_arch())
+    upload_atom_shell(github, release, os.path.join(DIST_DIR, chromedriver))
+    mksnapshot = 'mksnapshot-{0}-{1}-{2}.zip'.format(
+        ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+    upload_atom_shell(github, release, os.path.join(DIST_DIR, mksnapshot))
+
+  if PLATFORM == 'win32' and not tag_exists:
+    # Upload node headers.
+    execute([sys.executable,
+             os.path.join(SOURCE_ROOT, 'script', 'upload-node-headers.py'),
+             '-v', args.version])
+>>>>>>> .their
 
 
 def parse_args():
   parser = argparse.ArgumentParser(description='upload distribution file')
   parser.add_argument('-v', '--version', help='Specify the version',
+<<<<<<< .our
                       default=ELECTRON_VERSION)
   parser.add_argument('-o', '--overwrite',
                       help='Overwrite a published release',
                       action='store_true')
+=======
+                      default=ELECTRON_SHELL_VERSION)
+>>>>>>> .their
   parser.add_argument('-p', '--publish-release',
                       help='Publish the release',
                       action='store_true')
@@ -121,7 +199,11 @@
 def get_electron_build_version():
   if get_target_arch().startswith('arm') or os.environ.has_key('CI'):
     # In CI we just build as told.
+<<<<<<< .our
     return ELECTRON_VERSION
+=======
+    return ELECTRON_SHELL_VERSION
+>>>>>>> .their
   if PLATFORM == 'darwin':
     electron = os.path.join(SOURCE_ROOT, 'out', 'R',
                               '{0}.app'.format(PRODUCT_NAME), 'Contents',
@@ -170,6 +252,12 @@
   # Upload the checksum file.
   upload_sha256_checksum(args.version, file_path)
 
+<<<<<<< .our
+=======
+  data = dict(tag_name=tag, name=name, body=body, draft=True)
+  r = github.repos(ELECTRON_SHELL_REPO).releases.post(data=data)
+  return r
+>>>>>>> .their
 
 def upload_io_to_github(release, filename, filepath, version):
   print 'Uploading %s to Github' % \
@@ -178,6 +266,19 @@
   execute(['node', script_path, filepath, filename, str(release['id']),
           version])
 
+<<<<<<< .our
+=======
+def upload_atom_shell(github, release, file_path):
+  # Delete the original file before uploading in CI.
+  if os.environ.has_key('CI'):
+    try:
+      for asset in release['assets']:
+        if asset['name'] == os.path.basename(file_path):
+          github.repos(ELECTRON_SHELL_REPO).releases.assets(asset['id']).delete()
+          break
+    except Exception:
+      pass
+>>>>>>> .their
 
 def upload_sha256_checksum(version, file_path, key_prefix=None):
   bucket, access_key, secret_key = s3_config()
@@ -186,6 +287,7 @@
     key_prefix = 'atom-shell/tmp/{0}'.format(version)
   sha256 = hashlib.sha256()
   with open(file_path, 'rb') as f:
+<<<<<<< .our
     sha256.update(f.read())
 
   filename = os.path.basename(file_path)
@@ -198,6 +300,20 @@
 def auth_token():
   token = get_env_var('GITHUB_TOKEN')
   message = ('Error: Please set the $ELECTRON_GITHUB_TOKEN '
+=======
+    github.repos(ELECTRON_SHELL_REPO).releases(release['id']).assets.post(
+        params=params, headers=headers, data=f, verify=False)
+
+
+def publish_release(github, release_id):
+  data = dict(draft=False)
+  github.repos(ELECTRON_SHELL_REPO).releases(release_id).patch(data=data)
+
+
+def auth_token():
+  token = os.environ.get('ELECTRON_SHELL_GITHUB_TOKEN')
+  message = ('Error: Please set the $ELECTRON_SHELL_GITHUB_TOKEN '
+>>>>>>> .their
              'environment variable, which is your personal token')
   assert token, message
   return token
changed in both
  base   160000 d8e7d3e76cb3c6e709449d181ddc2af8c4859303 vendor/node
  our    160000 ece0a06ac8147efb5b5af431c21f312f1884616e vendor/node
  their  160000 fc81e4e8cc13f606cc18096a3f407e2a7aac82bb vendor/node
